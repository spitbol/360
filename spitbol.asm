         TITLE 'SPITBOL -- GENERAL DESCRIPTION'                         00001000
*                                                                       00002000
*                                                                       00003000
*        S    P    I    T    B    O    L        3    6    0             00004000
*        --------------------------------------------------             00004010
*                                                                       00005000
*        SPEEDY  IMPLEMENTATION  OF  SNOBOL-4                           00006000
*                                                                       00007000
*        VERSION 2.3                                                    00008000
*                                                                       00009000
*        ILLINOIS INSTITUTE OF TECHNOLOGY                               00010000
*                                                                       00011000
*        ROBERT B. K. DEWAR                                             00012000
*        KENNETH E. BELCHER                                             00013000
*                                                                       00014000
*    COPYRIGHT (C) 1971, 2001 ROBERT B. K. DEWAR AND KENNETH E. BELCHER 00014010
*                                                                       00014020
*                                                                       00014030
*        NEITHER AUTHOR IS CURRENTLY ASSOCIATED WITH ILLINOIS           00014040
*        INSTITUTE OF TECHNOLOGY. FOR CURRENT INFORMATION ABOUT         00014050
*        ABOUT SPITBOL 360 VISIT HTTP://WWW.SNOBOL4.COM                 00014060
*        -------------------------------------------------------------- 00014070
*                                                                       00014080
*                                                                       00014090
*        THIS FILE IS PART OF SPITBOL 360                               00014100
*                                                                       00014110
*        SPITBOL 360 IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR   00014120
*        MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE    00014130
*        AS PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 00014140
*        OF THE LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.         00014150
*                                                                       00014160
*        SPITBOL 360 IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, 00014170
*        BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF 00014180
*        MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE  00014190
*        GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.                   00014200
*                                                                       00014210
*        YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC      00014220
*        LICENSE ALONG WITH SPITBOL 360; IF NOT, WRITE TO THE FREE      00014230
*        SOFTWARE FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330,         00014240
*        BOSTON, MA  02111-1307  USA                                    00014250
*                                                                       00014260
*        -------------------------------------------------------------- 00014270
*                                                                       00014280
*                                                                       00014290
*        CHANGE LOG:                                                    00014300
*                                                                       00014310
*        2.3   8/14/2001 BOB GOLDBERG                                   00014320
*                                                                       00014330
*              PREPARED SOURCE FOR GPL DISTRIBUTION:                    00014340
*              - UPDATED COMMENTS                                       00014350
*              - UPDATED SYSHEAD                                        00014360
*              - KEPT CSECT OFFSETS THE SAME AS V2.2 FOR TFS 1 TO 6     00014370
*                                                                       00014380
*        -------------------------------------------------------------- 00014390
*                                                                       00014400
*                                                                       00015000
*        SPITBOL IS A FAST ONE PASS INCORE COMPILER ACCEPTING A         00016000
*        NEARLY COMPLETE VERSION OF THE SNOBOL-4 LANGUAGE WITH SOME     00017000
*        EXTENSIONS. THE FOLLOWING IS A BASIC DESCRIPTION OF THE        00018000
*        VARIOUS MODULES.                                               00019000
*                                                                       00020000
*        SPITBOLR                                                       00021000
*        --------                                                       00022000
*                                                                       00023000
*        IN MULTIPHASE ORGANIZATION, THIS IS THE ROOT PHASE. IT         00024000
*        CONTAINS A VARIETY OF ROUTINES WHICH ARE REQUIRED AT COMPILE   00025000
*        AND EXECUTE TIME AND ALSO CONTAINS THE CODE WHICH              00026000
*        HANDLES THE TRANSITION FROM COMPILATION TO EXECUTION.          00027000
*                                                                       00028000
*        SPITBOLC                                                       00029000
*        --------                                                       00030000
*                                                                       00031000
*        SPITBOLC IS THE COMPILER ITSELF WHICH IS DIVIDED INTO THE      00032000
*        FOLLOWING MAJOR SECTIONS --                                    00033000
*                                                                       00034000
*        CMPILE                   SUPERVISE STATEMENT COMPILATION       00035000
*        SCAN                     LEXICAL SCAN AND SYMBOL TABLE HANDLER 00036000
*        EXPAN                    BUILD TREE STRUCTURE FOR EXPRESSION   00037000
*        CODGEN                   GENERATE CODE FOR EXPRESSION          00038000
*        PRCODE                   PRINT GENERATED CODE                  00039000
*        CONCPROC                 CONTROL CARD PROCESSOR                00040000
*        ERROR                    ERROR MESSAGE HANDLER                 00041000
*        LISTER                   LIST SOURCE OUTPUT                    00042000
*        READER                   READ SOURCE INPUT                     00043000
*                                                                       00044000
         EJECT                                                          00045000
*                                                                       00046000
*        SPITBOLP                                                       00047000
*        --------                                                       00048000
*                                                                       00049000
*        THIS CONTROL SECTION CONTAINS THE CODE FOR EXECUTION TIME      00050000
*        PATTERN MATCHING. IT IS DIVIDED INTO THREE SECTIONS --         00051000
*                                                                       00052000
*        A)    INDIVIDUAL PATTERN ROUTINES                              00053000
*        B)    TRANSITION ROUTINES (QUICKSCAN MODE)                     00054000
*        C)    TRANSITION ROUTINES (FULLSCAN MODE)                      00055000
*                                                                       00056000
*        SPITBOLX                                                       00057000
*        --------                                                       00058000
*                                                                       00059000
*        SPITBOLX CONTAINS A WIDE VARIETY OF EXECUTION TIME ROUTINES    00060000
*        INCLUDING THE GARBAGE COLLECTOR. THERE ARE NO STANDARD BASE    00061000
*        REGISTERS COVERING THIS SECTION. EACH ROUTINE ESTABLISHES      00062000
*        ITS OWN BASE REGISTERS AS REQUIRED.                            00063000
*                                                                       00064000
*        SPITBOLA                                                       00065000
*        --------                                                       00066000
*                                                                       00067000
*        SPITBOLA IS A 4K SECTION UNDER THE STANDARD EXECUTION BASE     00068000
*        REGISTER (SYS). IT CONTAINS FREQUENTLY USED EXECUTION          00069000
*        ROUTINES AND ALSO LINKAGES TO SPITBOLX FOR LESSER USED         00070000
*        ROUTINES. ENTRY POINTS FROM THE GENERATED CODE INTO THIS AREA  00071000
*        ARE BY CONVENTION PREFIXED WITH TWO $ SIGNS, E.G. $$ADD2       00072000
*                                                                       00073000
*        SPITBOLF                                                       00074000
*        -------                                                        00075000
*                                                                       00076000
*        SPITBOLF CONTAINS CODE FOR ALL SYSTEM FUNCTIONS. THOSE         00077000
*        FUNCTIONS WHICH ARE NORMALLY OPTIMIZED INTO SPITBOLA ENTRY     00078000
*        CALLS ARE GROUPED AT THE START OF SPITBOLF. THE REMAINING      00079000
*        SYSTEM FUNCTIONS WHICH ARE CALLED BY THE STANDARD SPITBOL      00080000
*        FUNCTION LINKAGE, ARE IN ALPHABETICAL ORDER. PART OF THE       00081000
*        STANDARD LINKAGE ESTABLISHES DB4 AS A BASE REGISTER.           00082000
*                                                                       00083000
*        SPITBOLD                                                       00084000
*        --------                                                       00085000
*                                                                       00086000
*        SPITBOLD IS A DUMMY SECTION WHICH SHOWS THE LAYOUT OF          00087000
*        STANDARD WORK AREAS AND MODIFIED CONSTANTS AT THE START OF     00088000
*        THE ALLOCATED DATA AREA.                                       00089000
         EJECT                                                          00090000
*                                                                       00091000
*        USE OF MEMORY                                                  00092000
*        -------------                                                  00093000
*                                                                       00094000
*        THE USE OF MEMORY AT COMPILE TIME IS ILLUSTRATED BY THE        00095000
*        FOLLOWING PICTURE (LOW CORE AT THE TOP OF THE PICTURE)         00096000
*                                                                       00097000
*        +-------------------------------------------------------+      00098000
*        |             4K BLOCK UNDER BASE REG (DREG)            |      00099000
*        |             FIRST SECTION USED FOR STANDARD WORK      |      00100000
*        |             AREAS ETC., SEE SPITBOLD DSECT            |      00101000
*        |             REST USED FOR VARIABLE/CONSTANT BLKS      |      00102000
*        +-------------------------------------------------------+      00103000
*        |             GENERATED CODE, EXPANDS UPWARD            |      00104000
*        |             AS REQUIRED DURING COMPILATION            |      00105000
*        +-------------------------------------------------------+      00106000
*        |             2K SAFETY FOR CODE EXPANSION              |      00107000
*        +-------------------------------------------------------+      00108000
*        |             COMPILER WORK STACKS (3K)                 |      00109000
*        +-------------------------------------------------------+      00110000
*        |             2K SAFETY FOR CONSTANT CODE EXPANSION     |      00111000
*        +-------------------------------------------------------+      00112000
*        |             CODE TO COMPUTE VALUES OF                 |      00113000
*        |             CONSTANT SUBEXPRESSIONS, EXPANDS          |      00114000
*        |             DOWN AS REQUIRED.                         |      00115000
*        +-------------------------------------------------------+      00116000
*        |             SPACE FOR HIGH CORE DOWNWARD              |      00117000
*        |             EXPANSION, STARTS AT 2K EACH              |      00118000
*        |             TIME THE CONSTANT CODE IS MOVED           |      00119000
*        +-------------------------------------------------------+      00120000
*        |             HIGH CORE AREA, USED FOR STRINGS,         |      00121000
*        |             4K BLOCKS OF VARIABLES/CONSTANTS          |      00122000
*        +-------------------------------------------------------+      00123000
*        |             HASH TABLE FOR VARIABLES                  |      00124000
*        +-------------------------------------------------------+      00125000
*                                                                       00126000
*        THE COMPILER WORK STACKS ARE ESTABLISHED AT 2K ABOVE THE       00127000
*        CODE AT THE START OF EACH STATEMENT. NO STATEMENT CAN GENERATE 00128000
*        MORE THAN 2K CODE, SO NO CHECK IS REQUIRED.                    00129000
*                                                                       00130000
*        SPACE IS ALLOCATED IN THE HIGH CORE REGION BY THE HIGHCORE     00131000
*        ROUTINE. CALLS TO THIS ROUTINE MAY RESULT IN MOVING THE        00132000
*        CODE FOR CONSTANT SUBEXPRESSIONS DOWN WITH AN APPROPRIATE      00133000
*        OVERLAP CHECK (2K MUST BE LEFT FOR CONSTANT CODE EXPANSION).   00134000
*        TO AVOID FREQUENT MOVEMENT OF THIS CODE, A 2K EXPANSION        00135000
*        SPACE IS ALLOCATED EACH TIME THE CODE IS MOVED.                00136000
         EJECT                                                          00137000
*                                                                       00138000
*        USE OF MEMORY AT EXECUTION TIME                                00139000
*                                                                       00140000
*        DYNAMIC MEMORY FOR EXECUTION USE STARTS JUST BEYOND THE        00141000
*        GENERATED CODE. BLOCKS FOR THE VARIOUS DATA STRUCTURES ARE     00142000
*        BUILT UPWARDS IN MEMORY FROM THIS POINT. THE GARBAGE COLLECTOR 00143000
*        COMPACTS THESE BLOCKS DOWN WHENEVER MEMORY IS EXHAUSTED.       00144000
*                                                                       00145000
*        THE MAIN EXECUTION STACK, FOR RECURSIVE PATTERN MATCHING       00146000
*        AND FUNCTION CALLS BUILDS DOWN IN MEMORY (PDR IS THE STACK     00147000
*        POINTER).                                                      00148000
*                                                                       00149000
*        THE FIRST STEP AT EXECUTION TIME IS TO EXECUTE THE CODE        00150000
*        TO PRECALCULATE THE VALUES OF ALL CONSTANT SUBEXPRESSIONS.     00151000
*        FOR THIS PURPOSE, THE STACK POINTER IS INITIALIZED TO POINT    00152000
*        BELOW THE CONSTANT EXPRESSIONS CODE. NOTE THAT AN IMPORTANT    00153000
*        RESTRAINT AT THIS POINT IS THAT THE HIGH CORE CANNOT           00154000
*        EXPAND DURING THIS PROCESS.                                    00155000
*                                                                       00156000
*        WHEN THE CONSTANT CODE HAS BEEN EXECUTED, THE STACK POINTER    00157000
*        IS RESET TO JUST BELOW THE HIGH CORE AREA AND EXECUTION OF THE 00158000
*        MAIN CODE BEGINS.                                              00159000
*                                                                       00160000
*        AT THIS STAGE, CALLS TO THE HIGHCORE ROUTINE ARE PERMITTED,    00161000
*        (FOR EXAMPLE, TO BUILD NEW 4K BLOCKS FOR VARIABLES),           00162000
*        HIGHCORE RELOCATES THE STACK DOWNWARDS AS REQUIRED.            00163000
         EJECT                                                          00164000
*                                                                       00165000
*        MODULE SELECTION CONTROL                                       00166000
*        -------------------------                                      00167000
*                                                                       00168000
*        THE VARIABLE &LMOD CONTROLS THE ASSEMBLY MODE.                 00169000
*                                                                       00170000
*        WHEN &LMOD IS SET TO 0, THE STANDARD LOAD AND GO MODULES       00171000
*        ARE GENERATED. THESE MODULES INCLUDE ALL THE CODE WITH THE     00172000
*        EXCEPTION OF THE LINKUP ROUTINE FOR RESTART AFTER AN OBJECT    00173000
*        MODULE LOAD.                                                   00174000
*                                                                       00175000
*        IF &LMOD IS SET TO 1, THE LIBRARY MODULES ARE GENERATED.       00176000
*        THESE MODULES ARE USED TO LINK WITH A GENERATED OBJECT         00177000
*        MODULE. SEVERAL SECTIONS OF CODE, PARTICULARLY IN THE COMPILER 00178000
*        ARE NOT NEEDED IN THE LIBRARY MODULES AND ARE DELETED FROM     00179000
*        THE ASSEMBLY                                                   00180000
*                                                                       00181000
*        THE VARIABLE &LMOD IS DEFINED BY A SETA STATEMENT WHICH IS     00182000
*        COPIED FROM THE SYSLIB MEMBER 'DEFLMOD'. THUS TO ASSEMBLE      00183000
*        SPITBOL A MEMBER WITH THIS NAME MUST BE DEFINED IN SYSLIB      00184000
*        WITH ONE OF THE FOLLOWING TWO STATEMENTS --                    00185000
*                                                                       00186000
*        &LMOD     SETA  0                  FOR STANDARD MODULES        00187000
*                                                                       00188000
*        &LMOD     SETA  1                  FOR LIBRARY MODULES         00189000
*                                                                       00190000
*        NOTE THAT THE SPITBOL ASSEMBLY MODULE MAKES NO OTHER SYSLIB    00191000
*        REFERENCES EXCEPT FOR THIS SINGLE REFERENCE TO 'DEFLMOD',      00192000
*        THUS SYSLIB MAY SIMPLY BE POINTED AT A SUITABLE PDS            00193000
*                                                                       00194000
*        IN ENVIRONMENTS NOT PERMITTING THE COPY DIRECTIVE, IT MUST     00195000
*        BE PHYSICALLY REPLACED WITH ONE OF THE ABOVE TWO IMAGES.       00196000
         TITLE 'SPITBOL -- COMPILER MACRO DEFINITIONS'                  00197000
*                                                                       00198000
*        ERROR MESSAGE MACROS                                           00199000
*                                                                       00200000
*                                                                       00201000
*        ERR   NUMBER                                                   00202000
*                                                                       00203000
*              IS USED TO GENERATE A CALL TO THE ERROR ROUTINE TO       00204000
*              PRINT THE ERROR MESSAGE WITH THE GIVEN NUMBER            00205000
*                                                                       00206000
*NUMBER  ERRM  'MESSAGE'                                                00207000
*                                                                       00208000
*              IS USED TO GENERATE ERROR MESSAGE NUMBER                 00209000
*                                                                       00210000
         MACRO                                                          00211000
&LABL    ERR   &NUM                                                     00212000
         GBLA  &LMOD                                                    00213000
&LABL    BALR  R7,CB1                                                   00214000
         AIF   (&LMOD EQ 1).ERRL                                        00215000
         DC    Y(ERR&NUM-SPITBOLC)                                      00216000
         MEXIT                                                          00217000
.ERRL    DC    Y(0)                                                     00218000
         MEND                                                           00219000
*                                                                       00220000
*                                                                       00221000
         MACRO                                                          00222000
&NUM     ERRM  &MSG                                                     00223000
         LCLA  &CNT                                                     00224000
&CNT     SETA  K'&MSG-2-1                                               00225000
ERR&NUM  DC    YL1(&CNT)                                                00226000
         DC    C&MSG                                                    00227000
         MEND                                                           00228000
         EJECT                                                          00229000
*                                                                       00230000
*        MACRO USED BY CONTROL CARD ROUTINE TO SET UP DICTIONARY        00231000
*                                                                       00232000
*        CALL OF --                                                     00233000
*        CONC  NAME                                                     00234000
*                                                                       00235000
*        SETS UP AN ENTRY FOR A CONTROL CARD WHOSE NAME BEGINS WITH     00236000
*        THE CHARACTERS 'NAME' AND WHOSE PROCESSING ROUTINE IS AT       00237000
*        CONC'NAME'                                                     00238000
*                                                                       00239000
         MACRO                                                          00240000
         CONC  &NAME                                                    00241000
         DC    CL4'&NAME'                                               00242000
         DC    Y(CONC&NAME-CONCPROC)                                    00243000
         MEND                                                           00244000
*                                                                       00245000
*                                                                       00246000
*        MACRO TO GENERATE HEADING LINES (SEE SYSHEAD & INTERFACE)      00247000
*                                                                       00248000
         MACRO                                                          00249000
         HEDR  &LINE                                                    00250000
         LCLA  &L                                                       00251000
&L       SETA  K'&LINE-2                                                00252000
         DC    AL1(&L)                                                  00253000
         DC    C&LINE                                                   00254000
         MEND                                                           00255000
*                                                                       00256000
*        MACRO TO GENERATE PROPER CSECT NAMES DEPENDING ON MODULE       00257000
*                                                                       00258000
         MACRO                                                          00259000
         BEGIN &LTR                                                     00260000
         GBLA  &LMOD                                                    00261000
         AIF   (&LMOD EQ 1).LSECT                                       00262000
SPITBOL&LTR CSECT                                                       00263000
         MEXIT                                                          00264000
.LSECT   ANOP                                                           00265000
SPITBLL&LTR CSECT                                                       00266000
SPITBOL&LTR EQU SPITBLL&LTR                                             00267000
         MEND                                                           00268000
         EJECT                                                          00269000
*                                                                       00270000
*        INITV -- BUILD STANDARD VARIABLE ENTRY, SEE VARLOC             00271000
*                                                                       00272000
         MACRO                                                          00273000
         INITV &NAME,&TYPE                                              00274000
         LCLC  &NAME6,&TYPEL                                            00275000
         LCLA  &CTR,&FLAGS,&LENGTH,&P,&K,&F,&O,&L                       00276000
&NAME6   SETC  '&NAME'                                                  00277000
         AIF   (K'&NAME LE 6).NOK                                       00278000
&NAME6   SETC  '&NAME6'(1,6)                                            00279000
.NOK     ANOP                                                           00280000
E$&NAME6 EQU *                                                          00281000
&LENGTH  SETA  1+1+K'&NAME                                              00282000
&CTR     SETA  1                                                        00283000
.LOOP    AIF (&CTR GT K'&TYPE).ENDL                                     00284000
&TYPEL   SETC  '&TYPE'(&CTR,1)                                          00285000
&CTR     SETA  &CTR+1                                                   00286000
         AIF   ('&TYPEL' EQ 'K').KK                                     00287000
         AIF   ('&TYPEL' EQ 'P').PP                                     00288000
         AIF   ('&TYPEL' EQ 'F').FF                                     00289000
         AIF   ('&TYPEL' EQ 'O').OO                                     00290000
         AIF   ('&TYPEL' EQ 'L').LL                                     00291000
         MNOTE 12,'ERROR IN TYPE PARAMETER'                             00292000
.KK      ANOP                                                           00293000
&K       SETA  1                                                        00294000
&LENGTH  SETA  &LENGTH+1                                                00295000
&FLAGS   SETA  &FLAGS+1                                                 00296000
         AGO   .LOOP                                                    00297000
.PP      ANOP                                                           00298000
&P       SETA  1                                                        00299000
&FLAGS   SETA  &FLAGS+2                                                 00300000
&LENGTH  SETA  &LENGTH+2                                                00301000
         AGO   .LOOP                                                    00302000
.FF      ANOP                                                           00303000
&F       SETA  1                                                        00304000
&FLAGS   SETA  &FLAGS+4                                                 00305000
&LENGTH  SETA  &LENGTH+3                                                00306000
         AGO   .LOOP                                                    00307000
.OO      ANOP                                                           00308000
&O       SETA  1                                                        00309000
&FLAGS   SETA  &FLAGS+8                                                 00310000
&LENGTH  SETA  &LENGTH+2                                                00311000
         AGO   .LOOP                                                    00312000
.LL      ANOP                                                           00313000
&L       SETA  1                                                        00314000
&FLAGS   SETA  &FLAGS+16                                                00315000
&LENGTH  SETA  &LENGTH+2                                                00316000
         AGO   .LOOP                                                    00317000
.ENDL    DC    AL1(&LENGTH)                                             00318000
         DC    C'&NAME'                                                 00319000
         DC    AL1(&FLAGS)                                              00320000
         AIF   (&K EQ 0).KS                                             00321000
         DC    AL1(K$&NAME6)                                            00322000
.KS      AIF   (&P EQ 0).PS                                             00323000
         DC    AL2(P$&NAME6-SPITBOLX)                                   00324000
.PS      AIF   (&F EQ 0).FS                                             00325000
         DC    AL3(F$&NAME6-FCODE)                                      00326000
.FS      AIF   (&O EQ 0).OS                                             00327000
         DC    AL2(O$&NAME6-SPITBOLC)                                   00328000
.OS      AIF   (&L EQ 0).LS                                             00329000
         DC    AL2(L$&NAME6-SPITBOLX)                                   00330000
.LS      MEND                                                           00331000
         EJECT                                                          00332000
*                                                                       00333000
*        MACROS USED TO GENERATE TRANSLATE TABLES                       00334000
*                                                                       00335000
*                                                                       00336000
*LABL    TABL  DFLT                                                     00337000
*                                                                       00338000
*              INITIALIZES THE TABLE WITH NAME LABL TO CONTAIN          00339000
*              DFLT FOR ALL ENTRIES NOT SET WITH A 'FOR' MACRO CALL     00340000
*                                                                       00341000
*LABL    FOR   'CHARS',VALUE,FLAG                                       00342000
*                                                                       00343000
*              IN THE TABLE WITH NAME LABL, THE ENTRIES CORRESPONDING   00344000
*              TO THE CHARACTERS IN CHARS (WHICH MUST HAVE SEQUENTIAL   00345000
*              INTERNAL REPRESENTATIONS) ARE SET TO VALUE               00346000
*              THE FOLLOWING ARE USED IN PLACE OF THE FIRST PARAMETER   00347000
*              FOR SPECIAL CHARACTER CASES                              00348000
*              FOR ' USE QT                                             00349000
*              FOR & USE AM                                             00350000
*              FOR X'00' USE ZR                                         00351000
*                                                                       00352000
*              IF A SINGLE CHARACTER IS TO BE SET, THEN FLAG MAY BE     00353000
*              SET TO X TO INDICATE THAT THE ENTRY IMMEDIATELY          00354000
*              FOLLOWS THE PREVIOUS ONE -- I.E. THAT NO ORG IS NEEDED   00355000
*              (THIS WILL MINIMIZE THE NUMBER OF TEXT CARDS GENERATED)  00356000
*                                                                       00357000
*        NOTE THAT AN ORG SHOULD BE ISSUED AFTER EACH SEQUENCE OF       00358000
*        FOR CALLS FOLLOWING A TABL MACRO TO RESET THE LOCATION COUNTER 00359000
*                                                                       00360000
*                                                                       00361000
         MACRO                                                          00362000
&NAME    TABL  &DFLT                                                    00363000
&NAME    DC    256AL1(&DFLT)                                            00364000
         MEND                                                           00365000
         EJECT                                                          00366000
*                                                                       00367000
*                                                                       00368000
         MACRO                                                          00369000
&NAME    FOR   &CHARS,&VAL,&K                                           00370000
         LCLC  &FC                                                      00371000
         LCLA  &NM                                                      00372000
         AIF   ('&K' EQ 'X').F8                                         00373000
         AIF   (K'&CHARS EQ 2).F5                                       00374000
&FC      SETC  '&CHARS'(2,1)                                            00375000
&NM      SETA  K'&CHARS-2                                               00376000
         ORG   &NAME+C'&FC'                                             00377000
         DC    &NM.AL1(&VAL)                                            00378000
         MEXIT                                                          00379000
.F5      AIF   ('&CHARS' EQ 'QT').F7                                    00380000
         AIF   ('&CHARS' EQ 'ZR').F6                                    00381000
         AIF   ('&CHARS' EQ 'AM').F9                                    00382000
         MNOTE 0,'ERROR IN LOCATION PARAMETER'                          00383000
         MEXIT                                                          00384000
.F6      ORG   &NAME                                                    00385000
         AGO   .F8                                                      00386000
.F7      ORG   &NAME+C''''                                              00387000
         AGO   .F8                                                      00388000
.F9      ORG   &NAME+C'&&'                                              00389000
.F8      DC    AL1(&VAL)                                                00390000
         MEND                                                           00391000
         EJECT                                                          00392000
*                                                                       00393000
*        OPERATOR DOPE VECTOR GENERATION MACROS                         00394000
*        THE FORMAT OF THESE CALLS IS DESCIBED IN THE SCAN ROUTINE      00395000
*        WHERE THE CALLS APPEAR                                         00396000
*                                                                       00397000
         MACRO                                                          00398000
&LBL     BINOP &PRI,&VAL,&NAM,&FLG                                      00399000
         AIF   ('&NAM' EQ '').B4                                        00400000
         AIF   ('&FLG' EQ '').B2                                        00401000
&LBL     BINP1 &PRI,&VAL,YNAME+BNOP+&FLG                                00402000
         BINP1 &PRI,&NAM,&FLG+BNOP                                      00403000
         MEXIT                                                          00404000
.B2      ANOP                                                           00405000
&LBL     BINP1 &PRI,&VAL,YNAME+BNOP                                     00406000
         BINP1 &PRI,&NAM,BNOP                                           00407000
         MEXIT                                                          00408000
.B4      AIF   ('&FLG' EQ '').B6                                        00409000
&LBL     BINP1 &PRI,&VAL,&FLG+BNOP                                      00410000
         MEXIT                                                          00411000
.B6      ANOP                                                           00412000
&LBL     BINP1 &PRI,&VAL,BNOP                                           00413000
         MEND                                                           00414000
*                                                                       00415000
*                                                                       00416000
         MACRO                                                          00417000
&LBL     BINP1 &PRI,&RTN,&FLG                                           00418000
         CNOP  0,4                                                      00419000
&LBL     DC    AL1(&PRI)                                                00420000
         AIF   (N'&RTN EQ 1).B6                                         00421000
         AIF   ('&RTN(2)' EQ 'N').B3                                    00422000
         AIF   ('&RTN(3)' EQ 'N').B1                                    00423000
.B6      DC    AL1(&FLG)                                                00424000
         AGO   .B9                                                      00425000
.B1      DC    AL1(&FLG+RITNAM)                                         00426000
         AGO   .B9                                                      00427000
.B3      AIF   ('&RTN(3)' EQ 'N').B4                                    00428000
         DC    AL1(&FLG+LEFNAM)                                         00429000
         AGO   .B9                                                      00430000
.B4      DC    AL1(&FLG+LEFNAM+RITNAM)                                  00431000
.B9      DC    S(&RTN(1))                                               00432000
         MEND                                                           00433000
         EJECT                                                          00434000
         MACRO                                                          00435000
&LBL     UNOP  &VAL,&NAM,&FLG                                           00436000
         AIF   ('&NAM' EQ '').U4                                        00437000
         AIF   ('&FLG' EQ '').U2                                        00438000
&LBL     UNOP1 &VAL,YNAME+RASS+&FLG                                     00439000
         UNOP1 &NAM,RASS+&FLG                                           00440000
         MEXIT                                                          00441000
.U2      ANOP                                                           00442000
&LBL     UNOP1 &VAL,YNAME+RASS                                          00443000
         UNOP1 &NAM,RASS                                                00444000
         MEXIT                                                          00445000
.U4      AIF   ('&FLG' EQ '').U6                                        00446000
&LBL     UNOP1 &VAL,RASS+&FLG                                           00447000
         MEXIT                                                          00448000
.U6      ANOP                                                           00449000
&LBL     UNOP1 &VAL,RASS                                                00450000
         MEND                                                           00451000
*                                                                       00452000
*                                                                       00453000
         MACRO                                                          00454000
&LBL     UNOP1 &RTN,&FLG                                                00455000
         CNOP  0,4                                                      00456000
&LBL     DC    AL1(15)                                                  00457000
         AIF   (N'&RTN EQ 1).U6                                         00458000
         AIF   ('&RTN(2)' EQ 'N').U3                                    00459000
         DC    AL1(&FLG)                                                00460000
         AGO   .U4                                                      00461000
.U3      DC    AL1(&FLG+RITNAM)                                         00462000
.U4      DC    S(&RTN(1))                                               00463000
         MEXIT                                                          00464000
.U6      DC    AL1(&FLG)                                                00465000
         DC    S(&RTN)                                                  00466000
         MEND                                                           00467000
         EJECT                                                          00468000
*                                                                       00469000
*        MACRO TO GENERATE TABLE OF SYSTEM ROUTINE                      00470000
*        S ADDRESSES AND NAMES FOR SYMBOLIC PRINTOUT                    00471000
*                                                                       00472000
         MACRO                                                          00473000
         NAME                                                           00474000
         LCLA  &CTR                                                     00475000
&CTR     SETA  1                                                        00476000
.LOOP    ANOP                                                           00477000
         AIF   ('&SYSLIST(&CTR)' EQ '').END                             00478000
         DC    S($$&SYSLIST(&CTR))                                      00479000
         DC    C'&SYSLIST(&CTR)'                                        00480000
&CTR     SETA  &CTR+1                                                   00481000
         AGO   .LOOP                                                    00482000
.END     MEND                                                           00483000
         TITLE 'SPITBOL -- EXECUTION PACKAGE MACRO DEFINITIONS'         00484000
*                                                                       00485000
*        MACRO TO GENERATE STANDARD (ONE NODE) PATTERNS WITH NO PARAMS  00486000
*                                                                       00487000
*        PATTERN   NAME= , EXTEND= , MIN=                               00488000
*                                                                       00489000
*        NAME=NNN                 NAME OF PATTERN                       00490000
*                                 (THE CHARS  PAT  ARE ADDED ON)        00491000
*        EXTEND=YES               INDICATES USE OF EXTEND ROUTINE       00492000
*        MIN=NNN                  SPECIFIES CONTENTS OF MINMATCH FIELD  00493000
*                                 (DEFAULT IS ZERO)                     00494000
*                                                                       00495000
         MACRO                                                          00496000
         PATTERN   &NAME=,&EXTEND=NO,&MIN=0                             00497000
         CNOP  0,4                                                      00498000
&NAME.PAT EQU  *                                                        00499000
         DC    AL1(PBLOK)                                               00500000
         DC    AL3(0)                                                   00501000
         DC    Y(28)                                                    00502000
         DC    Y(ANCHEXT-QPATSUBS)                                      00503000
         DC    A(NOTHEN)                                                00504000
         DC    AL1(QF)                                                  00505000
         DC    AL3(NOOR)                                                00506000
         DC    AL1(QF)                                                  00507000
         DC    AL3(PN$&NAME)                                            00508000
         DC    Y(&MIN)                                                  00509000
         AIF   ('&EXTEND' EQ 'YES').YX                                  00510000
         DC    Y(NOEXT-QPATSUBS)                                        00511000
         AGO   .YZ                                                      00512000
.YX      DC    Y(&NAME.EXT-QPATSUBS)                                    00513000
.YZ      DC    AL2(PNOTHEN-PATS)                                        00514000
         DC    AL2(PNOOR-PATS)                                          00515000
         MEND                                                           00516000
         EJECT                                                          00517000
*                                                                       00518000
*        PORG -- MACRO USED TO POSITION FULL SCAN ROUTINES FOR PATTERN  00519000
*        MATCHING IN CORRECT LOCATION RELATIVE TO QUICKSCAN ROUTINES    00520000
*                                                                       00521000
         MACRO                                                          00522000
&NAME    PORG                                                           00523000
         LA    0,&NAME+FPATSUBS-QPATSUBS-*  CHECK FOR BACKWARDS         00524000
         ORG   &NAME+FPATSUBS-QPATSUBS                                  00525000
         MEND                                                           00526000
         EJECT                                                          00527000
*                                                                       00528000
*        MACRO TO GENERATE TABLE OF INTERRUPT LOCATIONS AND EXITS       00529000
*        FOR SPINTR                                                     00530000
*                                                                       00531000
         MACRO                                                          00532000
         INTRUP    &WHERE,&TYPE,&TRA                                    00533000
         DC    AL1(INT&TYPE)                                            00534000
         DC    AL2(IIN&TYPE)                                            00535000
         DC    AL3(&WHERE)                                              00536000
         DC    AL3(&TRA)                                                00537000
         MEND                                                           00538000
*                                                                       00539000
*        MACRO TO GENERATE KEYWORD TABLE ENTRY FOR DUMP FUNCTION        00540000
*                                                                       00541000
         MACRO                                                          00542000
&LBL     KEYOFF &N                                                      00543000
         LCLA  &A                                                       00544000
         LCLC  &C                                                       00545000
&C       SETC  '&N'                                                     00546000
&A       SETA  (K'&N-1)*4096                                            00547000
         AIF   (K'&N LE 6).NXT                                          00548000
&C       SETC  '&C'(1,6)                                                00549000
.NXT     ANOP                                                           00550000
&LBL     DC    Y(&A+E$&C-INITVR1)                                       00551000
         MEND                                                           00552000
         EJECT                                                          00553000
*                                                                       00554000
*        MACROS FOR EXECUTION ERROR MESSAGES                            00555000
*                                                                       00556000
*                                                                       00557000
*NUMBER  XERM  'ERROR MESSAGE'                                          00558000
*                                                                       00559000
*              SETS UP 'ERROR MESSAGE' AS MESSAGE NUMBER 'NUMBER'       00560000
*                                                                       00561000
         MACRO                                                          00562000
&NO      XERM  &MSG                                                     00563000
         GBLA  &XCNT                                                    00564000
         LCLA  &K                                                       00565000
&K       SETA  K'&MSG-3                                                 00566000
XERR&NO  DC    AL1(&K)                                                  00567000
         DC    C&MSG                                                    00568000
&XCNT    SETA  &NO                                                      00569000
         MEND                                                           00570000
*                                                                       00571000
*        XETB                                                           00572000
*                                                                       00573000
*        GENERATES A TABLE OF OFFSETS TO ERROR MESSAGES                 00574000
*                                                                       00575000
         MACRO                                                          00576000
         XETB                                                           00577000
         GBLA  &XCNT                                                    00578000
         LCLA  &CTR                                                     00579000
EXERMA   DS    0H                                                       00580000
&CTR     SETA  1                                                        00581000
.LOOP    DC    AL2(XERR&CTR-EXMSGS)                                     00582000
&CTR     SETA  &CTR+1                                                   00583000
         AIF   (&CTR LE &XCNT).LOOP                                     00584000
         MEND                                                           00585000
         EJECT                                                          00586000
*                                                                       00587000
*LABL    XERR  NUMBER,ID                                                00588000
*                                                                       00589000
*                                                                       00590000
*        GENERATES A CALL TO PRINT ERROR MESSAGE NUMBER WITH GIVEN ID   00591000
*                                                                       00592000
         MACRO                                                          00593000
&LBL     XERR  &MAJOR,&MINOR,&S                                         00594000
XER&MAJOR&MINOR EQU *                                                   00595000
         AIF   ('&S' EQ 'S').CALLS                                      00596000
&LBL     BALR  RETURN,SYS                                               00597000
         DC    AL1(&MAJOR,&MINOR)                                       00598000
         MEXIT                                                          00599000
.CALLS   ANOP                                                           00600000
&LBL     BAL   R1,EXERRS                                                00601000
         DC    AL1(&MAJOR,&MINOR)                                       00602000
         MEND                                                           00603000
*                                                                       00604000
*                                                                       00605000
*        XERN IS LIKE XERR EXCEPT THAT THE ASSEMBLY SYMBOL GENERATED    00606000
*        IS XENXXYYY INSTEAD OF XERXXYYY. THIS IS USED WHERE THE        00607000
*        SAME ERROR MESSAGE MUST BE ISSUED FROM TWO LOCATIONS           00608000
*                                                                       00609000
         MACRO                                                          00610000
&LBL     XERN  &MAJOR,&MINOR,&S                                         00611000
XEN&MAJOR&MINOR EQU *                                                   00612000
         AIF   ('&S' EQ 'S').CALLS                                      00613000
&LBL     BALR  RETURN,SYS                                               00614000
         DC    AL1(&MAJOR,&MINOR)                                       00615000
         MEXIT                                                          00616000
.CALLS   ANOP                                                           00617000
&LBL     BAL   R1,EXERRS                                                00618000
         DC    AL1(&MAJOR,&MINOR)                                       00619000
         MEND                                                           00620000
         EJECT                                                          00621000
*                                                                       00622000
*                                                                       00623000
*        MACRO TO GENERATE ENTRY POINTS FOR INTRINSIC FUNCTIONS         00624000
*        WITH ONE ARGUMENT (SEE ANY ENTRY POINT)                        00625000
*                                                                       00626000
         MACRO                                                          00627000
&NAME    FUNC  &TRA                                                     00628000
         LCLC  &NM                                                      00629000
&NM      SETC  '&NAME'                                                  00630000
         AIF   (K'&NAME LE 6).OKL                                       00631000
&NM      SETC  '&NM'(1,6)                                               00632000
.OKL     ANOP                                                           00633000
         USING F$&NM-FCODE,DB4                                          00634000
F$&NM    BAL   R2,LOADARG                                               00635000
         DC    Y(&TRA-SPITBOLA)                                         00636000
         MEND                                                           00637000
*                                                                       00638000
*        MACRO TO GENERATE STANDARD FUNCTION HEADER                     00639000
*                                                                       00640000
         MACRO                                                          00641000
&NAME    FUNCTION  &NARG,&FLAG                                          00642000
         LCLC  &NM                                                      00643000
&NM      SETC  '&NAME'                                                  00644000
         AIF   (K'&NAME LE 6).OKL                                       00645000
&NM      SETC  '&NM'(1,6)                                               00646000
.OKL     ANOP                                                           00647000
F$&NM    DS    0H                                                       00648000
         USING F$&NM-FCODE,DB4                                          00649000
         USING SPITBOLA,SYS                                             00650000
         AIF   (&NARG LT 2).S                                           00651000
         CH    R0,H&NARG                                                00652000
         BL    $$WNAG                                                   00653000
.S       AIF   ('&FLAG' NE '').T                                        00654000
         ST    RETURN,RETLOC                                            00655000
.T       ANOP                                                           00656000
         MEND                                                           00657000
*                                                                       00658000
*        MACRO TO GENERATE STANDARD FUNCTION TERMINATION                00659000
*                                                                       00660000
         MACRO                                                          00661000
&NAME    ENDFUNC                                                        00662000
         LTORG                                                          00663000
         MEND                                                           00664000
         TITLE 'SPITBOL -- GLOBAL SET SYMBOL DEFINITIONS'               00665000
         GBLA  &XCNT              EXECUTION ERROR MESSAGE COUNT         00666000
         GBLA  &LMOD              GLOBAL MODULE SWITCH                  00667000
*                                                                       00668000
&XCNT    SETA  0                  INITIALIZE EXECUTION MESSAGE COUNT    00669000
*                                                                       00670000
*        COPY EXTERNAL DEFINITION OF &LMOD                              00671000
*                                                                       00672000
         COPY  DEFLMOD            (CONTAINS &LMOD SETA 0 OR 1)          00673000
*                                                                       00674000
         PRINT NOGEN              LET THE LISTING BE CLEAN & BEAUTIFUL  00675000
         TITLE 'SPITBOL -- DATA STRUCTURES -- ADDRESSABLE AREA'         00676000
FORMAT   DSECT ,                  FORMATS AND DEFINITIONS               00677000
*                                                                       00678000
*        THE ADDRESSABLE AREA IS DIVIDED INTO 4K BLOCKS EACH OF         00679000
*        WHICH IS ADDRESSABLE USING A BASE VALUE LOADED FROM THE        00680000
*        DATA BASE TABLE ($$BAS1,2,3...). THE DATA BASE TABLE IS        00681000
*        ALWAYS ADDRESSABLE SINCE IT IS UNDER THE STANDARD DATA         00682000
*        REGISTER (8 = DREG = DB1). THIS REGISTER ALSO POINTS           00683000
*        TO THE FIRST 4K BLOCK, WHICH IS ATYPICAL SINCE THE FIRST       00684000
*        SECTION IS USED FOR GENERAL WORK AREAS (SEE SPITBOLD DSECT)    00685000
*                                                                       00686000
*        WITHIN EACH 4K SEGMENT, VARIABLE BLOCKS (SEE NEXT PAGE)        00687000
*        ARE BUILT UPWARDS FROM THE BOTTOM, AND CONSTANT BLOCKS         00688000
*        ARE BUILT DOWN FROM THE TOP.                                   00689000
*                                                                       00690000
*        THE LAST 8 BYTES OF EACH BLOCK ARE USED FOR CONTROL            00691000
*        INFORMATION AS FOLLOWS                                         00692000
*                                                                       00693000
CBLKBOT  EQU   4096-8             ADDRESS OF LOWEST CONSTANT BLOCK      00694000
*                                 ACTUALLY ALLOCATED (NOTE THAT THE     00695000
*                                 UPPER BYTE MUST BE ZERO FOR GCOL)     00696000
*                                                                       00697000
VBLKNXT  EQU   4096-4             ADDRESS OF NEXT VARIABLE BLOCK TO     00698000
*                                 BE ALLOCATED (VBLKNXT<=CBLKBOT)       00699000
*                                                                       00700000
CBLKEND  EQU   4096-8             INITIAL OFFSET TO LAST CONSTANT BLK   00701000
*                                                                       00702000
*        NOTE THAT THE ADDRESSES STORED IN CBLKBOT AND VBLKNXT          00703000
*        DO NOT CONTAIN THE STANDARD (VALUE) BLOCK OFFSET               00704000
*                                                                       00705000
*        ADDRESSES OF 4K BLOCKS STORED AND REFERENCED IN VARIOUS PLACES 00706000
*        ARE ADDRESSES OF THE ACTUAL BLOCKS EXCEPT FOR THE ADDRESSES    00707000
*        IN THE BASE TABLE WHICH POINT (VALUE) IN FRONT OF THE 4K       00708000
*        BLOCK TO ENSURE ADDRESSABILITY OF THE FIRST VARIABLE BLOCK.    00709000
         EJECT                                                          00710000
*                                                                       00711000
*        VARIABLE BLOCK                                                 00712000
*        --------------                                                 00713000
*                                                                       00714000
*                                                                       00715000
*     ->                                                                00716000
*        +-------------------------------------------------------+      00717000
*        |                                                       |      00718000
*        +                         VALUE                         +      00719000
*        |                                                       |      00720000
*        +-------------+-----------------------------------------+      00721000
*        |   VFLAGS    |                 VLINK                   |      00722000
*        +-------------+-----------------------------------------+      00723000
*        |   VKEY      |                 VFUNC                   |      00724000
*        +-------------+-----------------------------------------+      00725000
*        |   VPHASE    |                 VLABL                   |      00726000
*        +-------------+-----------------------------------------+      00727000
*        |   //////    |                 VIOPTR                  |      00728000
*        +-------------+-----------------------------------------+      00729000
*        |                                                       |      00730000
*        +                         VNAME                         +      00731000
*        |                                                       |      00732000
*        +-------------------------------------------------------+      00733000
*                                                                       00734000
*                                                                       00735000
*        DEFINITIONS AND DESCRIPTION FOR VARIABLE BLOCK                 00736000
*        ----------------------------------------------                 00737000
*                                                                       00738000
*        NOTE THAT DATA AREA IS ALLIGNED SO THAT BOTH VALUE AND VNAME   00739000
*        LIE ON DOUBLE WORD BOUNDARIES. THIS SPEEDS REFERENCES ON       00740000
*        LARGER 360S SO IT SHOULD BE PRESERVED                          00741000
*                                                                       00742000
VALUE    EQU   4                  OFFSET TO VALUE FIELD                 00743000
VFLAGS   EQU   12                 FLAGS (SEE OVER)                      00744000
VLINK    EQU   12                 LINK TO NEXT BLOCK ON HASH CHAIN      00745000
VKEY     EQU   16                 KEYWORD NUMBER (0 IF NOT KEYWORD)     00746000
*                                 LESS THAN X'80' SO VFUNC IS POSITIVE  00747000
VFUNC    EQU   16                 POINTER TO FUNCTION BLOCK (OR DV PTR) 00748000
VPHASE   EQU   20                 PHASE NUMBER FOR LABEL IN MULTIPHASE  00749000
VLABL    EQU   20                 POINTER TO LABEL                      00750000
VDVPTR   EQU   VALUE+4            DOPE VECTOR POINTER FOR INTRINSIC FNC 00751000
VIOPTR   EQU   24                 PTR TO IOBLOK IF I/O ASSOCIATED       00752000
*                                 SET TO ZERO IF NOT ASSOCIATED         00753000
VNAME    EQU   28                 NAME OF BLOCK (STANDARD SCODE FORMAT) 00754000
VARSIZ   EQU   32                 LENGTH OF VARIABLE BLOCK              00755000
         EJECT                                                          00756000
*                                                                       00757000
*        VARIABLE BLOCK -- CONTINUED                                    00758000
*                                                                       00759000
*        FLAGS IN VFLAGS                                                00760000
*                                                                       00761000
VINP     EQU   X'80'              ON -> INPUT CODE INTERCEPTS POSTED    00762000
VOUP     EQU   X'40'              ON -> OUTPUT CODE INTERCEPTS POSTED   00763000
VINA     EQU   X'20'              ON -> VARIABLE IS INPUT ASSOCIATED    00764000
VOUA     EQU   X'10'              ON -> VARIABLE IS OUTPUT ASSOCIATED   00765000
VTRC     EQU   X'08'              ON -> VARIABLE IS VALUE TRACED        00766000
VFTC     EQU   X'04'              ON -> FUNCTION IS CALL TRACED         00767000
VFTR     EQU   X'02'              ON -> FUNCTION IS RETURN TRACED       00768000
*                                                                       00769000
*                                                                       00770000
*        THE COMPILER BUILDS ONE OF THESE BLOCKS FOR EACH VARIABLE,     00771000
*        LABEL OR FUNCTION MENTIONED IN THE SOURCE PROGRAM.             00772000
*                                                                       00773000
*        IN ADDITION THE INDIRECT ADDRESSING ROUTINES $$DL1N,$$DL1S     00774000
*        ALSO BUILD VARIABLE BLOCKS IN THE ADDRESSABLE DATA AREA        00775000
*                                                                       00776000
*        NOTE THAT ALL THE OFFSETS ARE DEFINED WITH RESPECT TO A        00777000
*        PSEUDO-ORIGIN 4 BEHIND THE START OF THE BLOCK -- THIS IS FOR   00778000
*        COMPATABILITY WITH THE EXECUTE TIME STRUCTURES WHICH HAVE A    00779000
*        FOUR BYTE GARBAGE COLLECTION FIELD                             00780000
*                                                                       00781000
*                                                                       00782000
*        RELOCATABLE FIELDS       VALUE                                 00783000
*                                 VNAME                                 00784000
*                                 VFUNC                                 00785000
         EJECT                                                          00786000
*                                                                       00787000
*        REAL AND INTEGER CONSTANTS                                     00788000
*        --------------------------                                     00789000
*                                                                       00790000
*        (COMPILE TIME)                                                 00791000
*                                                                       00792000
*     ->                                                                00793000
*        +-------------+-----------------------------------------+      00794000
*        |   CONCODE   |                    CHASHL               |      00795000
*        +-------------+-----------------------------------------+      00796000
*        |                        CVALUE                         |      00797000
*        +-------------------------------------------------------+      00798000
*                                                                       00799000
CONCODE  EQU   VALUE              ICODE FOR INTEGER, RCODE FOR REAL     00800000
CHASHL   EQU   VALUE              PTR TO NEXT CONSTANT ON HASH CHAIN    00801000
CVALUE   EQU   VALUE+4            VALUE OF INTEGER OR REAL CONSTANT     00802000
*                                                                       00803000
*        AT EXECUTE TIME, THIS BLOCK IS CONVERTED TO STANDARD           00804000
*        VALUE FORMAT BY CLEARING THE CHASHL FIELD TO ZERO.             00805000
*        CHASHL IS USED TO LINK CONSTANTS INTO THE CONSTANT HASH TABLE  00806000
*        (CHASH) TO AVOID CREATING DUPLICATE CONSTANTS.                 00807000
*                                                                       00808000
*                                                                       00809000
*        STRING CONSTANTS                                               00810000
*        ----------------                                               00811000
*                                                                       00812000
*        (COMPILE TIME)                                                 00813000
*                                                                       00814000
*     ->                                                                00815000
*        +-------------+-----------------------------------------+      00816000
*        |   CONCODE   |                    CHASHL               |      00817000
*        +-------------+-----------------------------------------+      00818000
*        |   CSLENGTH  |                    CSADR                |      00819000
*        +-------------+-----------------------------------------+      00820000
*                                                                       00821000
*CONCODE EQU   VALUE              SET TO SCODE TO INDICATE STRING       00822000
*CHASHL  EQU   VALUE              POINTER TO NEXT BLOCK ON HASH CHAIN   00823000
CSLENGTH EQU   VALUE+4            360 LENGTH OF STRING CONSTANT         00824000
CSADR    EQU   VALUE+4            ADDRESS OF STRING (- SCHARS)          00825000
*                                                                       00826000
*        BEFORE EXECUTION, THIS BLOCK IS REORGANIZED TO CONFORM         00827000
*        TO THE REQUIREMENTS FOR A STANDARD STRING SPECIFIER            00828000
*                                                                       00829000
*                                                                       00830000
*        DREALS, EXPRESSIONS AND CONSTANT SUBEXPRESSIONS CAUSE THE      00831000
*        CONSTRUCTION OF A BLOCK IN STANDARD VALUE FORMAT AS DESCRIBED  00832000
*        IN A FOLLOWING SECTION. THESE CONSTANTS ARE NOT HASHED.        00833000
         TITLE 'SPITBOL -- DATA FORMATS -- DYNAMIC AREA'                00834000
*                                                                       00835000
*        COMMON STRUCTURE                                               00836000
*        ----------------                                               00837000
*                                                                       00838000
*                                                                       00839000
*        +-------------+-----------------------------------------+      00840000
*     -> |    DTYPE    |               GCOLPTR                   |      00841000
*        +-------------+-----------------------------------------+      00842000
*        |                                                       |      00843000
*        +                 REMAINDER OF BLOCK                    +      00844000
*        |                                                       |      00845000
*        +-------------------------------------------------------+      00846000
*                                                                       00847000
*                                                                       00848000
*        OFFSET DEFINITIONS                                             00849000
*        ------------------                                             00850000
*                                                                       00851000
DTYPE    EQU   0                  CODE FOR DATA TYPE                    00852000
GCOLPTR  EQU   0*4                POINTER FIELD USED BY GARBAGE         00853000
*                                 COLLECTOR                             00854000
*                                                                       00855000
*                                                                       00856000
*        FUNCTION BLOCK FORMAT DESCRIPTION                              00857000
*        ---------------------------------                              00858000
*                                                                       00859000
*        FUNCTIONS WHICH ARE COMPILED AS BLOCKS IN DYNAMIC MEMORY       00860000
*        HAVE A CERTAIN COMMON STRUCTURE. NAMELY EXECUTION OF THE       00861000
*        FUNCTION STARTS WITH A BRANCH TO THE INSTRUCTION IN THE        00862000
*        FCODE FIELD. THE FOUR TYPES OF FUNCTION IN DYNAMIC MEMORY      00863000
*        CAN BE UNIQUELY IDENTIFIED BY THE FIRST INSTRUCTION IN         00864000
*        THIS CODE SEQUENCE (I.E. THE INSTRUCTION AT FCODE):            00865000
*                                                                       00866000
*        FBLOK     PROG DEFINED FUNC        B  $$FUNC                   00867000
*        EFBLOK    EXTERNAL FUNCTION        B  $$LOAD                   00868000
*        PDFBLOK   PROG DEF DATATYPE FUNC   CH R0,*-*(DB4)              00869000
*        FFBLOK    FIELD FUNCTION           CLI  TEM#1(PDR),DCODE       00870000
*                                                                       00871000
*        IT IS MOST IMPORTANT THAT NO SYSTEM FUNCTIONS START WITH ANY   00872000
*        OF THE ABOVE FOUR INSTRUCTIONS OR SERIOUS CONFUSION WILL ARISE 00873000
         EJECT                                                          00874000
*                                                                       00875000
*        STRING BLOCK (SBLOK)                                           00876000
*        --------------------                                           00877000
*                                                                       00878000
*                                                                       00879000
*        +-------------+-----------------------------------------+      00880000
*     -> |    SBLOK    |                    ///////              |      00881000
*        +-------------+-------------+---------------------------+      00882000
*        |        STLENGTH           |                           |      00883000
*        +---------------------------+                           |      00884000
*        |                                                       |      00885000
*        |                       SCHARS                          |      00886000
*                                                                       00887000
*        /                                                       /      00888000
*        /                                                       /      00889000
*                                                                       00890000
*        |                                                       |      00891000
*        +-------------------------------------------------------+      00892000
*                                                                       00893000
*                                                                       00894000
*        DEFINITIONS AND DESCRIPTION FOR SBLOK                          00895000
*        -------------------------------------                          00896000
*                                                                       00897000
SBLOK    EQU   0                  CODE FOR STRING BLOCK                 00898000
STLENGTH EQU   4                  LENGTH OF BLOCK (PADDED TO 4 BT BDRY) 00899000
SCHARS   EQU   6                  START OF CHARACTER STRING             00900000
*                                                                       00901000
*        THIS BLOCK CONTAINS AN ARBITRARY STRING OF CHARACTERS OF       00902000
*        ANY LENGTH -- INDIVIDUAL SPECIFIERS MAY POINT TO A PART OR THE 00903000
*        WHOLE OF THIS STRING.                                          00904000
*                                                                       00905000
*        AN SBLOK IS CREATED BY ANY OPERATION WHICH FORMS A NEW STRING, 00906000
*        SUCH AS CONCATENATION, INPUT, PATTERN REPLACEMENT ETC.         00907000
*                                                                       00908000
*        RELOCATABLE FIELDS       NONE                                  00909000
         EJECT                                                          00910000
*                                                                       00911000
*        CHARACTER TABLE BLOCK (TBLOK)                                  00912000
*        -----------------------------                                  00913000
*                                                                       00914000
*        +-------------+-----------------------------------------+      00915000
*     -> |    TBLOK    |                    ///////              |      00916000
*        +-------------+-----------------------------------------+      00917000
*        |                                                       |      00918000
*        +                        CTCHARS                        +      00919000
*                                                                       00920000
*        /                                                       /      00921000
*        /                                                       /      00922000
*                                                                       00923000
*        |                                                       |      00924000
*        +-------------------------------------------------------+      00925000
*                                                                       00926000
*                                                                       00927000
*        DEFINITIONS AND DESCRIPTIONS FOR TBLOK                         00928000
*        --------------------------------------                         00929000
*                                                                       00930000
TBLOK    EQU   SBLOK+4            CODE FOR CHARACTER TABLE              00931000
CTCHARS  EQU   4                  OFFSET FOR 256 CHARACTER TABLE        00932000
*                                                                       00933000
*        THESE TABLES ARE USED BY THE SPAN,BREAK,ANY AND NOTANY         00934000
*        PATTERNS. FOR SPAN AND BREAK THEY ARE SIMPLY 360 TRANSLATE     00935000
*        AND TEST TABLES (ONE TABLE CORRESPONDS TO ONE PATTERN)         00936000
*        FOR ANY AND NOTANY, UP TO 8 PATTERNS CAN SHARE THE SAME TABLE  00937000
*        BY USING THE 8 AVAILABLE BIT POSITIONS IN EACH BYTE.           00938000
*                                                                       00939000
*        A TBLOK IS CREATED ON A CALL TO ONE OF THE ABOVE               00940000
*        FUNCTIONS WHEN NEEDED.                                         00941000
*                                                                       00942000
*        RELOCATABLE FIELDS       NONE                                  00943000
         EJECT                                                          00944000
*                                                                       00945000
*        FUNCTION BLOCK (FBLOK)                                         00946000
*        ----------------------                                         00947000
*                                                                       00948000
*        +-------------+-----------------------------------------+      00949000
*     -> |    FBLOK    |                    ///////              |      00950000
*        +-------------+-------------+-------------+-------------+      00951000
*        |           FNLENG          |    FFLAGS   |    /////    |      00952000
*        +---------------------------+-------------+-------------+      00953000
*        |                        B    $$FUNC                    |      00954000
*        +---------------------------+---------------------------+      00955000
*        |           FNARGS          |           FNLOCS          |      00956000
*        +---------------------------+---------------------------+      00957000
*        |                         FLABEL                        |      00958000
*        +-------------------------------------------------------+      00959000
*        |                         FNAME                         |      00960000
*        +-------------------------------------------------------+      00961000
*        |                FARGS (FIRST ARG POINTER)              |      00962000
*        +-------------------------------------------------------+      00963000
*                                                                       00964000
*        /                                                       /      00965000
*        /                                                       /      00966000
*                                                                       00967000
*        +-------------------------------------------------------+      00968000
*        |                    LAST ARG POINTER                   |      00969000
*        +-------------------------------------------------------+      00970000
*        |                    FIRST LOCAL POINTER                       00971000
*        +-------------------------------------------------------+      00972000
*                                                                       00973000
*        /                                                       /      00974000
*        /                                                       /      00975000
*                                                                       00976000
*        +-------------------------------------------------------+      00977000
*        |                    LAST LOCAL POINTER                 |      00978000
*        +-------------------------------------------------------+      00979000
         EJECT                                                          00980000
*                                                                       00981000
*        DEFINITIONS AND DESCRIPTION FOR FBLOK                          00982000
*        -------------------------------------                          00983000
*                                                                       00984000
FBLOK    EQU   TBLOK+4            CODE FOR FUNCTION BLOCK               00985000
FCODE    EQU   8                  ENTRY POINT TO CODE FOR FUNCTION      00986000
FNLENG   EQU   4                  LENGTH OF FBLOK (BYTES)               00987000
FFLAGS   EQU   6                  FUNCTION TRACE FLAGS                  00988000
FNARGS   EQU   12                 NUMBER OF ARGUMENTS                   00989000
FNLOCS   EQU   14                 NUMBER OF LOCALS                      00990000
FLABEL   EQU   16                 ACTUAL LABEL POINTER FOR TRA          00991000
FNAME    EQU   20                 VBLOK POINTER FOR NAME OF FUNCTION    00992000
FARGS    EQU   24                 START OF ARGS/LOCALS VBLOK POINTERS   00993000
*                                                                       00994000
*        FUNCTION TRACE FLAGS                                           00995000
*                                                                       00996000
FTRCC    EQU   VFTC               FLAG FOR FUNCTION CALL TRACE          00997000
FTRCR    EQU   VFTR               FLAG FOR FUNCTION RETURN TRACE        00998000
*                                                                       00999000
*        THIS BLOCK CONTROLS ALL THE NECCESSARY STACK MANIPULATIONS     01000000
*        SAVES ETC. TO CALL USER DEFINED FUNCTIONS. SEE SECTION ON      01001000
*        PDR STACK ORGANIZATION FOR A DETAILED DESCRIPTION OF THE       01002000
*        USE OF THIS STACK.                                             01003000
*                                                                       01004000
*        AN FBLOK IS BUILT BY A CALL TO THE DEFINE ROUTINE              01005000
*                                                                       01006000
*        RELOCATABLE FIELDS       NONE                                  01007000
         EJECT                                                          01008000
*                                                                       01009000
*        EXTERNAL FUNCTION CONTROL BLOCK (EFBLOK)                       01010000
*        ----------------------------------------                       01011000
*                                                                       01012000
*                                                                       01013000
*        +-------------+-----------------------------------------+      01014000
*        |    EFBLOK   |                    ///////              |      01015000
*        +-------------+-------------+---------------------------+      01016000
*        |           EFNARGS         |            EFLENG         |      01017000
*        +---------------------------+---------------------------+      01018000
*        |                  B     $$LOAD                         |      01019000
*        +-------------+-----------------------------------------+      01020000
*        |    EFUSE    |                 EFCODE                  |      01021000
*        +-------------+-----------------------------------------+      01022000
*        |                        EFNAME                         |      01023000
*        +-------------+-----------------------------------------+      01024000
*        |    EFTRSL   |                                         |      01025000
*        +-------------+                                         +      01026000
*                                                                       01027000
*        /                        EFTARGS                        /      01028000
*        /                                                       /      01029000
*                                                                       01030000
*        |                                                       |      01031000
*        +-------------------------------------------------------+      01032000
*                                                                       01033000
*                                                                       01034000
*        DEFINITIONS AND DESCRIPTION FOR EFBLOK                         01035000
*        --------------------------------------                         01036000
*                                                                       01037000
EFBLOK   EQU   FBLOK+4            CODE FOR EXTERNAL FUNCTION CNTL BLOCK 01038000
EFNARGS  EQU   4                  NUMBER OF ARGS FOR EXTERNAL FUNCTION  01039000
EFLENG   EQU   6                  LENGTH OF THE EFBLOK IN BYTES         01040000
EFUSE    EQU   12                 USECOUNT = # OF FUNCS POINTING TO BLK 01041000
*                                 USED TO DETERMINE WHEN CODE SHOULD    01042000
*                                 BE UNLOADED BY SYSTEM                 01043000
EFCODE   EQU   12                 FUNCTION CODE POINTER (SYSTEM AREA)   01044000
EFNAME   EQU   16                 POINTER TO VAR BLK WITH FUNCTION NAME 01045000
EFTRSL   EQU   20                 CODE FOR TYPE OF RESULT               01046000
*                                 REAL      LOADRRL-LOADRTNS            01047000
*                                 DREAL     LOADRDR-LOADRTNS            01048000
*                                 INTEGER   LOADRIN-LOADRTNS            01049000
*                                 STRING    LOADRST-LOADRTNS            01050000
*                                 NOCONVERT LOADRNC-LOADRTNS            01051000
         EJECT                                                          01052000
*                                                                       01053000
EFTARGS  EQU   21                 ARGUMENT TYPES (ONE BYTE PER ARG)     01054000
*                                 REAL      LOADRL-LOADCL               01055000
*                                 DREAL     LOADDR-LOADCL               01056000
*                                 INTEGER   LOADIN-LOADCL               01057000
*                                 STRING    LOADST-LOADCL               01058000
*                                 NOCONVERT LOADCNC-LOADCL              01059000
*                                                                       01060000
*                                                                       01061000
*        AN EFBLOK IS CREATED WHEN AN EXTERNAL FUNCTION IS LOADED WITH  01062000
*        A CALL TO THE LOAD FUNCTION -- THE VFUNC FIELD OF THE CORRES-  01063000
*        PONDING VARIABLE BLOCK IS CHANGED TO POINT TO THE EFBLOK       01064000
*                                                                       01065000
*        RELOCATABLE FIELDS       NONE                                  01066000
*                                                                       01067000
HNRLBLOK EQU   EFBLOK             HIGHEST BLOK CODE WITH NO RELOC FLDS  01068000
         EJECT                                                          01069000
*                                                                       01070000
*        I/O PARAMETER BLOCK (IOBLOK)                                   01071000
*        ----------------------------                                   01072000
*                                                                       01073000
*                                                                       01074000
*        +-------------+-----------------------------------------+      01075000
*     -> |   IOBLOK    |                    ///////              |      01076000
*        +-------------+-----------------------------------------+      01077000
*        |                                                       |      01078000
*        +                        IOTAG                          +      01079000
*        |                                                       |      01080000
*        +-------------------------------------------------------+      01081000
*        |                        IOVBLK                         |      01082000
*        +-------------------------------------------------------+      01083000
*        |                        IOFUNC                         |      01084000
*        +-------------------------------------------------------+      01085000
*        |                                                       |      01086000
*        +                        IFORMAT                        |      01087000
*        |                                                       |      01088000
*        +-------------------------------------------------------+      01089000
*        |                        IFILE                          |      01090000
*        +-------------------------------------------------------+      01091000
*        |                                                       |      01092000
*        +                        OFORMAT                        |      01093000
*        |                                                       |      01094000
*        +-------------------------------------------------------+      01095000
*        |                        OFILE                          |      01096000
*        +-------------------------------------------------------+      01097000
         EJECT                                                          01098000
*                                                                       01099000
*        DEFINITIONS AND DESCRIPTION FOR IOBLOK                         01100000
*        --------------------------------------                         01101000
*                                                                       01102000
IOBLOK   EQU   EFBLOK+4           CODE FOR I/O FORMAT BLOCK             01103000
IOTAG    EQU   4                  VALUE TO BE PASSED TO PROGRAMER'S     01104000
*                                 TRACE FUNCTION IF INVOKED ON VALUE TR 01105000
IOVBLK   EQU   IOTAG+8            ADDRESS OF VARIABLE BLOCK REFERING    01106000
*                                 TO THIS IOBLOK - ONLY IF TRACED       01107000
IOFUNC   EQU   IOVBLK+4           ADDRESS OF FUNCTION TO BE INVOKED FOR 01108000
*                                 VALUE TRACE - ZERO IF NO FUNCTION     01109000
IFORMAT  EQU   IOFUNC+4           INTEGER SPECIFIER FOR INPUT FORMAT    01110000
*                                 ZERO IF NO INPUT FORMAT               01111000
IFILE    EQU   IFORMAT+8          PTR TO SYSTEM INTERFACE I/O BLOCK     01112000
OFORMAT  EQU   IFILE+4            STRING SPECIFIER FOR OUTPUT FORMAT    01113000
*                                 ZERO IF NO OUTPUT FORMAT              01114000
OFILE    EQU   OFORMAT+8          PTR TO SYSTEM INTERFACE I/O BLOCK     01115000
IOBSIZE  EQU   OFILE+4            LENGTH OF IOBLOK                      01116000
*                                                                       01117000
*        AN IOBLOK IS ALLOCATED FOR EACH VARIABLE WHICH IS INPUT        01118000
*        OR OUTPUT ASSOCIATED. THE OFORMAT AND IFORMAT FIELDS ARE       01119000
*        TAKEN FROM THE THIRD ARGUMENTS OF THE INPUT AND                01120000
*        OUTPUT FUNCTION CALLS WHICH PERFORMED THE ASSOCIATION(S).      01121000
*        IFILE AND OFILE ARE POINTERS TO THE SYSTEM INTERFACE           01122000
*        CONTROL BLOCKS FOR THE INPUT AND OUTPUT FILES. THESE POINTERS  01123000
*        ARE SUPPLIED BY THE SYSTEM INTERFACE ON AN IOPEN OR OOPEN CALL 01124000
*        AND THE FORMAT OF THESE BLOCKS IS A FUNCTION OF THE INTERFACE. 01125000
*        TRACE INFORMATION IS ALSO KEPT IN AN IOBLOK WHEN A PROGRAMER   01126000
*        DEFINED TRACE FUNCTION IS SPECIFIED ON A VALUE TRACE CALL      01127000
*        TRACE FIELD OFFSETS MUST BE THE SAME AS IN A TRBLOK            01128000
*                                                                       01129000
*        RELOCATABLE FIELDS       OFORMAT                               01130000
*                                 IOTAG                                 01131000
         EJECT                                                          01132000
*                                                                       01133000
*        ARRAY BLOCK (ABLOK)                                            01134000
*        -------------------                                            01135000
*                                                                       01136000
*                                                                       01137000
*        +-------------+-----------------------------------------+      01138000
*     -> |    ABLOK    |                    ///////              |      01139000
*        +-------------+-----------------------------------------+      01140000
*        |                        NBYTESA                        |      01141000
*        +-------------+-----------------------------------------+      01142000
*        |    NSUBS    |                    ///////              |      01143000
*        +-------------+-----------------------------------------+      01144000
*        |                                                       |      01145000
*        |                      ASPEC                            |      01146000
*        |                                                       |      01147000
*        +-------------------------------------------------------+      01148000
*        |                      SUBFAC (1)                       |      01149000
*        +---------------------------+---------------------------+      01150000
*        |         SUBLBD (1)        |           SUBDIM (1)      |      01151000
*        +---------------------------+---------------------------+      01152000
*        |                                                       |      01153000
*        |         SUBLBD,SUBDIM,SUBFAC FOR SECOND SUBSCR        |      01154000
*        |                          ETC                          |      01155000
*        +-------------------------------------------------------+      01156000
*                                                                       01157000
*        /                                                       /      01158000
*        /                                                       /      01159000
*                                                                       01160000
*        +-------------------------------------------------------+      01161000
*        |                                                       |      01162000
*        |       CONTENTS OF FIRST ARRAY ELEMENT                 |      01163000
*        |                                                       |      01164000
*        +-------------------------------------------------------+      01165000
*        |                                                       |      01166000
*        |       CONTENTS OF SECOND ARRAY ELEMENT                |      01167000
*        |                          ETC                          |      01168000
*        +-------------------------------------------------------+      01169000
*                                                                       01170000
*        /                                                       /      01171000
*        /                                                       /      01172000
*                                                                       01173000
*        +-------------------------------------------------------+      01174000
*        |                                                       |      01175000
*        |       CONTENTS OF LAST ARRAY ELEMENT                  |      01176000
*        |                                                       |      01177000
*        +-------------------------------------------------------+      01178000
         EJECT                                                          01179000
*                                                                       01180000
*        DEFINITIONS AND DESCRIPTION FOR ABLOK                          01181000
*        -------------------------------------                          01182000
*                                                                       01183000
ABLOK    EQU   IOBLOK+4           CODE FOR ARRAY BLOCK                  01184000
NBYTESA  EQU   4                  NUMBER OF BYTES IN THIS BLOCK         01185000
NSUBS    EQU   NBYTESA+4          NUMBER OF SUBSCRIPTS IN THIS ARRAY    01186000
ASPEC    EQU   NBYTESA+8          STRING SPECIFIER FOR PROTOTYPE        01187000
SUBFAC   EQU   ASPEC+8            MULTIPLICATION FACTOR                 01188000
SUBLBD   EQU   SUBFAC+4           SUBSCRIPT LOW BOUND                   01189000
SUBDIM   EQU   SUBLBD+2           SUBSCRIPT DIMENSION (HBD-LBD+1)       01190000
AVALS    EQU   SUBFAC+8           PSEUDO OFFSET TO FIRST ELEMENT        01191000
*                                                                       01192000
*        NOTE THAT THE ARRAY ELEMENTS ARE STORED COLUMNWISE -- THUS     01193000
*        SUBFAC IS THE PRODUCT OF PREVIOUS SUBDIMS * 8 FOR BYTE FACTOR  01194000
*                                                                       01195000
*                                                                       01196000
*        ASPEC CONTAINS THE CONTENTS FIELD OF THE PROTOTYPE AS COPIED   01197000
*        FROM THE FIRST ARGUMENT IN THE CALL TO ARRAY WHICH GENERATED   01198000
*        THIS ABLOK -- THIS FIELD IS USED BY THE PROTOTYPE FUNCTION     01199000
*                                                                       01200000
*        AN ABLOK IS CREATED BY A CALL TO THE ARRAY FUNCTION            01201000
*                                                                       01202000
*        RELOCATABLE FIELDS       POINTER (IF ANY) IN ASPEC             01203000
*                                 POINTERS IN ALL VALUE FIELDS          01204000
*                                                                       01205000
*        NOTE THAT IF THE BLOCK STARTING WITH NBYTESA IS CONSIDERED     01206000
*        TO CONSIST ENTIRELY OF POINTERS PROCESSABLE BY THE GARBAGE     01207000
*        COLLECTOR  (PTRPROCV) NO PROBLEMS ARISE, SINCE THE 'TYPE CODE' 01208000
*        BYTE OF THE NON-VALUE ENTRIES IS ALWAYS 0, WHICH IS ICODE AND  01209000
*        IS NOT RELOCABLE  -- THIS TECHNIQUE IS USED IN GCOL            01210000
         EJECT                                                          01211000
*                                                                       01212000
*        PROGRAM DEFINED DATATYPE BLOCK (PDBLOK)                        01213000
*        ---------------------------------------                        01214000
*                                                                       01215000
*                                                                       01216000
*        +-------------+-----------------------------------------+      01217000
*     -> |    PDBLOK   |                    ///////              |      01218000
*        +-------------+-----------------------------------------+      01219000
*        |   NBYTESD   |                    PDFPTR               |      01220000
*        +-------------+-----------------------------------------+      01221000
*        |                                                       |      01222000
*        |                 PDFLDS(LAST FIELD VALUE)              |      01223000
*        |                                                       |      01224000
*        +-------------------------------------------------------+      01225000
*                                                                       01226000
*        /                                                       /      01227000
*        /                                                       /      01228000
*                                                                       01229000
*        +-------------------------------------------------------+      01230000
*        |                                                       |      01231000
*        |                        FIRST FIELD VALUE              |      01232000
*        |                                                       |      01233000
*        +-------------------------------------------------------+      01234000
*                                                                       01235000
*                                                                       01236000
*        DEFINITIONS AND DESCRIPTION FOR PDBLOK                         01237000
*        --------------------------------------                         01238000
*                                                                       01239000
*                                                                       01240000
PDBLOK   EQU   ABLOK+4            CODE FOR PROG DEFINED DATATYPE        01241000
NBYTESD  EQU   4                  LENGTH OF PDBLOK IN BYTES             01242000
PDFPTR   EQU   4                  POINTER TO CORRESPONDING PDFBLOK      01243000
PDFLDS   EQU   8                  LAST FIELD VALUE                      01244000
*                                                                       01245000
*                                                                       01246000
*        ONE OF THESE BLOCKS IS BUILT EACH TIME A PROGRAM DEFINED       01247000
*        DATATYPE IS CONTRUCTED BY A CALL TO ITS ASSOCIATED FUNCTION,   01248000
*        NOTE THAT THE FIELD CONTENTS ARE 'BACKWARDS', THIS IS BECAUSE  01249000
*        THE PDR BUILDS DOWN IN CORE AND SO FUNCTION ARGUMENT LISTS     01250000
*        ARE NATURALLY BUILT IN REVERSE ORDER.                          01251000
*                                                                       01252000
*        A PDBLOK IS CREATED BY A CALL TO ITS ASSOCIATED FUNCTION       01253000
*        (SEE PDFBLOK).                                                 01254000
*                                                                       01255000
*        RELOCATABLE FIELDS       PDFPTR                                01256000
*                                 EACH VALUE FIELD (WHERE NEEDED)       01257000
         EJECT                                                          01258000
*                                                                       01259000
*        FIELD FUNCTION BLOCK (FFBLOK)                                  01260000
*        -----------------------------                                  01261000
*                                                                       01262000
*                                                                       01263000
*        +-------------+-----------------------------------------+      01264000
*     -> |    FFBLOK   |                    ///////              |      01265000
*        +-------------+-----------------------------------------+      01266000
*        |   NBYTESD   |                    PDFPTR               |      01267000
*        +-------------+-----------------------------------------+      01268000
*        |     CLI   TEM#1,DCODE  CHECK FOR CORRECT POINTER      |      01269000
*        +-------------------------------------------------------+      01270000
*        |     LA    A1+1,OFFSET  LOAD CORRECT OFFSET FOR FLD    |      01271000
*        +-------------------------------------------------------+      01272000
*        |     BE    $$FLCN       IF OK, CALL FUNCTION TO CONT   |      01273000
*        +-------------------------------------------------------+      01274000
*        |     B     $$FLE1       ELSE GO GENERATE ERROR         |      01275000
*        +-------------------------------------------------------+      01276000
*        |                        FFBLNEXT                       |      01277000
*        +-------------------------------------------------------+      01278000
*                                                                       01279000
*                                                                       01280000
*        DEFINITIONS AND DESCRIPTION FOR FFBLOK                         01281000
*        --------------------------------------                         01282000
*                                                                       01283000
*                                                                       01284000
FFBLOK   EQU   PDBLOK+4           CODE FOR FIELD FUNCTION BLOCK         01285000
*NBYTESD EQU   4                  LENGTH OF PDBLOK IN BYTES             01286000
*PDFPTR  EQU   4                  POINTER TO ASSOCIATED PDFBLOK         01287000
FFBLNEXT EQU   24                 POINTER TO NEXT FFBLOK WITH SAME      01288000
*                                 NAME (ZERO IF THIS IS THE LAST)       01289000
FFBSIZE  EQU   28                 LENGTH OF AN FFBLOCK                  01290000
*                                                                       01291000
*        ONE OF THESE BLOCKS IS GENERATED FOR EVERY DEFINED             01292000
*        FIELD FUNCTION. LIKE ORDINARY FUNCTIONS, FIELD FUNCTIONS       01293000
*        CAUSE TRANSFER TO THE CODE AT FCODE (12) PAST THE START OF     01294000
*        THEIR ASSOCIATED BLOCKS.                                       01295000
*                                                                       01296000
*        SEE $$FLCN (IN SPITBOLX) FOR THE CONTINUATION OF THE CODE      01297000
*                                                                       01298000
*        AN FFBLOK IS SET UP BY A CALL TO THE DATA FUNCTION.            01299000
*                                                                       01300000
*        RELOCATABLE FIELDS       PDFPTR                                01301000
*                                 FFBLNEXT                              01302000
         EJECT                                                          01303000
*                                                                       01304000
*        PROGRAM DEFINED DATATYPE FUNCTION BLOCK (PDFBLOK)              01305000
*        -------------------------------------------------              01306000
*                                                                       01307000
*                                                                       01308000
*        +-------------+-----------------------------------------+      01309000
*     -> |   PDFBLOK   |                    ///////              |      01310000
*        +-------------+-------------+---------------------------+      01311000
*        |        NFLDSDF            |             NBYTESDF      |      01312000
*        +---------------------------+---------------------------+      01313000
*        |     CH    R0,NFLDSDF(DB4) CHECK FOR RIGHT NUMBER ARGS |      01314000
*        +-------------------------------------------------------+      01315000
*        |     BL    $$WNAG       CALL ADJUSTING FUNCTION IF NOT |      01316000
*        +-------------------------------------------------------+      01317000
*        |     LM    R0,R1,PDMODL(DB4)  LOAD INITIAL TWO WORDS   |      01318000
*        +-------------------------------------------------------+      01319000
*        |     STM   R0,R1,0(FR)  STORE IN PLACE                 |      01320000
*        +-------------------------------------------------------+      01321000
*        |     MVC   12(8*N,FR),TEM#N  MOVE CONTENTS INTO        |      01322000
*        +                           +---------------------------+      01323000
*        |        PLACE              | LR    A1,FR  SET ADDRESS  |      01324000
*        +---------------------------+---------------------------+      01325000
*        |       A      A1,DCODEBT       ADD CORRECT CODE        |      01326000
*        +-------------------------------------------------------+      01327000
*        |     LA    FR,12*8*N(FR)  BUMP FREE REG OVER NEW BLOK  |      01328000
*        +-------------------------------------------------------+      01329000
*        |     L     PDR,PDRLOC  RESET STACK POINTER             |      01330000
*        +---------------------------+---------------------------+      01331000
*        |  CR   FR,PDR  CHECK OVFLO |  BCR L,RETURN RETRN IF OK |      01332000
*        +---------------------------+---------------------------+      01333000
*        |     B     GBGCL1S      ELSE CALL GARBAGE COLLECTOR    |      01334000
*        +---------------------------+---------------------------+      01335000
*        |                        PDFNPTR                        |      01336000
*        +-------------+-----------------------------------------+      01337000
*        |   PDMODL    |                    0                    |      01338000
*        +-------------+-----------------------------------------+      01339000
*        |  (NFLDSD)   |            (PDFPTR)                     |      01340000
*        +-------------------------------------------------------+      01341000
*        |       FLDNPTR (POINTER TO NAME OF FIRST FIELD)        |      01342000
*        +-------------------------------------------------------+      01343000
*                                                                       01344000
*        /                                                       /      01345000
*        /                                                       /      01346000
*                                                                       01347000
*        +-------------------------------------------------------+      01348000
*        |          POINTER TO NAME OF LAST FIELD                |      01349000
*        +-------------------------------------------------------+      01350000
         EJECT                                                          01351000
*                                                                       01352000
*        DEFINITIONS AND DESCRIPTION FOR PDFBLOK                        01353000
*        ---------------------------------------                        01354000
*                                                                       01355000
*                                                                       01356000
PDFBLOK  EQU   FFBLOK+4           CODE FOR PROG DEF DATTYPE BLOCK       01357000
NFLDSDF  EQU   4                  NUMBER OF FIELDS                      01358000
NBYTESDF EQU   6                  LENGTH OF PDFBLOK (BYTES)             01359000
PDFNPTR  EQU   52                 POINTER TO NAME OF DATATYPE           01360000
PDMODL   EQU   56                 8 BYTES FOR PDBLOK (BYTE 1 = PDBLOK)  01361000
FLDNPTR  EQU   64                 POINTER TO VBLOK FOR FIRST FIELD FNC  01362000
*                                                                       01363000
*        ONE OF THESE BLOCKS IS CREATED FOR EACH DEFINED DATATYPE.      01364000
*        THIS BLOCK CREATES A PDBLOK WHEN THE FUNCTION IS CALLED, LIKE  01365000
*        OTHER FUNCTIONS, IT IS ENTERED BY SETTING DB4 TO THE START OF  01366000
*        THE BLOCK AND TRANSFERRING TO FCODE (4) BYTES PAST THIS POINT  01367000
*                                                                       01368000
*        NOTE THAT THE 8 BYTES AT PDMODL ARE FOR USE AS THE             01369000
*        FIRST 8 BYTES OF EACH CREATED PDBLOK.                          01370000
*                                                                       01371000
*        A PDFBLOK IS CREATED BY A CALL TO THE DATA FUNCTION.           01372000
*                                                                       01373000
*        RELOCATABLE FIELDS       (PDFPTR) POINTS TO THIS BLOCK         01374000
         EJECT                                                          01375000
*                                                                       01376000
*        PATTERN BLOCK (PBLOK)                                          01377000
*        ---------------------                                          01378000
*                                                                       01379000
*                                                                       01380000
*        +-------------+-----------------------------------------+      01381000
*     -> |    PBLOK    |                    ///////              |      01382000
*        +-------------+-----------------------------------------+      01383000
*        |           PTLENG          |          PANCHEXT         |      01384000
*        +---------------------------+---------------------------+      01385000
*        |                         PNOTHEN                       |      01386000
*        +-------------------------------------------------------+      01387000
*        |                         PNOOR                         |      01388000
*        +-------------------------------------------------------+      01389000
*                                                                       01390000
*        /                                                       /      01391000
*        /                                                       /      01392000
*                                                                       01393000
*        +-------------+-----------------------------------------+      01394000
*        |   PFLAGS    |                   CODELOC               |      01395000
*        +-------------+-------------+---------------------------+      01396000
*        |           MINMATCH        |           EXTEND          |      01397000
*        +---------------------------+---------------------------+      01398000
*        |           THEN            |           OR              |      01399000
*        +---------------------------+---------------------------+      01400000
*        |                         PARAM1                        |      01401000
*        +-------------------------------------------------------+      01402000
*        |                         PARAM2                        |      01403000
*        +-------------------------------------------------------+      01404000
*                                                                       01405000
*        /                                                       /      01406000
*        /                                                       /      01407000
         EJECT                                                          01408000
*                                                                       01409000
*        PBLOK DEFINITIONS AND DESCRIPTION                              01410000
*        ---------------------------------                              01411000
*                                                                       01412000
PBLOK    EQU   PDFBLOK+4          CODE FOR PATTERN STRUCTURE BLOCK      01413000
PTLENG   EQU   4                  LENGTH OF PBLOK IN BYTES              01414000
PANCHEXT EQU   6                  ALWAYS HAS ANCHEXT OFFSET SO THAT     01415000
*                                 A DUMMY PO OF 0 PTS TO ANCHOR XTEND   01416000
PNOTHEN  EQU   8                  HOLDS THE POINTER TO NOTHEN           01417000
PNOOR    EQU   12                 HOLDS NOOR POINTER (PLUS A QF FLAG)   01418000
PATS     EQU   16                 START OF NODES                        01419000
PFLAGS   EQU   0                  FLAGS FOR A NODE                      01420000
CODELOC  EQU   0                  LOCATION OF PATTERN MATCH CODE        01421000
MINMATCH EQU   4                  MIN CHARS REQUIRED TO MATCH NODE      01422000
EXTEND   EQU   6                  OFFSET TO EXTENSION ROUTINE           01423000
THEN     EQU   8                  OFFSET TO NODE FOR "THEN"             01424000
OR       EQU   10                 OFFSET TO NODE FOR ALTERNATE          01425000
PARAM1   EQU   12                 FIRST PATTERN PARAMETER               01426000
PARAM2   EQU   16                 SECOND PATTERN PARAMETER              01427000
*                                                                       01428000
*        FLAGS USED IN PFLAGS                                           01429000
*                                                                       01430000
QF       EQU   X'80'              FORCES MINMATCH FOR NOTHEN,NOOR MINUS 01431000
PARM1    EQU   X'40'              PARAMETER 1 PRESENT                   01432000
PARM2    EQU   X'20'              PARAMETER 2 PRESENT                   01433000
PRELOC1  EQU   X'10'              FLAG FOR FIRST PARAMETER RELOCATABLE  01434000
PRELOC2  EQU   PRELOC1+X'08'      FLAG FOR 2ND PARAMETER RELOCATABLE    01435000
*                                 INCLUDES PRELOC1 FOR FAST GCOL TEST   01436000
*                                 NOTE RELOC PARAM2 IS ALWAYS EXPR PTR  01437000
PSPANFLG EQU   X'04'              FLAG FOR PTR TO MASTER SPAN TABLE     01438000
*                                 USED BY RELOAD ROUTINE                01439000
*                                                                       01440000
LPRM0    EQU   28                 PTLENG FOR ONE NODE -- NO PARAMS      01441000
LPRM1    EQU   32                 PTLENG FOR ONE NODE -- ONE PARAM      01442000
LPRM2    EQU   36                 PTLENG FOR ONE NODE -- TWO PARAMS     01443000
*                                                                       01444000
*                                                                       01445000
*        NOTE THAT PARAMETERS ARE ONLY ALLOCATED WHEN THEY ARE NEEDED   01446000
*        THE USAGE OF THE PARAMETERS VARIES AMONG THE DIFFERENT KINDS   01447000
*        OF PATTERN.                                                    01448000
*                                                                       01449000
*        A PBLOK (OR PBLOK1,PBLOK2) IS CREATED BY A CALL TO ANY OF THE  01450000
*        PATTERN OPERATORS AND FUNCTIONS.                               01451000
*                                                                       01452000
*        NOTE THAT THE OFFSETS TO "NOOR" AND "NOTHEN" ARE NEGATIVE      01453000
*                                                                       01454000
*        ONLY ONE NODE IS SHOWN HERE, TYPICALLY THERE WILL BE MANY      01455000
*        NODES IN ONE PBLOK -- NOTE THAT THE NODE OFFSETS ARE DEFINED   01456000
*        FROM THE START OF THE NODE                                     01457000
*                                                                       01458000
*        RELOCATABLE FIELDS                 PARAM1 (IF PRELOC1 ON)      01459000
*                                           PARAM2 (IF PRELOC2 ON)      01460000
*                                                                       01461000
*        NOTE THAT AT THE CURRENT TIME, ONLY ONE OF THE TWO             01462000
*        PARAMETERS CAN BE RELOCATABLE IN ANY GIVEN PATTERN NODE        01463000
         EJECT                                                          01464000
*                                                                       01465000
*        TABLE BLOCK (TBBLOK)                                           01466000
*        --------------------                                           01467000
*                                                                       01468000
*                                                                       01469000
*        +-------------+-----------------------------------------+      01470000
*     -> |    TBBLOK   |                    ///////              |      01471000
*        +-------------+-----------------------------------------+      01472000
*        |                        TBLENGTH                       |      01473000
*        +-------------------------------------------------------+      01474000
*        |                      TBDIVIDE                         |      01475000
*        +-------------------------------------------------------+      01476000
*        |             TBLPTRS (PTR TO 1ST HASH SLOT)            |      01477000
*        +-------------------------------------------------------+      01478000
*        |             PTR TO 2ND HASH SLOT                      |      01479000
*        +-------------------------------------------------------+      01480000
*                                                                       01481000
*        /                                                       /      01482000
*        /                                                       /      01483000
*                                                                       01484000
*        +-------------------------------------------------------+      01485000
*        |             PTR TO LAST HASH SLOT                     |      01486000
*        +-------------------------------------------------------+      01487000
*                                                                       01488000
*                                                                       01489000
*        DEFINITIONS AND DESCRIPTION FOR TBBLOK                         01490000
*        --------------------------------------                         01491000
*                                                                       01492000
TBBLOK   EQU   PBLOK+4            BLOCK CODE FOR TABLE                  01493000
TBLENGTH EQU   4                  LENGTH OF BLOCK                       01494000
TBDIVIDE EQU   TBLENGTH+4         NUMBER OF POINTERS*4 USED IN HASH DIV 01495000
TBLPTRS  EQU   TBDIVIDE+4         START OF HASH SLOT POINTERS           01496000
*                                                                       01497000
*                                                                       01498000
*        A TABLE CONTAINS AN ARBITRARY NUMBER OF NAME/VALUE PAIRS       01499000
*        EACH ENTRY IS HASHED INTO ONE OF THE SLOT LOCATIONS            01500000
*        (SEE TBLOOK ROUTINE), EACH OF THE SLOT POINTERS                01501000
*        POINTS TO A CHAIN OF ENTRIES (SEE TEBLOK FORMAT)               01502000
*        ZERO IS USED TO SIGNAL THE END OF THE CHAIN                    01503000
*                                                                       01504000
*        RELOCATABLE FIELDS                 ALL SLOT POINTERS           01505000
         EJECT                                                          01506000
*                                                                       01507000
*        TABLE ELEMENT BLOCK (TEBLOK)                                   01508000
*        ----------------------------                                   01509000
*                                                                       01510000
*                                                                       01511000
*        +-------------+-----------------------------------------+      01512000
*     -> |    TEBLOK   |                    ///////              |      01513000
*        +-------------+-----------------------------------------+      01514000
*        |                                                       |      01515000
*        +                        TEVALUE                        +      01516000
*        |                                                       |      01517000
*        +-------------------------------------------------------+      01518000
*        |                        TLINK                          |      01519000
*        +-------------------------------------------------------+      01520000
*        |                                                       |      01521000
*        +                        TENAME                         +      01522000
*        |                                                       |      01523000
*        +-------------------------------------------------------+      01524000
*                                                                       01525000
*                                                                       01526000
*        DEFINITIONS AND DESCRIPTION FOR TEBLOK                         01527000
*        --------------------------------------                         01528000
*                                                                       01529000
*                                                                       01530000
TEBLOK   EQU   TBBLOK+4           BLOCK CODE FOR TABLE ELEMENT          01531000
TEVALUE  EQU   VALUE              VALUE OF ELEMENT                      01532000
TLINK    EQU   12                 LINK TO NEXT ELEMNT ON HASH CHAIN     01533000
TESIZE   EQU   24                 LENGTH OF TABLE ELEMENT BLOCK         01534000
TENAME   EQU   16                 NAME OF ELEMENT (NORMAL DATA FORMAT)  01535000
*                                                                       01536000
*        ONE OF THESE BLOCKS IS CREATED WHEN A NEW ENTRY IS ADDED TO    01537000
*        A TABLE, THE BLOCKS ARE LINKED TO GETHER ON CHAINS STARTING    01538000
*        FROM THE HASH SLOTS IN A TABLE BLOCK (TBBLOK)                  01539000
*                                                                       01540000
*        RELOCATABLE FIELDS                 POINTER FIELD IN TEVALUE    01541000
*                                           POINTER FIELD IN TENAME     01542000
*                                           TLINK                       01543000
         EJECT                                                          01544000
*                                                                       01545000
*        CODE BLOCK (CBLOK)                                             01546000
*        ------------------                                             01547000
*                                                                       01548000
*                                                                       01549000
*        +-------------+-----------------------------------------+      01550000
*        |    CBLOK    |                    ///////              |      01551000
*        +-------------+-----------------------------------------+      01552000
*        |                        CODNLEN                        |      01553000
*        +-------------------------------------------------------+      01554000
*        |                        CODNLOC                        |      01555000
*        +-------------------------------------------------------+      01556000
*        |                        CODECCHN                       |      01557000
*        +-------------------------------------------------------+      01558000
*        |                                                       |      01559000
*        +                        CODECODE                       +      01560000
*        |                                                       |      01561000
*                                                                       01562000
*        /                                                       /      01563000
*        /                                                       /      01564000
*                                                                       01565000
*        |                                                       |      01566000
*        +-------------------------------------------------------+      01567000
*                                                                       01568000
*                                                                       01569000
*        DEFINITIONS AND DESCRIPTION FOR CBLOK                          01570000
*        --------------------------------------                         01571000
*                                                                       01572000
CBLOK    EQU   TEBLOK+4           BLOCK CODE FOR CODE BLOCK             01573000
CODNLEN  EQU   4                  LENGTH OF CODE BLOCK IN BYTES         01574000
CODNLOC  EQU   8                  PTR TO THIS CODE BLOCK (FOR GCOL USE) 01575000
CODECCHN EQU   12                 PTR TO CONSTANT CHAIN, SEE BELOW      01576000
CODECODE EQU   16                 GENERATED CODE                        01577000
*                                 (TERMINATED BY X'0000' FOR IOASSOC)   01578000
*                                                                       01579000
*        ONE OF THESE BLOCKS IS CREATED FOR EACH CALL TO THE CODE OR    01580000
*        EVAL FUNCTIONS WITH STRING ARGUMENTS (OR EQUIVALENT            01581000
*        CONVERT CALLS). IN THE CASE OF AN EXPRESSION (EVAL), THE       01582000
*        CODE IS THE STANDARD EXPRESSION CODE (ENDED BY B $$EVLR).      01583000
*        IN THE CASE OF CODE, THE CODE IS IDENTICAL TO THAT NORMALLY    01584000
*        GENERATED BY THE COMPILER EXCEPT THAT EACH AUR INSTRUCTION     01585000
*        (AT THE START OF A STATEMENT), IS FOLLOWED BY X'4700' (NOP),   01586000
*        FOLLOWED BY A HALFWORD OFFSET OF THE AUR FROM THE START OF THE 01587000
*        CODE BLOCK (SEE GARBAGE COLLECTOR FOR USE OF THIS FIELD)       01588000
*                                                                       01589000
*        CODECCHN POINTS TO A CHAIN OF 32 BYTE BLOCKS USED FOR          01590000
*        CONSTANTS REFERENCED BY THE CODE. SEE FIND8 FOR DETAILS        01591000
*                                                                       01592000
*        RELOCATABLE FIELDS       CODNLOC                               01593000
         EJECT                                                          01594000
*                                                                       01595000
*        TRACE BLOCK (TRBLOK)                                           01596000
*        --------------------                                           01597000
*                                                                       01598000
*                                                                       01599000
*        +-------------+-----------------------------------------+      01600000
*     -> |    TRBLOK   |                    0                    |      01601000
*        +-------------+-----------------------------------------+      01602000
*        |                                                       |      01603000
*        +                        TRTAG                          +      01604000
*        |                                                       |      01605000
*        +-------------------------------------------------------+      01606000
*        |                        TRVBLK                         |      01607000
*        +-------------------------------------------------------+      01608000
*        |                        TRFUNC                         |      01609000
*        +-------------------------------------------------------+      01610000
*        |                        TRCLINK                        |      01611000
*        +-------------------------------------------------------+      01612000
*                                                                       01613000
*                                                                       01614000
*        DEFINITIONS AND DESCRIPTION FOR TRBLOK                         01615000
*        --------------------------------------                         01616000
*                                                                       01617000
TRBLOK   EQU   CBLOK+4            CODE FOR TRACE BLOCK                  01618000
TRTAG    EQU   4                  TAG VALUE PASSED TO PROG DEF TRACE FN 01619000
TRVBLK   EQU   TRTAG+8            ADDRESS OF VARIABLE BEING TRACED      01620000
TRFUNC   EQU   TRVBLK+4           ADDRESS OF VARIABLE BLK FOR FUNCTION  01621000
*                                 WHICH IS INVOKED ON TRACE CALL        01622000
TRCLINK  EQU   TRFUNC+4           LINK FIELD USED TO CHAIN TRBLOKS      01623000
*                                 TOGETHER FOR CALL AND RETURN TRACING  01624000
TRBSIZE  EQU   TRCLINK+4          TOTAL LENGTH OF A TRBLOK              01625000
*                                                                       01626000
*        ONE OF THESE BLOCKS IS CREATED ON A TRACE CALL THAT SPECIFIES  01627000
*        THE NAME OF A PROGRAMER DEFINED TRACE FUNCTION TO BE USED      01628000
*        THIS INFORMATION IS FOUND IN IOBLOK FOR VALUE TRACING AND IN   01629000
*        AN LTBLOK FOR LABEL TRACING.  THESE BLOCKS ARE CHAINED         01630000
*        TOGETHER FROM A POINTER IN THE USER AREA FOR FUNCTION CASES    01631000
*                                                                       01632000
*        RELOCATABLE FIELDS       TRTAG                                 01633000
*                                 TRCLINK                               01634000
         EJECT                                                          01635000
*                                                                       01636000
*        LABEL TRACE BLOCK (LTBLOK)                                     01637000
*        --------------------------                                     01638000
*                                                                       01639000
*                                                                       01640000
*        +-------------+-----------------------------------------+      01641000
*     -> |    X'48'    |                    0                    |      01642000
*        +-------------+-----------------------------------------+      01643000
*        |                        BAL DB2,LABTRAC                |      01644000
*        +-------------------------------------------------------+      01645000
*        |                        LTGOTO                         |      01646000
*        +-------------------------------------------------------+      01647000
*        |                                                       |      01648000
*        +                        LTTAG                          +      01649000
*        |                                                       |      01650000
*        +-------------------------------------------------------+      01651000
*        |                        LTBLOCK                        |      01652000
*        +-------------------------------------------------------+      01653000
*        |                        LTFUNC                         |      01654000
*        +-------------------------------------------------------+      01655000
*        |                        LTLOC                          |      01656000
*        +-------------------------------------------------------+      01657000
*                                                                       01658000
*                                                                       01659000
*        DEFINTIONS AND DESCRIPTION FOR LTBLOK                          01660000
*        -------------------------------------                          01661000
*                                                                       01662000
LTBLOK   EQU   X'48'              CODE FOR LABEL TRACE BLOCK            01663000
LTOFFSET EQU   8                  OFFSET FOR SETTING OF DB2             01664000
LTGOTO   EQU   8                  REAL CODE ADDRESS FOR TRANSFER        01665000
LTTAG    EQU   12                 TAG VALUE FOR PROG DEF TRACE CALL     01666000
LTBLOCK  EQU   LTTAG+8            ADDRESS OF VARIABLE BLOCK             01667000
LTFUNC   EQU   LTBLOCK+4          ADDRESS OF VBLOK FOR FUNCTION OR 0    01668000
LTLOC    EQU   LTFUNC+4           PTR TO THIS LTBLOK (USED BY GCOL)     01669000
LTSIZE   EQU   LTLOC+4            LENGTH OF LTBLOK IN BYTES             01670000
*                                                                       01671000
*        ONE OF THESE BLOCKS IS CONSTRUCTED FOR EACH TRACED LABEL.      01672000
*        THE VLABL FIELD OF THE VARIABLE BLOCK IS SET TO POINT TO THE   01673000
*        BLOCK SO THAT WHEN A TRANSFER TO THE LABEL OCCURS, CONTROL     01674000
*        IS PASSED TO THE FIRST WORD OF THIS BLOCK. X'48' IS THE CODE   01675000
*        FOR A LH (LOAD HALFWORD) INSTRUCTION. THUS THE FIRST WORD      01676000
*        IS EFFECTIVELY  LH 0,0(,0)  WHICH ACTS AS A NOOP. THEN         01677000
*        CONTROL PASSES TO THE STANDARD LABEL TRACE ROUTINE WITH        01678000
*        (R2) POINTING TO THE PARAMETERS.                               01679000
*        THE TAG,BLOCK AND FUNCTION FIELDS MUST BE SET UP AS IN TRBLOCK 01680000
*                                                                       01681000
*        NOTE THAT THE GARBAGE COLLECTOR HANDLES LTBLOK'S WITH          01682000
*        A SPECIAL PROCEDURE USING THE LTLOC FIELD (SEE PTRPROCL)       01683000
*        THE FACT THAT ONLY THE VLABL FIELD OF A VBLOK CAN POINT TO     01684000
*        AN LTBLOK IS IMPORTANT TO THE PROPER OPERATION OF GCOL.        01685000
*                                                                       01686000
*        RELOCATABLE FIELDS       LTTAG                                 01687000
*                                 LTGOTO                                01688000
*                                 LTLOC                                 01689000
         TITLE 'SPITBOL -- DATA FORMATS -- VALUE (CONTENTS) BLOCKS'     01690000
*                                                                       01691000
*                                                                       01692000
*        IN THE PREVIOUS DATA STRUCTURES, ALL VALUE (OR CONTENTS)       01693000
*        FIELDS WERE 8 BYTES LONG. THESE 8 BYTES CONTAIN A DATATYPE     01694000
*        CODE AND EITHER THE DATA ITEM ITSELF OR A POINTER TO THE       01695000
*        DATA ITEM -- THIS SECTION DESCRIBES THE VARIOUS POSSIBLE       01696000
*        CONTENTS.                                                      01697000
*                                                                       01698000
*                                                                       01699000
*        GENERAL FORMAT                                                 01700000
*        --------------                                                 01701000
*                                                                       01702000
*                                                                       01703000
*        +-------------+-----------------------------------------+      01704000
*        |   VALTYPE   |                  VALPTR                 |      01705000
*        +-------------+-----------------------------------------+      01706000
*        |                        VALCON                         |      01707000
*        +-------------------------------------------------------+      01708000
*                                                                       01709000
*                                                                       01710000
*        DEFINITIONS OF OFFSETS OF FIELDS IN CONTENTS BLOCK             01711000
*        --------------------------------------------------             01712000
*                                                                       01713000
VALTYPE  EQU   0                  CODE FOR CONTENT TYPE (SEE BELOW)     01714000
VALPTR   EQU   0*4                VALUE POINTER (VARIOUS USES)          01715000
VALCON   EQU   1*4                VALUE CONSTANT (VARIOUS USES)         01716000
         EJECT                                                          01717000
*        THE FOLLOWING GIVES THE DETAILED FORMATS AND CODES FOR THE     01718000
*        VARIOUS CONTENT TYPES                                          01719000
*                                                                       01720000
*                                                                       01721000
*        INTEGER                                                        01722000
*        -------                                                        01723000
*                                                                       01724000
*                                                                       01725000
*        +-------------+-----------------------------------------+      01726000
*        |    X'00'    |                  0                      |      01727000
*        +-------------+-----------------------------------------+      01728000
*        |             VALUE OF INTEGER (NORMAL 360 FORM)        |      01729000
*        +-------------------------------------------------------+      01730000
*                                                                       01731000
*                                                                       01732000
ICODE    EQU   0                  CODE FOR INTEGER CONTENTS             01733000
*                                                                       01734000
*                                                                       01735000
*        STRING                                                         01736000
*        ------                                                         01737000
*                                                                       01738000
*                                                                       01739000
*        +-------------+-----------------------------------------+      01740000
*        |    X'01'    |        POINTER TO SBLOK                 |      01741000
*        +-------------+-------------+---------------------------+      01742000
*        |          SOFFSET          |          SLENGTH          |      01743000
*        +---------------------------+---------------------------+      01744000
*                                                                       01745000
*                                                                       01746000
SCODE    EQU   1                  CODE FOR STRING                       01747000
SLENGTH  EQU   6                  360 LENGTH OF STRING                  01748000
SOFFSET  EQU   4                  OFFSET -- FIRST CHARACTER IS AT       01749000
*                                 SCHARS+SOFFSET+SBLOKADR               01750000
*                                                                       01751000
*                                                                       01752000
*        REAL                                                           01753000
*        ----                                                           01754000
*                                                                       01755000
*                                                                       01756000
*        +-------------+-----------------------------------------+      01757000
*        |    X'80'    |                    0                    |      01758000
*        +-------------+-----------------------------------------+      01759000
*        |             VALUE OF REAL (NORMAL 360 SHORT FORM)     |      01760000
*        +-------------------------------------------------------+      01761000
*                                                                       01762000
*                                                                       01763000
RCODE    EQU   128                CODE FOR REAL (MUST BE NEGATIVE)      01764000
         EJECT                                                          01765000
*                                                                       01766000
*        PATTERN                                                        01767000
*        -------                                                        01768000
*                                                                       01769000
*                                                                       01770000
*        +-------------+-----------------------------------------+      01771000
*        |    X'0B'    |        POINTER TO PBLOK WITH PAT        |      01772000
*        +-------------+-----------------------------------------+      01773000
*        |                        ///////                        |      01774000
*        +-------------------------------------------------------+      01775000
*                                                                       01776000
*                                                                       01777000
PCODE    EQU   11                 CODE FOR PATTERN                      01778000
*                                                                       01779000
*                                                                       01780000
*        EXPRESSION                                                     01781000
*        ----------                                                     01782000
*                                                                       01783000
*                                                                       01784000
*        +-------------+-----------------------------------------+      01785000
*        |    X'13'    |          POINTER TO EXPRESSION CODE     |      01786000
*        +-------------+-----------------------------------------+      01787000
*        |                        ///////                        |      01788000
*        +-------------------------------------------------------+      01789000
*                                                                       01790000
ECODE    EQU   19                 CODE FOR EXPRESSION                   01791000
*                                                                       01792000
*        NOTE THAT THE POINTER IS TO A CODE LOCATION                    01793000
*        SEE SPECIAL PTRPROCL ROUTINE IN GARBAGE COLLECTOR              01794000
*        THE SECOND WORD OF THIS VALUE IS USED BY THE GARBAGE COLLECTOR 01795000
*        TO BUILD A CHAIN OF ACTIVE EXPRESSION PTRS (SEE PASS 3)        01796000
*                                                                       01797000
*                                                                       01798000
*        NAME                                                           01799000
*        ----                                                           01800000
*                                                                       01801000
*                                                                       01802000
*        +-------------+-----------------------------------------+      01803000
*        |    X'03'    |        POINTER TO START OF BLOCK        |      01804000
*        +-------------+-----------------------------------------+      01805000
*        |                        OFFSET                         |      01806000
*        +-------------------------------------------------------+      01807000
*                                                                       01808000
*                                                                       01809000
MCODE    EQU   3                  CODE FOR NAME                         01810000
*        NOTE -- CONTENTS ARE TO BE FOUND AT VALUE +BASE+OFFSET         01811000
         EJECT                                                          01812000
*                                                                       01813000
*        ARRAY                                                          01814000
*        -----                                                          01815000
*                                                                       01816000
*                                                                       01817000
*        +-------------+-----------------------------------------+      01818000
*        |    X'05'    |        POINTER TO ARRAY BLOCK (ABLOK)   |      01819000
*        +-------------+-----------------------------------------+      01820000
*        |                        ///////                        |      01821000
*        +-------------------------------------------------------+      01822000
*                                                                       01823000
*                                                                       01824000
ACODE    EQU   5                  CODE FOR ARRAY                        01825000
*                                                                       01826000
*                                                                       01827000
*        TABLE                                                          01828000
*        ------                                                         01829000
*                                                                       01830000
*                                                                       01831000
*        +-------------+-----------------------------------------+      01832000
*        |    X'09'    |          TBBLOK POINTER                 |      01833000
*        +-------------+-----------------------------------------+      01834000
*        |                        ///////                        |      01835000
*        +-------------------------------------------------------+      01836000
*                                                                       01837000
*                                                                       01838000
TCODE    EQU   9                  CODE FOR TABLE                        01839000
*                                                                       01840000
*                                                                       01841000
*        NULL STRING                                                    01842000
*        -----------                                                    01843000
*                                                                       01844000
*                                                                       01845000
*        +-------------+-----------------------------------------+      01846000
*        |    X'42'    |                    ///////              |      01847000
*        +-------------+-----------------------------------------+      01848000
*        |                        ///////                        |      01849000
*        +-------------------------------------------------------+      01850000
*                                                                       01851000
*                                                                       01852000
NCODE    EQU   66                 CODE FOR NULL STRING                  01853000
         EJECT                                                          01854000
*                                                                       01855000
*        PROGRAM DEFINED DATATYPE                                       01856000
*        ------------------------                                       01857000
*                                                                       01858000
*        +-------------+-----------------------------------------+      01859000
*        |    X'07'    |        POINTER TO DATA BLOCK (PDBLOK)   |      01860000
*        +-------------+-----------------------------------------+      01861000
*        |                        ///////                        |      01862000
*        +-------------------------------------------------------+      01863000
*                                                                       01864000
*                                                                       01865000
DCODE    EQU   7                  CODE FOR PROG DEFINED DATATYPE        01866000
*                                                                       01867000
*                                                                       01868000
*        VARIABLE (SIMPLE EXPRESSION)                                   01869000
*        ----------------------------                                   01870000
*                                                                       01871000
*                                                                       01872000
*        +-------------+-----------------------------------------+      01873000
*        |    X'10'    |          POINTER TO VARIABLE BLOCK      |      01874000
*        +-------------+-----------------------------------------+      01875000
*        |                        ///////                        |      01876000
*        +-------------------------------------------------------+      01877000
*                                                                       01878000
*                                                                       01879000
VCODE    EQU   16                 CODE FOR EXPR WHICH IS SIMPLE VAR     01880000
*                                                                       01881000
*                                                                       01882000
*        DOUBLE PRECISION REAL                                          01883000
*        ---------------------                                          01884000
*                                                                       01885000
*                                                                       01886000
*        +-------------+-----------------------------------------+      01887000
*        |    X'C0'    |          7-BYTE DREAL                   |      01888000
*        +-------------+                                         +      01889000
*        |               (FIRST 7 BYTES OF 360 LONG FORM)        |      01890000
*        +-------------------------------------------------------+      01891000
*                                                                       01892000
*                                                                       01893000
WCODE    EQU   128+64             CODE FOR DREAL                        01894000
*                                                                       01895000
*                                                                       01896000
*        CODE                                                           01897000
*        ----                                                           01898000
*                                                                       01899000
*        +-------------+-----------------------------------------+      01900000
*        |    X'0D'    |          POINTER TO GENERATED CODE      |      01901000
*        +-------------+-----------------------------------------+      01902000
*        |                        ///////                        |      01903000
*        +-------------------------------------------------------+      01904000
*                                                                       01905000
CCODE    EQU   13                 CODE FOR CODE                         01906000
         EJECT                                                          01907000
*                                                                       01908000
*                                                                       01909000
*        SOME IMPORTANT CONSIDERATIONS IN THE CHOICE OF CODES ARE AS    01910000
*        FOLLOWS --                                                     01911000
*                                                                       01912000
*        1)    THE LAST BIT IS ON ONLY IF THE ITEM IS RELOCATABLE       01913000
*                                                                       01914000
*        2)    THE X'10' BIT IS ON ONLY FOR EXPRESSIONS                 01915000
*                                                                       01916000
*        3)    ONLY INTEGER IS ZERO AND TWO CODES ADDED ARE ONLY ZERO   01917000
*              IF BOTH CODES ARE INTEGER                                01918000
*                                                                       01919000
*        4)    ONLY REALS AND DREALS ARE NEGATIVE AND TWO CODES ADDED   01920000
*              TOGETHER LOGICALLY GIVE CARRY+ZERO ONLY ON REAL+REAL     01921000
*                                                                       01922000
*        5)    ECODE MUST BE LARGER THAN VCODE                          01923000
*                                                                       01924000
*        6)    NCODE (CODE FOR NULL) IS THE LARGEST ALGEBRAIC CODE      01925000
*                                                                       01926000
*        7)    THE THREE SMALLEST POSITIVE CODES MUST BE SCODE,         01927000
*              MCODE, ACODE IN THAT ORDER (SEE IDENT,$$IDNT CODING)     01928000
*                                                                       01929000
RELOCBIT EQU   1                  BIT SIGNALLING RELOCATION             01930000
EXPRBIT  EQU   X'10'              BIT SIGNALLING EXPRESSION             01931000
*                                                                       01932000
*                                                                       01933000
*        CONSTANT SUBEXPRESSION VALUE                                   01934000
*        ----------------------------                                   01935000
*                                                                       01936000
*        ONE OF THESE BLOCKS IS ALLOCATED FOR EACH CONSTANT             01937000
*        SUBEXPRESSION. SINCE THE VALUE IS NOT LOADED UNTIL IT HAS      01938000
*        BEEN STORED, THE CONTENTS OF THIS BLOCK ARE NOT                01939000
*        RELEVANT AT EXECUTION TIME. HOWEVER, THE BLOCK IS SETUP        01940000
*        AS SHOWN BELOW TO ASSIST THE CODE PRINTING ROUTINE (PRCODE)    01941000
*                                                                       01942000
*        +-------------+-----------------------------------------+      01943000
*        |    X'02'    |     ADDR OF EXPR CODE - SUBEXTOP        |      01944000
*        +-------------+-----------------------------------------+      01945000
*        |       POINTER TO STM INSTRUCTION LOADING VALUE        |      01946000
*        +-------------------------------------------------------+      01947000
*                                                                       01948000
*                                                                       01949000
KCODE    EQU   2                  CODE FOR CONSTANT EXPR VALUE          01950000
*                                                                       01951000
*        NOTE THAT SINCE SUBEXTOP IS BEYOND THE ADDRESS OF THE CODE,    01952000
*        THE RELATIVE POINTER VALUE STORED IS ACTUALLY NEGATIVE         01953000
*                                                                       01954000
*        THE POINTER TO THE STM IS USED IF AN ERROR OCCURS DURING       01955000
*        EVALUATION OF A CONSTANT EXPRESSION. IN THIS CASE, THE STM     01956000
*        INSTRUCTION IS OVERWRITTEN WITH AN APPROPRIATE XERR CALL.      01957000
         TITLE 'SPITBOLC -- START OF CONTROL SECTION'                   01958000
*                                                                       01959000
*        SPITBOLC IS THE CONTROL SECTION WHICH CONTAINS ALL THE COMPILE 01960000
*        TIME ROUTINES AND DATA -- IN TWO PHASE OPERATION, IT IS NOT    01961000
*        NEEDED AT EXECUTE TIME                                         01962000
*                                                                       01963000
*                                                                       01964000
         BEGIN C                  START OF SPITBOLC, SPITBLLC CSECT     01965000
         USING SPITBOLD,DREG      DATA BASE REG                         01966000
         USING SPITBOLC,CB1,CB2,CB3         COMPILER BASE REGS          01967000
         USING SPITBOLR,CB4                 . . . .                     01968000
         USING SPITBOLA,SYS       BASE REG FOR S CONSTANTS IN COMPILER  01969000
         AIF   (&LMOD EQ 1).SKIPSS1                                     01970000
*                                                                       01971000
*        THIS ROUTINE TO CALL FOR AN ERROR MESSAGE MUST BE AT THE START 01972000
*        OF SPITBOLC BECAUSE IT IS CALLED WITH A BR ON CB1              01973000
*                                                                       01974000
         LH    RE,0(,R7)          LOAD ERROR MESSAGE OFFSET             01975000
         AR    RE,CB1             POINT TO ERROR MSG (CB1 = SPITBOLC)   01976000
         TM    STAGE,$EXECUTE     ARE WE IN EXECUTE TIME? (CODE,EVAL)   01977000
         BNO   ERROR              JUMP TO ERROR ROUTINE IF NOT          01978000
.SKIPSS1 ANOP                                                           01979000
*                                                                       01980000
*        COME HERE IF ERROR OCCURS AT EXECUTE TIME (CODE,EVAL)          01981000
*                                                                       01982000
ERRORE   L     R1,CODSVREG+4*RETURN         LOAD NORMAL RETURN POINT    01983000
         SH    R1,=H'4'           ADJUST TO GET ERROR RETURN            01984000
         B     CODXXITE           JUMP TO ERROR CASE EXIT               01985000
         TITLE 'SPITBOLC -- REGISTER DEFINITIONS FOR COMPILER'          01986000
*                                                                       01987000
R0       EQU   0                                                        01988000
R1       EQU   1                                                        01989000
R2       EQU   2                                                        01990000
R3       EQU   3                                                        01991000
R4       EQU   4                                                        01992000
R5       EQU   5                                                        01993000
R6       EQU   6                                                        01994000
R7       EQU   7                                                        01995000
DREG     EQU   8                  DATA AREA BASE REGISTER               01996000
R9       EQU   9                                                        01997000
R10      EQU   10                                                       01998000
CB1      EQU   9                  FIRST COMPILER BASE REG               01999000
CB2      EQU   10                 SECOND COMPILER BASE REG              02000000
CB3      EQU   11                 THIRD COMPILER BASE REG               02001000
CB4      EQU   12                 FOURTH COMPILER BASE REG              02002000
LC       EQU   13                 POINTER PAST CODE GENERATED SO FAR    02003000
RE       EQU   14                                                       02004000
RF       EQU   15                 SUBROUTINE CALL REGISTER              02005000
SCNT     EQU   0                  FREG COUNTS STATEMENTS EXECUTED       02006000
SINC     EQU   2                  FREG CONTAINS INCREMENT FOR SCNT      02007000
FA       EQU   4                  FREG FOR ARITH ROUTINES               02008000
ZR       EQU   6                  FREG 6 (CONTAINS ZERO FOR COMPILER)   02009000
*                                                                       02010000
*        IN GENERAL, REGISTERS ARE NOT SAVED AND RESTORED BY THE        02011000
*        MAIN COMPILER ROUTINES                                         02012000
*                                                                       02013000
*        HOWEVER, LOW-LEVEL ROUTINES (CALLED ON R7) LIKE READER         02014000
*        ARE RESTRICTED TO USING REGISTERS R0,R1,R2,R3                  02015000
*                                                                       02016000
         TITLE 'SPITBOLC -- JOB INITIALIZATION ROUTINE'                 02017000
*                                                                       02018000
*        THIS ROUTINE PERFORMS ALL THE NECCESSARY STEPS                 02019000
*        TO INITIALIZE THE COMPILATION OF EACH PROGRAM IN A BATCH       02020000
*        IT IS ONLY INCLUDED IN THE STANDARD MODULES                    02021000
*                                                                       02022000
         AIF   (&LMOD EQ 1).SKIPS1                                      02023000
         ENTRY SYSSTART           ENTRY FROM INTERFACE                  02024000
         USING SYSSTART,15        BASE REG SET BY INTERFACE             02025000
SYSSTART LM    CB1,CB4,CBASERGS   LOAD COMPILER BASE REGISTERS          02026000
         DROP  15                 DROP ENTRY BASE REG                   02027000
         SR    R0,R0              GET ZERO                              02028000
         SPM   R0                 AND USE IT TO MASK ALL INTERRUPTS     02029000
         LR    R0,DREG            COPY DATA AREA POINTER                02030000
         SH    R0,=Y(VALUE)       INTRODUCE STANDARD OFFSET             02031000
         ST    R0,$$BAS1          SET FIRST BASE REGISTER ADDRESS       02032000
         LR    R1,DREG            COPY DATA POINTER                     02033000
         A     R1,DATASIZE        POINT PAST END OF DATA AREA           02034000
         SH    R1,=Y(HASHTBNS*4)  SUBTRACT LENGTH OF MAIN HASH TABLE    02035000
         ST    R1,HICINUSE        SAVE LOWEST BYTE IN USE               02036000
         SH    R1,=Y(VLINK)       INTRODUCE PROPER OFFSET               02037000
         ST    R1,HASHTBAD        STORE ADDRESS OF VARIABLE HASH TABLE  02038000
         LA    R0,4*HASHTBNS(,R1) POINT TO END OF HASH TABLE            02039000
         ST    R0,HASHTBEN        STORE END OF HASH TABLE ADDRESS       02040000
         SH    R1,=Y(2048-VLINK)  ALLOW 2K FOR HIGH CORE EXPANSION      02041000
         ST    R1,SUBEXTOP        SAVE END OF CONSTANT CODE             02042000
         SH    R1,=H'4'           BACK OFF TO ALLOW FOR BRANCH          02043000
         MVC   0(4,R1),B$$ECON    SET BRANCH INSTRUCTION IN PLACE       02044000
         ST    R1,SUBEXBOT        STORE START OF CONSTANT EXPR CODE     02045000
         MVC   0(4,DREG),BDOIO$   PUT B $$DOIO AT START OF AREA         02046000
*                                                                       02047000
*        INITIALIZE COMPILER WORK AREAS                                 02048000
*                                                                       02049000
         SDR   ZR,ZR              THIS REG IS ALWAYS ZERO               02050000
         ZAP   STMNO,=P'0'        SET STATEMENT NUMBER = ZERO           02051000
         ZAP   PAGENO,=P'0'       PAGE NUMBER = 0                       02052000
         MVI   OUTTITB,C'1'       SET NEW PAGE CTL FOR TITLE            02053000
         MVI   OUTITLE,C' '       SET A BLANK                           02054000
         MVC   OUTITLE+1(256),OUTITLE       BLANK TITLE,SUBTITLE        02055000
         MVC   OUTITLE+102(4),=C'PAGE'      SET 'PAGE' CAPTION          02056000
         MVI   OUSTITL-1,C'0'     CTL CHAR FOR SUBTITLE                 02057000
         MVI   BUFR-1,C' '        SET BLANK CONTROL CHAR FOR BUFFER     02058000
         MVC   SWITCHES(LSWITCH),SWITCHD    SET CONTROL CARD DEFAULTS   02059000
         MVC   AUR$,=X'3E02'      SET AUR INSTRUCTION                   02060000
         MVI   SCANTB4+C'''',1    SET ' TERMINATION                     02061000
         MVI   SCANTB4+C'"',1     SET " TERMINATION                     02062000
         LA    R0,INBUF+72        SET END OF CARD ADDRESS (-IN72)       02063000
         ST    R0,STOPLOC         AND SAVE FOR LITERAL PROCESSING       02064000
         MVC   INPUTDCB(4),READDCB          SET PTR TO MAIN INPUT FILE  02065000
         MVC   CSECTAD(6*4),CSECTADI        SET CSECT ADDRESSES         02066000
         ZAP   ERRCOUNT,=P'0'     ZERO COUNT OF COMPILER ERRORS         02067000
         EJECT                                                          02068000
*                                                                       02069000
*        READ USER SUPPLIED PATCH CARDS                                 02070000
*                                                                       02071000
         MVI   LINELEFT+1,255     SET ROOM FOR PATCH CARDS ON TITLE PAG 02072000
         BAL   RF,PATCHER         READ USER SUPPLIED PATCH CARDS        02073000
         MVI   LINELEFT+1,1       SET FOR NEW PAGE                      02074000
*                                                                       02075000
*        GET STARTING COMPILATION TIME                                  02076000
*                                                                       02077000
         L     R2,=V(SYSTIME)     ADDRESS OF TIMER ROUTINE              02078000
         BALR  R1,R2              CALL TIMER ROUTINE                    02079000
         NOP   0                  NO ERROR RETURN IS POSSIBLE           02080000
         ST    R0,TIME            STORE TIME AT START OF COMPILATION    02081000
         MVI   STAGE,$COMPILE     SET COMPILE TIME FLAG                 02082000
*                                                                       02083000
*        INITIALIZE POINTERS TO VARIOUS WORK AREAS ETC.                 02084000
*                                                                       02085000
         LA    LC,DATABGN         POINT TO START OF AVAILABLE AREA      02086000
         ST    LC,VBLKNXT(,DREG)  STORE AS ADDR OF 1ST VAR BLK (=INPUT) 02087000
         ST    DREG,DATACUR       STORE DREG AS ADDR OF CURRENT 4K BLK  02088000
         LA    LC,CBLKEND(,DREG)  POINT TO LAST LOC IN 1ST 4K BLK       02089000
         ST    LC,CBLKBOT(,DREG)  STORE AS ADDR OF LAST CONSTANT        02090000
         LA    LC,4096-CBLKEND(,LC)         POINT PAST 1ST 4K BLOCK     02091000
         ST    LC,CODEADR         STORE STARTING CODE ADDRESS           02092000
         ST    LC,LASTNOP         SETUP NOP GENERATION (SEE AURGEN)     02093000
*                                                                       02094000
*        BUILD VARIABLE BLOCKS FOR INPUT, OUTPUT AND PUNCH. THESE ARE   02095000
*        BUILT SO THAT WE CAN SETUP THE STANDARD I/O ASSOCIATIONS.      02096000
*                                                                       02097000
         L     R2,=A(VARLOC)      LOAD BASE REGISTER FOR HASH ROUTINE   02098000
         USING VARLOC,R2          EXTRA BASE REG TO COVER INITV ENTRIES 02099000
         LA    R4,E$INPUT+1-SCHARS          POINT TO NAME 'INPUT'       02100000
         LA    R5,5-1             360 LENGTH                            02101000
         BALR  R1,R2              BUILD BLOCK                           02102000
         LA    R4,E$OUTPUT+1-SCHARS         POINT TO NAME 'OUTPUT'      02103000
         LA    R5,6-1             360 LENGTH                            02104000
         BALR  R1,R2              BUILD BLOCK                           02105000
         LA    R4,E$PUNCH+1-SCHARS          POINT TO NAME 'PUNCH'       02106000
         LA    R5,5-1             360 LENGTH                            02107000
         BALR  R1,R2              BUILD BLOCK                           02108000
         DROP  R2                 DROP INITV BASE REG                   02109000
         OI    B$INPUT+VFLAGS,VINP+VINA     SET INPUT INPUT ASSOC       02110000
         OI    B$OUTPUT+VFLAGS,VOUP+VOUA    SET OUTPUT OUTPUT ASSOC     02111000
         OI    B$PUNCH+VFLAGS,VOUP+VOUA     SET PUNCH OUTPUT ASSOC      02112000
*                                                                       02113000
*        INITIALIZE THE SCAN ROUTINE AND START COMPILATION              02114000
*                                                                       02115000
         LA    R1,INBUF           POINT TO START OF BUFFER              02116000
         ST    R1,SCANLOC         STORE AS CURRENT SCAN LOCATION        02117000
         ST    R1,FLAGLOC         INITIALIZE ERROR FLAG LOCATION        02118000
         MVI   RESCAN,X'FF'       RESET RESCAN FLAG                     02119000
         B     CMPILE             START COMPILATION OF 1ST STATEMENT    02120000
.SKIPS1  ANOP                                                           02121000
         TITLE 'SPITBOLC -- EXECUTION TIME COMPILER ENTRY'              02122000
*                                                                       02123000
*        CONTROL IS PASSED TO THIS POINT AT EXECUTION TIME IF THE CODE, 02124000
*        EVAL OR CONVERT FUNCTIONS REQUIRE EXECUTION TIME COMPILATION   02125000
*                                                                       02126000
*        (R1)                     POINTS TO CODXENT                     02127000
*        CODXSW                   = CCODE   CODE                        02128000
*                                 = ECODE   EXPRESSION (EVAL)           02129000
*        (A1,A1+1)                STRING TO BE COMPILED                 02130000
*        (REGS 0-15)              STORED AT CODSVREG, SEE 'COMPILER')   02131000
*        (RETURN)                 RETURN POINT   0(RETURN) -- ERROR     02132000
*                                                4(RETURN) -- NORMAL    02133000
*        (DB2,DB3)                RELOADED FROM $$BAS2 ON EXIT          02134000
*                                                                       02135000
         USING CODXENT,R1         BASE REG SET BY CALLER                02136000
CODXENT  LM    CB1,CB4,CBASERGS   SET COMPILER BASE REGS                02137000
         DROP  R1                 DROP ENTRY BASE REG                   02138000
         STE   ZR,GCOLPTR(,FR)    CLEAR GCOL FLD IN NEW CODE BLOCK      02139000
         MVI   DTYPE(FR),CBLOK    SET FREE CORE BLOCK TYPE CODE         02140000
         ST    FR,CODNLOC(,FR)    STORE STANDARD BACK POINTER           02141000
         STE   ZR,CODECCHN(,FR)   CLEAR CONS CHAIN POINTER              02142000
         MVI   SCANTB4+C'''',1    SET ' ENTRY IN SCANTB4                02143000
         MVI   SCANTB4+C'"',1     SET " ENTRY IN SCANTB4                02144000
         OI    STAGE,$COMPILE     SET COMPILE FLAG ($EXECUTE STILL SET) 02145000
         MVI   CODEOS,0           RESET END OF STRING FLAG              02146000
         AH    A1,CODSVREG+4*A1+SOFFSET     ADD STRING OFFSET           02147000
         LA    A1,SCHARS(,A1)     POINT TO STRING TO COMPILE            02148000
         ST    A1,SCANLOC         SET SCAN LOCATION AT START OF STRING  02149000
         AH    A1,CODSVREG+4*A1+SLENGTH     POINT TO LAST CHAR          02150000
         CLI   CODSVREG+4*A1,NCODE          WAS ARGUMENT NULL?          02151000
         BNE   *+8                SKIP IF NOT                           02152000
         MVI   CODEOS,1           IF SO, SET END OF STRING FLAG         02153000
         LA    A1,1(,A1)          POINT PAST LAST CHARACTER             02154000
         ST    A1,STOPLOC         STORE AS STOP CHARACTER               02155000
         LA    LC,CODECODE(,FR)   POINT TO LOC FOR GENERATED CODE       02156000
         ST    LC,LASTNOP         STOP UNNECESSARY NOP GENERATION       02157000
         STE   ZR,LABSAVE         CLEAR LABEL SAVE LOC FOR & CODE       02158000
         MVI   FRETOPT,0          RESET FRETURN OPTIMIZATION CELL       02159000
         MVC   AUR$,=X'3E02'      INITIALIZE AUR CONSTANT               02160000
         MVI   RESCAN,X'FF'       RESET RESCAN FLAG                     02161000
         MVI   OPTFLAG,X'00'      CODE IS NEVER OPTIMIZED               02162000
         MVI   CONGEN,X'FF'       NO CONSTANT EXPRESSIONS               02163000
         MVI   FAILSET,1          SET FOR -FAIL MODE                    02164000
         MVI   OLDBASE+1,0        CLEAR GARBAGE DB4 SETTING             02165000
         CLI   CODXSW,CCODE       TEST FOR CODE CASE                    02166000
         BE    CMPILE             JUMP IF CODE TO COMPILE 1ST STMNT     02167000
         EJECT                                                          02168000
*                                                                       02169000
*        CASE OF EXPRESSION (EVAL OR CONVERT TO 'EXPRESSION')           02170000
*                                                                       02171000
         STE   ZR,LASTOPN         FORGET CONTENTS OF (A1,A1+1)          02172000
         MVI   GOTOFLG,X'00'      RESET GOTO FLAG                       02173000
         MVI   AMPFLAG,X'FF'      INHIBIT SPECIAL & CODE                02174000
         BAL   RF,STACKSET        SETUP COMPILER WORK STACKS            02175000
         LA    R3,NULBLK          POINT TO NULL CONSTANT BLOCK IN CASE  02176000
         CLI   CODEOS,0           ALREADY END OF STRING?                02177000
         BNE   *+8                SKIP IF SO (NULL SETUP)               02178000
         BAL   RF,EXPAN           ELSE SCAN EXPRESSION                  02179000
         CLI   CODEOS,1           END OF STRING FLAG SHOULD BE SET      02180000
         BNE   ERRORE             GIVE ERROR IF BAD ARG (ELSE SET CC)   02181000
         LR    R5,R3              ELSE SET TREE POINTER FOR CODEGEN     02182000
         L     R3,TEMSTKBS        INITIALIZE POINTER TO TEM#NN STACK    02183000
         BAL   R4,CODEGEN         GENERATE CODE (CC = 0 = BY VALUE)     02184000
*                                                                       02185000
*        NOW WE GENERATE THE FOLLOWING TERMINATION CODE                 02186000
*                                                                       02187000
*        B     $$EVLR                                                   02188000
*        AUR   0,2                                                      02189000
*        NOP   OFFSET                                                   02190000
*        DC    X'0000'            FLAG END OF CODE BLOCK                02191000
*                                                                       02192000
         MVC   0(4,LC),BLEVLR$    SET B $$EVLR AT END OF CODE           02193000
         LA    LC,4(,LC)          BUMP PAST IT                          02194000
         BAL   RF,AURGENU         GENERATE AUR AND NOP INSTRUCTIONS     02195000
         SH    LC,=H'4'           DELETE UNWANTED NOP STMNT-NUMBER      02196000
         SR    R0,R0              GET ZERO                              02197000
         STH   R0,0(,LC)          SET X'0000' TO FLAG END OF CODE       02198000
         LA    LC,2(,LC)          BUMP PAST IT                          02199000
         B     CODXXIT            JUMP TO EXIT                          02200000
*                                                                       02201000
*        BASE REGISTER VALUES FOR COMPILATION (LOADED INTO CB1-CB4)     02202000
*                                                                       02203000
*        THESE VALUES MUST BE WITHIN 4K OF SYSSTART                     02204000
*                                                                       02205000
CBASERGS DC    A(SPITBOLC,SPITBOLC+4096,SPITBOLC+8192,SPITBOLR)         02206000
*                                                                       02207000
*        INITIAL VALUES FOR CONTROL SECTION ADDRESSES                   02208000
*                                                                       02209000
CSECTADI DC    A(SPITBOLC,SPITBOLR,SPITBOLP,SPITBOLX,SPITBOLA,SPITBOLF) 02210000
         TITLE 'SPITBOLC -- COMPILATION CONTROL CIRCUIT'                02211000
*                                                                       02212000
*        THIS ROUTINE CONTROLS THE COMPILATION PROCESS FOR A SINGLE     02213000
*        STATEMENT, MAKING APPROPRIATE CALLS TO SCAN, EXPAN AND CODGEN  02214000
*                                                                       02215000
*        THE FIELDS RITESIDE,LEFTSIDE,SGOTO,FGOTO CONTAIN POINTERS      02216000
*        TO TREE STRUCTURES OF EXPRESSION BLOCKS AS RETURNED BY THE     02217000
*        EXPAN ROUTINE AND AS USED BY THE CODEGEN ROUTINE TO GENERATE   02218000
*        CODE FOR EXPRESSIONS                                           02219000
*                                                                       02220000
CMPILE   TM    STAGE,$OVERTIM     CHECK FOR OVERTIME                    02221000
         BNO   *+12               SKIP IF NOT                           02222000
         MVI   FATAL,1            ELSE SIGNAL FATAL ERROR               02223000
         ERR   14                 ***TIME LIMIT EXCEEDED***             02224000
         ST    LC,STMCODE         IF OK, SAVE STARTING CODE LOC FOR STM 02225000
         CLI   CODEOS,1           END OF STRING (CODE CASE)?            02226000
         BE    SCANLEND           SKIP IF SO (TREAT AS END LABEL)       02227000
         STE   ZR,LASTOPN         FORGET CONTENTS OF (A1,A1+1)          02228000
         MVI   PREDFUNC,0         CLEAR PREDICATE FUNCTION FLAG         02229000
         STD   ZR,RITESIDE        ZERO LEFTSIDE AND RITESIDE POINTERS   02230000
         STD   ZR,FGOTO           CLEAR SGOTO AND FGOTO POINTERS        02231000
         MVI   GOTOFLG,0          SUPPRESS S( AND F(                    02232000
         MVI   OLDBASE+1,0        FORGET CURRENT DB4 SETTING            02233000
         MVI   FAILFLAG,0         RESET FLAG FOR FAILURE POSSIBLE       02234000
         MVI   PATFLG,0           RESET FLAG FOR PATTERN MATCH          02235000
         MVI   AMPFLAG,0          RESET SPECIAL FLAG FOR & CODE         02236000
         BAL   RF,SCANINIT        INITIALIZE SCAN AND PROCESS LABEL     02237000
         BAL   RF,AURGEN          GENERATE AUR ETC. AT STATEMENT START  02238000
         BAL   RF,SCAN            SCAN FIRST ELEMENT IN STATEMENT       02239000
         CLI   SCANFL,TRM         NULL STATEMENT?                       02240000
         BE    CMPILENN           SKIP IF NULL STATEMENT                02241000
         MVI   RESCAN,0           ELSE SET TO RESCAN FIRST ELEMENT      02242000
         BAL   RF,STACKSET        ALLOCATE WORK STACKS                  02243000
         B     CMPILE1            JUMP TO CONTINUE                      02244000
*                                                                       02245000
*        COME HERE FOR NULL STATEMENT. FOR COMPATABILITY WITH BTL       02246000
*        SNOBOL-4 WE GENERATE AUR SCNT,ZR SO THAT &STCOUNT IS UNCHANGED 02247000
*        ALSO THIS IS THE ONE CASE WHERE FRETURN NEED NOT BE SET        02248000
*                                                                       02249000
CMPILENN L     R1,STMCODE         POINT TO START OF STMNT CODE          02250000
         MVI   1(R1),16*SCNT+ZR   CHANGE AUR TO AUR SCNT,ZR             02251000
         B     CMPILE             LOOP BACK FOR NEXT STATEMENT          02252000
         EJECT                                                          02253000
*                                                                       02254000
*        COME HERE FOR AN ERROR DURING COMPILATION OF CODE AT EXECUTE   02255000
*        TIME. IT IS IMPORTANT TO FINISH OFF THE CODE BLOCK PROPERLY    02256000
*        SO THAT ANY CONSTANTS IT USES ARE RELEASED TO THE FREELIST     02257000
*                                                                       02258000
*        (R1)                     ADJUSTED RETURN LOCATION              02259000
*                                                                       02260000
CODXXITE ST    R1,CODSVREG+4*RETURN         SAVE RETURN POINT           02261000
         SR    R0,R0              GET ZERO                              02262000
         MVC   0(2,LC),AUR$       SET AUR TO TERMINATE BLOCK            02263000
         STH   R0,2(,LC)          STORE X'0000' AS END OF BLOCK FLAG    02264000
         LA    LC,4(,LC)          BUMP CODE POINTER AND MERGE           02265000
*                                                                       02266000
*        COME HERE TO RETURN TO EXECUTE PACKAGE FOR CODE COMPILED       02267000
*        AT EXECUTE TIME (CODE, EVAL, CONVERT)                          02268000
*                                                                       02269000
CODXXIT  LA    LC,3(,LC)          PUSH LC PAST FULLWORD BDRY            02270000
         N     LC,FULWRDAJ        ADJUST TO FULLWORD                    02271000
         L     R1,CODSVREG+4*FR   LOAD POINTER TO BLOCK                 02272000
         LR    R2,R1              COPY BLOCK POINTER                    02273000
         CLI   CODXSW,CCODE       CODE CASE?                            02274000
         BE    *+8                SKIP IF SO                            02275000
         LA    R2,CODECODE(,R2)   ELSE POINT TO CODE FOR EXPR CASE      02276000
         ST    R2,CODSVREG+4*A1   STORE RESULT POINTER                  02277000
         MVC   CODSVREG+4*A1(1),CODXSW      SET TYPE CODE               02278000
         ST    LC,CODSVREG+4*FR   SET NEW FREE CORE POINTER             02279000
         SR    LC,R1              CALCULATE LENGTH OF BLOCK             02280000
         ST    LC,CODNLEN(,R1)    STORE LENGTH OF CODE BLOCK IN CBLOK   02281000
         LM    0,15,CODSVREG      RESTORE REGS                          02282000
         MVI   SCANTB4+C'''',0    CLEAR SCANTB4 ENTRIES                 02283000
         MVI   SCANTB4+C'"',0     . . . .                               02284000
         NI    STAGE,X'FF'-$COMPILE         TURN OFF COMPILE SWITCH     02285000
         LM    DB2,DB3,$$BAS2     LOAD DB'S IN CASE GET4KBLK CALLED     02286000
         LA    RETURN,4(,RETURN)  POINT TO ACTUAL RETURN LOCATION       02287000
         L     R1,SPITRAD         ADDRESS OF SPITBOLR CONTROL SECTION   02288000
         B     EXECUTE-SPITBOLR(,R1)        JUMP TO EXECUTE SECTION     02289000
         EJECT                                                          02290000
*                                                                       02291000
*        GATHER POINTERS TO LEFT AND RIGHT SIDE EXPRESSIONS             02292000
*                                                                       02293000
CMPILE1  MVI   PATFLG,2           SET FLAG FOR PATTERN MATCH POSSIBLE   02294000
         LTR   CB1,CB1            SET CC#0 (TERMINATING )> ILLEGAL)     02295000
         BAL   RF,EXPAN           SCAN AN EXPRESSION                    02296000
         NI    PATFLG,1           RESET FLAG FOR PATTERN MATCH POSSIBL  02297000
         BZ    *+8                SKIP IF NOT A PATTERN MATCH           02298000
         NI    0(R3),X'FF'-OPNCN  ELSE SET PATTERN MATCH NOT CONSTANT   02299000
         ST    R3,LEFTSIDE        STORE POINTER IN LEFTSIDE             02300000
         CLI   SCANFL,EQL         TEST FOR SCAN TERMINATED BY =         02301000
         BNE   CMPILE8            SKIP IF NOT                           02302000
         LTR   CB1,CB1            SET CC#0 (TERMINATING )> ILLEGAL)     02303000
         BAL   RF,EXPAN           SCAN EXPRESSION                       02304000
         ST    R3,RITESIDE        STORE POINTER                         02305000
         CLI   PATFLG,0           CHECK FOR PATTERN MATCH               02306000
         BE    CMPILE6            SKIP IF NOT                           02307000
         L     R2,LEFTSIDE        PICK UP LEFT SIDE POINTER             02308000
         MVC   1(3,R2),=AL3(PTNDV) CHANGE LEFT SIDE OPTR TO PAT BY NAME 02309000
*                                                                       02310000
*        MERGE HERE FOR PATTERN, NON PATTERN MATCH CASES                02311000
*                                                                       02312000
CMPILE6  CLI   SCANFL,EQL         CHECK FOR SCAN TERMINATED BY =        02313000
         BNE   CMPILE8            SKIP IF NOT                           02314000
         ERR   10                 *** ILLEGAL USE OF = ***              02315000
*                                                                       02316000
*        COME HERE TO CHECK FOR GOTO FIELD                              02317000
*                                                                       02318000
CMPILE8  CLI   SCANFL,GTO         CHECK FOR SCAN TERMINATED BY :        02319000
         BNE   CMPILG             NO GOTO FIELD IF NOT                  02320000
         MVI   GOTOFLG,X'FF'      SET FLAG TO ALLOW S( AND F( DETECTION 02321000
         BAL   RF,SCAN            SCAN NEXT ELEMENT                     02322000
         CLI   SCANFL,SGO         SUCCESS GOTO FIELD?                   02323000
         BE    CMPILE9            SKIP IF SO                            02324000
         CLI   SCANFL,FGO         FAILURE GOTO?                         02325000
         BE    CMPILE10           SKIP IF SO                            02326000
         MVI   RESCAN,0           ELSE RESCAN ELEMENT                   02327000
         BAL   RF,GOSCAN          SCAN UNCONDITIONAL GOTO               02328000
         ST    R3,SGOTO           STORE AS SUCCESS GOTO                 02329000
         ST    R3,FGOTO           STORE AS FAILURE GOTO                 02330000
         CLI   FAILSET,1          TEST -NOFAIL OPTION                   02331000
         BE    CMPILE11           ALL DONE WITH GOTO FIELD IF -FAIL     02332000
         EJECT                                                          02333000
*                                                                       02334000
*        HERE WE HAVE PROCESSED AN UNCONDITIONAL GOTO IN -NOFAIL MODE   02335000
*        WE SET THE UNCONDF FLAG FOR TWO PURPOSES --                    02336000
*                                                                       02337000
*        1)    TO GENERATE PROPER CODE TO SET FRETURN (LR FRETURN,SYS)  02338000
*                                                                       02339000
*        2)    TO SUPPRESS THE SGOTO=FGOTO OPTIMIZATION                 02340000
*                                                                       02341000
         OI    FGOTO,UNCONDF      SET SPECIAL FLAG                      02342000
         B     CMPILE11           ALL DONE WITH GOTO FIELD              02343000
*                                                                       02344000
*        COME HERE FOR A SUCCESS GOTO FOLLOWING THE COLON               02345000
*                                                                       02346000
CMPILE9  BAL   RF,GOSCAN          SCAN SUCCESS GOTO EXPRESSION          02347000
         ST    R3,SGOTO           SAVE POINTER                          02348000
         CLI   SCANFL,FGO         SGOTO FOLLOWED BY AN FGOTO?           02349000
         BNE   CMPILE11           ALL DONE WITH GOTO FIELD IF NOT       02350000
         BAL   RF,GOSCAN          ELSE SCAN FGOTO EXPRESSION            02351000
         ST    R3,FGOTO           SAVE POINTER                          02352000
         B     CMPILE11           ALL DONE WITH GOTO FIELD              02353000
*                                                                       02354000
*        COME HERE FOR A FAILURE GOTO FOLLOWING THE COLON               02355000
*                                                                       02356000
CMPILE10 BAL   RF,GOSCAN          SCAN FAILURE GOTO EXPRESSION          02357000
         ST    R3,FGOTO           SAVE POINTER                          02358000
         CLI   SCANFL,SGO         FGOTO FOLLOWED BY SGOTO?              02359000
         BNE   CMPILE11           ALL DONE WITH GOTO FIELD IF NOT       02360000
         BAL   RF,GOSCAN          ELSE SCAN SGOTO EXPRESSION            02361000
         ST    R3,SGOTO           SAVE POINTER                          02362000
*                                                                       02363000
*        MERGE HERE AFTER DEALING WITH GOTO FIELD                       02364000
*                                                                       02365000
CMPILE11 CLI   SCANFL,TRM         END OF STATEMENT?                     02366000
         BE    CMPILG             JUMP TO GENERATE CODE IF SO           02367000
*                                                                       02368000
*        MERGE HERE FOR ERROR IN GOTO FIELD                             02369000
*                                                                       02370000
CMPILE8E ERR   11                 *** ERROR IN GOTO FIELD ***           02371000
         EJECT                                                          02372000
*                                                                       02373000
*        SUBROUTINE TO SCAN OUT GOTO EXPRESSION FIELD                   02374000
*                                                                       02375000
*        BAL   RF,GOSCAN                                                02376000
*        (R3)                     POINTER TO GOTO EXPRESSION            02377000
*                                 NGOTOFLG IN UPPER BYTE IF () CASE     02378000
*                                                                       02379000
GOSCAN   ST    RF,GOSCANSV        SAVE LINKAGE                          02380000
         MVI   GOTOFLG,0          RESET NORMAL SCAN MODE                02381000
         BAL   RF,SCAN            SCAN NEXT ELEMENT                     02382000
         CLI   SCANFL,LPR         CHECK FOR LEFT PAREN (NORMAL GOTO)    02383000
         BE    GOSCANP            SKIP IF NORMAL CASE                   02384000
         CLI   SCANFL,LBR         CHECK FOR < (DIRECT GOTO)             02385000
         BNE   CMPILE8E           ERROR IN GOTO FIELD IF NOT            02386000
         BAL   RF,EXPAN           SCAN EXPR (CC=0 ALLOW )> TERMINATION) 02387000
         CLI   SCANFL,RBR         CHECK FOR SCAN ENDED BY >             02388000
         B     GOSCANX            JUMP TO MERGE POINT WITH CC SET       02389000
*                                                                       02390000
*        HERE FOR LEFT PAREN (NORMAL GOTO)                              02391000
*                                                                       02392000
GOSCANP  BAL   RF,EXPAN           SCAN EXPR (CC=0 ALLOW )> TERMINATION) 02393000
         A     R3,=A(NGOTOFLG*256*256*256)  SUPPLY FLAG FOR NORMAL GOTO 02394000
         CLI   SCANFL,RPR         MUST BE ENDED BY RIGHT PAREN          02395000
*                                                                       02396000
*        BOTH CASES MERGE HERE                                          02397000
*                                                                       02398000
GOSCANX  BNE   CMPILE8E           ERROR IF NOT CORRECTLY TERMINATED     02399000
         MVI   GOTOFLG,X'FF'      SET TO ALLOW F( S( F< S<              02400000
         ST    R3,GOSCANSV+4      SAVE EXPRESSION POINTER               02401000
         BAL   RF,SCAN            SCAN NEXT ELEMENT FOR CALLER          02402000
         L     RF,GOSCANSV        RELOAD LINKAGE                        02403000
         L     R3,GOSCANSV+4      RESTORE EXPRESSION POINTER            02404000
         BR    RF                 RETURN TO CALLER                      02405000
         EJECT                                                          02406000
*                                                                       02407000
*        COME HERE AFTER SCANNING THROUGH THE STATEMENT -- NOW GENERATE 02408000
*        CODE -- FIRST DEAL WITH SETTING FAIL RETURN REGISTER IF NEEDED 02409000
*                                                                       02410000
CMPILG   L     R3,TEMSTKBS        INITIALIZE TEMP STACK S ADDRESS       02411000
         L     R5,FGOTO           LOAD POSSIBLE FGOTO POINTER           02412000
         LTR   R5,R5              WAS FGOTO GIVEN                       02413000
         BZ    CMPILG2            SKIP IF NO FAILURE GOTO AT ALL        02414000
         TM    FGOTO,UNCONDF      CHECK FOR FGOTO=SGOTO WI -NOFAIL ON   02415000
         BNO   CMPILG3            SKIP IF NOT (NORMAL FGOTO SUPPLIED)   02416000
*                                                                       02417000
*        COME HERE IF FAIL IS UNEXPECTED UNDER -NOFAIL OPTION           02418000
*        LR    FRETURN,SYS        POINT TO ERROR ROUTINE                02419000
*                                                                       02420000
CMPILG1  CLI   FRETOPT,1          STILL SET FROM LAST STMNT?            02421000
         BE    CMPILG9            SKIP IF SO, DO NOT REGENERATE         02422000
         MVI   FRETOPT,1          AND SET FOR NEXT STATEMENT            02423000
         MVC   0(2,LC),LRFSYS$    AND GENERATE LR  FRETURN,SYS          02424000
         LA    LC,2(,LC)          BUMP CODE POINTER                     02425000
         B     CMPILG9            JUMP TO GEN REST OF CODE              02426000
*                                                                       02427000
*        COME HERE IF NO FGOTO AND NO UNCONDITIONAL GOTO                02428000
*                                                                       02429000
CMPILG2  CE    ZR,SGOTO           WAS AN S GOTO SUPPLIED?               02430000
         BNZ   CMPILG2A           SKIP IF SO (FAIL IS EXPECTED)         02431000
         CLI   PREDFUNC,0         DID WE HAVE A PREDICATE FUNCTION REF  02432000
         BNE   CMPILG2A           SKIP IF SO (FAIL IS EXPECTED)         02433000
         CLI   FAILSET,1          ELSE IS UNEXPECTED FAIL ALLOWED?      02434000
         BNE   CMPILG1            SKIP IF NOT TO GEN  LR FRETURN,SYS    02435000
*                                                                       02436000
*        COME HERE WITH NO FGOTO WITH -FAIL SET                         02437000
*        LR    FRETURN,DB1        POINT TO INTERCEPT ROUTINE            02438000
*                                                                       02439000
         CLI   FRETOPT,2          ALREADY SET FROM LAST STMNT?          02440000
         BE    CMPILG9            IF SO, SKIP, DO NOT REGENERATE        02441000
         MVI   FRETOPT,2          ELSE SET FLAG FOR NEXT STATEMENT      02442000
         MVC   0(2,LC),LRFDB1$    GENERATE LR FRETURN,DB1               02443000
         LA    LC,2(,LC)          BUMP CODE POINTER                     02444000
         B     CMPILG9            JUMP TO GEN REST OF CODE              02445000
*                                                                       02446000
*        COME HERE FOR NO FGOTO WITH EXPECTED FAIL                      02447000
*        BALR  R2,0               GET BASE                              02448000
*        LA    FRETURN,(NEXT STATEMENT)     (USING BASE REG R2)         02449000
*                                                                       02450000
CMPILG2A MVC   0(4,LC),BAL2LA$    GEN BALR R2,0  LA FRETURN,*-*(R2)     02451000
         ST    LC,FGOINAD         SAVE ADDR FOR LATER GEN OF DISPLACEMN 02452000
         LA    LC,6(,LC)          BUMP CODE POINTER                     02453000
         MVI   FAILFLAG,X'FF'     SET FLAG TO FINISH UP AT END OF STMNT 02454000
         MVI   FRETOPT,0          FORGET PREVIOUS FRETURN SETTING       02455000
         B     CMPILG9            JUMP TO GEN REST OF CODE              02456000
         EJECT                                                          02457000
*                                                                       02458000
*        JUMP HERE WHEN A FAILURE GOTO WAS GIVEN                        02459000
*                                                                       02460000
CMPILG3  MVI   FRETOPT,0          FORGET PREVIOUS FRETURN SETTING       02461000
         TM    0(R5),OPNNM        CHECK FOR SIMPLE FGOTO                02462000
         BNO   CMPILG6            SKIP IF COMPLEX FGOTO                 02463000
         TM    FGOTO,NGOTOFLG     NORMAL GOTO?                          02464000
         BNO   CMPILG6            IF DIRECT GOTO, TREAT AS COMPLEX      02465000
*                                                                       02466000
*        CASE OF SIMPLE FGOTO                                           02467000
*                                                                       02468000
*        L     FRETURN,LBL$FGOTO  (DIRECT LOAD OF ADDRESS)              02469000
*                                                                       02470000
         L     R1,0(,R5)          LOAD VARIABLE BLOCK ADDRESS           02471000
         LA    R1,VLABL(R1)       BUMP TO LABEL FIELD                   02472000
         BAL   RF,CALCSAD         CALCULATE S ADDRESS                   02473000
         STH   R1,2(LC)           GENERATE S ADDRESS                    02474000
         LH    R1,LFRTN$          PICK UP L FRETURN,                    02475000
         STH   R1,0(LC)           GENERATE L FRETURN,                   02476000
         LA    LC,4(LC)           BUMP CODE POINTER                     02477000
         B     CMPILG9            SKIP TO GENERATE REST OF CODE         02478000
*                                                                       02479000
*        CASE OF COMPLEX FGOTO                                          02480000
*                                                                       02481000
*        BALR  R2,0               GET BASE REGISTER                     02482000
*        BAL   FRETURN,*-*(R2)    SKIP FOLLOWING CODE SETTING FRETURN   02483000
*        LA    FRETURN,$$FING     FAIL IN GOTO ILLEGAL                  02484000
*        (CODE BY NAME FOR LABEL)           (CODE BY VALUE IF DIRECT)   02485000
*        BAL   RETURN,$$GOTO                ($$DGTO IF DIRECT GOTO)     02486000
*                                                                       02487000
CMPILG6  MVC   0(4,LC),BLRBAL$    BALR R2,0  BAL FRETURN,*-*(R2)        02488000
         ST    LC,FGOINAD         SAVE POINTER FOR DISPLACEMENT GEN     02489000
         MVC   6(4,LC),LAFING$    GENERATE LA FRETURN,$$FING            02490000
         LA    LC,10(LC)          BUMP CODE POINTER                     02491000
         TM    FGOTO,NGOTOFLG     SET FOR NAME/VALUE ACCORDING TO TYPE  02492000
         BAL   R4,CODEGEN         GENERATE CODE FOR FGOTO EXPRESSION    02493000
         MVI   OLDBASE+1,0        FORGET CURRENT SETTING OF DB4         02494000
         MVC   0(4,LC),BGOTO$     GENERATE BAL  RETURN,$$GOTO           02495000
         SPM   R4                 RESTORE CC FROM TEST FOR DIRECT GOTO  02496000
         BO    *+10               SKIP IF NORMAL GOTO                   02497000
         MVC   2(2,LC),DGOTO$+2   FOR DIRECT GOTO, CHANGE TO $$DGTO     02498000
         LA    LC,4(,LC)          BUMP PAST BAL                         02499000
         LR    R2,LC              COPY CURRENT CODE POINTER             02500000
         L     R1,FGOINAD         RECALL ORIGINAL CODE POINTER          02501000
         LA    R1,2(,R1)          POINT TO BAL INSTRUCTION              02502000
         SR    R2,R1              CALCULATE DISPLACEMENT                02503000
         STH   R2,2(,R1)          STORE IN BAL INSTRUCTION              02504000
         STE   ZR,LASTOPN         FORGET CONTENTS OF (A1,A1+1)          02505000
*                                                                       02506000
*        SECTION TO GENERATE CODE FOR BODY OF STATEMENT                 02507000
*                                                                       02508000
CMPILG9  L     R1,RITESIDE        CHECK RIGHT HAND SIDE                 02509000
         LTR   R1,R1              DO WE HAVE ONE?                       02510000
         BNZ   CMPILG10           SKIP IF YES                           02511000
         EJECT                                                          02512000
*                                                                       02513000
*        HERE WE HAVE A LEFT SIDE WITH NO RIGHT HAND SIDE               02514000
*                                                                       02515000
*        SIMPLY GENERATE CODE BY VALUE. IF THE CODE ENDS WITH A         02516000
*        USELESS LOAD OF THE NULL CONSTANT, DELETE THE LOAD             02517000
*                                                                       02518000
         L     R5,LEFTSIDE        LOAD POINTER TO LEFT SIDE             02519000
         BAL   R4,CODEGEN         ELSE CODE BY VALUE (CC=0 FROM ABOVE)  02520000
         CLI   PATFLG,0           CHECK FOR PATTERN MATCH               02521000
         BE    *+12               SKIP IF NOT                           02522000
         MVI   OLDBASE+1,0        ELSE DELETE OLD DB4 SETTING           02523000
*                                 SINCE PAT MATCH DESTROYS DB4          02524000
         B     CMPILT             AND TERMINATE                         02525000
*                                                                       02526000
*        HERE CHECK FOR DELETION OF USELESS LOAD OF NULL                02527000
*                                                                       02528000
         LR    R2,LC              COPY CURRENT CODE POINTER             02529000
         SH    R2,=H'4'           BACK OFF FOUR BYTES                   02530000
         CLC   0(4,R2),LA1NUL$    IS LAST INSTRUCTION  L A1,$$NULL ?    02531000
         BNE   CMPILT             ALL DONE IF NOT                       02532000
         LR    LC,R2              IF SO DELETE IT                       02533000
         B     CMPILT             AND THEN JUMP FOR GOTO                02534000
*                                                                       02535000
*        COME HERE IF A RIGHT HAND SIDE IS GIVEN                        02536000
*                                                                       02537000
CMPILG10 CLI   PATFLG,0           WAS THIS A PATTERN MATCH              02538000
         BE    CMPILG11           SKIP IF NOT                           02539000
         L     R5,LEFTSIDE        ELSE LOAD POINTER FOR LEFT SIDE       02540000
         CR    R5,R5              SET CC ZERO FOR CODE BY VALUE         02541000
         BAL   R4,CODEGEN         GENERATE CODE FOR LEFT HAND SIDE      02542000
         L     R5,RITESIDE        LOAD RIGHT SIDE POINTER               02543000
         MVI   OLDBASE+1,0        DELETE OLD DB4 SETTING                02544000
         STE   ZR,LASTOPN         FORGET CONTENTS OF (A1,A1+1)          02545000
*                                                                       02546000
*        DEAL HERE WITH SPECIAL CASE OF REPLACING RIGHT HAND SIDE NULL  02547000
*                                                                       02548000
         C     R5,=A(NULBLK)      IS RIGHT HAND SIDE NULL?              02549000
         BNE   CMPLG10A           SKIP IF NOT                           02550000
         LR    R1,LC              ELSE GET CODE POINTER                 02551000
         SH    R1,=H'4'           BACK OFF PAST BAL RETURN,$$PTN2       02552000
         MVC   2(2,R1),SPTNL$     REPLACE WITH BAL RETURN,$$PTNL        02553000
         B     CMPILT             AND WE ARE ALL DONE                   02554000
*                                                                       02555000
*        COME HERE FOR PATMATCH WITH NON-NULL REPLACEMENT               02556000
*                                                                       02557000
CMPLG10A CR    R5,R5              SET CC ZERO FOR CODE BY VALUE         02558000
         BAL   R4,CODEGEN         GENERATE CODE FOR RIGHT HAND SIDE     02559000
         MVC   0(4,LC),BLPATA$    GENERATE BAL RETURN,$$PATA            02560000
         LA    LC,4(LC)           BUMP CODE POINTER                     02561000
         B     CMPILT             JUMP TO CLEAN UP                      02562000
         EJECT                                                          02563000
*                                                                       02564000
*        COME HERE FOR ASSIGNMENT STATEMENT                             02565000
*                                                                       02566000
*        GENERATE ONE OF THE FOLLOWING ---                              02567000
*                                                                       02568000
*        1)    SIMPLEVAR = NULL                                         02569000
*                                                                       02570000
*              MVI   VAL.VAR,NCODE                                      02571000
*                                                                       02572000
*        2)    SIMPLEVAR = VALUE                                        02573000
*                                                                       02574000
*              RIGHT SIDE BY VALUE TO (A1,A1+1)                         02575000
*              STM   A1,A1+1,VAL.VAR                                    02576000
*                                                                       02577000
*        3)    &KEYWORD = VALUE                                         02578000
*                                                                       02579000
*              NAME OF KEYWORD (& OPERAND) BY NAME TO (A1,A1+1)         02580000
*              RIGHT SIDE BY VALUE TO (A2,A2+1)                         02581000
*              BAL   RETURN,$$KPUT                                      02582000
*                                                                       02583000
*        4)    ALL OTHER CASES (COMPLEX LEFT SIDE)                      02584000
*                                                                       02585000
*              LEFT SIDE BY NAME TO (A1,A1+1)                           02586000
*              RIGHT SIDE BY VALUE TO (A2,A2+1)                         02587000
*              BAL   RETURN,$$ASSN                                      02588000
*                                                                       02589000
*              OR                                                       02590000
*                                                                       02591000
*              RIGHT SIDE BY VALUE TO (A1,A1+1)                         02592000
*              LEFT SIDE BY NAME TO (A2,A2+1)                           02593000
*              BAL   RETURN,$$RASN                                      02594000
*                                                                       02595000
*        FOR THE LAST TWO CASES, A DUMMY BINARY OPERATOR BLOCK          02596000
*        WITH A POINTER TO THE APPROPRIATE DOPE VECTOR IS CONSTRUCTED   02597000
*        AND CODEGEN IS USED TO GENERATE THE CODE -- FOR THE FIRST      02598000
*        TWO CASES, THE CODE IS GENERATED BY THIS ROUTINE               02599000
         EJECT                                                          02600000
*                                                                       02601000
*        CHECK TO DISTINGUISH CASES OF ASSIGNMENT STATEMENT             02602000
*                                                                       02603000
CMPILG11 LM    R5,R6,RITESIDE     LOAD RITESIDE/LEFTSIDE                02604000
         TM    0(R6),X'FF'-OPNNM-READV      SIMPLE LEFT HAND SIDE?      02605000
         BNZ   CMPILG13           SKIP IF NOT (CASE 3 OR 4)             02606000
*                                                                       02607000
*        COME HERE FOR CASES 1) AND 2) -- SEE WHICH IT IS               02608000
*                                                                       02609000
         CE    ZR,0(,R5)          IS RIGHT HAND SIDE NULL?              02610000
         LH    R0,MVNCD$          LOAD MVI *-*,NCODE IN CASE            02611000
         BE    CMPILG12           SKIP IF IT IS (CASE 1)                02612000
         CR    R5,R5              ELSE SET CC FOR CODE BY VALUE         02613000
         BAL   R4,CODEGEN         GENERATE CODE FOR RIGHT SIDE          02614000
         LH    R0,STMA1$          PICK UP STM A1,A1+1,*-*               02615000
*                                                                       02616000
*        CASES 1) AND 2) MERGE HERE FOR ACTUAL GENERATION               02617000
*                                                                       02618000
CMPILG12 L     R1,0(,R6)          LOAD VARIABLE POINTER                 02619000
         LA    R1,VALUE(,R1)      POINT TO VALUE FIELD                  02620000
         BAL   RF,CALCSAD         CALCULATE S ADDRESS                   02621000
         STH   R0,0(,LC)          GENERATE STM A1,A1+1,*-* OR MVI ...   02622000
         STH   R1,2(,LC)          GENERATE S ADDRESS                    02623000
         LA    LC,4(,LC)          BUMP CODE POINTER                     02624000
         B     CMPILT             SKIP TO PROCESS GOTO                  02625000
*                                                                       02626000
*        COME HERE WITH LEFT SIDE COMPLEX                               02627000
*                                                                       02628000
CMPILG13 LA    R4,ASSNDV          POINT TO NORMAL ASSIGNMENT DV         02629000
         CLC   0(4,R6),=A(OPTRU*256*256*256+KGETDV) KEYWORD REF?        02630000
         BNE   CMPILG16           ALL SET IF ANYTHING ELSE              02631000
         LA    R4,KPUTDV          ELSE POINT TO KEYWORD ASSIGN DV       02632000
         L     R6,4(,R6)          POINT TO & OPERAND AND MERGE          02633000
         EJECT                                                          02634000
*                                                                       02635000
*        COME HERE FOR CASES 3) AND 4) (R4) HAS PROPER DV POINTER       02636000
*        BUILD THE EQUIVALENT OF AN EXPAN BINARY OPERATOR BLOCK         02637000
*                                                                       02638000
CMPILG16 ST    R4,CMPILBLK        STORE POINTER TO OPERATOR DV          02639000
         ST    R6,CMPILBLK+4      STORE POINTER TO LEFT ARG             02640000
         ST    R5,CMPILBLK+8      STORE POINTER TO RIGHT ARG            02641000
         MVI   CMPILBLK,OPTRB     INDICATE A BINARY OPERATOR BLOCK      02642000
         LA    R5,CMPILBLK        POINT TO IT                           02643000
         CR    R5,R5              SET CC ZERO FOR CODE BY VALUE         02644000
         BAL   R4,CODEGEN         GENERATE CODE & MERGE TO PROCESS GOTO 02645000
*                                                                       02646000
*        COME HERE AFTER CODE HAS BEEN GENERATED FOR BODY OF STATEMENT  02647000
*        PROCESS SUCCESS GO TO                                          02648000
*                                                                       02649000
CMPILT   L     R5,SGOTO           CHECK FOR SGOTO                       02650000
         LTR   R5,R5              WAS THERE ONE?                        02651000
         BZ    CMPILF             SKIP IF NOT                           02652000
*                                                                       02653000
*        FOR SUCCESS GO TO GENERATE (DEPENDING ON CASE)                 02654000
*                                                                       02655000
*        L     R1,LBL.VAR         FOR SIMPLE VARIABLE                   02656000
*        BALR  RETURN,R1                                                02657000
*                                                                       02658000
*        LA    FRETURN,$$FING     COMPLEX CASE                          02659000
*        (CODE FOR SGOTO BY NAME TO A1)                                 02660000
*        BAL   RETURN,$$GOTO                                            02661000
*                                                                       02662000
*        LA    FRETURN,$$FING     DIRECT GOTO                           02663000
*        (CODE FOR SGOTO BY VALUE TO A1)                                02664000
*        BAL   RETURN,$$DGTO                                            02665000
*                                                                       02666000
*        BALR  RETURN,FRETURN     IF RETURN = FRETURN                   02667000
*                                                                       02668000
*        THE BALR SETTING RETURN IS SO THAT WE CAN TELL WHERE WE        02669000
*        CAME FROM IN THE CASE OF A BAD TRANSFER                        02670000
*                                                                       02671000
         C     R5,FGOTO           DOES FGOTO = SGOTO?                   02672000
         BNE   CMPILT0            SKIP IF NOT                           02673000
         MVC   0(2,LC),BALREFR$   ELSE GENERATE BALR RETURN,FRETURN     02674000
         LA    LC,2(,LC)          BUMP PAST                             02675000
         B     CMPILF             JUMP TO CLEAN UP                      02676000
         EJECT                                                          02677000
*                                                                       02678000
*        JUMP HERE IF FGOTO # SGOTO                                     02679000
*                                                                       02680000
CMPILT0  TM    0(R5),OPNNM        IS SGOTO COMPLEX?                     02681000
         BNO   CMPILT1            SKIP IF YES                           02682000
         TM    SGOTO,NGOTOFLG     TEST FOR NORMAL GOTO                  02683000
         BNO   CMPILT2            SKIP ON CASE OF DIRECT GOTO           02684000
         L     R1,0(,R5)          LOAD VARIABLE BLOCK ADDRESS           02685000
         LA    R1,VLABL(R1)       BUMP TO LABEL FIELD                   02686000
         BAL   RF,CALCSAD         GET S ADDRESS                         02687000
         MVC   0(6,LC),LR1BR1$    GEN   L R1,*-*  BALR RETURN,R1        02688000
         STH   R1,2(LC)           GENERATE S ADDRESS                    02689000
         LA    LC,6(LC)           BUMP CODE POINTER                     02690000
         B     CMPILF             JUMP TO CLEAN UP                      02691000
*                                                                       02692000
*        CASE OF COMPLEX SGOTO                                          02693000
*                                                                       02694000
CMPILT1  MVC   0(4,LC),LAFING$    GENERATE LA FRETURN,$$FING            02695000
         LA    LC,4(LC)           BUMP CODE POINTER                     02696000
         MVI   FRETOPT,0          FORGET FRETURN SETTING                02697000
         CR    CB1,CB2            SET CC NON-ZERO FOR CODE BY NAME      02698000
         BAL   R4,CODEGEN         GENERATE CODE FOR SGOTO               02699000
         MVC   0(4,LC),BGOTO$     GENERATE BAL  RETURN,$$GOTO           02700000
         LA    LC,4(,LC)          BUMP CODE POINTER                     02701000
         B     CMPILF             JUMP TO CLEAN UP                      02702000
*                                                                       02703000
*        HERE FOR DIRECT SGOTO                                          02704000
*                                                                       02705000
CMPILT2  MVC   0(4,LC),LAFING$    GENERATE LA FRETURN,$$FING            02706000
         LA    LC,4(,LC)          BUMP CODE POINTER                     02707000
         CR    R0,R0              SET CC ZERO FOR CODE BY VALUE         02708000
         BAL   R4,CODEGEN         GENERATE CODE BY VALUE                02709000
         MVC   0(4,LC),DGOTO$     GENERATE  BAL RETURN,$$DGTO           02710000
         LA    LC,4(,LC)          BUMP CODE POINTER AND MERGE           02711000
*                                                                       02712000
*        END OF STATEMENT -- CHECK FOR BALR LA TYPE FGOTO TO CLEAR UP   02713000
*                                                                       02714000
CMPILF   CLI   FAILFLAG,X'FF'     CHECK FOR LA TYPE GOTO TO FINISH UP   02715000
         BNE   CMPILE             BACK FOR NEXT STATEMENT IF NOT        02716000
         L     R1,FGOINAD         RECALL OLD CODE LOC                   02717000
         LR    R2,LC              COPY NEW CODE LOC                     02718000
         SR    R2,R1              CALCULATE DISPLACEMENT FOR LA         02719000
         SH    R2,=H'2'           ALLOWING FOR BALR (TWO BYTES)         02720000
         STH   R2,4(,R1)          GENERATE DISPLACEMENT                 02721000
         B     CMPILE             BACK TO COMPILE NEXT STATEMENT        02722000
         EJECT                                                          02723000
*                                                                       02724000
*        SUBROUTINE TO ALLOCATE COMPILER WORK STACKS                    02725000
*                                                                       02726000
*        THIS ROUTINE ALLOCATES THE THREE WORK STACKS USED BY EXPAN     02727000
*        ABOVE THE GENERATED CODE. THE CURRENT CODE IS ALLOWED TO GROW  02728000
*        UP TO 2K ON EACH STATEMENT. IN ADDITION, AT COMPILE TIME ( AS  02729000
*        OPPOSED TO CODE,EVAL CALLS), 2K IS ALLOWED FOR EXPANSION OF    02730000
*        CONSTANT CODE.                                                 02731000
*                                                                       02732000
STACKSET LA    R1,2048+3(,LC)     ALLOW FOR 2K GENERATED CODE           02733000
         N     R1,FULWRDAJ        ADJUST TO FULLWORD BOUNDARY           02734000
         ST    R1,EXPINIT         STORE AS ADDRESS OF EXPAN BLOCK STACK 02735000
         LA    R1,2048(,R1)       ALLOW 2K FOR EXPRESSION BLOCKS        02736000
         ST    R1,WRKSTKAD        STORE ADDR OF EXPAN OPERATOR STACK    02737000
         LA    R1,512(,R1)        ALLOW 512 BYTES FOR OPERATOR STACK    02738000
         ST    R1,WRKSTKAD+4      STORE PTR TO EXPAN POINTER STACK      02739000
         LA    R1,512(,R1)        ALLOW 512 BYTES FOR PTR (OPERAND) STK 02740000
         ST    R1,ESTACKS         STORE END OF STACK AREA               02741000
         TM    STAGE,$EXECUTE     IS THIS A CODE OR EVAL CALL?          02742000
         BO    STACKSTX           SKIP IF SO                            02743000
*                                                                       02744000
*        HERE WE HAVE A CALL AT STANDARD COMPILE TIME                   02745000
*                                                                       02746000
         LA    R1,2048(,R1)       ALLOW 2K FOR CONSTANT EXPRESSIONS     02747000
         C     R1,SUBEXBOT        DO WE HAVE ROOM?                      02748000
         BCR   L,RF               RETURN IF WE HAVE ROOM                02749000
         MVI   FATAL,1            ELSE SET FATAL ERROR                  02750000
         ERR   12                 ******PROGRAM TOO LARGE******         02751000
*                                                                       02752000
*        COME HERE TO CHECK FOR STORAGE OVERFLOW DURING EXECUTE TIME    02753000
*                                                                       02754000
STACKSTX C     R1,CODSVREG+4*PDR  ROOM UNDER STACK?                     02755000
         BCR   L,RF               RETURN IF SO                          02756000
*                                                                       02757000
*        MERGE HERE FROM HIGHCORE WHEN WE RUN OUT OF ROOM AT XEQ TIME   02758000
*                                                                       02759000
CODXCOR  L     R1,=A(GBGCLF-4)    SET FOR RETURN TO GBGCLF              02760000
         B     CODXXITE           JUMP TO ERROR EXIT LOCATION           02761000
         TITLE 'SPITBOLC -- SCAN CIRCUIT'                               02762000
*                                                                       02763000
*        THIS IS THE ONLY ROUTINE WHICH LOOKS AT THE INPUT STATE-       02764000
*        MENTS DIRECTLY. IT IS CALLED BY --                             02765000
*                                                                       02766000
*        BAL   RF,SCAN                                                  02767000
*                                                                       02768000
*        IN SCANFL, A SYNTAX FLAG IS RETURNED (SEE NEXT PAGE)           02769000
*        AND IN SCANAD THE DOPE VECTOR ADDRESS IS RETURNED WHERE        02770000
*        APPROPRIATE (VARIABLE,CONSTANT FUNCTION,OPERATOR)              02771000
*                                                                       02772000
*        SCANCHR SAVES THE INITIAL CHARACTER (BEFORE A SCAN BEGINS)     02773000
*                                                                       02774000
*        IF RESCAN IS SET TO ZERO, THEN THE LAST ITEM IS REPEATED ON    02775000
*        A CALL TO SCAN (I.E. SCAN RETURNS IMMEDIATELY)                 02776000
*                                                                       02777000
*        BEFORE USING SCAN, A CALL TO SCANINIT MUST BE MADE AT THE      02778000
*        BEGINNING OF EACH STATEMENT -- THIS ROUTINE INITIALIZES THE    02779000
*        SCAN AND PROCESSES A LABEL IF ONE IS PRESENT                   02780000
*                                                                       02781000
         EJECT                                                          02782000
*                                                                       02783000
*        SYNTAX PARAMETER DEFINITIONS                                   02784000
*                                                                       02785000
*        THE FOLLOWING PARAMETERS ARE THOSE WHICH CAN BE RETURNED       02786000
*        BY THE SCAN ROUTINE IN SCANFL                                  02787000
*                                                                       02788000
EQL      EQU   4                  =                                     02789000
GTO      EQU   EQL+4              : GOTO                                02790000
TRM      EQU   GTO+4              STATEMENT TERMINATOR                  02791000
LBR      EQU   TRM+4              <                                     02792000
RBR      EQU   LBR+4              >                                     02793000
LPR      EQU   RBR+4              (                                     02794000
RPR      EQU   LPR+4              )                                     02795000
CMA      EQU   RPR+4              ,                                     02796000
OPR      EQU   CMA+4              OPERATOR                              02797000
FNC      EQU   OPR+4              FUNCTION CALL (LEFT PRN INCLUDED)     02798000
VAR      EQU   FNC+4              VARIABLE                              02799000
CON      EQU   VAR+4              CONSTANT                              02800000
*                                                                       02801000
*        THE FOLLOWING ARE DEFINITIONS USED IN THE MAIN SCAN CIRCUIT    02802000
*                                                                       02803000
DLR      EQU   CMA+4              $                                     02804000
PLS      EQU   DLR+4              +                                     02805000
MNS      EQU   PLS+4              -                                     02806000
AST      EQU   MNS+4              *                                     02807000
SLS      EQU   AST+4              /                                     02808000
DOT      EQU   SLS+4              .                                     02809000
QUS      EQU   DOT+4              ?                                     02810000
NOT      EQU   QUS+4                                                   02811000
AMP      EQU   NOT+4              &                                     02812000
ATS      EQU   AMP+4              @                                     02813000
NMS      EQU   ATS+4              #                                     02814000
EXC      EQU   NMS+4              EXCLAMATION POINT                     02815000
ORP      EQU   EXC+4              |                                     02816000
PCT      EQU   ORP+4              %                                     02817000
NUM      EQU   PCT+4              NUMBER (DIGIT)                        02818000
QUT      EQU   NUM+4              ' OR "                                02819000
ILG      EQU   QUT+4              ILLEGAL CHARACTER                     02820000
*                                                                       02821000
*        THE FOLLOWING THREE VALUES ARE GROUPED AT THE END SINCE        02822000
*        THEY REPRESENT THE LEGAL POSSIBILITIES FOR AN END              02823000
*        CARD TRANSFER LABEL (SEE SCANLEND)                             02824000
*                                                                       02825000
LTR      EQU   ILG+4              LETTER                                02826000
*                                                                       02827000
*        THE FOLLOWING TWO DEFINITIONS CAN BE RETURNED IN SCANFL ONLY   02828000
*        IF THE SPECIAL GOTO FLAG GOTOFLG IS SET TO X'FF'               02829000
*                                                                       02830000
FGO      EQU   LTR+4              F (POSSIBLE FGOTO)                    02831000
SGO      EQU   FGO+4              S (POSSIBLE SGOTO)                    02832000
         EJECT                                                          02833000
*                                                                       02834000
*        OPERATOR DOPE VECTOR FORMAT                                    02835000
*        ---------------------------                                    02836000
*                                                                       02837000
*        +-------------+-------------+---------------------------+      02838000
*        |   PRIORITY  | FLAGS+YNAME | S ADR OF ROUTINE FOR VALUE|      02839000
*        +-------------+-------------+---------------------------+      02840000
*        |    ///      |    FLAGS    | S ADR OF ROUTINE FOR NAME |      02841000
*        +-------------+-------------+---------------------------+      02842000
*                                                                       02843000
*                                 OR                                    02844000
*                                                                       02845000
*        +-------------+-------------+---------------------------+      02846000
*        |   PRIORITY  |    FLAGS    | S ADR OF ROUTINE FOR VALUE|      02847000
*        +-------------+-------------+---------------------------+      02848000
*                                                                       02849000
*                                 OR                                    02850000
*                                                                       02851000
*        +-------------+-------------+-------------+-------------+      02852000
*        |   PRIORITY  |    FLAGS    |   0,1 OR 2  |    CCODE    |      02853000
*        +-------------+-------------+-------------+-------------+      02854000
*                                                                       02855000
*        THE TWO WORD FORMAT IS USED IF THE OPERATOR CAN BE CALLED BY   02856000
*        NAME OR VALUE (E.G. $) THE ONE WORD FORMAT IS USED IF THE      02857000
*        CALL BY NAME IS ILLEGAL (MOST USUAL CASE)                      02858000
*        THE PRESENCE OF THE FLAG YNAME INDICATES THE TWO WORD FORMAT   02859000
*        THE FORMAT USING THE CCODE FIELD IS USED FOR THE OPERATORS     02860000
*        GE,LT,LE,NE,EQ,GT (0), LEQ,LNE,LGT,LLT,LLE,LGE (1),            02861000
*        IDENT,DIFFER (2) -- FOR ALL THESE OPERATORS, THE CALL IS       02862000
*        FOLLOWED BY A SUITABLE BCR INSTRUCTION USING CCODE             02863000
*                                                                       02864000
*        DEFINITIONS OF FLAGS                                           02865000
*                                                                       02866000
YNAME    EQU   1                  FLAG FOR CALL BY NAME PERMITTED       02867000
RASS     EQU   2                  FLAG FOR RIGHT ASSOCIATIVE            02868000
LEFNAM   EQU   4                  FLAG FOR LEFT OPERAND BY NAME         02869000
RITNAM   EQU   8                  FLAG FOR RIGHT OR ONLY OPERAND BY NAM 02870000
COMMUT   EQU   16                 FLAG FOR COMMUTATIVE BINARY OPERATOR  02871000
PREDF    EQU   32                 FLAG FOR PREDICATE (EQ,IDENT ...)     02872000
BNOP     EQU   64                 FLAG FOR BINARY OPERATOR              02873000
SPECL    EQU   128                FLAG FOR SPECIAL CODE REQUIRED        02874000
*                                                                       02875000
*        THERE ARE THREE CASES FOR THE S ADDRESS --                     02876000
*                                                                       02877000
*        1)    S ADDRESS OF A ROUTINE IN SPITBOLA (SYS BASE REG)        02878000
*                                                                       02879000
*        2)    S ADDRESS OF DEFINABLE OPERATOR LOCATION IN THE          02880000
*              DATA AREA, SEE OPTRTABL (DB1 BASE REG)                   02881000
*                                                                       02882000
*        3)    DUMMY VALUE USED TO RECOGNIZE THE DV IN THE SPECIAL      02883000
*              OPERATOR TEST SECTION OF CODEGEN. SUCH DUMMY VALUES      02884000
*              MUST USE SYS AS THE BASE REGISTER TO AVOID CONFUSION     02885000
*        IN THE CODE GENERATOR CIRCUIT.                                 02886000
         EJECT                                                          02887000
*                                                                       02888000
*        MACRO FORMAT FOR GENERATION OF OPERATOR DOPE VECTORS           02889000
*        ----------------------------------------------------           02890000
*                                                                       02891000
*        UNARY OPERATOR                                                 02892000
*        --------------                                                 02893000
*                                                                       02894000
*LABL    UNOP  (VR,X),(NR,X),FLAGS                                      02895000
*        VR    NAME OF ROUTINE TO RETURN VALUE                          02896000
*        VN    NAME OF ROUTINE TO RETURN NAME (OMIT IF ILLEGAL)         02897000
*        X     IS V OR N DEPENDING ON WHETHER OPERAND IS BY VAL OR NAME 02898000
*        (PRIORITY OF 15  ASSUMED -- THIS IS THE HIGHEST PRIORITY)      02899000
*                                                                       02900000
*                                                                       02901000
*        X MAY BE OMITTED IF IT IS V (VALUE) AND THE CALL SIMPLIFIED TO 02902000
*                                                                       02903000
*LABL    UNOP  VR,NR,FLAGS                                              02904000
*                                                                       02905000
*        FLAGS IS OPTIONAL AND IF WRITTEN WILL BE ADDED INTO THE        02906000
*        FLAG FIELD OF THE VALUE WORD AND THE NAME WORD IF PRESENT      02907000
*        THE NR FIELD MAY BE OMITTED IF THE CALL BY NAME IS ILLEGAL     02908000
*        HOWEVER, THIS OMISSION MUST BE EXPLICIT IF FLAGS ARE SUPPLIED  02909000
*                                                                       02910000
*        BINARY OPERATOR                                                02911000
*        ---------------                                                02912000
*                                                                       02913000
*LABL    BINOP PRIORITY,(VR,X,Y),(NR,X,Y),FLAGS                         02914000
*                                                                       02915000
*        VR,NR,FLAGS ARE THE SAME AS FOR A UNARY OPERATOR               02916000
*        PRIORITY IS THE PRECEDENCE LEVEL -- AN INTEGER FROM 1 - 14     02917000
*        X,Y ARE V/N  VALUE/NAME FLAGS FOR LEFT AND RIGHT OPNDS         02918000
*        IF BOTH X AND Y ARE V (VALUE), THEY MAY BE OMITTED AND THE     02919000
*        CALL WRITTEN AS                                                02920000
*                                                                       02921000
*LABL    BINOP PRIORITY,VR,NR,FLAGS                                     02922000
         EJECT                                                          02923000
*                                                                       02924000
*        SCAN INITIALIZATION -- HANDLES LABEL AND START OF STATEMENT    02925000
*                                                                       02926000
SCANINIT MVI   SCANFL,0           CLEAR SCAN FLAG IN CASE ERROR         02927000
         LH    R1,BSTMNO          LOAD BINARY STATEMENT NUMBER          02928000
         LA    R1,1(,R1)          INCREMENT                             02929000
         STH   R1,BSTMNO          STORE INCREMENTED STATEMENT COUNT     02930000
*                                                                       02931000
*        CHECK FOR COMMENT, CONTROL CARDS (STANDARD MODULES ONLY)       02932000
*                                                                       02933000
         AIF   (&LMOD EQ 1).SCANSS1                                     02934000
SCANINLL CLI   INBUF,C'*'         IS THIS A COMMENT CARD?               02935000
         BNE   SCANINCC           SKIP IF NOT TO CHECK FOR CTL CARD     02936000
*                                                                       02937000
*        HERE WE LIST A COMMENT CARD                                    02938000
*                                                                       02939000
         BAL   R7,LISTER          LIST COMMENT CARD                     02940000
         BAL   R7,READER          READ NEXT CARD                        02941000
         B     SCANINLL           LOOP BACK TO CHECK CARD READ          02942000
*                                                                       02943000
*        HERE WE CHECK FOR A CONTROL CARD                               02944000
*                                                                       02945000
SCANINCC CLI   INBUF,C'-'         IS THIS A CONTROL CARD?               02946000
         BNE   SCANINDD           SKIP IF NOT                           02947000
         BAL   R7,CONCPROC        ELSE PROCESS CONTROL CARD             02948000
         B     SCANINLL           AND LOOP BACK TO CHECK NEXT CARD      02949000
*                                                                       02950000
*        HERE WE FINALLY HAVE A PROGRAM CARD IN THE BUFFER              02951000
*        LIST IT WITH STATEMENT NUMBER                                  02952000
*                                                                       02953000
SCANINDD AP    STMNO,PONE         INCREMENT STATEMENT NUMBER            02954000
         LA    R0,INBUF           POINT TO START OF BUFFER              02955000
         C     R0,SCANLOC         ARE WE AT START OF CARD?              02956000
         BNE   SCANIN2            SKIP IF NOT TO DEAL WITH LABEL        02957000
         MVC   BUFR(5),=X'2020202020'       EDIT PATTERN FOR STM NO     02958000
         ED    BUFR-1(6),STMNO    EDIT STATEMENT NUMBER                 02959000
         BAL   R7,LISTER          LIST PROGRAM CARD                     02960000
         EJECT                                                          02961000
.SCANSS1 ANOP                                                           02962000
*                                                                       02963000
*        NOW DEAL WITH LABEL                                            02964000
*                                                                       02965000
SCANIN2  L     R1,SCANLOC         LOAD SCAN LOCATION                    02966000
         ST    R1,FLAGLOC         SAVE LOCATION FOR POSSIBLE ERROR FLAG 02967000
         CLC   0(4,R1),=C'END '   CHECK FOR END LABEL                   02968000
         BE    SCANLEND           OFF TO PROCESS IT IF ONE              02969000
         LR    R3,R1              SAVE START OF POSSIBLE LABEL          02970000
         BCTR  R1,0               ADJUST FOR MERGE INTO LOOP            02971000
*                                                                       02972000
*        LOOP TO SCAN OUT LABEL, NOTE THAT BLANKS AND ; ARE NOT ALLOWED 02973000
*                                                                       02974000
SCANIN3  TRT   1(256,R1),SCANTB2  SCAN OUT LABEL                        02975000
         BNZ   SCANIN3A           SKIP IF WE STOPPED                    02976000
         LA    R1,256(,R1)        ELSE STEP PAST 256 CHARACTERS         02977000
         B     SCANIN3            AND LOOP BACK TO KEEP SCANNING        02978000
*                                                                       02979000
*        HERE IF WE ARE STOPPED BY SOMETHING                            02980000
*                                                                       02981000
SCANIN3A C     R1,STOPLOC         ARE WE AT END OF IMAGE OR PAST IT?    02982000
         BL    SCANIN3B           SKIP IF NOT (SOMETHING ELSE STOPPED ) 02983000
         L     R1,STOPLOC         ELSE RESET POINTER TO END OF IMAGE    02984000
         B     SCANIN4            LABEL IS SCANNED OUT                  02985000
*                                                                       02986000
*        HERE IF WE ARE STOPPED BY SOMETHING OTHER THAN END-OF-CARD     02987000
*                                                                       02988000
SCANIN3B CLI   0(R1),C' '         BLANK?                                02989000
         BE    SCANIN4            END OF LABEL IF SO                    02990000
         CLI   0(R1),C';'         STATEMENT SEPARATOR?                  02991000
         BNE   SCANIN3            IF NOT, KEEP GOING, ELSE MERGE        02992000
*                                                                       02993000
*        COME HERE WITH LABEL SCANNED OUT                               02994000
*                                                                       02995000
SCANIN4  CR    R1,R3              IS LABEL NULL? (I.E. NO LABEL)        02996000
         BCR   E,RF               IF SO, RETURN TO SCANINIT CALLER      02997000
         BAL   R4,SCANHSH         ELSE GET BLOCK LOCATION FOR VARIABLE  02998000
         ST    R1,SCANLOC         SAVE SCAN LOCATION                    02999000
         CLC   VLABL+1(3,R5),=AL3($$NOGO)   IS LABEL ALREADY DEFINED?   03000000
         BE    SCANIN5            SKIP IF NOT (ALL OK)                  03001000
         TM    STAGE,$EXECUTE     ELSE ARE WE IN A CODE FUNCTION CALL?  03002000
         BO    SCANIN5            REDEFINITION ALLOWED IF SO            03003000
         BAL   RF,AURGEN          ELSE GENERATE AUR AND GIVE ERROR      03004000
         ERR   20                 ****** LABEL ALREADY DEFINED ******   03005000
         EJECT                                                          03006000
*                                                                       03007000
*        COME HERE IF LABEL IS LEGITIMATE                               03008000
*                                                                       03009000
SCANIN5  ST    R5,LABSAVE         SAVE LABEL BLOCK LOC (&LASTNO)        03010000
         ST    LC,VLABL(,R5)      STORE LABEL LOCATION                  03011000
         MVI   FRETOPT,0          FORGET FRETURN SETTING                03012000
         BR    RF                 RETURN TO CALLER                      03013000
*                                                                       03014000
*        HERE ON END LABEL OR END OF SOURCE STRING (CODE FUNCTION)      03015000
*                                                                       03016000
*        GENERATE THE FOLLOWING TERMINATION CODE                        03017000
*                                                                       03018000
*        AUR   SCNT,ZR                                                  03019000
*        BAL   RETURN,$$STOP                                            03020000
*        AUR   SCNT,SINC                                                03021000
*        (NOP INSTRUCTIONS)       SEE AURGENU                           03022000
*        DC    X'0000'            END OF CODE FLAG (FOR IOASSOC)        03023000
*                                                                       03024000
*        NOTE THAT THE AUR INSTRUCTION IS ARRANGED TO COMPENSATE FOR    03025000
*        THE FACT THAT BTL SNOBOL4 DOES NOT COUNT THE END STATEMENT     03026000
*                                                                       03027000
SCANLEND LR    R7,LC              SAVE CODE LOCATION                    03028000
         BAL   RF,AURGEN          GENERATE AUR FOR LAST STMNT           03029000
         MVI   1(R7),SCNT*16+ZR   CHANGE TO AUR SCNT,ZR                 03030000
         MVC   0(4,LC),$STOP$     GENERATE BAL RETURN,$$STOP            03031000
         LA    LC,4(,LC)          BUMP CODE POINTER                     03032000
         LH    R7,BSTMNO          LOAD BINARY STATEMENT NUMBER          03033000
         LA    R7,1(,R7)          INCREMENT                             03034000
         STH   R7,BSTMNO          STORE INCREMENTED COUNT               03035000
         MVI   AUR$,X'3E'         STOP PROCDE PRINTING LAST GARBAGE STM 03036000
         BAL   RF,AURGENU         GENERATE FINAL AUR FOR CALCSTNO       03037000
         SR    R0,R0              GET ZERO                              03038000
         STH   R0,0(,LC)          STORE X'0000' AT END OF CODE          03039000
         LA    LC,2(,LC)          BUMP PAST ZEROS AT END                03040000
         TM    STAGE,$EXECUTE     CODE FUNCTION CASE?                   03041000
         BO    CODXXIT            IF SO, JUMP TO SPECIAL EXIT POINT     03042000
*                                                                       03043000
*        THE FOLLOWING SECTION OF CODE CAN BE ENTERED ONLY IN THE       03044000
*        STANDARD MODULES AND IS THEREFORE REMOVED FROM THE LIB MODS    03045000
*                                                                       03046000
         AIF   (&LMOD EQ 1).SCANLL1                                     03047000
         EJECT                                                          03048000
*                                                                       03049000
*        HERE WE DEAL WITH A POSSIBLE TRANSFER LABEL ON THE END CARD    03050000
*                                                                       03051000
         MVC   TRAADR,CODEADR     PROVISIONALLY SET TRA ADDR TO START   03052000
         MVI   FATAL,2            SET FLAG IN CASE OF ERROR ON END CARD 03053000
         CLI   EOF,0              DID WE HIT AN END OF FILE?            03054000
         BE    *+8                SKIP IF NOT                           03055000
         ERR   19                 *** MISSING END CARD SUPPLIED ***     03056000
         SR    R2,R2              CLEAR FOR TRT                         03057000
         LA    R1,4(,R1)          PUSH PAST END LABEL                   03058000
         TRT   0(256,R1),SCANTB1  SCAN TO LABEL (TRA ADDRESS)           03059000
         BZ    XEQGO              NO TRANSFER ADDRESS IF RUN OUT        03060000
         C     R1,STOPLOC         AT END OF CARD?                       03061000
         BNL   XEQGO              NO TRANSFER ADDRESS IF SO             03062000
         ST    R1,FLAGLOC         SAVE LOCATION FOR POSSIBLE ERROR FLAG 03063000
         CH    R2,=Y(LTR)         ELSE DID WE STOP ON A LETTER?         03064000
         BNL   *+8                SKIP IF LETTER (OR F OR S)            03065000
         ERR   21                 *** ILLEGAL TRANSFER ADDRESS ***      03066000
         LR    R3,R1              SAVE SCAN LOCATION                    03067000
         TRT   1(256,R1),SCANTB2  SCAN TO END OF LABEL (TRA ADDRESS)    03068000
         BAL   R4,SCANHSH         GET BLOCK LOCATION                    03069000
         CLC   VLABL+1(3,R5),=AL3($$NOGO)   IS LABEL DEFINED            03070000
         BNE   *+8                SKIP IF IT IS DEFINED                 03071000
         ERR   22                 *** UNDEFINED TRANSFER ADDRESS ***    03072000
         MVC   TRAADR+1(3),VLABL+1(R5)      MOVE IN TRANSFER ADDRESS    03073000
         TRT   0(256,R1),SCANTB1  SCAN TO MAKE SURE THAT WE ARE THROUGH 03074000
         CLI   0(R1),X'00'        WE MUST END AT END OF CARD            03075000
         BE    XEQGO              ALL OK IF AT END OF CARD              03076000
         ERR   21                 *** ILLEGAL TRANSFER ADDRESS ***      03077000
.SCANLL1 ANOP                                                           03078000
         EJECT                                                          03079000
*                                                                       03080000
*        MAIN ENTRY POINT                                               03081000
*                                                                       03082000
SCAN     TS    RESCAN             TEST FOR RESCAN, RESETTING FLAG       03083000
         BCR   8,RF               ALL DONE IF RESCAN FLAG SET           03084000
*                                                                       03085000
*        REENTER HERE AFTER READING CONTINUATION CARD                   03086000
*                                                                       03087000
SCAN0    L     R1,SCANLOC         PICK UP SCAN POINTER                  03088000
         MVC   SCANCHR,0(R1)      SAVE INITIAL SCAN CHARACTER           03089000
         SR    R2,R2              CLEAR FOR TRT INSERTION               03090000
*                                                                       03091000
*        LOOP BACK HERE IF MORE THAN 255 BLANKS SCANNED OUT             03092000
*                                                                       03093000
SCAN1    TRT   0(256,R1),SCANTB1  SCAN TO FIND SOMETHING SIGNIFICANT    03094000
         C     R1,STOPLOC         CHECK FOR PAST END OF CARD            03095000
         BNL   SCANTRM            JUMP IF AT END OF INPUT IMAGE         03096000
         ST    R1,FLAGLOC         SAVE LOCATION FOR POSSIBLE ERROR FLAG 03097000
         EX    0,SCANBRA(R2)      EXECUTE BRANCH TO CORRECT ROUTINE     03098000
*                                                                       03099000
*        BRANCH TABLE USED TO CONTROL MAIN LOGIC FLOW                   03100000
*                                                                       03101000
SCANBRA  B     SCAN256B           256 BLANKS                            03102000
         B     SCANEQL            =                                     03103000
         B     SCANS              : GOTO                                03104000
         B     SCANSMC            ;                                     03105000
         B     SCANS              <                                     03106000
         B     SCANS              >                                     03107000
         B     SCANS              (                                     03108000
         B     SCANS              )                                     03109000
         B     SCANS              ,                                     03110000
         B     SCANDLR            $                                     03111000
         B     SCANPLS            +                                     03112000
         B     SCANMNS            -                                     03113000
         B     SCANAST            *                                     03114000
         B     SCANSLS            /                                     03115000
         B     SCANDOT            .                                     03116000
         B     SCANQUS            ?                                     03117000
         B     SCANNOT                                                 03118000
         B     SCANAMP            &                                     03119000
         B     SCANATS            @                                     03120000
         B     SCANNMS            #                                     03121000
         B     SCANEXC            EXCLAMATION POINT                     03122000
         B     SCANORP            |                                     03123000
         B     SCANPCT            %                                     03124000
         B     SCANNUM            DIGIT (INTEGER)                       03125000
         B     SCANQUT            ' OR "                                03126000
         B     SCANILG            ILLEGAL CHARACTER                     03127000
         B     SCANLTR            LETTER (VARIABLE)                     03128000
         B     SCANGOTO           F (POSSIBLE FGOTO)                    03129000
         B     SCANGOTO           S (POSSIBLE SGOTO)                    03130000
         EJECT                                                          03131000
*                                                                       03132000
*        ENTRY FOR SEMICOLON                                            03133000
*                                                                       03134000
SCANSMC  CLI   1(R1),C'*'         IS NEXT CHARACTER * (COMMENT)?        03135000
         BNE   SCANS              IF NOT, NORMAL SPECIAL CHAR CIRCUIT   03136000
         TM    STAGE,$EXECUTE     EXECUTE TIME?                         03137000
         BNO   SCANTRM            IF COMPILE TIME, ;* IS END OF CARD    03138000
*                                                                       03139000
*        ENTRY FOR SPECIAL CHARACTER                                    03140000
*                                                                       03141000
SCANS    STC   R2,SCANFL          STORE SYNTAX PARAMETER                03142000
         LA    R1,1(R1)           BUMP PAST CHARACTER                   03143000
         ST    R1,SCANLOC         SAVE SCAN LOCATION                    03144000
         BR    RF                 RETURN                                03145000
*                                                                       03146000
*        ENTRY FOR $ (UNARY OR BINARY)                                  03147000
*                                                                       03148000
         CNOP  0,4                ENSURE ALLIGNMENT OF BINOP FOR BAL    03149000
SCANDLR  BAL   R5,SCANUB          CALL COMMON ROUTINE TO PROCESS UN/BIN 03150000
DLR2DV   BINOP 11,($$DLR2,V,N),,SPECL       BINARY $                    03151000
DLR1DV   UNOP  $$DL1V,$$DL1N                                            03152000
         BINOP 11,$$DLRD          BINARY $, DEFERRED ARG                03153000
*                                                                       03154000
*        ENTRY POINT FOR + (UNARY OR BINARY)                            03155000
*                                                                       03156000
SCANPLS  BAL   R5,SCANUB          OFF TO COMMON ROUTINE                 03157000
ADDDV    BINOP 5,$$ADD2,,SPECL+COMMUT       BINARY +                    03158000
         BINOP 5,$$ADD2                     BINARY + COMMUTED           03159000
         UNOP  $$ADD1                                                   03160000
         UNOP  $$INCR                       INCREMENT BY ONE            03161000
*                                                                       03162000
*        ENTRY FOR - (UNARY OR BINARY)                                  03163000
*                                                                       03164000
SCANMNS  BAL   R5,SCANUB          OFF TO COMMON ROUTINE                 03165000
SUBDV    BINOP 5,$$SUB2,,SPECL              BINARY -                    03166000
         UNOP  $$SUB1                                                   03167000
         DC    AL4(0)             FILLER (SEE CODE AT CODEBNSA)         03168000
         UNOP  $$DECR                       DECREMENT BY ONE            03169000
*                                                                       03170000
*        ENTRY FOR EXCLAMATION POINT (UNARY OR BINARY)                  03171000
*                                                                       03172000
SCANEXC  BAL   R5,SCANUB          OFF TO COMMON ROUTINE                 03173000
         BINOP 10,$$EXP2,,RASS    BINARY EXCLAMATION POINT              03174000
         UNOP  $$EXC1             UNARY EXCLAMATION POINT               03175000
         EJECT                                                          03176000
*                                                                       03177000
*        ENTRY FOR = SIGN, MUST BE SURROUNDED BY BLANKS                 03178000
*                                                                       03179000
SCANEQL  CLI   SCANCHR,C' '       IS PREVIOUS CHARACTER A BLANK?        03180000
         BNE   SCANEQLE           ERROR IF NOT                          03181000
         TM    1(R1),X'FF'-X'40'  NEXT CHAR BLANK OR END OF CARD?       03182000
         BZ    SCANS              NORMAL SPECIAL CHAR TREATMENT IF SO   03183000
         CLI   1(R1),C';'         ALSO ALLOW SEMICOLON TERMINATOR       03184000
         BE    SCANS              NORMAL SPECIAL CHAR TREATMENT IF SO   03185000
*                                                                       03186000
*        HERE FOR = NOT SURROUNDED BY BLANKS, GIVE MISSING OPERATOR MSG 03187000
*                                                                       03188000
SCANEQLE BAL   RF,SCANS           USE SCANS AS SUBR TO STORE SCAN LOC   03189000
         ERR   7                  ****** MISSING OPERATOR ******        03190000
*                                                                       03191000
*        ENTRY POINT FOR * (COULD BE * UNARY,BINARY OR ** BINARY)       03192000
*                                                                       03193000
SCANAST  CLI   1(R1),C'*'         CHECK FOR **                          03194000
         BNE   SCANAST1           SKIP IF NOT                           03195000
         TM    2(R1),X'FF'-X'40'  TEST FOR BLANK OR CARD END AFTER      03196000
         BNZ   SCANAST1           SKIP IF NOT (UNARY)                   03197000
*                                                                       03198000
*        HERE FOR BINARY **                                             03199000
*                                                                       03200000
         LA    R1,2(,R1)          BUMP PAST **                          03201000
         CNOP  0,4                ALLIGN BAL SO THAT DV IS ALLIGNED     03202000
         BAL   R5,SCANUBC         JUMP TO STORE DV ADDR (R5 --> EXPDV)  03203000
EXPDV    BINOP 10,$$EXP2,,RASS    ALTERNATE GRAPHIC FOR EXPONENTIATION  03204000
*                                                                       03205000
*        REENTRY FOR NORMAL *                                           03206000
*                                                                       03207000
         CNOP  0,4                ENSURE ALLIGNMENT                     03208000
SCANAST1 BAL   R5,SCANUB          OFF TO COMMON ROUTINE                 03209000
         BINOP 8,$$MLT2,,COMMUT   BINARY *                              03210000
         BINOP 8,$$MLT2           BINARY * COMMUTED                     03211000
AST1DV   UNOP  $$AST1,,SPECL      UNARY *                               03212000
         B     CODENQ4            CODEGEN JUMP FOR UNARY * PROCESSING   03213000
*                                                                       03214000
*        PROCESSING FOR / (UNARY OR BINARY)                             03215000
*                                                                       03216000
         CNOP  0,4                ENSURE BAL ALLIGNMENT                 03217000
SCANSLS  BAL   R5,SCANUB          OFF TO COMMON ROUTINE                 03218000
         BINOP 7,$$DVD2           BINARY /                              03219000
         UNOP  $$SLS1             UNARY /                               03220000
*                                                                       03221000
*        PROCESSING FOR . (UNARY OR BINARY)                             03222000
*                                                                       03223000
SCANDOT  CLI   1(R1),C'0'         IS THIS NUMERIC CASE? (REAL NUMBER)   03224000
         BNL   SCANNUM            IF SO, USE STANDARD NUMBER CIRCUIT    03225000
         CNOP  0,4                ALLIGN BAL                            03226000
         BAL   R5,SCANUB          ELSE CALL COMMON OPTR ROUTINE         03227000
DOT2DV   BINOP 11,($$DOT2,V,N),,SPECL       BINARY .                    03228000
DOT1DV   UNOP  (SPITBOLA,N),,SPECL          UNARY . (DUMMY ADDRESS)     03229000
         B     CODENQ6            CODEGEN JUMP FOR UNARY .              03230000
         BINOP 11,$$DOTD          BINARY . DEFERRED ARG CASE            03231000
         EJECT                                                          03232000
*                                                                       03233000
*        PROCESSING FOR ?                                               03234000
*                                                                       03235000
         CNOP  0,4                ENSURE BAL ALLIGNMENT                 03236000
SCANQUS  BAL   R5,SCANUB          CALL COMMON ROUTINE                   03237000
QUS2DV   BINOP 12,$$QUS2          BINARY ?                              03238000
         UNOP  SPITBOLA+1,,PREDF+SPECL      UNARY ? (DUMMY ADDRESS)     03239000
         B     CODENQ1            CODEGEN JUMP FOR UNARY ?              03240000
*                                                                       03241000
*        PROCESSING FOR & (UNARY OR BINARY)                             03242000
*                                                                       03243000
*        TO TAKE CARE OF THE &LASTNO CASE, WE GENERATE THE FOLLOWING    03244000
*        SPECIAL CODE --                                                03245000
*                                                                       03246000
*        BALR  RETURN,0           (IN CASE CONTROL FLOWS IN TO STMNT)   03247000
*        AUR   0,2                NORMAL STATEMENT COUNT                03248000
*        ST    RETURN,$$LAST                                            03249000
*                                                                       03250000
SCANAMP  CLI   AMPFLAG,0          DID WE GENERATE IT ALREADY?           03251000
         BNE   SCANAMP1           SKIP IF SO, NEED IT ONLY ONCE         03252000
         CLI   1(R1),C'L'         NEXT CHARACTER AN L?                  03253000
         BH    SCANAMP1           IF HIGHER, CANNOT BE &LASTNO          03254000
         BE    SCANAMP0           SKIP IF AN L (COULD BE &LASTNO)       03255000
         CLI   1(R1),C'A'         IS IT FROM A-K?                       03256000
         BNL   SCANAMP1           SKIP IF SO (CANNOT BE &LASTNO)        03257000
*                                                                       03258000
*        HERE IF THIS COULD BE A DIRECT OR INDIRECT &LASTNO REFERENCE   03259000
*                                                                       03260000
SCANAMP0 MVI   AMPFLAG,1          SET SIGNAL FOR & CODE ALREADY DONE    03261000
         L     R2,LABSAVE         LOAD SAVED LABEL BLOCK POINTER        03262000
         LTR   R2,R2              WAS THERE A LABEL                     03263000
         BZ    *+16               SKIP IF NOT                           03264000
         L     R3,VLABL(,R2)      ELSE LOAD OLD LABEL POINTER           03265000
         AH    R3,=H'2'           ADJUST PAST THE BALR WE WILL MAKE     03266000
*                                 SAVING LEFT POINTER BYTE              03267000
         ST    R3,VLABL(,R2)      STORE ADJUSTED VALUE                  03268000
         L     LC,STMCODE         DELETE AUR ETC. ALREADY GENERATED     03269000
         MVC   0(8,LC),LSTCD$     GENERATE OUR SPECIAL CODE             03270000
         MVC   2(2,LC),AUR$       GENERATE THE AUR                      03271000
         LA    LC,8(,LC)          BUMP CODE POINTER                     03272000
*                                                                       03273000
*        COMPLETE NORMAL PROCESSING OF &                                03274000
*                                                                       03275000
         CNOP  0,4                MAKE SURE WE ARE ALLIGNED FOR BAL     03276000
SCANAMP1 BAL   R5,SCANUB          CALL COMMON ROUTINE                   03277000
         BINOP 1,$$AMP2           BINARY &                              03278000
KGETDV   UNOP  ($$KGET,N)         UNARY &                               03279000
         EJECT                                                          03280000
*                                                                       03281000
*        ENTRY FOR  (UNARY OR BINARY)                                  03282000
*                                                                       03283000
         CNOP  0,4                ENSURE BAL ALLIGNMENT                 03284000
SCANNOT  BAL   R5,SCANUB          CALL COMMON ROUTINE                   03285000
         BINOP 12,$$NOT2,,RASS                                          03286000
NOTDV    UNOP  SPITBOLA+3,,PREDF+SPECL      UNARY  (DUMMY ADDRESS)     03287000
         B     CODENQ2            CODEGEN JUMP FOR UNARY               03288000
*                                                                       03289000
*        ENTRY FOR | (BINARY ONLY)                                      03290000
*                                                                       03291000
         CNOP  0,4                ENSURE BAL ALLIGNMENT                 03292000
SCANORP  BAL   R5,SCANUB          CALL COMMON ROUTINE                   03293000
         BINOP 2,$$ORP2           BINARY |                              03294000
         UNOP  $$BAR1             UNARY |                               03295000
*                                                                       03296000
*        ENTRY FOR # (UNARY OR BINARY)                                  03297000
*                                                                       03298000
SCANNMS  BAL   R5,SCANUB          CALL COMMON ROUTINE                   03299000
         BINOP 6,$$PND2           BINARY #                              03300000
         UNOP  $$PND1             UNARY #                               03301000
*                                                                       03302000
*        ENTRY FOR @ (UNARY OR BINARY)                                  03303000
*                                                                       03304000
         CNOP  0,4                ENSURE BAL ALLIGNMENT                 03305000
SCANATS  BAL   R5,SCANUB          CALL COMMON ROUTINE                   03306000
         BINOP 4,$$ATS2           BINARY @                              03307000
ATS1DV   UNOP  ($$ATSP,N),,SPECL  UNARY @                               03308000
         B     CODENQ5            CODEGEN JUMP FOR UNARY @              03309000
         DC    AL4(0)             FILLER TO GET OFFSET (SEE CODEXTST)   03310000
         UNOP  $$ATSD             UNARY @ WITH EXPR ARGUMENT            03311000
*                                                                       03312000
*        ENTRY FOR % (UNARY OR BINARY)                                  03313000
*                                                                       03314000
         CNOP  0,4                ENSURE BAL ALLIGNMENT                 03315000
SCANPCT  BAL   R5,SCANUB          CALL COMMON ROUTINE                   03316000
         BINOP 9,$$PCT2           BINARY %                              03317000
         UNOP  $$PCT1             UNARY %                               03318000
         EJECT                                                          03319000
*                                                                       03320000
*        OPERATOR PROCESSING ROUTINE                                    03321000
*                                                                       03322000
*        CNOP  0,4                                                      03323000
*        BAL   R5,SCANUB                                                03324000
*        (DOPE VECTOR FOR BINARY OPERATOR)                              03325000
*        (COMMUTED BINARY OPERATOR DV IF USED, +,* ONLY)                03326000
*        (DOPE VECTOR FOR UNARY OPERATOR)                               03327000
*                                                                       03328000
*        THIS ROUTINE DETERMINES WHETHER THE OPERATOR IS UNARY OR       03329000
*        BINARY AND RETURNS TO THE CALLER OF SCAN WITH THE ADDRESS      03330000
*        OF THE APPROPRIATE OPERATOR DOPE VECTOR STORED IN SCANAD       03331000
*                                                                       03332000
*        NOTE THAT AN OPERATOR IS TREATED AS BINARY ONLY IF IT IS       03333000
*        PRECEDED AND FOLLOWED BY BLANKS. OTHERWISE IT IS UNARY.        03334000
*        ERROR SITUATIONS (SUCH AS ' A+ B ') ARE CAUGHT IN EXPAN        03335000
*                                                                       03336000
SCANUB   LA    R1,1(,R1)          BUMP PAST OPERATOR                    03337000
         TM    0(R1),X'FF'-X'40'  TEST FOR BLANK OR END OF CARD AFTER   03338000
         BZ    SCANUB1            SKIP IF SO, COULD BE BINARY           03339000
*                                                                       03340000
*        COME HERE IF UNARY                                             03341000
*                                                                       03342000
SCANUBU  LA    R5,4(,R5)          POINT TO UNARY OP DOPE VECTOR         03343000
         TM    1(R5),BNOP         STILL POINTING TO BINARY OP (+,*)     03344000
         BO    SCANUBU            BACK TO BUMP AGAIN IF SO              03345000
*                                                                       03346000
*        COME HERE TO STORE DOPE VECTOR ADDRESS & REPORT OPERATOR       03347000
*                                                                       03348000
SCANUBC  ST    R5,SCANAD          STORE OPTR DOPE VECTOR ADDRESS        03349000
         MVI   SCANAD,0           MAKE SURE UPPER BYTE IS ZERO          03350000
         MVI   SCANFL,OPR         REPORT OPERATOR                       03351000
         ST    R1,SCANLOC         SAVE SCAN LOCATION                    03352000
         BR    RF                 AND RETURN                            03353000
*                                                                       03354000
*        COME HERE IF IT COULD BE BINARY (FOLLOWED BY BLANK)            03355000
*                                                                       03356000
SCANUB1  CLI   SCANCHR,C' '       DID WE HAVE A PRECEDING BLANK?        03357000
         BE    SCANUBC            IF SO, DEFINITELY BINARY              03358000
         B     SCANUBU            ELSE UNARY                            03359000
         EJECT                                                          03360000
*                                                                       03361000
*        SPECIAL ENTRY FOR F,S -- POSSIBLE GOTOS IF FLAG IS SET         03362000
*                                                                       03363000
SCANGOTO CLI   GOTOFLG,X'FF'      TEST FOR GOTO POSSIBLE                03364000
         BNE   SCANLTR            SKIP IF NOT FOR NORMAL PROCESSING     03365000
         CLI   1(R1),C'('         TEST FOR LEFT PAREN (GOTO)            03366000
         BE    SCANS              SIGNAL GOTO IF SO                     03367000
         CLI   1(R1),C'<'         ELSE CHECK FOR DIRECT GOTO CASE       03368000
         BE    SCANS              SIGNAL GOTO IF SO, ELSE MERGE LETTER  03369000
*                                                                       03370000
*        ENTRY POINT FOR LETTER -- VARIABLE                             03371000
*                                                                       03372000
SCANLTR  LR    R3,R1              SAVE SCAN LOC (START OF STRING)       03373000
*                                                                       03374000
*        LOOP HERE IF NAME IS LONGER THAN 255 CHARACTERS                03375000
*                                                                       03376000
SCANLTR0 TRT   1(256,R1),SCANTB2  SCAN TO END OF NAME                   03377000
         BNZ   SCANLTR1           SKIP IF END OF NAME FOUND             03378000
         LA    R1,256(,R1)        ELSE PUSH POINTER PAST 256 BYTES      03379000
         B     SCANLTR0           AND LOOP BACK                         03380000
*                                                                       03381000
*        HERE WHEN WE FIND THE END OF THE NAME                          03382000
*                                                                       03383000
SCANLTR1 C     R1,STOPLOC         DID WE OVERSHOOT ON TRT?              03384000
         BNL   SCANLTR3           SKIP IF SO                            03385000
         BAL   R4,SCANHSH         LOCATE VARIABLE BLOCK                 03386000
         CLI   0(R1),C'('         DO WE HAVE A FOLLOWING (              03387000
         BE    SCANFNC            FUNCTION IF SO                        03388000
*                                                                       03389000
*        HERE IF A VARIABLE REFERENCE (NOT A FUNCTION CALL)             03390000
*                                                                       03391000
SCANLTR2 ST    R5,SCANAD          STORE VARIABLE BLOCK ADDRESS          03392000
         ST    R1,SCANLOC         SAVE SCAN LOCATION                    03393000
         MVI   SCANFL,VAR         SET SYNTAX REPORT                     03394000
         BR    RF                 AND RETURN                            03395000
*                                                                       03396000
*        HERE IF WE SCAN OFF THE END OF THE INPUT IMAGE                 03397000
*                                                                       03398000
SCANLTR3 L     R1,STOPLOC         POINT BACK TO END OF IMAGE            03399000
         BAL   R4,SCANHSH         LOCATE VARIABLE BLOCK                 03400000
         B     SCANLTR2           MERGE BACK (CANNOT BE A FUNCTION)     03401000
*                                                                       03402000
*        HERE FOR A FUNCTION (I.E. VARIABLE NAME FOLLOWED BY A LEFTPRN) 03403000
*                                                                       03404000
SCANFNC  LA    R1,1(,R1)          BUMP SCAN POINTER PAST (              03405000
         ST    R5,SCANAD          REPORT DOPE VECTOR ADDRESS FOR BLOCK  03406000
         MVI   SCANFL,FNC         REPORT FUNCTION                       03407000
         ST    R1,SCANLOC         SAVE SCAN LOCATION                    03408000
         BR    RF                 RETURN                                03409000
         EJECT                                                          03410000
*                                                                       03411000
*        ENTRY TO DEAL WITH REAL OR INTEGER CONSTANT                    03412000
*                                                                       03413000
*                                                                       03414000
*        IF THIS CONSTANT HAS NOT ALREADY BEEN DEFINED, AN 8-BYTE       03415000
*        BLOCK IS BUILT IN THE DATA AREA. A HASH TABLE IS MAINTAINED    03416000
*        FOR REAL AND INTEGER CONSTANTS. (DREALS ARE NOT HASHED).       03417000
*        THE HASH TABLE HAS 64 FULLWORD ENTRIES. EACH ENTRY IS A PTR    03418000
*        TO A CHAIN OF CONSTANTS HASHING INTO THE SAME SLOT. THE        03419000
*        CONSTANTS ARE LINKED THROUGH THE FIRST WORD OF THE VALUE       03420000
*        FIELD.  ZERO MARKS THE END OF THE CHAIN                        03421000
*                                                                       03422000
SCANNUM  LR    R4,R1              SAVE STARTING LOCATION                03423000
*                                                                       03424000
*        SCAN OUT NUMERIC CONSTANT                                      03425000
*                                                                       03426000
         BCTR  R1,0               BACK OFF R1 TO CALL COMMON ROUTINE    03427000
         BAL   R5,SCANDIGS        CALL ROUTINE TO SCAN PAST DIGITS      03428000
         CLI   0(R1),C'.'         IS THIS A REAL NUMBER?                03429000
         BNE   SCANNUMG           ALL SCANNED OUT IF NOT                03430000
         BAL   R5,SCANDIGS        ELSE SCAN DIGITS AFTER DEC POINT      03431000
         CLI   0(R1),C'E'         DO WE HAVE "E" EXPONENT               03432000
         BE    SCANNUMR           SKIP IF SO                            03433000
         CLI   0(R1),C'D'         ELSE DO WE HAVE "D" EXPONENT          03434000
         BNE   SCANNUMG           ALL DONE IF NOT                       03435000
*                                                                       03436000
*        COME HERE AFTER FINDING A D OR E EXPONENT                      03437000
*                                                                       03438000
SCANNUMR CLI   1(R1),C'+'         DO WE HAVE A PLUS SIGN                03439000
         BE    *+12               SKIP IF SO                            03440000
         CLI   1(R1),C'-'         OR A MINUS SIGN?                      03441000
         BNE   *+8                SKIP IF NOT                           03442000
         LA    R1,1(,R1)          ELSE BUMP ONE FOR THE SIGN            03443000
         BAL   R5,SCANDIGS        SCAN PAST DIGITS IN EXPONENT          03444000
*                                                                       03445000
*        COME HERE TO CALL CONVERT ROUTINE                              03446000
*                                                                       03447000
SCANNUMG C     R1,STOPLOC         PAST END OF INPUT IMAGE?              03448000
         BL    *+8                SKIP IF NOT                           03449000
         L     R1,STOPLOC         ELSE RESET SCAN PTR TO END OF IMAGE   03450000
         ST    R1,SCANLOC         STORE UPDATED SCAN LOCATION           03451000
         MVI   SCANFL,CON         INDICATE RETURN TYPE = CONSTANT       03452000
         SR    R1,R4              GET REAL LENGTH OF NUMBER STRING      03453000
         LR    R5,R1              MOVE TO R5 (A1+1)                     03454000
         BCTR  R5,0               ADJUST TO 360 LENGTH                  03455000
         SH    R4,=Y(SCHARS)      INTRODUCE PROPER OFFSET TO ADDRESS    03456000
         LA    R2,STGTONUM        LOAD ADDRESS OF CONVERT ROUTINE       03457000
         BALR  R1,R2              CALL ROUTINE TO CONVERT TO NUMERIC    03458000
         ERR   16                 ILLEGAL NUMERIC ON CONVERT ERROR      03459000
         LCR   R2,R4              TEST DATATYPE OF NUMERIC ITEM         03460000
         BP    SCANNUM4           SKIP IF DREAL (NO HASH FOR DREAL)     03461000
         TM    STAGE,$EXECUTE     EXECUTE TIME (CODE,EVAL)?             03462000
         BO    SCANNUM4           SKIP IF SO (DO NOT HASH)              03463000
         EJECT                                                          03464000
*                                                                       03465000
*        COME HERE TO HASH THE NUMERIC CONSTANT AND LOOK IT UP          03466000
*                                                                       03467000
*        HASH IS FIRST 6 BITS OF XOR OF 2ND & 4TH BYTES OF SECOND WORD  03468000
*                                                                       03469000
         LR    R2,R5              COPY SECOND WORD (VALUE)              03470000
         SRL   R2,16              RIGHT JUSTIFY SECOND BYTE             03471000
         XR    R2,R5              GET EXCLUSIVE OR WITH FOURTH BYTE     03472000
         N     R2,=X'000000FC'    GET 6 BITS (FULLWORD OFFSET)          03473000
         LA    R6,CHASH-CHASHL(R2)          POINT TO SLOT WITH OFFSET   03474000
         ST    R4,SCANWRK         STORE FIRST WORD (TYPE CODE)          03475000
*                                                                       03476000
*        LOOP TO SCAN DOWN HASH CHAIN                                   03477000
*                                                                       03478000
SCANUM3A CE    ZR,CHASHL(,R6)     CHECK FOR END OF HASH CHAIN           03479000
         BZ    SCANNUM4           SKIP IF AT END OF CHAIN               03480000
         L     R6,CHASHL(,R6)     ELSE POINT TO NEXT BLK ON HASH CHAIN  03481000
         C     R5,CVALUE(,R6)     CHECK FOR MATCH ON VALUE              03482000
         BNE   SCANUM3A           IF NO MATCH, LOOP BACK                03483000
         CLC   CONCODE(1,R6),SCANWRK        CHECK FOR CORRECT TYPE      03484000
         BNE   SCANUM3A           LOOP BACK IF NO MATCH                 03485000
*                                                                       03486000
*        COME HERE IF WE FIND AN OLD COPY WE CAN USE                    03487000
*                                                                       03488000
         ST    R6,SCANAD          STORE ADDRESS OF BLOCK                03489000
         BR    RF                 RETURN                                03490000
*                                                                       03491000
*        COME HERE TO CREATE NEW CONSTANT (REAL OR INTEGER) BLOCK       03492000
*                                                                       03493000
SCANNUM4 BAL   R2,FIND8           LOCATE AN 8 BYTE BLOCK                03494000
         STM   R4,R5,VALUE(R1)    STORE CONSTANT                        03495000
         ST    R1,SCANAD          STORE ADDRESS OF BLOCK FOR SCAN       03496000
*                                                                       03497000
*        HERE WE LINK NEW BLOCK INTO HASH CHAIN UNLESS TYPE = DREAL     03498000
*                                                                       03499000
         LCR   R4,R4              TEST TYPE                             03500000
         BCR   P,RF               RETURN IF DREAL                       03501000
         TM    STAGE,$EXECUTE     EXECUTE TIME (CODE,EVAL)?             03502000
         BCR   O,RF               SKIP HASH LINKING IF SO               03503000
         IC    R0,CONCODE(,R6)    SAVE UPPER BYTE                       03504000
         ST    R1,CHASHL(,R6)     LINK NEW CONSTANT ONTO HASH CHAIN     03505000
         STC   R0,CONCODE(,R6)    RESTORE UPPER BYTE                    03506000
         BR    RF                 RETURN TO SCAN CALLER                 03507000
*                                                                       03508000
*        LITTLE SUBROUTINE TO SCAN PAST DIGITS                          03509000
*                                                                       03510000
SCANDIGS TRT   1(256,R1),SCANTB3  SCAN PAST DIGITS                      03511000
         BCR   NZ,R5              RETURN IF WE FOUND NON-DIGIT          03512000
         LA    R1,256(,R1)        ELSE BUMP PAST 256 DIGITS             03513000
         B     SCANDIGS           AND LOOP BACK                         03514000
         EJECT                                                          03515000
*                                                                       03516000
*        ENTRY FOR ' OR "                                               03517000
*                                                                       03518000
*        AFTER THE ELEMENT IS SCANNED OUT, A STRING IS CONSTRUCTED IN   03519000
*        HIGH CORE, AND AN 8-BYTE SPECIFIER POINTING TO THIS STRING     03520000
*        IS CONSTRUCTED IN THE DATA AREA                                03521000
*        IF THE STRING ALREADY EXISTS, THEN A NEW SPECIFIER IS NOT      03522000
*        CONSTRUCTED, RATHER THE OLD ADDRESS IS RETURNED--THE LOGIC OF  03523000
*        USING A HASH TABLE TO REMEMBER OLD ENTRIES IS VIRTUALLY        03524000
*        IDENTICAL TO THAT USED IN PROCESSING INTEGERS                  03525000
*        EXCEPT THAT THE NXTHASHS FIELD IS USED AS THE LINK FIELD       03526000
*                                                                       03527000
SCANQUT  MVI   SCANFL,CON         INDICATE CONSTANT                     03528000
         LR    R3,R1              SAVE LOCATION OF INITIAL QUOTE        03529000
*                                                                       03530000
*        LOOP TO SCAN OUT THE LITERAL                                   03531000
*                                                                       03532000
SCANQT0  TRT   1(256,R1),SCANTB4  SCAN TO ' OR "                        03533000
         BNZ   SCANQT1            SKIP IF WE GOT STOPPED                03534000
         LA    R1,256(,R1)        ELSE BUMP PAST 256 CHARACTERS         03535000
         C     R1,STOPLOC         PAST END OF IMAGE?                    03536000
         BL    SCANQT0            LOOP BACK IF NOT TO KEEP SCANNING     03537000
*                                                                       03538000
*        COME HERE IF WE SCAN OFF THE END OF THE CARD                   03539000
*                                                                       03540000
SCANQT00 MVC   SCANLOC,STOPLOC    UPDATE SCAN POINTER TO END OF CARD    03541000
         ERR   18                 ******UNMATCHED QUOTE******           03542000
*                                                                       03543000
*        COME HERE IF WE STOP ON A ' OR "                               03544000
*                                                                       03545000
SCANQT1  C     R1,STOPLOC         DID WE SCAN OFF THE END OF THE INPUT? 03546000
         BNL   SCANQT00           JUMP TO GIVE ERROR IF SO              03547000
         CLC   0(1,R3),0(R1)      IS THIS THE QUOTE WE ARE LOOKING FOR? 03548000
         BNE   SCANQT0            NO -- PART OF STRING -- KEEP GOING    03549000
*                                                                       03550000
*        HERE WHEN WE HAVE SCANNED TO THE CLOSING QUOTE                 03551000
*                                                                       03552000
         LR    R2,R1              GET LOCATION OF FINAL QUOTE           03553000
         LA    R1,1(R1)           POINT SCAN POINTER PAST QUOTE         03554000
         ST    R1,SCANLOC         SAVE UPDATED SCAN POINTER             03555000
         SH    R2,=H'2'           R2 IS LOCATION OF LAST CHAR WI FUDGE  03556000
         SR    R2,R3              GET LENGTH - 1                        03557000
         BNM   SCANQT2            SKIP IF THERE IS A STRING             03558000
         STE   ZR,SCANAD          INDICATE NULL CONSTANT BY ZERO PTR    03559000
         BR    RF                 RETURN                                03560000
         EJECT                                                          03561000
*                                                                       03562000
*        REENTRY TO HASH STRING AND LOOK IT UP                          03563000
*        THE HASHING ALGORITHM IS TO EXCLUSIVE OR THE LENGTH, CHARS 1-4 03564000
*        AND CHARS 5-8 AND TAKE THE REMAINDER ON DIVIDING BY 63         03565000
*                                                                       03566000
SCANQT2  TM    STAGE,$EXECUTE     CALL AT EXECUTE TIME?                 03567000
         BO    SCANQH5            SKIP IF SO                            03568000
         CH    R2,=H'7'           ELSE TEST FOR LENGTH < 8              03569000
         BH    SCANQT3            SKIP IF LONG STRING                   03570000
         STD   ZR,SCANWRK         ZERO WORK AREA                        03571000
         EX    R2,SCANQMV         MOVE IN WHAT CHARACTERS WE HAVE       03572000
         B     SCANQT4            MERGE                                 03573000
*                                                                       03574000
*        SKIP HERE IF LENGTH 8 CHARS OR MORE                            03575000
*                                                                       03576000
SCANQT3  MVC   SCANWRK(8),1(R3)   FOR LENGTH > 7, MOVE 1ST EIGHT CHARS  03577000
*                                                                       03578000
*        MERGE HERE WITH HASH CHARACTERS MOVED INTO PLACE IN SCANWRK    03579000
*                                                                       03580000
SCANQT4  L     R5,SCANWRK         LOAD FIRST FOUR BYTES                 03581000
         XR    R5,R2              EXCLUSIVE OR LENGTH                   03582000
         X     R5,SCANWRK+4       EXCLUSIVE OR BYTES 5-8                03583000
         SR    R4,R4              CLEAR HIGH ORDER PART                 03584000
         D     R4,=F'63'          DIVIDE TO GET HASH                    03585000
         SLL   R4,2               *4 TO INDEX HASH TABLE                03586000
         LA    R4,CHASH-CHASHL(R4)          POINT TO HASH SLOT          03587000
         SR    R0,R0              CLEAR R0 FOR IC IN LOOP               03588000
*                                                                       03589000
*        LOOP TO SCAN DOWN HASH CHAIN                                   03590000
*                                                                       03591000
SCANQH3  CE    ZR,CHASHL(,R4)     IS THIS THE END OF THE CHAIN?         03592000
         BZ    SCANQH4            SKIP IF SO                            03593000
         L     R4,CHASHL(,R4)     ELSE POINT TO NEXT BLOCK ON CHAIN     03594000
         CLI   CONCODE(R4),SCODE  IS IT A STRING?                       03595000
         BNE   SCANQH3            LOOP BACK IF NOT A STRING             03596000
         IC    R0,CSLENGTH(,R4)   LOAD 360 LENGTH                       03597000
         CR    R0,R2              DO LENGTHS MATCH?                     03598000
         BNE   SCANQH3            LOOP BACK IF DIFFERENT LENGTHS        03599000
         L     R7,CSADR(,R4)      LOAD POINTER TO STRING                03600000
         EX    R2,SCANQCMP        COMPARE STRINGS                       03601000
         BNE   SCANQH3            LOOP BACK IF DIFFERENT                03602000
*                                                                       03603000
*        HERE IF WE FOUND AN OLD BLOCK WE CAN USE                       03604000
*                                                                       03605000
         ST    R4,SCANAD          SAVE ITS ADDRESS                      03606000
         BR    RF                 RETURN                                03607000
*                                                                       03608000
SCANQCMP CLC   1(*-*,R3),SCHARS(R7)         COMPARE STRINGS FOR MATCH   03609000
SCANQMV  MVC   SCANWRK(*-*),1(R3) MOVE CHARACTERS TO WORK AREA          03610000
         EJECT                                                          03611000
*                                                                       03612000
*        COME HERE TO CREATE NEW BLOCK FOR STRING CONSTANT              03613000
*                                                                       03614000
SCANQH4  LTR   R7,R4              SAVE LOCATION OF LAST HASH SLOT       03615000
*                                 ALSO SET CC=NONZERO FOR HIGHCORE CALL 03616000
         LA    R4,1(,R3)          POINT TO STRING                       03617000
         LA    R5,1(,R2)          ACTUAL LENGTH OF STRING               03618000
         LR    R0,R5              COPY LENGTH OF STRING                 03619000
         A     R0,STRUSED         ADD LENGTH USED SO FAR FOR STRINGS    03620000
         ST    R0,STRUSED         STORE INCREMENTED COUNT               03621000
         LA    R2,HIGHCORE        POINT TO HIGH CORE ROUTINE            03622000
         BALR  R1,R2              MOVE STRING CONSTANT TO HIGH CORE     03623000
         SH    R4,=Y(SCHARS)      INTRODUCE PROPER STRING OFFSET        03624000
         BCTR  R5,0               ADJUST TO 360 LENGTH                  03625000
         BAL   R2,FIND8           LOCATE AN 8 BYTE BLOCK                03626000
         ST    R1,SCANAD          STORE ADDRESS OF NEW CONSTANT BLOCK   03627000
*                                                                       03628000
*        NOW STORE STRING IN CONSTANT BLOCK IN SPECIAL COMPILER FORMAT  03629000
*                                                                       03630000
         ST    R4,CSADR(,R1)      STORE STRING ADDRESS IN NEW BLOCK     03631000
         STC   R5,CSLENGTH(,R1)   STORE LENGTH OF STRING                03632000
         MVI   CONCODE(R1),SCODE  INDICATE STRING TYPE                  03633000
*                                                                       03634000
*        LINK THIS BLOCK INTO THE CONSTANT HASH TABLE                   03635000
*                                                                       03636000
         IC    R0,CONCODE(,R7)    SAVE TYPE CODE IN PREVIOUS BLOCK      03637000
         ST    R1,CHASHL(,R7)     LINK THIS BLOCK INTO THE CHAIN        03638000
         STC   R0,CONCODE(,R7)    RESTORE UPPER BYTE                    03639000
         BR    RF                 RETURN TO CALLER                      03640000
*                                                                       03641000
*        HERE FOR CODE,EVAL CASE, COMPUTE OFFSET IN ARGUMENT STRING     03642000
*                                                                       03643000
*        (R2)                     360 LENGTH OF STRING                  03644000
*        (R3)                     POINTS TO INITIAL QUOTE               03645000
*                                                                       03646000
SCANQH5  LR    R5,R2              COPY 360 LENGTH                       03647000
         BAL   R2,FIND8           LOCATE AN 8 BYTE BLOCK                03648000
         ST    R1,SCANAD          SAVE AS RETURNED SCAN BLOCK PTR       03649000
         STH   R5,SLENGTH+VALUE(,R1)        STORE 360 LENGTH OF STRING  03650000
         L     R0,CODSVREG+4*A1   LOAD SOURCE STRING BASE POINTER       03651000
         ST    R0,VALUE(,R1)      STORE AS FIRST WORD OF CONSTANT       03652000
         SH    R3,=Y(SCHARS-1)    POINT SCHARS BEHIND STRING            03653000
         SR    R3,R0              COMPUTE PROPER OFFSET IN STRING       03654000
         STH   R3,SOFFSET+VALUE(,R1)        STORE OFFSET IN BLOCK       03655000
         MVI   CRELFLG,1          TELL GCOL TO COLLECT CONSTANTS        03656000
         BR    RF                 RETURN TO CALLER                      03657000
         EJECT                                                          03658000
*                                                                       03659000
*        COME HERE IF WE SCAN OUT 256 BLANKS (TRT FALLS THROUGH)        03660000
*                                                                       03661000
SCAN256B LA    R1,256(,R1)        PUSH SCAN POINTER                     03662000
         C     R1,STOPLOC         PAST END OF IMAGE?                    03663000
         BL    SCAN1              KEEP SCANNING IF NOT                  03664000
*                                                                       03665000
*        COME HERE AT END OF INPUT IMAGE                                03666000
*        RETURN TRM UNLESS THERE ARE CONTINUATION CARDS                 03667000
*                                                                       03668000
SCANTRM  MVI   SCANFL,TRM         SET PROVISIONAL REPORT                03669000
*                                                                       03670000
*        FOR END OF IMAGE, TEST FOR COMPILE OR EXECUTE TIME. IN THE     03671000
*        LIBRARY MODULES THIS TEST IS OMITTED SINCE IT MUST BE XEQ TIME 03672000
*                                                                       03673000
         AIF   (&LMOD EQ 1).SCANTRS                                     03674000
         TM    STAGE,$EXECUTE     IS THIS CODE OR EVAL CALL?            03675000
         BO    SCANTR3            SKIP IF SO                            03676000
*                                                                       03677000
*        IF NOT EXECUTE TIME, THEN WE READ THE NEXT CARD TO SEE IF IT   03678000
*        IS A CONTINUATION CARD. COMMENT CARDS ARE MERELY LISTED.       03679000
*        THIS CODE IS NOT REQUIRED IN THE LIBRARY MODULES               03680000
*                                                                       03681000
SCANTR1  BAL   R7,READER          READ NEXT CARD                        03682000
         LA    R1,INBUF           POINT TO START OF NEW CARD            03683000
         ST    R1,SCANLOC         INITIALIZE SCAN LOCATION              03684000
         CLI   0(R1),C'*'         IS THIS A COMMENT CARD?               03685000
         BNE   SCANTR2            SKIP IF NOT                           03686000
         BAL   R7,LISTER          ELSE JUST LIST A COMMENT CARD         03687000
         B     SCANTR1            AND BACK TO READ NEXT CARD            03688000
*                                                                       03689000
*        IF NOT A COMMENT CARD, IS IT A CONTINUATION CARD?              03690000
*                                                                       03691000
SCANTR2  CLI   0(R1),C'.'         PERIOD?                               03692000
         BE    SCANCNTC           SKIP IF SO, CONTINUATION              03693000
         CLI   0(R1),C'+'         ALTERNATE CONTINUATION (PLUS)?        03694000
         BCR   NE,RF              IF NOT, ALL SET REAL END OF STATEMENT 03695000
*                                                                       03696000
*        HERE FOR CONTINUATION CARD                                     03697000
*                                                                       03698000
SCANCNTC MVI   0(R1),C' '         BLANK CONTINUATION CHARACTER          03699000
         LA    R7,SCAN0           SET EXIT TO SCAN NEXT ELEMENT         03700000
         B     LISTER             LIST CONT CARD & BACK TO SCAN ELEMENT 03701000
.SCANTRS ANOP                                                           03702000
*                                                                       03703000
*        COME HERE AT END OF STRING FOR EXECUTION TIME CALL             03704000
*                                                                       03705000
SCANTR3  MVI   CODEOS,1           SET CODE END OF STRING FLAG           03706000
         BR    RF                 RETURN WITH END OF STRING SET         03707000
         EJECT                                                          03708000
*                                                                       03709000
*        ENTRY POINT FOR ILLEGAL CHARACTER DETECTED                     03710000
*                                                                       03711000
SCANILG  LA    R1,1(R1)           BUMP POINTER OVER BAD CHARACTER       03712000
         CLI   ERRFLG,1           CHECK FOR ERROR IN ERROR              03713000
         BE    SCANERR            SKIP IF ERROR IN ERROR                03714000
         ERR   24                 *** ILLEGAL CHARACTER ***             03715000
*                                                                       03716000
*        WE COME HERE IF AN ERROR OCCURS INSIDE AN ERROR WHILE          03717000
*        SCANNING TO A STATEMENT BOUNDARY (ALSO USED BY CONCPROC)       03718000
*                                                                       03719000
SCANERR  ST    R1,SCANLOC         PUT IN LAST SCAN LOCATION             03720000
         MVI   SCANFL,0           CLEAR REPORT CELL                     03721000
         BR    RF                 RETURN                                03722000
         EJECT                                                          03723000
*                                                                       03724000
*        INTERNAL SUBROUTINE TO HASH TO LOCATE VARIABLE BLOCK           03725000
*        A NEW VARIABLE BLOCK IS CREATED IF NECCESSARY                  03726000
*        SEE DATA STRUCTURES SECTION FOR DESCRIPTION OF VARIABLE BLOCK  03727000
*        AND MAIN HASH TABLE STRUCTURE                                  03728000
*                                                                       03729000
*        (R1)                     POINTER TO CHARACTER AFTER NAME       03730000
*        (R3)                     POINTER TO FIRST CHARACTER OF NAME    03731000
*        BAL   R4,SCANHSH                                               03732000
*        (R5)                     DOPE VECTOR POINTER ON RETURN         03733000
*                                                                       03734000
SCANHSH  STM   R1,R4,SCANHSV      SAVE REGS                             03735000
         LR    R5,R1              COPY PTR TO CHAR AFTER NAME           03736000
         SR    R5,R3              GET LENGTH OF NAME                    03737000
         BCTR  R5,0               ADJUST TO 360 LENGTH                  03738000
         LR    R4,R3              COPY START OF NAME ADDRESS            03739000
         SH    R4,=Y(SCHARS)      INTRODUCE STANDARD OFFSET             03740000
         LA    R2,VARLOC          POINT TO HASH ROUTINE                 03741000
         BALR  R1,R2              CALL MAIN HASH ROUTINE                03742000
         LR    R5,R4              MOVE BLOCK PTR TO PROPER REG          03743000
         LM    R1,R4,SCANHSV      RELOAD REGS                           03744000
         BR    R4                 RETURN TO CALLER                      03745000
         EJECT                                                          03746000
*                                                                       03747000
*        FIND8                    LOCATE CONSTANT BLOCK                 03748000
*                                                                       03749000
*        THIS ROUTINE IS CALLED TO LOCATE AN 8-BYTE BLOCK FOR USE       03750000
*        AS A CONSTANT (STRING, INTEGER, REAL, DREAL, VCODE)            03751000
*                                                                       03752000
*        BAL   R2,FIND8                                                 03753000
*        (R1)                     ADDRESS OF ALLOCATED BLOCK            03754000
*        (R0)                     MAY BE CLOBBERED                      03755000
*        (R2-RF)                  UNCHANGED BY CALL                     03756000
*                                                                       03757000
*        AT COMPILE TIME, THE BLOCKS ARE OBTAINED SEQUENTIALLY FROM     03758000
*        THE CURRENT 4K BLOCK. HOWEVER, AT EXECUTION TIME, USE OF CODE  03759000
*        AND EVAL CAN RESULT IN BLOCKS BEING FREED. SUCH BLOCKS ARE     03760000
*        HANDELED AS FOLLOWS --                                         03761000
*                                                                       03762000
*        SPACE FOR CONSTANTS AT EXECUTION TIME IS ALLOCATED IN          03763000
*        MULTIPLES OF 32 BYTES (CONTIGUOUS). THE FIRST WORD IS USED     03764000
*        TO CHAIN SUCH 32 BYTE BLOCKS IN USE BY A SECTION OF CODE       03765000
*        FROM THE CODECCHN FIELD OF THE CBLOK. THE SECOND WORD GIVES    03766000
*        THE ADDRESS OF THE HIGHEST CONSTANT USED IN A PARTICULAR 32    03767000
*        BYTE BLOCK. THERE IS ROOM FOR THREE CONSTANTS IN EACH BLOCK.   03768000
*        WHEN A CBLOK IS COLLECTED, THE GARBAGE COLLECTOR RETURNS THE   03769000
*        32 BYTE BLOCKS TO A FREE LIST CHAINED FROM CONSCHAN IN THE     03770000
*        MAIN DATA AREA. THUS WE USE THIS CHAIN FIRST WHEN ATTEMPTING   03771000
*        TO OBTAIN A NEW 32 BYTE BLOCK.                                 03772000
*                                                                       03773000
FIND8    STM   R2,R5,SCANHSV      SAVE ENTRY REGS                       03774000
         TM    STAGE,$EXECUTE     EXECUTE TIME?                         03775000
         BO    FIND8EX            SKIP IF SO                            03776000
*                                                                       03777000
*        HERE AT COMPILE TIME                                           03778000
*                                                                       03779000
         BAL   R4,FIND8S          GET A BLOCK FROM THE CURRENT 4K BLK   03780000
         DC    H'8'               EIGHT BYTES                           03781000
         STD   ZR,0(,R1)          CLEAR BLOCK OBTAINED                  03782000
*                                                                       03783000
*        MERGE HERE TO EXIT TO CALLER WITH (R1) SET TO POINT TO BLOCK   03784000
*                                                                       03785000
FIND8X   LM    R2,R5,SCANHSV      RESTORE REGS                          03786000
         SH    R1,=Y(VALUE)       INTRODUCE STANDARD VALUE OFFSET       03787000
         BR    R2                 RETURN TO CALLER                      03788000
*                                                                       03789000
*        HERE AT EXECUTION TIME                                         03790000
*                                                                       03791000
FIND8EX  L     R5,CODSVREG+4*FR   LOAD POINTER TO CBLOK                 03792000
         L     R3,CODECCHN(,R5)   LOAD POINTER TO CURRENT 32 BYTE BLOCK 03793000
         LTR   R3,R3              IS THERE ONE?                         03794000
         BZ    FIND8EX1           IF NOT, SKIP TO GET ONE               03795000
         L     R1,4(,R3)          ELSE LOAD ADDR OF LAST CONSTANT       03796000
         SH    R1,=H'8'           BACKOFF TO MAKE ROOM FOR NEW ONE      03797000
         ST    R1,4(,R3)          STORE NEW LOWEST LOC                  03798000
         CR    R1,R3              ANY MORE ROOM IN 32 BYTE BLOCK?       03799000
         BNE   FIND8X             ALL SET TO EXIT IF SO                 03800000
         EJECT                                                          03801000
*                                                                       03802000
*        FIND8 -- CONTINUED                                             03803000
*                                                                       03804000
*        HERE IF NO 32 BYTE BLOCK ALLOCATED YET OR IF LAST ONE USED UP  03805000
*                                                                       03806000
FIND8EX1 L     R1,CONSCHAN        LOAD HEAD OF FREE LIST POINTER        03807000
         LTR   R1,R1              ANY ENTRIES ON FREE LIST?             03808000
         BNZ   FIND8EX2           SKIP IF SO                            03809000
*                                                                       03810000
*        HERE WE MUST GET A 32 BYTE CHUNK FROM THE CURRENT 4K BLOCK     03811000
*                                                                       03812000
         BAL   R4,FIND8S          ALLOCATE BLOCK                        03813000
         DC    H'32'              32 BYTES LONG                         03814000
         B     FIND8EX3           MERGE                                 03815000
*                                                                       03816000
*        HERE IF THERE IS A BLOCK ON THE FREE CHAIN WE CAN USE          03817000
*                                                                       03818000
FIND8EX2 L     R0,0(,R1)          LOAD FORWRAD LINK                     03819000
         ST    R0,CONSCHAN        DELETE BLOCK FROM CHAIN AND MERGE     03820000
*                                                                       03821000
*        MERGE HERE WITH (R1) POINTING TO NEW 32 BYTE BLOCK             03822000
*                                                                       03823000
FIND8EX3 ST    R3,0(,R1)          STORE FORWARD LINK                    03824000
         ST    R1,CODECCHN(,R5)   LINK NEW BLOCK INTO CBLOK CHAIN       03825000
         STD   ZR,8(,R1)          CLEAR SPACE FOR THREE CONSTANTS       03826000
         STD   ZR,16(,R1)         . . . .                               03827000
         STD   ZR,24(,R1)         . . . .                               03828000
         LA    R0,24(,R1)         POINT TO LAST OF THREE CONSTANTS      03829000
         ST    R0,4(,R1)          STORE AS HIGHEST ONE USED             03830000
         LR    R1,R0              GET ADDR OF ONE TO USE THIS TIME      03831000
         B     FIND8X             AND EXIT                              03832000
*                                                                       03833000
*        SUBROUTINE TO ALLOCATE 8 OR 32 BYTES FROM CURRENT 4K BLOCK     03834000
*                                                                       03835000
*        BAL   R4,FIND8S                                                03836000
*        DC    H'LENGTH'          LENGTH REQUIRED                       03837000
*        (R1)                     CONTAINS ADDRESS ON RETURN            03838000
*                                                                       03839000
FIND8S   L     R2,DATACUR         LOAD POINTER TO CURRENT BLOCK         03840000
         L     R1,CBLKBOT(,R2)    LOAD POINTER TO LOWEST CONSTANT       03841000
         SH    R1,0(,R4)          MAKE ROOM FOR NEW SUBBLOCK            03842000
         C     R1,VBLKNXT(,R2)    IS THERE ROOM?                        03843000
         BNL   FIND8S2            SKIP IF THERE IS ROOM                 03844000
         LA    R2,GET4KBLK        POINT TO ROUTINE TO ALLOCATE 4K BLOCK 03845000
         BALR  R1,R2              ALLOCATE A NEW 4K BLOCK               03846000
         B     FIND8S             LOOP BACK TO USE NEW BLOCK            03847000
*                                                                       03848000
*        HERE WHEN WE HAVE GOT SPACE IN THE CURRENT 4K BLOCK            03849000
*                                                                       03850000
FIND8S2  ST    R1,CBLKBOT(,R2)    STORE NEW LOWEST CONSTANT BLOCK       03851000
         L     R2,CONUSED         LOAD COUNT OF SPACE FOR CONSTANTS     03852000
         AH    R2,0(,R4)          INCREMENT FOR THIS BLOCK              03853000
         ST    R2,CONUSED         STORE INCREMENTED COUNT               03854000
         B     2(,R4)             RETURN PAST PARAMETER                 03855000
         EJECT                                                          03856000
*                                                                       03857000
*        TABLE OF SUPPLEMENTARY DOPE VECTORS                            03858000
*                                                                       03859000
*        THESE DOPE VECTORS ARE REFERENCED ELSEWHERE IN THE COMPILER    03860000
*                                                                       03861000
CNCDV    BINOP 3,$$CNC2,,SPECL              CONCATENATION               03862000
PTNDV    BINOP SFPRI,($$PTN2,N,V)           PATTERN MATCH BY NAME       03863000
PTVDV    BINOP SFPRI,($$PTV2,V,V)           PATTERN MATCH BY VALUE      03864000
O$EQ     BINOP SFPRI,NE,,PREDF+COMMUT       EQ                          03865000
         BINOP SFPRI,NE,,PREDF+COMMUT       EQ COMMUTED                 03866000
O$NE     BINOP SFPRI,E,,PREDF+COMMUT        NE                          03867000
         BINOP SFPRI,E,,PREDF+COMMUT        NE COMMUTED                 03868000
O$GT     BINOP SFPRI,NH,,PREDF+COMMUT       GT                          03869000
O$LT     BINOP SFPRI,NL,,PREDF+COMMUT       LT + GT COMMUTED            03870000
         BINOP SFPRI,NH,,PREDF+COMMUT       LT COMMUTED                 03871000
O$LE     BINOP SFPRI,H,,PREDF+COMMUT        LE                          03872000
O$GE     BINOP SFPRI,L,,PREDF+COMMUT        GE + LE COMMUTED            03873000
         BINOP SFPRI,H,,PREDF+COMMUT        GE COMMUTED                 03874000
O$LEQ    BINOP SFPRI,256+NE,,PREDF+COMMUT   LEQ                         03875000
         BINOP SFPRI,256+NE,,PREDF+COMMUT   LEQ COMMUTED                03876000
O$LNE    BINOP SFPRI,256+E,,PREDF+COMMUT    LNE                         03877000
         BINOP SFPRI,256+E,,PREDF+COMMUT    LNE COMMUTED                03878000
O$LGT    BINOP SFPRI,256+NH,,PREDF+COMMUT   LGT                         03879000
O$LLT    BINOP SFPRI,256+NL,,PREDF+COMMUT   LLT + LGT COMMUTED          03880000
         BINOP SFPRI,256+NH,,PREDF+COMMUT   LLT COMMUTED                03881000
O$LLE    BINOP SFPRI,256+H,,PREDF+COMMUT    LLE                         03882000
O$LGE    BINOP SFPRI,256+L,,PREDF+COMMUT    LGE + LLE COMMUTED          03883000
         BINOP SFPRI,256+H,,PREDF+COMMUT    LGE COMMUTED                03884000
O$IDENT  BINOP SFPRI,512+NE,,PREDF+SPECL+COMMUT  IDENT                  03885000
         BINOP SFPRI,512+NE,,PREDF+SPECL+COMMUT  IDENT COMMUTED         03886000
         BINOP SFPRI,512+L,,PREDF+SPECL+COMMUT   IDENT WITH NULL        03887000
         BINOP SFPRI,512+L,,PREDF+SPECL+COMMUT   IDENT WI NULL COMM     03888000
O$DIFFER BINOP SFPRI,512+E,,PREDF+SPECL+COMMUT   DIFFER                 03889000
         BINOP SFPRI,512+E,,PREDF+SPECL+COMMUT   DIFFER COMMUTED        03890000
         BINOP SFPRI,512+NL,,PREDF+SPECL+COMMUT  DIFFER WITH NULL       03891000
         BINOP SFPRI,512+NL,,PREDF+SPECL+COMMUT  DIFFER WI NULL COMM    03892000
         EJECT                                                          03893000
*                                                                       03894000
*        OPERATOR DOPE VECTORS -- CONTINUED                             03895000
*                                                                       03896000
O$ANY    UNOP  $$ANYP             ANY                                   03897000
O$BREAK  UNOP  $$BRKP             BREAK                                 03898000
O$BREAKX UNOP  $$BRKX             BREAKX                                03899000
O$INTEGE UNOP  $$INTG,,PREDF      INTEGER                               03900000
O$NOTANY UNOP  $$NTNP             NOTANY                                03901000
O$SPAN   UNOP  $$SPNP             SPAN                                  03902000
O$POS    UNOP  $$POSP             POS                                   03903000
O$RPOS   UNOP  $$RPSP             RPOS                                  03904000
O$TAB    UNOP  $$TABP             TAB                                   03905000
O$RTAB   UNOP  $$RTBP             RTAB                                  03906000
O$LEN    UNOP  $$LENP             LEN                                   03907000
KPUTDV   BINOP SFPRI,($$KPUT,N,V) KEYWORD ASSIGNMENT                    03908000
ASSNDV   BINOP SFPRI,($$ASSN,N,V),,COMMUT   ASSIGN WITH I/O CHECK       03909000
         BINOP SFPRI,($$RASN,V,N)           I/O CHECK ASSIGN COMMUTED   03910000
*                                                                       03911000
*        THE VALUE SFPRI (PRECEDENCE FOR SYSTEM FUNCTIONS) IS           03912000
*        NOT ACTUALLY USED, SINCE THESE DOPE VECTORS ARE NOT USED BY    03913000
*        EXPAN, BUT RATHER THEY ARE SUBSTITUTED IN THE CODEGEN ROUTINE. 03914000
*                                                                       03915000
SFPRI    EQU   0                  DUMMY DEFINITION FOR SYSTEM FUNCS     03916000
         TITLE 'SPITBOLC -- SCAN TABLES'                                03917000
*                                                                       03918000
*        TABLE 1                                                        03919000
*        -------                                                        03920000
*                                                                       03921000
*        COMPILE TIME USE -- MAIN SYNTAX SCAN TABLE                     03922000
*                                                                       03923000
SCANTB1  TABL  ILG                ILLEGAL CHAR IF NOT OTHERWISE SET     03924000
SCANTB1  FOR   'ABCDEFGHI',LTR                                          03925000
SCANTB1  FOR   'JKLMNOPQR',LTR                                          03926000
SCANTB1  FOR   'STUVWXYZ',LTR                                           03927000
SCANTB1  FOR   'abcdefghi',LTR    LOWER CASE                            03928000
SCANTB1  FOR   'jklmnopqr',LTR    LOWER CASE                            03929000
SCANTB1  FOR   'stuvwxyz',LTR     LOWER CASE                            03930000
SCANTB1  FOR   '0123456789',NUM                                         03931000
SCANTB1  FOR   ' ',0                                                    03932000
SCANTB1  FOR   '#',NMS                                                  03933000
SCANTB1  FOR   '!',EXC            EXCLAMATION MARK                      03934000
SCANTB1  FOR   '.',DOT                                                  03935000
SCANTB1  FOR   '<',LBR,X                                                03936000
SCANTB1  FOR   '(',LPR,X                                                03937000
SCANTB1  FOR   '+',PLS,X                                                03938000
SCANTB1  FOR   '|',ORP,X                                                03939000
SCANTB1  FOR   AM,AMP                                                   03940000
SCANTB1  FOR   '$',DLR                                                  03941000
SCANTB1  FOR   '*',AST,X                                                03942000
SCANTB1  FOR   ')',RPR,X                                                03943000
SCANTB1  FOR   ';',TRM,X                                                03944000
SCANTB1  FOR   '',NOT,X                                                03945000
SCANTB1  FOR   '-',MNS,X                                                03946000
SCANTB1  FOR   '/',SLS,X                                                03947000
SCANTB1  FOR   ',',CMA                                                  03948000
SCANTB1  FOR   '%',PCT,X                                                03949000
SCANTB1  FOR   '>',RBR                                                  03950000
SCANTB1  FOR   '?',QUS,X                                                03951000
SCANTB1  FOR   ':',GTO                                                  03952000
SCANTB1  FOR   '@',ATS                                                  03953000
SCANTB1  FOR   QT,QUT,X                                                 03954000
SCANTB1  FOR   '=',EQL,X                                                03955000
SCANTB1  FOR   '"',QUT,X                                                03956000
SCANTB1  FOR   'F',FGO                                                  03957000
SCANTB1  FOR   'f',FGO            LOWER CASE F                          03958000
SCANTB1  FOR   'S',SGO                                                  03959000
SCANTB1  FOR   's',SGO            LOWER CASE S                          03960000
         ORG                                                            03961000
         EJECT                                                          03962000
*                                                                       03963000
*        TABLE 2                                                        03964000
*        -------                                                        03965000
*                                                                       03966000
*        COMPILE TIME USE -- SCAN TO END OF VARIABLE NAME               03967000
*                                                                       03968000
SCANTB2  TABL  1                                                        03969000
SCANTB2  FOR   'ABCDEFGHI',0                                            03970000
SCANTB2  FOR   'JKLMNOPQR',0                                            03971000
SCANTB2  FOR   'STUVWXYZ',0                                             03972000
SCANTB2  FOR   'abcdefghi',0      LOWER CASE                            03973000
SCANTB2  FOR   'jklmnopqr',0      LOWER CASE                            03974000
SCANTB2  FOR   'stuvwxyz',0       LOWER CASE                            03975000
SCANTB2  FOR   '0123456789',0                                           03976000
SCANTB2  FOR   '_',0                                                    03977000
SCANTB2  FOR   '.',0                                                    03978000
         ORG                                                            03979000
*                                                                       03980000
*        SCAN TABLE 3 IS IN SPITBOLR SINCE IT IS USED AT EXECUTION      03981000
*        TIME BY THE NUMERIC CONVERSION ROUTINES                        03982000
*                                                                       03983000
*        SCAN TABLE 4 IS IN THE DATA AREA, IT IS CLEARED TO ZEROS       03984000
*        FOR USE AT EXECUTION TABLE (ZTBL)                              03985000
         TITLE 'SPITBOLC -- EXPRESSION ANALYZER'                        03986000
*                                                                       03987000
*        DATA STRUCTURES BUILT BY EXPAN                                 03988000
*        ------------------------------                                 03989000
*                                                                       03990000
*                                                                       03991000
*        SIMPLE VARIABLE                                                03992000
*        ---------------                                                03993000
*                                                                       03994000
*        +-------------+-----------------------------------------+      03995000
*        |    FLAGS    |       ADDRESS OF BLOCK IN DATA AREA     |      03996000
*        +-------------+-----------------------------------------+      03997000
*                                                                       03998000
OPNNM    EQU   1                  FLAG FOR SIMPLE VARIABLE              03999000
READV    EQU   128                FLAG FOR READ ASSOCIATED VARIABLE     04000000
WRITEV   EQU   64                 FLAG FOR WRITE ASSOCIATED VARIABLE    04001000
*                                                                       04002000
*        CONSTANT                                                       04003000
*        --------                                                       04004000
*                                                                       04005000
*        +-------------+-----------------------------------------+      04006000
*        |    FLAGS    |       ADDRESS OF BLOCK IN DATA AREA     |      04007000
*        +-------------+-----------------------------------------+      04008000
*                                                                       04009000
OPNCN    EQU   2                  FLAG FOR CONSTANT OPERAND             04010000
*                                                                       04011000
*        IN THE ABOVE CASES, THE ADDRESS IS POINTING TO THE BASE OF THE 04012000
*        REFERENCE BLOCK -- I.E FOUR BYTES BEFORE THE VALUE             04013000
*                                                                       04014000
*        UNARY OPERATOR                                                 04015000
*        --------------                                                 04016000
*                                                                       04017000
*        +-------------+-----------------------------------------+      04018000
*        |    FLAGS    |     POINTER TO OPERATOR DOPE VECTOR     |      04019000
*        +-------------+-----------------------------------------+      04020000
*        |               POINTER TO OPERAND BLOCK                |      04021000
*        +-------------------------------------------------------+      04022000
*                                                                       04023000
OPTRU    EQU   4                  FLAG FOR UNARY OPERATOR               04024000
STARNAME EQU   128                FLAG FOR * BY NAME (USED IN CODGEN)   04025000
*                                                                       04026000
*        BINARY OPERATOR                                                04027000
*        ---------------                                                04028000
*                                                                       04029000
*        +-------------+-----------------------------------------+      04030000
*        |    FLAGS    |     POINTER TO OPERATOR DOPE VECTOR     |      04031000
*        +-------------+-----------------------------------------+      04032000
*        |           POINTER TO LEFT OPERAND BLOCK               |      04033000
*        +-------------------------------------------------------+      04034000
*        |           POINTER TO RIGHT OPERAND BLOCK              |      04035000
*        +-------------------------------------------------------+      04036000
*                                                                       04037000
OPTRB    EQU   8                  FLAG FOR BINARY OPERATOR              04038000
         EJECT                                                          04039000
*                                                                       04040000
*        ARRAY ELEMENT                                                  04041000
*        -------------                                                  04042000
*                                                                       04043000
*        +-------------+-----------------------------------------+      04044000
*        |    FLAGS    |     POINTER TO ARRAY OPERAND BLOCK      |      04045000
*        +-------------+-----------------------------------------+      04046000
*        |                POINTER TO FIRST SUBSCRIPT BLOCK       |      04047000
*        +-------------------------------------------------------+      04048000
*                                                                       04049000
ARRAYFLG EQU   16                 FLAG FOR ARRAY ELEMENT                04050000
*                                                                       04051000
*        FUNCTION CALL                                                  04052000
*        -------------                                                  04053000
*                                                                       04054000
*        +-------------+-----------------------------------------+      04055000
*        |    FLAGS    |      ADDRESS OF FUNCTION BLOCK          |      04056000
*        +-------------+-----------------------------------------+      04057000
*        |              POINTER TO FIRST ARGUMENT BLOCK          |      04058000
*        +-------------------------------------------------------+      04059000
*                                                                       04060000
FUNCT    EQU   32                 FLAG FOR FUNCTION CALL                04061000
*                                                                       04062000
*        FUNCTION ARGUMENT/ ARRAY SUBSCRIPT                             04063000
*        ----------------------------------                             04064000
*                                                                       04065000
*        +-------------------------------------------------------+      04066000
*        |      POINTER TO FUNCTION ARG OR SUBSCRIPT BLOCK       |      04067000
*        +-------------------------------------------------------+      04068000
*        |      POINTER TO NEXT ARG/SUBSCR BLOCK (0 IF LAST)     |      04069000
*        +-------------------------------------------------------+      04070000
*                                                                       04071000
*                                                                       04072000
COMPLEX  EQU   ARRAYFLG+FUNCT+OPTRU+OPTRB   MASK TO TEST COMPLEX OPND   04073000
*                                                                       04074000
*                                                                       04075000
*        NOTE -- FOR OPERATOR DOPE VECTOR FORMAT -- SEE SCAN ROUTINE    04076000
*                                                                       04077000
*        THE FLAG OPNCN IS ALSO SET FOR CONSTANT SUBEXPRESSIONS WHICH   04078000
*        ARE DEFINED TO OCCUR AS FOLLOWS --                             04079000
*                                                                       04080000
*        1)    A CONSTANT IS ITSELF A CONSTANT SUBEXPRESSION            04081000
*                                                                       04082000
*        2)    A NON-PREDICATE SPECIAL CHARACTER OPERATOR IS            04083000
*              CONSTANT IF ITS OPERANDS ARE CONSTANT                    04084000
*                                                                       04085000
*        3)    VARIABLES HAVING A CONSTANT PATTERN VALUE (ARB,BAL,..)   04086000
*              ARE CONSTANTS IF THE OPTIMIZE FLAG IS ON                 04087000
*                                                                       04088000
*        4)    FUNCTIONS WHICH ARE TREATED AS OPERATORS IF THE          04089000
*              OPTIMIZE FLAG IS ON ARE CONSTANT IF THEIR                04090000
*              ARGUMENTS ARE ALL CONSTANT                               04091000
         EJECT                                                          04092000
*                                                                       04093000
*        ENTRY POINT TO EXPAN                                           04094000
*        --------------------                                           04095000
*                                                                       04096000
*        (CC)                     ZERO IF CALLED DURING SCAN OF A GOTO  04097000
*                                 FIELD IN WHICH CASE A ) OR >          04098000
*                                 TERMINATES THE SCAN,                  04099000
*                                 ELSE AN ERROR MESSAGE WILL BE GIVEN   04100000
*        BAL   RF,EXPAN                                                 04101000
*        (POINTER TO OUTER BLOCK RETURNED IN R3)                        04102000
*                                                                       04103000
*        REGISTER USAGE                                                 04104000
*        --------------                                                 04105000
*                                                                       04106000
*        (R0,R1,R2,R3)            SCRATCH                               04107000
*        (R4)                     POINTER TO FREE STORAGE FOR BLOCKS    04108000
*        (R5)                     OPERATOR STACK                        04109000
*        (R6)                     POINTER STACK                         04110000
*                                                                       04111000
*        USE OF STACKS                                                  04112000
*        -------------                                                  04113000
*                                                                       04114000
*        THE FREE STACK IS USED TO BUILD ACTUAL BLOCKS                  04115000
*        (R4) IS UPDATED BETWEEN CALLS TO PRESERVE ANY BLOCKS FORMED    04116000
*                                                                       04117000
*        THE OPERATOR STACK CONTAINS OPERATOR DOPE VECTOR POINTERS      04118000
*        (WHICH ALWAYS BEGIN WITH A HEX 00)                             04119000
*        AND STACK LIDS -- WHICH BEGIN WITH A BYTE CONTAINING AN        04120000
*        INTEGER FROM 1-4 DEPENDING ON THE USAGE                        04121000
*                                                                       04122000
*        1                        STANDARD LID ON END OF STACK          04123000
*        2                        NORMAL ( LID                          04124000
*        3                        LID AFTER < OR , FOLLOWING <          04125000
*        4                        LID FOR ( OR , IN FUNCTION CALL       04126000
*                                                                       04127000
*        SIMPLE COMPARISON OF PRECEDENCES IS USED IN BUILDING THIS      04128000
*        STACK -- LOW PRECEDENCE OPERATORS DUMP HIGHER PRECEDENCE       04129000
*        OPERATORS FROM THE TOP OF THE STACK UP TO A STACK LID          04130000
*                                                                       04131000
*                                                                       04132000
*        THE POINTER STACK CONTAINS POINTERS TO OPERANDS AND            04133000
*        SUBEXPRESSIONS AS THE EXPRESSION IS BUILT UP                   04134000
         EJECT                                                          04135000
*                                                                       04136000
*        THE EXPRESSION ANALYSIS IS CONTROLED BY A FINITE STATE         04137000
*        TRANSITION TABLE WITH THE FOLLOWING STRUCTURE                  04138000
*                                                                       04139000
*        ELEMENT       STATE 0,2            STATE 1                     04140000
*        -------       ---------            -------                     04141000
*                                                                       04142000
*        VARIABLE      SETUP VAR BLOCK      GENERATE CONCATENATION      04143000
*                      PUT PTR ON PTR STK   RESCAN -- S=>2              04144000
*                      S=>1                                             04145000
*                                                                       04146000
*        CONSTANT      SETUP CON BLOCK      GENERATE CONCATENATION      04147000
*                      PUT PTR ON PTR STK   RESCAN -- S=>2              04148000
*                      S=>1                                             04149000
*                                                                       04150000
*        UNOP          PUT OP ON OP STK     GENERATE CONCATENATION      04151000
*                      (DUMP OFF OPS)       RESCAN -- S=>2              04152000
*                      S=>2                                             04153000
*                                                                       04154000
*        BINOP         ERROR                PUT OP ON OP STK            04155000
*                                           S=>2                        04156000
*                                                                       04157000
*        TRM : =       S2=>ERROR            DUMP 1 LEVEL OPTRS          04158000
*                      S0=>GENERATE NULL    LID=1  TERMINATE            04159000
*                          TREAT LIKE S=1   LID=2-4  ERROR              04160000
*                                                                       04161000
*        (             SET LID=2 ON OP STK  GENERATE CONCATENATION      04162000
*                      S=>0                 RESCAN -- STATE=>2          04163000
*                                                                       04164000
*        <             ERROR                GEN ARRAY BLOCK             04165000
*                                           PUT ON PTR STACK            04166000
*                                           SET LID=3(ARRAY BLK PTR)    04167000
*                                           S=>0                        04168000
*                                                                       04169000
*        FUNCTION      GEN FUNC BLOCK       GENERATE CONCATENATION      04170000
*                      PUT ON PTR STACK     RESCAN -- S=>2              04171000
*                      SET LID=5(FUNC BLK)                              04172000
*                      S=>0                                             04173000
         EJECT                                                          04174000
*        ELEMENT       STATE 0,2            STATE 1                     04175000
*        -------       ---------            -------                     04176000
*                                                                       04177000
*        ,             S2=>ERROR            DUMP 1 LEVEL OPERATORS      04178000
*                      S0=>GENERATE NULL    LID=0,1  ERROR              04179000
*                          TREAT LIKE S=1   LID=3 GEN SUBSCR BLK        04180000
*                                             SET PTR IN PREVIOUS BLK   04181000
*                                             SET LID=3(SUBSCR BLK)     04182000
*                                           LID=4  GEN ARG BLOCK        04183000
*                                             SET PTR IN PREVIOUS BLK   04184000
*                                             SET LID=4(ARG BLK)        04185000
*                                           S=>0 FOR ALL OF ABOVE       04186000
*                                                                       04187000
*        )             S2=>ERROR            DUMP 1 LEVEL OPERATORS      04188000
*                      S0=>GENERATE NULL    LID=1  TERMINATE IF CC=0    04189000
*                          TREAT LIKE S=1     ELSE ERROR IF CC#0        04190000
*                                           LID=2  OK, REMOVE LID S=>1  04191000
*                                           LID=3  ERROR                04192000
*                                           LID=4  GEN ARG BLOCK        04193000
*                                             SET PTR FROM PREVIOUS BLK 04194000
*                                             REMOVE LID S=>1           04195000
*                                                                       04196000
*        >             S2=>ERROR            DUMP 1 LEVEL OPERATORS      04197000
*                      S0=>GENERATE NULL    LID=1  TERMINATE IF CC=0    04198000
*                         TREAT LIKE S=1      ELSE ERROR IF CC#0        04199000
*                                           LID=2  ERROR                04200000
*                                           LID=3  GEN LAST SUBSCR BLK  04201000
*                                             SET PTR FROM PREVIOUS BLK 04202000
*                                             REMOVE LID S=>1           04203000
*                                           LID=4  ERROR                04204000
*                                                                       04205000
*        IN THE ABOVE TABLE THE NOTATION LID=N(DATA) MEANS THAT THE     04206000
*        INDICATED DATA IS STORED IN THE LOW ORDER THREE BYTES OF THE   04207000
*        STACK LID, THE UPPER BYTE IS THE LID CODE.                     04208000
*                                                                       04209000
*        DUMP 1 LEVEL OPERATORS MEANS THAT OPERATORS ARE DUMPED FROM    04210000
*        THE OPERATOR STACK (I.E. POPPED AND APPLIED), UNTIL A          04211000
*        STACK LID IS ENCOUNTERED, THE LID IS THEN REMOVED AND EXAMINED 04212000
         EJECT                                                          04213000
*                                                                       04214000
*        MAIN ENTRY POINT                                               04215000
*                                                                       04216000
EXPAN    ST    RF,EXPSAV          SAVE CALL REGISTER                    04217000
         MVI   EXPNUMBR+1,200     MAX ELEMENTS IN STATEMENT = 200       04218000
         MVI   STATE,0            SET INITIAL STATE OF ZERO             04219000
         LM    R4,R6,EXPINIT      INITIALIZE STACK POINTERS             04220000
         MVI   0(R5),1            SET OUTER STACK LID ON OPERATOR STACK 04221000
         LA    R5,4(R5)           COVER IT UP                           04222000
*                                                                       04223000
*        LOOP BACK HERE TO ANALYZE SUCCESSIVE ELEMENTS                  04224000
*                                                                       04225000
EXPANLP  STM   R4,R6,EXPSAV+4     SAVE CRITICAL REGS                    04226000
         BAL   RF,SCAN            CALL SCAN ROUTINE                     04227000
         LM    R4,R6,EXPSAV+4     RESTORE CRITICAL REGS                 04228000
         LH    R7,EXPNUMBR        LOAD COUNT OF ITEMS                   04229000
         BCT   R7,*+8             SKIP UNLESS TOO MANY ELEMENTS         04230000
         ERR   8                  *** EXPRESSION TOO COMPLEX ***        04231000
         STH   R7,EXPNUMBR        STORE AWAY COUNT                      04232000
         SR    R2,R2              CLEAR R2 FOR IC                       04233000
         IC    R2,SCANFL          PICK UP SYNTAX FLAG                   04234000
         B     *+4-EQL(R2)        TAKE CORRECT BRANCH IN TABLE          04235000
         B     EXPTERM            EQL       =                           04236000
         B     EXPTERM            GTO       :                           04237000
         B     EXPTERM            TRM       STATEMENT TERMINATOR        04238000
         B     EXPLBR             LBR       LEFT BRACKET                04239000
         B     EXPRBR             RBR       RIGHT BRACKET               04240000
         B     EXPLPR             LPR       LEFT PAREN                  04241000
         B     EXPRPR             RPR       RIGHT PAREN                 04242000
         B     EXPCMA             CMA       ,                           04243000
         B     EXPOPTR            OPR       OPERATOR                    04244000
         B     EXPFUNC            FNC       FUNCTION CALL               04245000
         B     EXPVAR             VAR       VARIABLE                    04246000
*                                 CON       CONSTANT                    04247000
         EJECT                                                          04248000
*                                                                       04249000
*        PROCESSING FOR CONSTANTS                                       04250000
*                                                                       04251000
         BAL   R7,EXPCNT          CHECK FOR CONCATENATION               04252000
         L     R0,SCANAD          PICK UP ADDRESS                       04253000
         ST    R0,0(,R4)          STORE ADDRESS IN BLOCK                04254000
         MVI   0(R4),OPNCN        SET FLAG FOR CONSTANT                 04255000
         B     EXPVAR1            MERGE WITH VARIABLE PROCESSING        04256000
*                                                                       04257000
*        PROCESSING FOR VARIABLES                                       04258000
*                                                                       04259000
EXPVAR   BAL   R7,EXPCNT          CHECK FOR CONCATENATION               04260000
         L     R1,SCANAD          LOAD ADDRESS                          04261000
         ST    R1,0(,R4)          STORE ADDRESS IN BLOCK                04262000
         TM    VFLAGS(R1),VINP    IS INPUT ASSOCIATION POSSIBLE?        04263000
         BNO   *+8                SKIP IF NOT                           04264000
         OI    0(R4),READV        SET FLAG IF SO                        04265000
         TM    VFLAGS(R1),VOUP    IS OUTPUT ASSOCIATION POSSIBLE?       04266000
         BNO   *+8                SKIP IF NOT                           04267000
         OI    0(R4),WRITEV       IF SO, SET FLAG                       04268000
         OI    0(R4),OPNNM        ADD FLAG FOR VARIABLE                 04269000
*                                                                       04270000
*        HERE CHECK FOR VARIABLE CONTAINING POTENTIAL CONSTANT PATTERN  04271000
*                                                                       04272000
         CLI   OPTFLAG,0          ARE WE OPTIMIZING?                    04273000
         BZ    EXPVAR1            SKIP IF NOT                           04274000
         CLI   VALUE(R1),PCODE    ELSE DOES VARIABLE CONTAIN A PATTERN? 04275000
         BNE   EXPVAR1            SKIP IF NOT                           04276000
         OI    0(R4),OPNCN        ELSE SET FLAG FOR CONSTANT            04277000
*                                                                       04278000
*        REENTER HERE FOR CONSTANT                                      04279000
*                                                                       04280000
EXPVAR1  ST    R4,0(R6)           STORE BLOCK ADDRESS ON PTR STACK      04281000
         LA    R4,4(R4)           BUMP BLOCK POINTER                    04282000
         LA    R6,4(R6)           BUMP PTR STACK POINTER                04283000
         MVI   STATE,1            MAKE STATE TRANSITION                 04284000
         B     EXPANLP            AND GO BACK FOR NEXT ELEMENT          04285000
*                                                                       04286000
*        HERE FOR BINARY OPERATOR                                       04287000
*                                                                       04288000
EXPBNOP  CLI   STATE,1            CHECK STATE                           04289000
         BE    EXPDUMP            SKIP TO ENTER OP IF STATE OK (S=1)    04290000
         ERR   1                  *** MISSING OPERAND ***               04291000
*                                                                       04292000
*        PROCESSING FOR OPERATOR                                        04293000
*                                                                       04294000
EXPOPTR  L     RE,SCANAD          PICK UP OPERATOR DV ADDRESS           04295000
         TM    1(RE),BNOP         TEST FOR BINARY OPERATOR              04296000
         BO    EXPBNOP            SKIP IF BINARY                        04297000
         BAL   R7,EXPCNT          ELSE TEST FOR POSSIBLE CONCATENATION  04298000
*                                 MERGE WITH EXPDUMP IF STATE NE 1      04299000
         EJECT                                                          04300000
*                                                                       04301000
*        SECTION TO ENTER OPERATOR ON STACK                             04302000
*                                                                       04303000
*        (RE)                     POINTER TO DV OF ENTERING OPERATOR    04304000
*                                                                       04305000
EXPDUMP  MVI   STATE,2            SET NEW STATE                         04306000
*                                                                       04307000
*        LOOP TO DUMP OPERATORS                                         04308000
*                                                                       04309000
EXPDUMPL SH    R5,=H'4'           UNCOVER TOP OPTR ON STACK             04310000
         CLI   0(R5),0            CHECK FOR STACK LID                   04311000
         BE    EXPDUMP3           SKIP IF NOT                           04312000
*                                                                       04313000
*        COME HERE TO PUT OPERATOR ON OPERATOR STACK                    04314000
*                                                                       04315000
EXPDUMP2 ST    RE,4(,R5)          PUT ENTERING OPTR ON STACK            04316000
         LA    R5,8(R5)           BUMP STACK POINTER                    04317000
         B     EXPANLP            BACK FOR NEXT ELEMENT                 04318000
*                                                                       04319000
*        COME HERE IF OPERATOR STACK IS NOT EMPTY (NOT AGAINST LID)     04320000
*                                                                       04321000
EXPDUMP3 L     R2,0(R5)           DOPE VECTOR OF STACK OPERATOR         04322000
         CLC   0(1,RE),0(R2)      COMPARE PRECEDENCES                   04323000
         BH    EXPDUMP2           SKIP IF ENTERING OP HIGHER            04324000
         BL    EXPDUMP4           FORCE STACK OPTR OFF IF ENTER OP LOWR 04325000
         TM    1(R2),RASS         ON EQUAL PRECEDENCE -- CHECK ASSOC    04326000
         BNZ   EXPDUMP2           RIGHT ASS => PUT ENTER OP ON STACK    04327000
*                                                                       04328000
*        COME HERE TO DUMP TOP OPERATOR ON OPERATOR STACK               04329000
*                                                                       04330000
EXPDUMP4 BAL   R7,EXPDMPO         DUMP OFF TOP OPERATOR ON STACK        04331000
         B     EXPDUMPL           BACK TO TEST NEXT STACK ENTRY         04332000
         EJECT                                                          04333000
*                                                                       04334000
*        PROCESSING AT END OF EXPRESSION                                04335000
*                                                                       04336000
EXPTERM  BAL   RF,NULCHK          SUPPLY NULL IF IN STATE 0             04337000
         ERR   1                  *** MISSING OPERAND (S=2)             04338000
*                                                                       04339000
*        COME HERE FOR NORMAL S=1 CASE (OPERATOR STRIP ALREADY DONE)    04340000
*                                                                       04341000
         CLI   0(R5),1            DO WE END UP AT SUPER LID             04342000
         BE    EXPTERM5           SKIP IF SO (ALL OK)                   04343000
         ERR   2                  *** UNBALANCED () OR <> ***           04344000
*                                                                       04345000
*        MERGE HERE WHEN EXPRESSION IS TERMINATED BY EXTRA RIGHT PAREN  04346000
*                                                                       04347000
EXPTERM5 SH    R6,=H'4'           ENTRY ON PTR STACK IS RESULT          04348000
         L     R3,0(R6)           LOAD IT INTO RESULT REGISTER          04349000
*                                                                       04350000
*        COMMON EXIT POINT                                              04351000
*                                                                       04352000
EXPLEAVE ST    R4,EXPINIT         SAVE UPDATED BLOCK AREA POINTER       04353000
         L     RF,EXPSAV          RESTORE LINK REGISTER                 04354000
         BR    RF                 AND RETURN                            04355000
         EJECT                                                          04356000
*                                                                       04357000
*        PROCESSING FOR LEFT PARENTHESIS                                04358000
*                                                                       04359000
EXPLPR   BAL   R7,EXPCNT          CHECK FOR POSSIBLE CONCATENATION      04360000
         MVI   0(R5),2            SET LID=2                             04361000
         LA    R5,4(R5)           BUMP OPTR STACK POINTER               04362000
         MVI   STATE,0            SET NEW STATE                         04363000
         B     EXPANLP            BACK FOR NEXT ELEMENT                 04364000
*                                                                       04365000
*        PROCESSING FOR LEFT BRACKET (ARRAY REFERENCE)                  04366000
*                                                                       04367000
EXPLBR   CLI   STATE,1            CHECK STATE                           04368000
         BE    *+8                SKIP IF OK (STATE=1)                  04369000
         ERR   3                  *** ILLEGAL USE OF < ***              04370000
         SH    R6,=H'4'           PICK UP ARRAY POINTER FROM PTR STACK  04371000
         L     R0,0(R6)                     INTO R0                     04372000
         ST    R4,0(R6)           STORE ARRAY BLOCK POINTER ON PTR STAK 04373000
         LA    R6,4(R6)           BUMP PTR STACK POINTER                04374000
         ST    R0,0(R4)           STORE ARRAY POINTER IN ARRAY BLOCK    04375000
         MVI   0(R4),ARRAYFLG     SET CODE FOR ARRAY BLOCK              04376000
         ST    R4,0(R5)           SET ARRAY BLOCK ADR ONTO OPTR STACK   04377000
         MVI   0(R5),3            ADD CODE FOR LID=3                    04378000
         LA    R4,8(R4)           BUMP BLOCK AREA POINTER OVER ARRAY BL 04379000
         LA    R5,4(R5)           BUMP OPTR STACK POINTER               04380000
         MVI   STATE,0            SET NEW STATE                         04381000
         B     EXPANLP            BACK FOR NEXT ELEMENT                 04382000
*                                                                       04383000
*        PROCESSING FOR FUNCTION CALL                                   04384000
*                                                                       04385000
EXPFUNC  BAL   R7,EXPCNT          CHECK FOR POSSIBLE CONCATENATION      04386000
         ST    R4,0(R6)           SET ADDRESS OF FUNC BLOCK ON PTR STK  04387000
         LA    R6,4(R6)           BUMP PTR STACK POINTER                04388000
         L     R1,SCANAD          GET FUNCTION VARIABLE BLOCK ADDRESS   04389000
         ST    R1,0(,R4)          STORE ADDRESS IN FUNCTION BLOCK       04390000
         MVI   0(R4),FUNCT        SET CODE FOR FUNCTION                 04391000
         STE   ZR,4(R4)           ZERO ARG POINTER IN CASE NO ARGS      04392000
         ST    R4,0(R5)           STORE FUNC ADDRESS ON OPTR STACK      04393000
         MVI   0(R5),4            SUPPLY CODE FOR TYPE 4 LID (FUNC ARG) 04394000
         LA    R5,4(R5)           BUMP PTR OVER LID                     04395000
         LA    R4,8(R4)           BUMP POINTER OVER FUNCTION BLOCK      04396000
         MVI   STATE,0            SET NEW STATE                         04397000
         B     EXPANLP            BACK FOR NEXT ELEMENT                 04398000
         EJECT                                                          04399000
*                                                                       04400000
*        PROCESSING FOR COMMA                                           04401000
*                                                                       04402000
EXPCMA   BAL   RF,NULCHK          CHECK FOR STATE=0, DO STRIP           04403000
         ERR   4                  *** ILLEGAL USE OF , *** (S=0)        04404000
         CLI   0(R5),2            IF STATE OK, TEST LID                 04405000
         BNH   *-8                GIVE ERROR IF LID=1 OR 2              04406000
         SH    R6,=H'4'           UNCOVER SUBSCRIPT OR ARGUMENT POINTER 04407000
         L     R0,0(,R6)          PICK IT UP                            04408000
         ST    R0,0(,R4)          PUT POINTER IN NEW ARG/SUBSCR BLOCK   04409000
         STE   ZR,4(R4)           CLEAR NEXT POINTER (IN CASE LAST)     04410000
         L     R1,0(R5)           PICK UP POINTER TO PREVIOUS BLOCK     04411000
         ST    R4,4(R1)           LINK TO CURRENT BLOCK                 04412000
         IC    R0,0(,R5)          SAVE LID CODE                         04413000
         ST    R4,0(R5)           STORE CURRENT BLOCK POINTER IN LID    04414000
         STC   R0,0(,R5)          SET CORRECT LID CODE                  04415000
         LA    R5,4(R5)           BUMP OPTR STACK POINTER               04416000
         LA    R4,8(R4)           BUMP BLOCK POINTER                    04417000
         MVI   STATE,0            SET NEW STATE                         04418000
         B     EXPANLP            JUMP TO PROCESS NEXT ITEM             04419000
*                                                                       04420000
*        PROCESSING FOR RIGHT PARENTHESIS                               04421000
*                                                                       04422000
EXPRPR   BAL   RF,NULCHK          CHECK FOR S=0, DO STRIP               04423000
         ERR   5                  *** ILLEGAL USE OF ) *** (S=2)        04424000
         CLI   0(R5),2            CHECK LID CODE                        04425000
         BNL   EXPRPR1            SKIP IF LID = 2 OR HIGHER             04426000
*                                                                       04427000
*        HERE FOR ) OR > STRIPPING LID WITH CODE=1 (SUPER LID)          04428000
*        WE TERMINATE IF THIS IS A GOTO FIELD (CALLING CC = 0)          04429000
*        ELSE THIS IS AN EXTRA UNBALANCED ) OR > AND WE GIVE AN ERROR   04430000
*                                                                       04431000
EXPRPRM  TM    EXPSAV,X'30'       TEST CALLING CONDITION CODE           04432000
         BZ    EXPTERM5           IF CC=0, THEN TERMINATE ON EXTRA )    04433000
         ERR   2                  *** UNBALANCED () OR <> ***           04434000
*                                                                       04435000
*        HERE FOR RIGHT PAREN, LID CODE > 1                             04436000
*                                                                       04437000
EXPRPR1  BE    EXPANLP            ALL SET IF STANDARD ( LID REMOVED     04438000
         CLI   0(R5),4            FURTHER CHECK ON LID CODE             04439000
         BL    EXPRPR+4           GIVE ERROR IF LID=3, ELSE MERGE       04440000
*                                                                       04441000
*        COME HERE FOR ) COMPLETING FUNCTION AND > COMPLETING ARRAY     04442000
*                                                                       04443000
EXPRPR5  SH    R6,=H'4'           GET TOP ENTRY ON PTR STACK (ARG)      04444000
         L     R0,0(R6)           PICK IT UP                            04445000
         ST    R0,0(,R4)          STORE IN NEW ARG BLOCK                04446000
         STE   ZR,4(R4)           ZERO OUT LINK POINTER                 04447000
         L     R1,0(R5)           LID HAS POINTER TO PREVIOUS BLOCK     04448000
         ST    R4,4(R1)           LINK TO CURRENT BLOCK                 04449000
         LA    R4,8(R4)           BUMP PAST NEW ARGUMENT BLOCK          04450000
         LA    RF,EXPANLP         SET EXIT ADDRESS FOR NEXT ELEMENT     04451000
         CLI   SCANFL,RPR         WAS THAT A FUNCTION?                  04452000
         BCR   NE,RF              NO, ARRAY, BACK FOR NEXT ITEM         04453000
         EJECT                                                          04454000
*                                                                       04455000
*        HERE WE CHECK FOR A CONSTANT FUNCTION CALL                     04456000
*                                                                       04457000
         CLI   OPTFLAG,0          FIRST CHECK FOR OPTIMIZATION          04458000
         BCR   Z,RF               NOT CONSTANT IF NO OPTIMIZATION       04459000
         LR    R1,R6              ELSE COPY OPERAND STACK POINTER       04460000
         SH    R1,=H'4'           UNCOVER POINTER TO FUNCTION BLOCK     04461000
         L     R2,0(,R1)          LOAD IT                               04462000
         L     R3,0(,R2)          LOAD POINTER TO FUNCTION NAME BLOCK   04463000
         L     R3,VDVPTR(,R3)     LOAD POSSIBLE OPERATOR DV POINTER     04464000
         LTR   R3,R3              TEST TO SEE IF THERE IS A DV POINTER  04465000
         BCR   Z,RF               IF NOT, EXIT (NOT CONSTANT)           04466000
         TM    1(R3),PREDF        IS IT A PREDICATE OPERATOR?           04467000
         BO    EXPRPR6            JUMP IF PREDICATE FUNCTION            04468000
         L     R3,4(,R2)          LOAD POINTER TO FIRST ARGUMENT BLOCK  04469000
         LR    R1,R2              COPY PTR TO ORIGINAL FUNCTION BLK     04470000
         OI    0(R1),OPNCN        TURN ON CONSTANT FLAG IN CASE         04471000
*                                                                       04472000
*        HERE IS A LOOP TO CHECK IF THE ARGUMENTS ARE ALL CONSTANT      04473000
*                                                                       04474000
EXPARGLP LTR   R3,R3              TEST FOR ALL ARGUMENTS CHECKED        04475000
         BCR   Z,RF               IF SO, RETURN (IT IS CONSTANT)        04476000
         LM    R2,R3,0(R3)        ELSE LOAD ARG PTR, POINT TO NEXT ARG  04477000
         TM    0(R2),OPNCN        IS THI ARGUMENT CONSTANT?             04478000
         BO    EXPARGLP           LOOP BACK TO CHECK NEXT IF SO         04479000
         NI    0(R1),X'FF'-OPNCN  ELSE TURN OFF CONSTANT FLAG           04480000
         BR    RF                 AND RETURN (NOT CONSTANT)             04481000
*                                                                       04482000
*        HERE FOR PREDICATE FUNCTION (NOT CONSTANT, BUT FLAG OCCURENCE) 04483000
*                                                                       04484000
EXPRPR6  MVI   PREDFUNC,1         SIGNAL PREDICATE FUNCTION OCCURED     04485000
         BR    RF                 RETURN TO CALLER (NOT CONSTANT)       04486000
*                                                                       04487000
*        PROCESSING FOR RIGHT BRACKET                                   04488000
*                                                                       04489000
EXPRBR   BAL   RF,NULCHK          CHECK FOR S=0, STRIP ONE LEVEL        04490000
         ERR   6                  *** ILLEGAL USE OF > ***              04491000
         CLI   0(R5),3            IF S=1, CHECK FOR TYPE 3 LID          04492000
         BE    EXPRPR5            MERGE WITH FUNCTION END CODE IF SO    04493000
         CLI   0(R5),1            ELSE TEST FOR LID CODE = 1            04494000
         BE    EXPRPRM            MERGE WITH ) PROCESSING IF SO         04495000
         B     EXPRBR+4           ELSE GIVE ERROR                       04496000
         EJECT                                                          04497000
*                                                                       04498000
*        CIRCUIT TO DUMP ONE LEVEL OF OPERATORS (UP TO A STACK LID)     04499000
*                                                                       04500000
*        NOTE THAT (RE) MUST NOT BE USED IN THIS ROUTINE SINCE          04501000
*        IT MAY CONTAIN AN OPERATOR DOPE VECTOR ADDRESS                 04502000
*                                                                       04503000
EXPSTRIP SH    R5,=H'4'           UNCOVER NEXT ENTRY                    04504000
         CLI   0(R5),0            IS IT A STACK LID                     04505000
         BCR   7,RF               ALL DONE IF YES                       04506000
         BAL   R7,EXPDMPO         ELSE DUMP OPERATOR                    04507000
         B     EXPSTRIP           AND KEEP GOING                        04508000
*                                                                       04509000
*        COME HERE (BAL R7,EXPDMPO) TO DUMP ONE OPERATOR OFF STACK      04510000
*                                                                       04511000
EXPDMPO  L     R2,0(R5)           PICK UP OPERATOR DOPE VECTOR POINTER  04512000
         ST    R2,0(R4)           STORE IN FIRST WORD OF OPERATOR BLOCK 04513000
         TM    1(R2),BNOP         CHECK FOR BINARY OPERATOR             04514000
         BO    EXPDMPO2           SKIP IF BINARY                        04515000
*                                                                       04516000
*        HERE TO DUMP A UNARY OPERATOR                                  04517000
*                                                                       04518000
         SH    R6,=H'4'           GET TOP PTR STACK ENTRY (OPERAND)     04519000
         L     R3,0(R6)           PUT IN (R3)                           04520000
         ST    R3,4(,R4)          STORE OPERAND POINTER                 04521000
         MVI   0(R4),OPTRU        SET UNARY OPERATOR CODE               04522000
         ST    R4,0(R6)           STORE OPTR BLOCK POINTER ON PTR STACK 04523000
         LA    R6,4(R6)           BUMP PTR STACK POINTER                04524000
         BAL   R3,UNOPCHK         JUMP TO CHECK FOR CONSTANT UNOP       04525000
         LA    R4,8(,R4)          BUMP POINTER PAST UNOP BLOCK          04526000
         BR    R7                 RETURN TO CALLER                      04527000
*                                                                       04528000
*        COME HERE FOR BINARY OPERATOR TO BE DUMPED                     04529000
*                                                                       04530000
EXPDMPO2 SH    R6,=H'8'           FOR BINOP UNCOVER TWO ELEMENTS ON PTR 04531000
         LM    R2,R3,0(R6)        STACK -- LEFT AND RIGHT ARGUMENTS     04532000
         STM   R2,R3,4(R4)        STORE LEFT/RIGHT ARG POINTERS         04533000
         MVI   0(R4),OPTRB        SET CODE FOR BINARY OPERATOR          04534000
         ST    R4,0(R6)           STORE BINOP BLOCK ADR ON PTR STACK    04535000
         LA    R6,4(,R6)          PUSH PTR STACK PTR                    04536000
         BAL   R3,BINOPCHK        CHECK FOR CONSTANT BINOP              04537000
         LA    R4,12(R4)          BUMP POINTER OVER BINOP BLOCK         04538000
         BR    R7                 RETURN TO CALLER                      04539000
         EJECT                                                          04540000
*                                                                       04541000
*        ROUTINE TO CHECK FOR CONSTANT BINOP                            04542000
*                                                                       04543000
*        A BINARY OPERATOR IS CONSTANT IN THE FOLLOWING CASES --        04544000
*                                                                       04545000
*        1)    THE OPERATOR IS $ OR . AND THE RIGHT ARGUMENT IS         04546000
*              A SIMPLE VARIABLE & THE LEFT ARG IS FLAGGED AS CONSTANT  04547000
*                                                                       04548000
*        2)    ANY OTHER OPERATOR WHERE BOTH THE LEFT AND RIGHT         04549000
*              ARGUMENTS ARE FLAGGED AS CONSTANT                        04550000
*                                                                       04551000
BINOPCHK L     R1,0(,R4)          LOAD POINTER TO OPERATOR DV           04552000
         LH    R0,2(,R1)          LOAD LAST TWO BYTES OF OPTR DV        04553000
         L     R1,8(,R4)          LOAD POINTER TO RIGHT ARGUMENT        04554000
         CH    R0,DLR2DV+2        BINARY $?                             04555000
         BE    BINOPCK0           SKIP IF SO                            04556000
         CH    R0,DOT2DV+2        BINARY . ?                            04557000
         BNE   BINOPCK1           SKIP IF NEITHER $ NOR .               04558000
*                                                                       04559000
*        HERE FOR SPECIAL $ . CASES                                     04560000
*                                                                       04561000
BINOPCK0 TM    0(R1),OPNNM        IS RIGHT ARG A SIMPLE VAR?            04562000
         BO    UNOPCHK            SKIP TEST OF RIGHT ARG IF SO          04563000
         BR    R3                 ELSE RESULT IS NOT CONSTANT           04564000
*                                                                       04565000
*        HERE FOR NORMAL BINOP, TEST RIGHT ARG                          04566000
*                                                                       04567000
BINOPCK1 TM    0(R1),OPNCN        IS RIGHT ARGUMENT CONSTANT?           04568000
         BCR   NO,R3              RETURN IF NOT (NOT CONSTANT)          04569000
         EJECT                                                          04570000
*                                                                       04571000
*        HERE TO CHECK FOR CONSTANT UNARY OPERATOR                      04572000
*                                                                       04573000
*        A UNARY OPERATOR IS CONSTANT IF ITS ARGUMENT IS FLAGGED        04574000
*        AS CONSTANT (BINOP MERGES TO TEST LEFT ARG)                    04575000
*        EXCEPT THAT PREDICATE OPERATORS ARE NEVER CONSTANT             04576000
*                                                                       04577000
*        HOWEVER, $ IS NEVER CONSTANT SINCE WE CANNOT TOLERATE THE      04578000
*        ALLOCATION OF AN ADDITIONAL 4K BLOCK DURING EVALUATION         04579000
*        OF CONSTANT EXPRESSIONS                                        04580000
*                                                                       04581000
*                                                                       04582000
*        A SPECIAL CASE ARISES WITH UNEVALUTED EXPRESSIONS (* OPTR)     04583000
*        IF THE ARGUMENT IS COMPLEX, THEN THE RESULT IS NEVER CONSTANT  04584000
*        SINCE THE EXPR CODE MUST BE GENERATED INLINE. HOWEVER, IF THE  04585000
*        ARGUMENT IS A SIMPLE VARIABLE. THEN THIS ROUTINE CONSTRUCTS    04586000
*        A SUITABLE VCODE BLOCK AND REPLACES THE UNOP * BLOCK WITH A    04587000
*        STANDARD CONSTANT BLOCK POINTING TO THE VCODE CONSTANT.        04588000
*                                                                       04589000
UNOPCHK  LM    R1,R2,0(R4)        LOAD DV PTR, LEFT(ONLY) OPND PTR      04590000
         LH    R0,2(,R1)          LOAD LAST 2 BYTES OF OPTR DV          04591000
         CH    R0,DLR1DV+2        IS IT UNARY $?                        04592000
         BCR   E,R3               IF SO, RETURN, NOT CONSTANT           04593000
         CH    R0,AST1DV+2        CHECK FOR UNARY * OPERATOR            04594000
         BNE   UNOPCHK1           SKIP IF NOT SPECIAL * CASE            04595000
         TM    0(R2),OPNNM        SIMPLE VARIABLE AS ARGUMENT?          04596000
         BCR   NO,R3              RETURN IF NOT (NOT CONSTANT)          04597000
         MVC   1(3,R4),1(R2)      ELSE SAVE PTR TO VARIABLE BLOCK       04598000
         BAL   R2,FIND8           LOCATE AN 8 BYTE CONSTANT BLOCK       04599000
         MVC   VALUE+1(3,R1),1(R4)          STORE VAR PTR IN BLOCK      04600000
         MVI   VALUE(R1),VCODE    SET PROPER TYPE CODE                  04601000
         ST    R1,0(,R4)          STORE PTR ON TOP OF * UNOP BLOCK      04602000
         MVI   0(R4),OPNCN        AND CHANGE TO NORMAL CONSTANT BLOCK   04603000
         BR    R3                 AND RETURN TO CALLER                  04604000
*                                                                       04605000
*        HERE FOR NORMAL UNOP CHECK                                     04606000
*                                                                       04607000
UNOPCHK1 TM    1(R1),PREDF        IS IT A PREDICATE OPERATOR?           04608000
         BO    UNOPCHK2           SKIP IF PREDICATE OPERATOR            04609000
         TM    2(R1),X'70'        CHECK FOR DEFINABLE OPERATOR          04610000
         BCR   Z,R3               IF SO, CANNOT BE CONSTANT             04611000
         TM    0(R2),OPNCN        ELSE IS LEFT(ONLY) OPERAND CONSTANT?  04612000
         BCR   NO,R3              RETURN IF NOT                         04613000
         OI    0(R4),OPNCN        ELSE WE PASSED TESTS, FLAG CONSTANT   04614000
         BR    R3                 RETURN TO CALLER                      04615000
*                                                                       04616000
*        HERE FOR PREDICATE OPERATOR (NOT CONSTANT, BUT FLAG OCCURENCE) 04617000
*                                                                       04618000
UNOPCHK2 MVI   PREDFUNC,1         SIGNAL PREDICATE OCCURENCE            04619000
         BR    R3                 RETURN TO UNOPCHK CALLER              04620000
         EJECT                                                          04621000
*                                                                       04622000
*        TEST FOR POSSIBLE CONCATENATION                                04623000
*                                                                       04624000
EXPCNT   CLI   STATE,1            TEST STATE                            04625000
         BCR   7,R7               NO CONCATENATION NEEDED IF S#1        04626000
         MVI   RESCAN,0           ELSE SET FOR RESCAN                   04627000
         TM    PATFLG,2           TEST FOR PATTERN MATCH POSSIBLE       04628000
         BZ    EXPCNT2            SKIP IF NOT                           04629000
         LR    R1,R5              GET OPTR STACK ADDRESS                04630000
*                                                                       04631000
*        SEARCH DOWN TO LID TO SEE IF THIS IS PATTERN MATCH             04632000
*                                                                       04633000
EXPCNT1  SH    R1,=H'4'           UNCOVER TOP ENTRY                     04634000
         CLI   0(R1),1            CHECK FOR OUTER LID                   04635000
         BL    EXPCNT1            KEEP GOING IF NOT AT LID              04636000
         BH    EXPCNT2            SKIP IF AT HIGHER TYPE LID            04637000
         LA    RE,PTVDV           ELSE SET FOR PATTERN BY VALUE         04638000
         MVI   PATFLG,1           RESET POSSIBLE FLAG AND SET OCCURED   04639000
         B     EXPCNT3            SKIP AND MERGE                        04640000
*                                                                       04641000
*        SKIP HERE IF NOT A PATTERN MATCH                               04642000
*                                                                       04643000
EXPCNT2  LA    RE,CNCDV           GET CONCATENATION OPERATOR DV         04644000
*                                                                       04645000
*        MERGE HERE TO MAKE SURE WE HAD THE BLANK FOR CONCATENATION     04646000
*                                                                       04647000
EXPCNT3  CLI   SCANCHR,C' '       WAS THERE A BLANK BEFORE THIS ELEMENT 04648000
         BE    EXPDUMP            GO PUT ON STACK IF SO, ALL OK         04649000
         ERR   7                  *** MISSING OPERATOR ***              04650000
*                                                                       04651000
*        HERE TO CHECK FOR STATE 0 (USED BY ) > , TRM)                  04652000
*                                                                       04653000
*        BAL   RF,NULCHK                                                04654000
*        -->   ERROR RETURN IF STATE=2                                  04655000
*        -->   NORMAL RETURN      STATE SET TO 1                        04656000
*                                 OPERATOR STRIP COMPLETED              04657000
*                                 NULL BLOCK BUILT IF WE WERE IN STATE0 04658000
*                                                                       04659000
NULCHK   CLI   STATE,1            CHECK STATE                           04660000
         BCR   H,RF               ERROR RETURN IF S=2                   04661000
         LA    RF,4(,RF)          ELSE FUDGE RETURN POINT FOR EXPSTRIP  04662000
         BE    EXPSTRIP           IF S=1, ALL SET, EXIT VIA STRIP ROUTN 04663000
*                                                                       04664000
*        FOR STATE 0, BUILD A NULL OPERAND BLOCK                        04665000
*                                                                       04666000
         LA    R0,NULBLK          POINT TO NULL BLOCK                   04667000
         ST    R0,0(,R6)          STORE PTR TO NULL ON OPERAND STACK    04668000
         LA    R6,4(,R6)          BUMP OPERAND STACK POINTER            04669000
         MVI   STATE,1            RESET STATE TO 1                      04670000
         B     EXPSTRIP           EXIT VIA OPERATOR STRIP ROUTINE       04671000
         TITLE 'SPITBOLC -- CODE GENERATOR'                             04672000
*                                                                       04673000
*        THIS ROUTINE IS CALLED TO GENERATE CODE -- GIVEN A STRUCTURE   04674000
*        OF AN EXPRESSION AS CONSTRUCTED BY THE EXPRESSION ANALYSIS     04675000
*        ROUTINE EXPAN WHICH CONTAINS DESCRIPTIONS OF THE DATA          04676000
*        STRUCTURES INVOLVED.                                           04677000
*                                                                       04678000
*        CODEGEN IS A RECURSIVE ROUTINE WHICH PROCESSES EXPRESSIONS     04679000
*        FROM THE OUTERMOST OPERATOR INWARDS, MAKING RECURSIVE CALLS    04680000
*        TO GENERATE CODE FOR THE OPERANDS.                             04681000
*                                                                       04682000
*        AT EACH LEVEL OF THE EXPRESSION, EITHER THE VALUE OR THE       04683000
*        NAME OF THE ARGUMENT MAY BE REQUIRED -- THUS IN A $ B,         04684000
*        THE VALUE OF A AND THE NAME OF B ARE REQUIRED                  04685000
*        CODEGEN HANDLES THE NECCESSARY TESTS FOR THESE TWO             04686000
*        POSSIBILITIES                                                  04687000
*                                                                       04688000
*        A SPECIAL PROCEDURE IS USED TO HANDLE CONSTANT SUBEXPRESSIONS  04689000
*        (MARKED WITH THE OPNCN FLAG BY EXPAN). THE FLAG CONGEN, RESET  04690000
*        ON ENTRY, IS SET ON ENCOUNTERING A CONSTANT EXPRESSION AND     04691000
*        THE CODE MOVED TO THE APPROPRIATE AREA FOLLOWED BY A STORE     04692000
*        INTO A BLOCK IN THE DATA AREA. THE CONGEN FLAG STOPS THIS TEST 04693000
*        FROM BEING APPLIED RECURSIVELY.                                04694000
*                                                                       04695000
*        CALLING SEQUENCE                                               04696000
*        ----------------                                               04697000
*        (R3)                     S ADDRESS OF FIRST AVAILABLE TEMP LOC 04698000
*        (R5)                     ADDRESS OF OUTER (TOP) ELEMENT BLOCK  04699000
*        CC ZERO                  VALUE IS REQUIRED                     04700000
*        CC NONZERO               NAME IS REQUIRED                      04701000
*        BAL   R4,CODEGEN         NOTE CALL IS ON R4 -- NOT RF          04702000
*        (R4,R5,R6,R7)            PRESERVED OVER CALL                   04703000
*                                                                       04704000
*        REGISTER USAGE                                                 04705000
*        --------------                                                 04706000
*                                                                       04707000
*        R0,R1                    SCRATCH                               04708000
*        R2                       PUSH DOWN POINTER FOR RECURSIVE CALLS 04709000
*        R3                       S ADDRESS OF NEXT TEMP LOC            04710000
*        R4                       REGISTER FOR INTERNAL CALLS           04711000
*        R5                       BLOCK CURRENTLY BEING WORKED ON       04712000
*        R6,R7                    SCRATCH                               04713000
*                                                                       04714000
*        (R4,R5,R6,R7)            ARE SAVED AT EACH RECURSIVE CALL      04715000
*                                 AT 8(R2) ON THE STACK                 04716000
*                                                                       04717000
*        THE 8 BYTES AT 0(R2) ARE AVAILABLE AS RECURSIVELY SAVED SCRTCH 04718000
*                                                                       04719000
*        THE FIRST BYTE (AT 0(R2) ) IS USED TO HOLD VARIOUS FLAGS --    04720000
*                                                                       04721000
CODBYVAL EQU   1                  FLAG FOR CODE BY VALUE                04722000
CODBYNAM EQU   2                  FLAG FOR CODE BY NAME                 04723000
ARAYCODE EQU   4                  FLAG FOR ARRAY CASE                   04724000
FUNCCODE EQU   8                  FLAG FOR FUNCTION CASE                04725000
CONSFLAG EQU   16                 FLAG FOR CONSTANT EXPRESSION          04726000
OPTRFUNC EQU   32                 CODE FOR OPERATOR TREATED AS FUNCTION 04727000
         EJECT                                                          04728000
*                                                                       04729000
*        MAIN ENTRY                                                     04730000
*                                                                       04731000
CODEGEN  L     R2,WRKSTKAD        INITIALIZE PUSH-DOWN TO WORK AREA     04732000
         NI    CONGEN,X'FF'-1     CLEAR CONSTANT EXPR FLAG              04733000
         SPM   R4                 RESTORE ENTRY CONDITION CODE          04734000
*                                                                       04735000
*        ENTRY POINT FOR INTERNAL CALL                                  04736000
*        (R5)                     BLOCK TO BE PROCESSED                 04737000
*        CC ZERO                  VALUE REQUIRED                        04738000
*        CC NONZERO               NAME REQUIRED                         04739000
*        BAL   R4,CODER                                                 04740000
*                                                                       04741000
CODER    BNZ   CODENAM            SKIP IF BY NAME                       04742000
*                                                                       04743000
*        ENTRY POINT FOR ONLY VALUE REQUIRED                            04744000
*                                                                       04745000
*        BAL   R4,CODEVAL                                               04746000
*                                                                       04747000
CODEVAL  TM    0(R5),COMPLEX      IS OPERAND SIMPLE?                    04748000
         BNZ   CODE1              SKIP IF NOT                           04749000
*                                                                       04750000
*        SIMPLE OPERAND BY VALUE, GENERATE ONE OF THE FOLLOWING:        04751000
*                                                                       04752000
*        LM    A1,A1+1,VAL.VAR                                          04753000
*                                                                       04754000
*        LA    A1,VAR             IF READ ASSOCIATION POSSIBLE          04755000
*        BAL   RETURN,$$READ                                            04756000
*                                                                       04757000
*        L     A1,$$NULL          FOR NULL OPERAND                      04758000
*                                                                       04759000
         CE    ZR,0(,R5)          CHECK FOR ZERO ADDR (=NULL)           04760000
         BZ    CODEVALN           SKIP IF SO (NULL)                     04761000
         L     R1,0(,R5)          LOAD OPERAND BLOCK ADDRESS            04762000
         CLC   1(3,R5),LASTOPN+1  OPERAND ALREADY LOADED?               04763000
         BCR   E,R4               GENERATE NO CODE IF SO, RETURN        04764000
         STE   ZR,LASTOPN         ELSE FORGET CONTENTS OF A1,A1+1       04765000
         TM    0(R5),OPNCN        IS OPERAND A CONSTANT?                04766000
         BNO   *+8                SKIP IF NOT                           04767000
         ST    R1,LASTOPN         ELSE REMEMBER VALUE IS LOADED         04768000
         LH    R0,LA1SR$          LOAD LA A1,*-* IN CASE IT IS READ VAR 04769000
         TM    0(R5),READV        TEST FOR READ VARIABLE                04770000
         BO    *+12               SKIP IF SO                            04771000
         LA    R1,VALUE(,R1)      POINT TO VALUE FIELD IF NOT READ ASS  04772000
         LH    R0,LMA1$           PICK UP LM A1,A1+1,*-*                04773000
         BAL   RF,CALCSAD         GET S ADDRESS                         04774000
         STH   R0,0(,LC)          GENERATE LM A1,A1+1,*-* OR LA A1,*-*  04775000
         STH   R1,2(,LC)          GENERATE S ADDRESS                    04776000
         LA    LC,4(,LC)          BUMP CODE POINTER                     04777000
         TM    0(R5),READV        WAS IT READ VAR                       04778000
         BCR   NO,R4              LEAVE IF NOT                          04779000
         MVC   0(4,LC),BALRD$     GENERATE BAL RETURN,$$READ            04780000
         LA    LC,4(LC)           UPDATE CODE POINTER                   04781000
         BR    R4                 LEAVE                                 04782000
         EJECT                                                          04783000
*                                                                       04784000
*        HERE FOR REFERENCE TO NULL                                     04785000
*                                                                       04786000
CODEVALN MVC   0(4,LC),LA1NUL$    GENERATE L A1,$$NULL                  04787000
         LA    LC,4(,LC)          BUMP POINTER                          04788000
         STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1            04789000
         BR    R4                 RETURN TO CALLER                      04790000
*                                                                       04791000
*        COMPLEX OPERAND BY VALUE                                       04792000
*                                                                       04793000
*        USED AS AN AUXILIARY ENTRY POINT WHEN CALLER KNOWS BLOCK       04794000
*        IS COMPLEX                                                     04795000
*                                                                       04796000
*        BAL   R4,CODE1                                                 04797000
*                                                                       04798000
CODE1    STM   R4,R7,8(R2)        SAVE REGISTERS                        04799000
         LA    R2,24(R2)          BUMP STACK POINTER                    04800000
         MVI   0(R2),CODBYVAL     SET CODE BY VALUE FLAG                04801000
*                                                                       04802000
*        NOW TEST FOR START OF A CONSTANT EXPRESSION                    04803000
*                                                                       04804000
         CLI   CONGEN,0           ARE WE ALREADY IN A CONSTANT EXPR?    04805000
         BNZ   CODE1C             SKIP IF SO (DON'T START A NEW ONE)    04806000
         TM    0(R5),OPNCN        IS THIS EXPRESSION CONSTANT?          04807000
         BNO   CODE1C             SKIP IF NOT                           04808000
*                                                                       04809000
*        HERE WE HAVE THE START OF A CONSTANT SUBEXPRESSION             04810000
*                                                                       04811000
         STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1            04812000
         MVI   0(R2),CONSFLAG     SET FLAG TO CATCH RETURN              04813000
         OI    CONGEN,1           SET FLAG TO INHIBIT RECURSIVE TEST    04814000
         ST    LC,CONCODAD        SAVE START OF CODE FOR EXPR           04815000
         ST    R3,CONSTAK         SAVE CURRENT TEMP STACK POINTER       04816000
         L     R3,TEMSTKBS        AND REINITIALIZE POINTER TO BOTTOM    04817000
         MVC   SOLDBASE,OLDBASE   SAVE CURRENT OLDBASE VALUE            04818000
         MVI   OLDBASE+1,0        AND FORGET CURRENT OLDBASE            04819000
*                                                                       04820000
*        MERGE HERE TO INSPECT TYPE OF EXPRESSION                       04821000
*                                                                       04822000
CODE1C   L     R6,0(,R5)          LOAD FIRST WORD OF BLOCK              04823000
         TM    0(R5),OPTRU        IS IT UNARY OPERATOR?                 04824000
         BO    CODEUN             SKIP IF YES                           04825000
         TM    0(R5),OPTRB        IS IT BINARY OPERATOR?                04826000
         BO    CODEBN             SKIP IF YES                           04827000
         TM    0(R5),FUNCT        IS IT A FUNCTION?                     04828000
         BO    CODEFN             SKIP IF YES                           04829000
*                                                                       04830000
*        ONLY POSSIBILITY LEFT IS ARRAY                                 04831000
*                                                                       04832000
         EJECT                                                          04833000
*                                                                       04834000
*        ARRAY BY VALUE OR NAME                                         04835000
*                                                                       04836000
*        CODE TO BE GENERATED                                           04837000
*                                                                       04838000
*        IF ONLY ONE SUBSCRIPT                                          04839000
*        LM    A1,A1+1,SUBSCRIPTVALUE                                   04840000
*        LM    A2,A2+1,ARRAYVALUE                                       04841000
*        BAL   RETURN,$$AR1V      ($$AR1N IF BY NAME)                   04842000
*                                                                       04843000
*        IF MORE THAN ONE SUBSCRIPT AND NO TEMP LOCS IN USE             04844000
*        (LOAD SUBSCRIPT VALUES ONTO STACK)                             04845000
*        LA    R0,NUMSUBSCRIPTS                                         04846000
*        BAL   RETURN,$$ARMV      ($$ARMN IF BY NAME)                   04847000
*                                                                       04848000
*        IF MORE THAN ONE SUBSCRIPT AND NTLOC (#0) TEMP LOCS IN USE     04849000
*        (LOAD SUBSCRIPT VALUES ONTO STACK)                             04850000
*        LA    R0,NUMSUBSCRIPTS                                         04851000
*        LA    R1,8*NTLOC                                               04852000
*        SR    PDR,R1                                                   04853000
*        BAL   RETURN,$$ARMV      ($$ARMN IF BY NAME)                   04854000
*                                                                       04855000
CODEAR   OI    0(R2),ARAYCODE     SET FLAG FOR ARRAY                    04856000
         LM    R6,R7,0(R5)        LOAD ARRAYVALPTR, SUBSCRIPT PTR       04857000
         CE    ZR,4(,R7)          TEST FOR ONLY ONE SUBSCRIPT           04858000
         BNZ   CODEFNA            JUMP IF MORE THAN ONE SUBSCRIPT       04859000
         TM    0(R6),COMPLEX+READV          TEST FOR ARRAY COMPLEX      04860000
         BNZ   CODEAR1            SKIP IF ARRAY COMPLEX                 04861000
         L     R5,0(R7)           PICK UP SUBSCRIPT BLOCK POINTER       04862000
         BAL   R4,CODEVAL         AND GENERATE CODE FOR IT BY VALUE     04863000
         LH    R0,LMA2$           PICK UP LM A2,A2+1,*-*                04864000
*                                                                       04865000
*        REENTER HERE FOR CASE OF COMPLEX ARRAY VALUE                   04866000
*                                                                       04867000
CODEAR0  L     R1,0(,R6)          LOAD BLOCK ADDRESS                    04868000
         LA    R1,VALUE(R1)       ADJUST TO POINT TO VALUE              04869000
         BAL   RF,CALCSAD         CONVERT TO S ADDRESS                  04870000
         STH   R0,0(,LC)          GENERATE LM                           04871000
         STH   R1,2(LC)           GENERATE S ADDRESS                    04872000
         LA    LC,4(LC)           UPDATE CODE POINTER                   04873000
         B     CODEAR2A           JUMP TO GENERATE CALL                 04874000
         EJECT                                                          04875000
*                                                                       04876000
*        ARRAY VALUE IS COMPLEX                                         04877000
*                                                                       04878000
CODEAR1  LR    R5,R6              POINTER TO ARRAY VALUE BLOCK          04879000
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE                04880000
         L     R6,0(R7)           PICK UP SUBSCRIPT POINTER             04881000
         TM    0(R6),COMPLEX+READV          IS SUBSCRIPT SIMPLE?        04882000
         BNZ   CODEAR2            SKIP IF NOT                           04883000
         MVC   0(4,LC),LRA2A1$    GENERATE LR A2,A1  LR A2+1,A1+1       04884000
         LA    LC,4(LC)           UPDATE CODE POINTER                   04885000
         LH    R0,LMA1$           PICK UP LM A1,A1+1,*-*                04886000
         B     CODEAR0            MERGE BACK TO GENERATE S ADDRESS      04887000
*                                                                       04888000
*        ARRAY WITH ONE SUBSCRIPT                                       04889000
*        ARRAY VALUE AND SUBSCRIPT COMPLEX                              04890000
*        ARRAY VALUE IS IN A1,A1+1                                      04891000
*                                                                       04892000
CODEAR2  LR    R5,R6              SUBSCRIPT POINTER                     04893000
         SH    R3,=H'8'           RESERVE A TEMPORARY LOCATION          04894000
         LH    R1,STMA1$          PICK UP STM A1,A1+1,                  04895000
         STH   R1,0(LC)           GENERATE IT                           04896000
         STH   R3,2(LC)           GENERATE TEMP LOC S ADDRESS           04897000
         LA    LC,4(LC)           UPDATE CODE POINTER                   04898000
         BAL   R4,CODEVAL         GENERATE CODE FOR SUBSCRIPT           04899000
         LH    R1,LMA2$           PICK UP LM A2,A2+1,                   04900000
         STH   R1,0(LC)           GENERATE (RELOAD ARRAYVAL FROM STACK) 04901000
         STH   R3,2(LC)           GENERATE STACK S ADDRESS              04902000
         LA    LC,4(LC)           UPDATE CODE POINTER                   04903000
         LA    R3,8(R3)           RELEASE TEMPORARY LOCATION ON STACK   04904000
*                                                                       04905000
*        MERGE HERE TO GENERATE CALL FOR SINGLE SUBSCRIPT CASE          04906000
*                                                                       04907000
CODEAR2A TM    0(R2),CODBYVAL     TEST FOR BY VALUE                     04908000
         MVC   0(4,LC),BALAV1$    PICK UP  BAL RETURN,$$AR1V            04909000
         BO    *+10               SKIP IF BY VALUE (ALL SET)            04910000
         MVC   0(4,LC),BALAN1$    ELSE GEN BAL RETURN,$$AR1N IF BY NAME 04911000
         LA    LC,4(LC)           UPDATE CODE POINTER                   04912000
         B     CODEDONE           ALL DONE -- LEAVE                     04913000
         EJECT                                                          04914000
*                                                                       04915000
*        ARRAY -- MULTIPLE SUBSCRIPT CASE -- REENTRY AFTER LOADING      04916000
*        SUBSCRIPTS -- SEE CODEFNA                                      04917000
*                                                                       04918000
CODEAR3  LR    R5,R6              ARRAY VALUE POINTER                   04919000
         LR    R6,R0              SUBSCRIPT COUNT (SAVE OVER CALL)      04920000
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE FOR ARRAYVAL   04921000
         LR    R3,R7              RESTORE OLD TEMP STACK S ADDRESS      04922000
         LH    R1,LAR0$           PICK UP LA,R0                         04923000
         STH   R1,0(LC)           GENERATE IT                           04924000
         STH   R6,2(LC)           GENERATE SUBSCR COUNT -- LA R0,NSUBS  04925000
         LA    LC,4(LC)           BUMP CODE POINTER PAST THE LA R0      04926000
         LCR   R0,R7              NEGATIVE OF ORIGINAL TEMP LOC S ADDR  04927000
         A     R0,TEMSTKBS        MINUS S ADDRESS FOR NO TEMPS IN USE   04928000
         BZ    CODEAR4            SKIP IF CASE OF NO TEMPS IN USE       04929000
         MVC   0(6,LC),ARM$       ELSE GENERATE THE MODEL CODE          04930000
         STH   R0,2(LC)           PLUG IN 8*NTLOC                       04931000
         LA    LC,6(LC)           UPDATE CODE POINTER AND MERGE         04932000
*                                                                       04933000
*        SKIP HERE IF NO TEMPORARY LOCATIONS WERE IN USE                04934000
*                                                                       04935000
CODEAR4  TM    0(R2),CODBYVAL     TEST FOR BY VALUE                     04936000
         MVC   0(4,LC),BALAV$     GENERATE BAL RETURN,$$ARMV            04937000
         BO    *+10               SKIP IF BY VALUE (ALL SET)            04938000
         MVC   0(4,LC),BALAN$     ELSE GEN BAL RETURN,$$ARMN IF BY NAME 04939000
         LA    LC,4(LC)           UPDATE CODE POINTER                   04940000
         B     CODEDONE           AND RETURN                            04941000
         EJECT                                                          04942000
*                                                                       04943000
*        FUNCTION CALL                                                  04944000
*                                                                       04945000
*                                                                       04946000
*        IF NO TEMPS IN USE BEFORE CALL                                 04947000
*        (LOAD ARGUMENTS ONTO TEMPORARY STACK)                          04948000
*        LA    R0,NUMARGS                                               04949000
*        L     DB4,FUNCTIONADDRESS                                      04950000
*        BAL   RETURN,FCODE(,DB4)                                       04951000
*       (B     $$FRVN             IF CALL BY NAME)                      04952000
*                                                                       04953000
*        IF NTLOC (#0) TEMPS IN USE BEFORE CALL                         04954000
*        (LOAD ARGUMENTS ONTO TEMPORARY STACK)                          04955000
*        LA    R0,NUMARGS                                               04956000
*        L     DB4,FUNCTIONADDRESS                                      04957000
*        LA    R1,8*NTLOC                                               04958000
*        SR    PDR,R1                                                   04959000
*        BAL   RETURN,FCODE(,DB4)                                       04960000
*       (B     $$FRVN             IF CALL BY NAME)                      04961000
*                                                                       04962000
CODEFN   BAL   RF,CODEFCHK        CHECK FOR OPERATOR (SYSTEM FUNC)      04963000
*                                                                       04964000
*        MERGE HERE FOR FUNCTION BY NAME                                04965000
*                                                                       04966000
CODEFNN  L     R6,0(,R5)          LOAD PTR TO VAR BLK FOR FUNCTION      04967000
         OI    0(R2),FUNCCODE     SET FLAG FOR FUNCTION                 04968000
*                                                                       04969000
*        MULTIPLE SUBSCRIPT ARRAY PROCESSING MERGES HERE                04970000
*        THE FOLLOWING SECTION IS USED TO LOAD PARAMS OR SUBSCRIPTS     04971000
*        ONTO THE STACK                                                 04972000
*                                                                       04973000
CODEFNA  STH   R3,2(,R2)          SAVE CURRENT TEMP LOC POINTER         04974000
         LR    R7,R5              ADJUST PTR TO PICK UP FIRST ARGUMENT  04975000
*                                                                       04976000
*        LOOP TO PROCESS ONE ARGUMENT AT A TIME                         04977000
*                                                                       04978000
CODEFNL  L     R7,4(R7)           MOVE TO NEXT ARGUMENT/SUBSCRIPT BLOCK 04979000
         LTR   R7,R7              ARE THERE ANY MORE?                   04980000
         BZ    CODEFN2            SKIP IF NO MORE                       04981000
         L     R5,0(R7)           PICK UP POINTER TO THIS ARG/SUB       04982000
         BAL   R1,CODTMPST        GENERATE STORE ON STACK               04983000
         B     CODEFNL            LOOP BACK FOR NEXT ARG/SUB            04984000
         EJECT                                                          04985000
*                                                                       04986000
*        COME HERE WHEN ALL ARG/SUBS PROCESSED (PUT ON TEPORARY STACK)  04987000
*                                                                       04988000
CODEFN2  LH    R7,2(,R2)          RETRIEVE ORIGINAL TEMP LOC S ADDRESS  04989000
         N     R7,=X'0000FFFF'    STRIP POSSIBLE GARBAGE SIGN BITS      04990000
         LR    R0,R7              COPY IT                               04991000
         SR    R0,R3              NUMBER OF BYTES USED ON TEMP STACK    04992000
         SRL   R0,3               DIVIDED BY 8 = NUMBER OF ARGS/SUBS    04993000
         TM    0(R2),FUNCCODE     TEST FOR FUNCTION CASE                04994000
         BNO   CODEAR3            SKIP IF NOT TO COMPLETE ARRAY PROC    04995000
         LR    R3,R7              RESTORE OLD TEMP LOC S ADDRESS        04996000
         LH    R1,LAR0$           PICK UP LA R0,                        04997000
         STH   R1,0(LC)           GENERATE LA 0,                        04998000
         STH   R0,2(LC)                         NUMARGS                 04999000
         LA    LC,4(,LC)          BUMP CODE POINTER                     05000000
         TM    0(R2),OPTRFUNC     OPERATOR TREATED AS FUNCTION?         05001000
         LH    R1,2(,R6)          LOAD POSS. FUNC ADDR FROM OPTR DV     05002000
         BO    CODEFN3            SKIP IF WE HAVE THE FUNC ADDRESS      05003000
         LA    R1,VFUNC(,R6)      ELSE POINT TO FUNC FLD OF VAR BLK     05004000
         MVI   OLDBASE+1,0        FORCE LOAD OF DB4 FOR FUNC IF NECC    05005000
         BAL   RF,CALCSAD         GET S ADDRESS                         05006000
*                                                                       05007000
*        NOW GENERATE THE L DB4,FUNC -- (R1) HAS THE S ADDR OF FUNC ADR 05008000
*                                                                       05009000
CODEFN3  LH    R0,LDB4$           PICK UP L  DB4,                       05010000
         STH   R0,0(,LC)          GENERATE L  DB4,                      05011000
         STH   R1,2(,LC)          COMPLETE GENERATION OF L  DB4,FUNCADR 05012000
         MVI   OLDBASE+1,0        FORGET DB4, WE JUST CLOBBERED IT      05013000
         LA    LC,4(,LC)          BUMP CODE POINTER                     05014000
         LCR   R0,R7              - ORIGINAL TEMP LOC S ADDRESS         05015000
         A     R0,TEMSTKBS        + BASE (NO TEMPS) S ADDRESS           05016000
         BZ    CODEFN4            SKIP IF ZERO (NO TEMPS IN USE)        05017000
         MVC   0(14,LC),FUNCM$    MOVE IN MODEL CODE FOR TEMPS IN USE   05018000
         STH   R0,2(LC)           PLUG IN 8*NTLOC                       05019000
         LA    LC,10(,LC)         BUMP PAST ALL BUT B $$FRVN            05020000
         B     CODEFN5            MERGE WITH NO TEMPS IN USE CASE       05021000
*                                                                       05022000
*        FINISH OFF IF NO TEMPS WERE IN USE                             05023000
*                                                                       05024000
CODEFN4  MVC   0(8,LC),BALFR2$    GENERATE BAL RETURN,FCODE(R2) B $$FRV 05025000
         LA    LC,4(LC)           UPDATE CODE POINTER                   05026000
*                                                                       05027000
*        TEMPS/NO TEMPS CASES MERGE TO GENERATE NAME CALL IF NEEDED     05028000
*                                                                       05029000
CODEFN5  TM    0(R2),CODBYNAM     CHECK FOR CODE BY NAME                05030000
         BNO   CODEDONE           ALL DONE IF BY VALUE, DELETE B $$FRVN 05031000
         LA    LC,4(LC)           ELSE BUMP LC TO KEEP B $$FRVN IF NAME 05032000
         B     CODEDONE           AND RETURN                            05033000
         EJECT                                                          05034000
*                                                                       05035000
*        COME HERE TO TEST FOR A FUNCTION CALL WHICH REFERENCES A       05036000
*        STANDARD SYSTEM FUNCTION FOR WHICH WE CAN COMPILE OPERATOR     05037000
*        TYPE CODE IF WE ARE IN OPTIMIZING MODE. RETURNS                05038000
*        ON (RF) IF ALL THE NECCESSARY CONDITIONS ARE NOT MET.          05039000
*                                                                       05040000
CODEFCHK CLI   OPTFLAG,0          ARE WE OPTIMIZING?                    05041000
         BCR   Z,RF               RETURN IF NOT                         05042000
         LM    R6,R7,0(R5)        LOAD FUNCTION PTR, FIRST ARG PTR      05043000
         L     R6,VDVPTR(,R6)     LOAD POSSIBLE OPERATOR DV PTR         05044000
         LTR   R6,R6              IS THERE ONE?                         05045000
         BCR   Z,RF               RETURN IF NOT                         05046000
         TM    1(R6),BNOP         ELSE TEST UNARY/BINARY                05047000
         BO    CODEFNB            SKIP IF BINARY OPERATOR               05048000
*                                                                       05049000
*        COME HERE IF OPERATOR IS UNARY                                 05050000
*                                                                       05051000
         CE    ZR,4(,R7)          IS THERE A SECOND ARGUMENT?           05052000
         BCR   NZ,RF              IF MORE THAN ONE ARG, USE NORMAL      05053000
         L     R5,0(,R7)          ELSE LOAD POINTER TO OPERAND          05054000
         B     CODEUNF            AND MERGE WITH UNOP PROCESSING        05055000
*                                                                       05056000
*        HERE IF OPERATOR IS BINARY                                     05057000
*                                                                       05058000
CODEFNB  L     R1,0(,R7)          SAVE POINTER TO FIRST ARG (LEFT OPND) 05059000
         L     R7,4(,R7)          POINT TO SECOND ARGUMENT BLOCK        05060000
         LTR   R7,R7              IS THERE A SECOND ARGUMENT?           05061000
         BZ    CODEFNNN           SKIP IF NOT                           05062000
         CE    ZR,4(,R7)          ELSE IS THERE A THIRD ARGUMENT?       05063000
         BCR   NZ,RF              IF > 2 ARGS, USE STANDARD CIRCUIT     05064000
         LR    R5,R1              ELSE RECALL POINTER TO LEFT OPND      05065000
         L     R7,0(,R7)          LOAD PTR FO 2ND ARG (RIGHT OPERAND)   05066000
         B     CODEBN1            MERGE WITH BINOP PROCESSING           05067000
*                                                                       05068000
*        HERE FOR BINOP WITH ONLY ONE ARGUMENT                          05069000
*                                                                       05070000
CODEFNNN LR    R5,R1              RECALL POINTER TO LEFT OPERAND        05071000
         LA    R7,NULBLK          SET NULL AS RIGHT OPERAND             05072000
         B     CODEBN1            MERGE WITH BINOP PROCESSING           05073000
*                                                                       05074000
*        SUBROUTINE TO STORE VALUE ON TEMPORARY STACK, CALLED ON (R1)   05075000
*                                                                       05076000
CODTMPST ST    R1,4(,R2)          SAVE LINKAGE                          05077000
         CE    ZR,0(,R5)          IS ARGUMENT NULL?                     05078000
         LH    R1,MVNCD$          GET MVI *-*,NCODE IN CASE             05079000
         BE    *+12               SKIP IF ARGUMENT NULL (MVI *-*,NCODE) 05080000
         BAL   R4,CODEVAL         ELSE GENERATE CODE FOR ARGUMENT       05081000
         LH    R1,STMA1$          AND LOAD STM A1,A1+1,*-*              05082000
         STH   R1,0(,LC)          GENERATE MVI OR STM                   05083000
         SH    R3,=H'8'           RESERVE A TEMPORARY LOCATION          05084000
         STH   R3,2(,LC)          GENERATE TEMP STACK S ADDRESS         05085000
         LA    LC,4(,LC)          BUMP CODE POINTER                     05086000
         L     R1,4(,R2)          LOAD RETURN LINKAGE                   05087000
         BR    R1                 RETURN TO CALLER                      05088000
         EJECT                                                          05089000
*                                                                       05090000
*        ENTRY FOR CALL TO CODE BY NAME                                 05091000
*                                                                       05092000
CODENAM  TM    0(R5),OPNNM        IS OPERAND A SIMPLE VARIABLE?         05093000
         BNO   CODEN1             SKIP IF NOT                           05094000
*                                                                       05095000
*        SIMPLE OPERAND BY NAME                                         05096000
*        LA    A1,ADDRESS                                               05097000
*        SR    A1+1,A1+1                                                05098000
*                                                                       05099000
         L     R1,0(,R5)          LOAD ADDRESS OF BLOCK                 05100000
         BAL   RF,CALCSAD         CALCULATE S ADDRESS                   05101000
         MVC   0(6,LC),LA1SR$     GENERATE LA A1,*-* SR A1+1,A1+1       05102000
         STH   R1,2(,LC)          GENERATE S ADDRESS                    05103000
         LA    LC,6(,LC)          BUMP CODE POINTER                     05104000
         BR    R4                 RETURN                                05105000
*                                                                       05106000
*        COMPLEX OPERAND BY NAME (NOTE: CAN NEVER BE A CONSTANT EXPR)   05107000
*                                                                       05108000
CODEN1   STM   R4,R7,8(R2)        SAVE REGISTERS                        05109000
         LA    R2,24(R2)          BUMP CALL STACK POINTER               05110000
         MVI   0(R2),CODBYNAM     SET CODE BY NAME FLAG                 05111000
         TM    0(R5),OPTRU        TEST FOR UNARY OPERATOR               05112000
         BO    CODENUN            SKIP IF YES                           05113000
         TM    0(R5),OPTRB        TEST FOR BINARY OPERATOR              05114000
         BO    CODENBN            SKIP IF YES                           05115000
         TM    0(R5),ARRAYFLG     TEST FOR ARRAY                        05116000
         BO    CODEAR             SKIP IF ARRAY                         05117000
         TM    0(R5),FUNCT        TEST FOR FUNCTION                     05118000
         BO    CODEFNN            SKIP IF FUNCTION                      05119000
*                                                                       05120000
*        COME HERE FOR VALUE WHERE NAME IS REQUIRED                     05121000
*        GENERATE CALL TO CLOBBER HIM AT XEQ TIME                       05122000
*                                                                       05123000
CODENMER MVC   0(4,LC),BNMVL$     GENERATE BAL  RETURN,$$NMVL           05124000
         LA    LC,4(,LC)          BUMP PAST IT                          05125000
         B     CODEDONE           ALL FINISHED                          05126000
         EJECT                                                          05127000
*                                                                       05128000
*        UNARY OPERATOR BY NAME                                         05129000
*                                                                       05130000
CODENUN  L     R6,0(R5)           POINTER TO OPERATOR DOPE VECTOR       05131000
         TM    2(R6),X'70'        OPTR TREATED AS FUNC (DB1 BASE REG)?  05132000
         BZ    CODEUN             SKIP IF SO                            05133000
         TM    1(R6),YNAME        CALL BY NAME ALLOWED?                 05134000
         BZ    CODENMER           NO CLOBBER HIM                        05135000
         LA    R6,4(R6)           ELSE POINT TO NAME ENTRY & MERGE      05136000
*                                                                       05137000
*        UNARY OPERATOR BY VALUE ENTRY (UNOP BY NAME MERGES)            05138000
*        (R6) POINTS TO OPERATOR DOPE VECTOR                            05139000
*                                                                       05140000
*        LM    A1,A1+1,OPERAND                                          05141000
*        BAL   RETURN,OPERATORROUTINE                                   05142000
*                                                                       05143000
CODEUN   LR    R7,R5              SAVE POINTER TO UNOP BLOCK            05144000
         L     R5,4(,R5)          LOAD OPERAND POINTER                  05145000
         TM    2(R6),X'70'        OPTR TREATED AS FUNC (DB1 BASE REG)?  05146000
         BZ    CODENUNU           SKIP TO SPECIAL CIRCUIT IF SO         05147000
*                                                                       05148000
*        MERGE HERE FOR FUNCTION TREATED AS UNARY OPERATOR              05149000
*                                                                       05150000
*        (R6)                     POINTER TO OPERATOR DV                05151000
*        (R5)                     POINTER TO BLOCK FOR OPERAND          05152000
*                                                                       05153000
CODEUNF  TM    1(R6),SPECL        TEST FOR SPECIAL PROCESSING           05154000
         BO    4(,R6)             EXECUTE JUMP IF SPECIAL PROCESSING    05155000
*                                                                       05156000
*        COME HERE FOR NORMAL UNOP PROCESSING (ALSO FOR $$INCR,$$DECR)  05157000
*                                                                       05158000
CODESRT  TM    1(R6),RITNAM       SET CC FOR NAME OR VALUE REQUIRED     05159000
         BAL   R4,CODER           GENERATE CODE FOR OPERAND             05160000
*                                                                       05161000
*        MERGE HERE ALSO FROM BINARY OPERATOR PROCESSING                05162000
*                                                                       05163000
CODEOP   LH    R1,BALRTN$         LOAD BAL RETURN,                      05164000
         STH   R1,0(,LC)          GENERATE IT                           05165000
         CLI   2(R6),2            CHECK FOR SPECIAL COMPARE OP EG,GT... 05166000
         BH    CODEOP1            SKIP IF NOT                           05167000
*                                                                       05168000
*        COME HERE FOR SPECIAL PREDICATE OPERATORS EQ,NE,IDENT ETC.     05169000
*                                                                       05170000
         MVC   2(4,LC),CMPSAD$    GENERATE ,$$CMPR BCR 0,0              05171000
         CLI   2(R6),1            CHECK 3 DIFFERENT CASES               05172000
         BL    CODEOP0            SKIP IF NE,EQ,GE,LE,GT,LT             05173000
         MVC   2(2,LC),IDNT$      ELSE CHANGE S ADDRESS TO $$IDNT       05174000
         BH    CODEOP0            SKIP IF IDENT,DIFFER                  05175000
         MVC   2(2,LC),LCMP$      ELSE CHANGE S ADDRESS TO $$LCMP       05176000
         EJECT                                                          05177000
*                                                                       05178000
*        COME HERE TO GENERATE BCR AFTER $$CMPR,$$LCMP OR $$IDNT CALL   05179000
*                                                                       05180000
CODEOP0  IC    R1,3(R6)           PICK UP CONDITION CODE                05181000
         SLL   R1,4               POSITION                              05182000
         LA    R1,FRETURN(R1)     ADD IN FRETURN REG                    05183000
         STC   R1,5(LC)           GENERATE CODE,FRETURN                 05184000
         LA    LC,6(LC)           UPDATE CODE POINTER                   05185000
         B     CODEOP2            MERGE                                 05186000
*                                                                       05187000
*        JUMP HERE FOR CASES OTHER THAN GT,NE,IDENT,LEQ ETC.            05188000
*                                                                       05189000
CODEOP1  LH    R1,2(R6)           OPERATOR ROUTINE S ADDRESS            05190000
         STH   R1,2(LC)           GENERATE IT                           05191000
         LA    LC,4(LC)           UPDATE CODE POINTER                   05192000
*                                                                       05193000
*        TEST FOR PREDICATE OPERATOR                                    05194000
*        IF SO -- GENERATE L A1,NULL                                    05195000
*                                                                       05196000
CODEOP2  TM    1(R6),PREDF        IS THIS A PREDICATE FUNCTION?         05197000
         BZ    CODEDONE           SKIP IF NOT                           05198000
*                                                                       05199000
*        MERGE HERE FROM ?                                             05200000
*                                                                       05201000
CODEOP3  MVC   0(4,LC),LA1NUL$    GENERATE L  A1,=NULL                  05202000
         LA    LC,4(,LC)          BUMP CODE POINTER, MERGE TO RETURN    05203000
         B     CODEDONE           ALL DONE                              05204000
*                                                                       05205000
*        SPECIAL ROUTINE FOR UNARY OPERATOR TREATED AS FUNCTION         05206000
*                                                                       05207000
CODENUNU STH   R3,2(,R2)          SAVE TEMP STACK POINTER               05208000
         OI    0(R2),OPTRFUNC+FUNCCODE      SET PROPER FLAGS            05209000
         BAL   R1,CODTMPST        GENERATE CODE TO STORE ARG ON STACK   05210000
         B     CODEFN2            MERGE WITH FUNCTION PROCESSING        05211000
         EJECT                                                          05212000
*                                                                       05213000
*        COMMON RETURN POINT                                            05214000
*                                                                       05215000
CODEDONE STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1            05216000
         TM    0(R2),CONSFLAG     CHECK FOR END OF CONSTANT EXPR        05217000
         BNO   CODEDON1           SKIP IF NOT                           05218000
*                                                                       05219000
*        HERE IF THIS IS THE COMPLETION OF CODE FOR A CONSTANT EXPR     05220000
*                                                                       05221000
*        GENERATE THE FOLLOWING TERMINATION CODE                        05222000
*                                                                       05223000
*        (L    DB4,$$BASXX)       ALWAYS GENERATED IF ON DB4            05224000
*        STM   A1,A1+1,***        STORE RESULT IN 8 BYTE BLOCK          05225000
*        AUR   0,2                FOR GARBAGE COLLECTOR AND CODE LISTER 05226000
*                                                                       05227000
         LR    R5,R2              SAVE CODEGEN CALL STACK POINTER       05228000
         BAL   R2,FIND8           LOCATE AN 8 BYTE BLOCK                05229000
         LA    R1,VALUE(,R1)      BUMP TO POINT TO VALUE FIELD          05230000
         LR    R4,R1              SAVE POINTER TO BLOCK                 05231000
         MVI   OLDBASE+1,0        MAKE SURE OF DB4 LOAD IF REQUIRED     05232000
         BAL   RF,CALCSAD         CALCULATE S ADDRESS                   05233000
         STH   R1,2(,LC)          STORE S ADDRESS                       05234000
         MVC   0(2,LC),STMA1$     SET STM A1,A1+1,                      05235000
         MVC   4(2,LC),=X'3E02'   SET AUR 0,2 (SCNT,SINC)               05236000
         LA    R6,6(,LC)          POINT TO END OF EXPR CODE             05237000
*                                                                       05238000
*        NOW MOVE THE CODE UP TO THE CONSTANT CODE AREA                 05239000
*                                                                       05240000
         L     LC,CONCODAD        POINT BACK TO START OF EXPR CODE      05241000
         LR    R2,LC              COPY CODE POINTER                     05242000
         SR    R6,R2              ACTUAL LENGTH OF CODE                 05243000
         L     R7,SUBEXBOT        CURRENT LOWEST BYTE IN USE            05244000
         SR    R7,R6              COMPUTE NEW VALUE                     05245000
         ST    R7,SUBEXBOT        STORE UPDATED LOWEST BYTE IN USE      05246000
         LR    R0,R7              COPY CODE ADDRESS                     05247000
         S     R0,SUBEXTOP        MAKE PTR RELATIVE FOR PRCODE          05248000
         ST    R0,VALUE-VALUE(,R4)          STORE PTR FOR PRCODE        05249000
         ST    LC,VALUE-VALUE+4(,R4)        SET PTR TO LM IN CASE ERROR 05250000
         MVI   VALUE-VALUE(R4),KCODE        SET PROPER TYPE CODE        05251000
         BCTR  R6,0               ADJUST TO 360 LENGTH                  05252000
         LA    R0,256             GET CRANK CONSTANT                    05253000
         EJECT                                                          05254000
*                                                                       05255000
*        LOOP TO MOVE UP CONSTANT CODE IN 256 BYTE CHUNKS               05256000
*                                                                       05257000
CODEDONL CR    R6,R0              CHECK LENGTH REMAINING                05258000
         BL    CODEDONG           SKIP IF 256 BYTES LEFT OR LESS        05259000
         MVC   0(256,R7),0(R2)    ELSE MOVE 256 BYTES                   05260000
         AR    R7,R0              PUSH POINTERS                         05261000
         AR    R2,R0              . . . .                               05262000
         SR    R6,R0              DECREMENT LENGTH REMAINING            05263000
         B     CODEDONL           LOOP BACK FOR NEXT CHUNK              05264000
*                                                                       05265000
*        HERE TO MOVE LAST CHUNK                                        05266000
*                                                                       05267000
CODEDONG EX    R6,CODEDONM        MOVE LAST SECTION                     05268000
         LR    R1,R4              COPY POINTER TO TEMPORARY CELL        05269000
         MVC   OLDBASE,SOLDBASE   RESTORE OLDBASE FROM BEFORE EXPR      05270000
         L     R3,CONSTAK         RESTORE SAVED TEMP STACK POINTER      05271000
         LR    R2,R5              RESTORE CODGEN CALL STACK POINTER     05272000
         NI    CONGEN,X'FF'-1     TURN OFF CONGEN FLAG                  05273000
         BAL   RF,CALCSAD         GET S ADDRESS OF TEMPORARY CELL       05274000
*                                 NOTE: MUST REGENERATE POSSIBLE DB4 L  05275000
         STH   R1,2(,LC)          STORE IN CODE                         05276000
         MVC   0(2,LC),LMA1$      GENERATE LM A1,A1+1,                  05277000
         LA    LC,4(,LC)          PUSH CODE POINTER                     05278000
*                                                                       05279000
*        HERE TO POP STACK AND RETURN TO CALLER                         05280000
*                                                                       05281000
CODEDON1 SH    R2,=H'24'          POP CALL STACK                        05282000
         LM    R4,R7,8(R2)        RESTORE REGISTERS                     05283000
         BR    R4                 AND RETURN                            05284000
*                                                                       05285000
CODEDONM MVC   0(*-*,R7),0(R2)    MOVE LAST CHUNK OF CODE UP            05286000
         EJECT                                                          05287000
*                                                                       05288000
*        UNARY OPERATORS REQUIRING SPECIAL PROCESSING                   05289000
*                                                                       05290000
*                                                                       05291000
*                                                                       05292000
*        FOR ?, WE MERELY EVALUATE THE ARGUMENT BY VALUE AND THEN       05293000
*        GENERATE THE L A1,NULL AS USUAL FOR PREDICATE OPERATORS        05294000
*                                                                       05295000
CODENQ1  BAL   R4,CODEVAL         GENERATE CODE BY VALUE FOR ARGUMENT   05296000
         B     CODEOP3            MERGE TO GENERATE LOAD OF NULL        05297000
*                                                                       05298000
*        FOR NOT, THE CODE IS AS FOLLOWS --                             05299000
*                                                                       05300000
*        ST    FRETURN,TEM#N      SAVE CURRENT FRETURN                  05301000
*        MVI   TEM#N,ECODE        MAKE SURE IT GETS RELOCATED           05302000
*        BALR  R2,0               ESTABLISH BASE REGISTER               05303000
*        LA    FRETURN,L#NNN      POINT SO THAT FAILURE JUMPS TO END    05304000
*        (CODE FOR ARGUMENT BY VALUE)                                   05305000
*        L     FRETURN,TEM#N      ON SUCCESS, RELOAD FRETURN            05306000
*        BALR  RETURN,FRETURN     AND FAIL                              05307000
*L#NNN   L     FRETURN,TEM#N      ON SUCCESS, JUST RELOAD FRETURN       05308000
*                                                                       05309000
CODENQ2  SH    R3,=H'8'           RESERVE A TEMPORARY LOCATION          05310000
         MVC   0(6,LC),STFR$      GET ST FRETURN,*-* MVI *-*,ECODE      05311000
         STH   R3,2(LC)           STORE TEMP S ADDRESS IN ST            05312000
         STH   R3,6(,LC)          STORE TEMP S ADDRESS IN MVI           05313000
         LA    LC,8(,LC)          BUMP CODE POINTER                     05314000
         MVC   0(4,LC),BAL2LA$    GEN BALR R2,0 LA FRETURN,*-*(R2)      05315000
         LA    R7,2(LC)           SAVE ADDRESS OF LA                    05316000
         LA    LC,6(LC)           BUMP CODE POINTER                     05317000
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE FOR ARGUMENT   05318000
         MVI   OLDBASE+1,0        FORGET CURRENT DB4 SETTING            05319000
         MVC   0(8,LC),LFRBR$     L FRETURN,*-* BR FRETURN L FRETURN,   05320000
         STH   R3,2(LC)           STORE TEMP SADDRESS                   05321000
         STH   R3,8(LC)           WHERE NEEDED                          05322000
         LA    R1,6(LC)           ADDRESS FOR LA PREVIOUSLY GENERATED   05323000
         LA    LC,10(LC)          BUMP CODE POINTER                     05324000
         SR    R1,R7              CALCULATE DISPLACEMENT                05325000
         STH   R1,2(R7)           STORE DISPLACEMENT                    05326000
         LA    R3,8(R3)           RELEASE TEMPORARY LOCATION            05327000
         B     CODEOP3            JUMP TO GENERATE L A1,NULL            05328000
         EJECT                                                          05329000
*                                                                       05330000
*        FOR UNEVALUATED EXPRESSIONS WITH COMPLEX ARGUMENTS, WE         05331000
*        GENERATE THE FOLLOWING SPECIAL CODE --                         05332000
*                                                                       05333000
*        BALR  R2,0                                                     05334000
*        B     L#XXX              (USING INDEX R2 AS BASE)              05335000
*        (CODE FOR EXPR)          (TEM STACK RESET TO BASE)             05336000
*        B     $$EVLR                                                   05337000
*L#XXX   BAL   RETURN,$$AST1                                            05338000
*                                                                       05339000
*        NOTE THAT THE CASE OF SIMPLE VARIABLES AS ARGUMENTS HAS        05340000
*        ALREADY BEEN DEALT WITH BY THE EXPRESSION ANALYZER (UNOPCHK)   05341000
*                                                                       05342000
*        IN SOME SITUATIONS, THE CODE FOR THE EXPRESSION MUST BE        05343000
*        GENERATED BY NAME. IN THIS EVENT, THE SPECIAL STARNAME FLAG    05344000
*        HAS BEEN SET IN THE UNOP BLOCK BY OUR CALLER.                  05345000
*                                                                       05346000
*        THERE MAY BE SOME CONCERN THAT THE CODE IN THE GARBAGE         05347000
*        COLLECTOR WHICH SCANS TO FIND THE NEXT TEMPORARY REFERENCE     05348000
*        WILL BE UPSET BY TEMPORARILY RESETTING THE TEMPORARY STACK     05349000
*        POINTER. THIS IS NOT THE CASE, SINCE EXCEPT IN THE SIMPLEST    05350000
*        CASES, WHERE NO SUCH SCAN WILL OCCUR, THE ABOVE CODE WILL      05351000
*        ALWAYS BE PRECEEDED BY A STM WHICH SAVES THE PREVIOUS VALUE    05352000
*        OF (A1,A1+1) IN A TEMPORARY AND STOPS THE GCOL SCAN.           05353000
*                                                                       05354000
CODENQ4  STH   R3,2(,R2)          SAVE CURRENT TEMP STACK POINTER       05355000
         STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1            05356000
         L     R3,TEMSTKBS        RESET TEMP STACK POINTER TO BASE      05357000
         ST    LC,4(,R2)          SAVE CODE PTR (PTR TO BALR)           05358000
         TM    0(R7),STARNAME     SET CC FOR NAME/VALUE (R7 IS BLK PTR) 05359000
         LH    R7,OLDBASE         REMEMBER CURRENT DB4 SETTING          05360000
         MVI   OLDBASE+1,0        AND THEN FORGET IT                    05361000
         MVC   0(4,LC),BLRB$      GENERATE BALR R2,0 B *-*(R2)          05362000
         LA    LC,6(,LC)          BUMP PAST IT AND DISPLACEMENT         05363000
         BAL   R4,CODER           GENERATE CODE FOR EXPRESSION          05364000
         MVC   0(4,LC),BLEVLR$    GENERATE B $$EVLR                     05365000
         LA    LC,4(,LC)          BUMP PAST IT                          05366000
         STH   R7,OLDBASE         RECALL PREVIOUS DB4 VALUE             05367000
         LH    R3,2(,R2)          RESTORE TEMP STACK S ADDRESS          05368000
         N     R3,=X'0000FFFF'    STRIP GARBAGE SIGN BITS               05369000
         L     R4,4(,R2)          POINT TO BALR AT START                05370000
         LR    R0,LC              COPY CURRENT CODE PTR (L#NNN)         05371000
         SR    R0,R4              CALCULATE DISPLACEMENT                05372000
         SH    R0,=H'2'           ADJUST FOR 2 BYTE BALR                05373000
         STH   R0,4(,R4)          GENERATE DISPLACEMENT                 05374000
         B     CODEOP             MERGE BACK TO GENERATE BAL $$EXP1     05375000
         EJECT                                                          05376000
*                                                                       05377000
*        FOR THE @ OPERATOR, WE MUST MAKE A TEST FOR THE SPECIAL CASE   05378000
*        OF AN EXPRESSION ARGUMENT. SEE BINARY $ . FOR FURTHER DETAILS  05379000
*                                                                       05380000
CODENQ5  LR    R1,R5              COPY OPERAND POINTER                  05381000
         BAL   R4,CODEXTST        PERFORM SPECIAL TEST FOR EXPR CASE    05382000
         B     CODESRT            RETURN TO STANDARD UNOP CIRCUIT       05383000
*                                                                       05384000
*        SPECIAL PROCESSING FOR UNARY .                                 05385000
*                                                                       05386000
*        WE FIRST GENERATE CODE BY NAME FOR THE ARGUMENT. IF THE        05387000
*        ARGUMENT IS COMPLEX, THEN THE RESULT IS IN CORRECT FORM        05388000
*        WITH NO ADDITIONAL CODE. FOR SIMPLE VARIABLES, WE ADD:         05389000
*                                                                       05390000
*        O     A1,$$MCOD          ADD NAME CODE                         05391000
*                                                                       05392000
CODENQ6  BAL   R4,CODENAM         GENERATE CODE BY NAME FOR ARG         05393000
         TM    0(R5),OPNNM        IS OPERAND A SIMPLE VARIABLE?         05394000
         BNO   CODEDONE           ALL SET IF NOT                        05395000
         MVC   0(4,LC),OMCOD$     ELSE GENERATE O A1,$$MCOD             05396000
         LA    LC,4(,LC)          BUMP CODE POINTER                     05397000
         B     CODEDONE           AND EXIT                              05398000
         EJECT                                                          05399000
*                                                                       05400000
*        BINARY OPERATOR BY NAME                                        05401000
*                                                                       05402000
CODENBN  L     R6,0(R5)           OPERATOR DOPE VECTOR POINTER          05403000
         TM    2(R6),X'70'        OPTR TREATED AS FUNC (DB1 BASE REG)?  05404000
         BZ    CODEBN             SKIP IF SO                            05405000
         TM    1(R6),YNAME        TEST FOR CALL BY NAME ALLOWED         05406000
         BZ    CODENMER           CLOBBER HIM IF NOT                    05407000
         LA    R6,4(R6)           ELSE POINT TO NAME ENTRY & MERGE      05408000
*                                                                       05409000
*        BINARY OPERATOR BY VALUE (BINOP BY NAME MERGES)                05410000
*        (R6)                     OPERATOR DOPE VECTOR POINTER          05411000
*                                                                       05412000
*        LM    A1,A1+1            LEFT ARGUMENT                         05413000
*        LM    A2,A2+1            RIGHT ARGUMENT                        05414000
*        BAL   RETURN,OPERATOR-ROUTINE                                  05415000
*                                                                       05416000
CODEBN   L     R7,8(R5)           RIGHT ARGUMENT POINTER                05417000
         L     R5,4(R5)           LEFT ARGUMENT POINTER                 05418000
         TM    2(R6),X'70'        OPTR TREATED AS FUNC (DB1 BASE REG)?  05419000
         BZ    CODENBNU           SKIP TO SPECIAL ROUTINE IF SO         05420000
*                                                                       05421000
*        MERGE HERE FOR SYSTEM FUNCTION TREATED AS BINARY OP            05422000
*                                                                       05423000
*        (R6)                     POINTER TO OPERATOR DV                05424000
*        (R5)                     POINTER TO LEFT OPERAND               05425000
*        (R7)                     POINTER TO RIGHT OPERAND              05426000
*                                                                       05427000
CODEBN1  TM    1(R6),SPECL        TEST FOR SPECIAL PROCESSING           05428000
         BO    CODEBNS            SKIP IF SPECIAL PROCESSING            05429000
*                                                                       05430000
*        NORMAL BINARY OPERATOR PROCESSING                              05431000
*                                                                       05432000
CODEBNC  TM    0(R7),COMPLEX+READV          TEST FOR RIGHT ARG COMPLEX  05433000
         BZ    CODEBNC1           SKIP IF DEFINITELY SIMPLE             05434000
         TM    1(R6),RITNAM       IS RIGHT ARG BY NAME?                 05435000
         BO    CODEBN5            IF SO, CANNOT BE CONSTANT (SIMPLE)    05436000
         CLI   CONGEN,0           ARE WE IN MIDDLE OF CONSTANT EXPR?    05437000
         BNZ   CODEBN5            IF SO, DEFINITELY COMPLEX             05438000
         TM    0(R7),OPNCN        ELSE IS RIGHT ARGUMENT CONSTANT?      05439000
         BNO   CODEBN5            COMPLEX IF NOT, ELSE TREAT AS SIMPLE  05440000
         EJECT                                                          05441000
*                                                                       05442000
*        COME HERE IF RIGHT ARGUMENT IS SIMPLE                          05443000
*                                                                       05444000
*        IN THIS SITUATION, GENERATION OF CODE FOR THE RIGHT ARGUMENT   05445000
*        CAN BE DONE LEAVING THE RESULT DIRECTLY IN A2,A2+1 WITHOUT     05446000
*        DISTURBING A1,A1+1 SO WE CAN GENERATE CODE FOR THE LEFT ARG    05447000
*        FIRST AND THEN LOAD THE RIGHT ARGUMENT WITHOUT NEEDING         05448000
*        A TEMPORARY STORE OF THE LEFT ARGUMENT                         05449000
*                                                                       05450000
*        NOTE: COMMUTATIVE OPERATORS REENTER HERE AFTER SWITCHING ARGS  05451000
*                                                                       05452000
CODEBNC1 TM    1(R6),LEFNAM       SET CC FOR LEFT ARG BY NAME OR VALUE  05453000
         BAL   R4,CODER           GENERATE CODE FOR LEFT ARG            05454000
         TM    1(R6),RITNAM       TEST FOR RIGHT ARG BY NAME OR VALUE   05455000
         BO    CODEBN3            SKIP IF RIGHT ARG BY NAME             05456000
*                                                                       05457000
*        SIMPLE RIGHT ARGUMENT BY VALUE                                 05458000
*                                                                       05459000
CODEBN1A LR    R5,R7              COPY POINTER TO RIGHT ARGUMENT        05460000
         STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1            05461000
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE                05462000
         LR    R1,LC              COPY CODE POINTER                     05463000
         SH    R1,=H'4'           POINT TO LM A1,A1+1,XX OR L A1,$$NULL 05464000
         CLI   1(R1),16*A1+A1+1   IS IT LM A1,A1+1, CASE?               05465000
         MVI   1(R1),16*A2+A2+1   REPLACE BY LM A2,A2+1, IN CASE        05466000
         BE    CODEOP             DONE EXCEPT FOR BAL IF IT WAS         05467000
         MVI   1(R1),16*A2        ELSE CHG L A1,$$NULL TO L A2,$$NULL   05468000
         B     CODEOP             AND JUMP BACK TO GENERATE BAL         05469000
*                                                                       05470000
*        SIMPLE RIGHT ARGUMENT BY NAME                                  05471000
*                                                                       05472000
CODEBN3  TM    0(R7),OPNNM        MAKE SURE IT IS A NAME                05473000
         BNO   CODENMER           ERROR OF VALUE BY NAME IF NOT         05474000
         L     R1,0(,R7)          ELSE LOAD BLOCK ADDRESS               05475000
         BAL   RF,CALCSAD         CALCULATE S ADDRESS                   05476000
         MVC   0(6,LC),LA2SR$     LA A2,*-*  SR A2+1,A2+1               05477000
         STH   R1,2(,LC)          GENERATE S ADDRESS                    05478000
         LA    LC,6(,LC)          BUMP CODE POINTER                     05479000
         B     CODEOP             MERGE BACK TO GENERATE BAL            05480000
*                                                                       05481000
*        COME HERE FOR A COMMUTATIVE OP (LEFT SIMPLE, RIGHT COMPLEX)    05482000
*                                                                       05483000
CODEBN1B LA    R6,4(,R6)          POINT TO DV FOR COMMUTED OP           05484000
         B     CODEBNC1           AND MERGE BACK                        05485000
         EJECT                                                          05486000
*                                                                       05487000
*        BINARY OPERATOR PROCESSING -- RIGHT ARG IS COMPLEX             05488000
*                                                                       05489000
CODEBN5  TM    0(R5),COMPLEX+READV          TEST FOR LEFT ARG COMPLEX   05490000
         BZ    CODEBN6            SKIP IF DEFINITELY SIMPLE             05491000
         TM    1(R6),LEFNAM       LEFT ARGUMENT BY NAME?                05492000
         BO    CODEBN10           IF SO, CANNOT BE CONSTANT (SIMPLE)    05493000
         CLI   CONGEN,0           ARE WE IN A CONSTANT EXPRESSION?      05494000
         BNZ   CODEBN10           DEFINITELY COMPLEX IF SO              05495000
         TM    0(R5),OPNCN        ELSE TEST FOR CONSTANT EXPR           05496000
         BNO   CODEBN10           COMPLEX IF NOT, ELSE TREAT AS SIMPLE  05497000
*                                                                       05498000
*        BINARY OPERATOR -- LEFT ARG SIMPLE -- RIGHT ARG COMPLEX        05499000
*                                                                       05500000
CODEBN6  LR    R1,R5              SWITCH ARGS AROUND                    05501000
         LR    R5,R7              RIGHT ARG TO (R5)                     05502000
         LR    R7,R1              LEFT ARG TO (R7)                      05503000
         TM    1(R6),COMMUT       IS THIS OPERATOR COMMUTATIVE?         05504000
         BO    CODEBN1B           SKIP IF SO WITH ARGS SWITCHED         05505000
         TM    1(R6),RITNAM       SET CC FOR RIGHT ARG BY NAME/VALUE    05506000
         BAL   R4,CODER           GENERATE CODE FOR RIGHT ARGUMENT      05507000
         MVC   0(4,LC),LRA2A1$    GENERATE LR A2,A1  LR A2+1,A1+1       05508000
         LA    LC,4(LC)           BUMP CODE POINTER                     05509000
         TM    1(R6),LEFNAM       TEST FOR LEFT ARG BY NAME/VALUE       05510000
         LR    R5,R7              LOAD LEFT ARG                         05511000
         BAL   R4,CODER           GENERATE CODE FOR LEFT ARG            05512000
         B     CODEOP             GENERATE OPERATOR CALL                05513000
         EJECT                                                          05514000
*                                                                       05515000
*        BINARY OPERATOR -- BOTH ARGUMENTS COMPLEX                      05516000
*                                                                       05517000
CODEBN10 TM    1(R6),LEFNAM       SET CC FOR LEFT ARG BY NAME/VALUE     05518000
         BAL   R4,CODER           GENERATE CODE FOR LEFT ARG            05519000
*                                                                       05520000
*        MERGE HERE FROM SPECIAL CONCATENATION CIRCUIT                  05521000
*                                                                       05522000
CODEBN11 SH    R3,=H'8'           RESERVE A TEMPORARY LOCATION          05523000
         LH    R1,STMA1$          PICK UP STM A1,A1+1, FOR TEMP STORE   05524000
         STH   R1,0(LC)           GENERATE STM A1,A1+1,                 05525000
         STH   R3,2(LC)           GENERATE TEMP LOC S ADDRESS           05526000
         LA    LC,4(LC)           UPDATE CODE POINTER                   05527000
         LR    R5,R7              LOAD RIGHT ARG                        05528000
         TM    1(R6),RITNAM       SET CC FOR RIGHT ARG BY NAME/VALUE    05529000
         BAL   R4,CODER           GENERATE CODE FOR RIGHT ARG           05530000
*                                                                       05531000
*        NOW WE GENERATE TWO POSSIBLE SEQUENCES AS FOLLOWS:             05532000
*                                                                       05533000
*        FOR NON-COMMUTATIVE OPERATORS:                                 05534000
*                                                                       05535000
*        LR    A2,A1              MOVE SECOND ARG TO SECOND ACCUM       05536000
*        LR    A2+1,A1+1          .                                     05537000
*        LM    A1,A1+1,TEM#NN     RELOAD FIRST ARG                      05538000
*                                                                       05539000
*        FOR COMMUTATIVE OPERATORS:                                     05540000
*                                                                       05541000
*        LM    A2,A2+1,TEM#NN     LOAD FIRST ARG TO SECOND ACCUM        05542000
*                                                                       05543000
*        FOLLOWED BY A CALL TO THE APPROPRIATE ROUTINE (CODEOP)         05544000
*                                                                       05545000
         TM    1(R6),COMMUT       IS OPERATOR COMMUTATIVE?              05546000
         BNO   CODEBN12           SKIP IF NOT                           05547000
*                                                                       05548000
*        HERE FOR A COMMUTATIVE OPERATOR                                05549000
*                                                                       05550000
         LA    R6,4(,R6)          POINT TO DV FOR COMMUTED OPERATOR     05551000
         LH    R1,LMA2SM$         SET TO GENERATE LM A2,A2+1            05552000
         B     CODEBN13           JUMP TO MERGE                         05553000
*                                                                       05554000
*        HERE FOR NON-COMMUTATIVE OPERATOR                              05555000
*                                                                       05556000
CODEBN12 MVC   0(4,LC),LRA2A1$    GENERATE LR A2,A1 LR A2+1,A1+1        05557000
         LA    LC,4(,LC)          BUMP CODE POINTER                     05558000
         LH    R1,LMA1$           SET TO GENERATE LM A1,A1+1            05559000
*                                                                       05560000
*        THE TWO CASES MERGE HERE                                       05561000
*                                                                       05562000
CODEBN13 STH   R1,0(,LC)          GENERATE LM INSTRUCTION               05563000
         STH   R3,2(,LC)          STORE S ADDRESS OF TEMPORARY LOC      05564000
         LA    LC,4(,LC)          BUMP CODE POINTER                     05565000
         LA    R3,8(,R3)          RELEASE TEMPORARY LOCATION            05566000
         B     CODEOP             JUMP TO GENERATE BAL TO SYSTEM ROUTNE 05567000
         EJECT                                                          05568000
*                                                                       05569000
*        BINARY OPERATORS REQUIRING SPECIAL PROCESSING                  05570000
*                                                                       05571000
CODEBNS  LH    R1,2(,R6)          GET LAST BYTES OF DOPE VEC FOR TEST   05572000
         CH    R1,CNCDV+2         IS THIS CASE OF CONCATENATION?        05573000
         BE    CODEBNSC           SKIP IF SO                            05574000
         CH    R1,ADDDV+2         IS THIS CASE OF +                     05575000
         BE    CODEBNSA           SKIP IF SO                            05576000
         CH    R1,SUBDV+2         IS THIS CASE OF - ?                   05577000
         BE    CODEBNSA           SKIP IF SO                            05578000
         CLI   2(R6),2            CHECK FOR IDENT,DIFR                  05579000
         BE    CODEBNSI           SKIP FOR THIS SPECIAL CASE            05580000
*                                                                       05581000
*        THE REMAINING POSSIBILITIES ARE $ . WHICH SHARE COMMON CODE    05582000
*                                                                       05583000
*        THE ONLY SPECIAL CASE IS WHEN THE RIGHT ARGUMENT IS AN         05584000
*        UNEVALUATED EXPRESSION -- OTHERWISE NORMAL PROCESSING OCCURS   05585000
*                                                                       05586000
*        IN THE CASE OF AN UNEVALUTED EXPRESSION. THE OPERATOR DOPE     05587000
*        VECTOR POINTER IS ADJUSTED TO POINT TO THE SPECIAL CASE DV     05588000
*        AND THE STARNAME FLAG IS SET FOR COMPLEX EXPRESSION ARGUMENTS  05589000
*                                                                       05590000
         LR    R1,R7              COPY RIGHT ARGUMENT POINTER           05591000
         BAL   R4,CODEXTST        CALL ROUTINE TO PERFORM TEST          05592000
         B     CODEBNC            MERGE WITH NORMAL PROCESSING          05593000
*                                                                       05594000
*        COMMON ROUTINE SHARED BY $ . AND @ TO DEAL WITH EXPR ARGS      05595000
*                                                                       05596000
*        (R6)                     OPERATOR DV POINTER                   05597000
*        (R1)                     ARGUMENT POINTER                      05598000
*        BAL   R4,CODEXTST                                              05599000
*                                                                       05600000
CODEXTST CLC   1(3,R1),=AL3(AST1DV)         IS OPERAND UNARY * ?        05601000
         BE    CODEXTS1           SKIP IF SO                            05602000
         CLI   0(R1),OPNCN        ELSE IS ARGUMENT A CONSTANT?          05603000
         BCR   NE,R4              RETURN IF NOT (NOT EXPR ARGUMENT)     05604000
         L     RE,0(,R1)          ELSE LOAD POINTER TO CONSTANT         05605000
         CLI   VALUE(RE),VCODE    IS ARGUMENT A SIMPLE EXPR?            05606000
         BCR   NE,R4              RETURN IF NOT                         05607000
         LA    R6,12(,R6)         ELSE ADJUST OPERATOR DV POINTER       05608000
         BR    R4                 AND RETURN                            05609000
*                                                                       05610000
*        HERE IF ARGUMENT IS A COMPLEX EXPRESSION                       05611000
*                                                                       05612000
CODEXTS1 OI    0(R1),STARNAME     SET SPECIAL FLAG FOR EXPR BY NAME     05613000
         LA    R6,12(,R6)         ADJUST OPERATOR DV POINTER            05614000
         BR    R4                 RETURN TO CALLER                      05615000
         EJECT                                                          05616000
*                                                                       05617000
*        CONCATENATION SPECIAL PROCESSING                               05618000
*                                                                       05619000
*        THE ONLY SPECIAL CASE IS WHEN THE LEFT ARGUMENT IS A           05620000
*        PREDICATE EXPRESSION (SUCH AS EQ(..) ) WHICH MUST BE NULL,     05621000
*        IN THIS CASE, WE CAN SKIP THE CONCATENATION ALLTOGETHER        05622000
*                                                                       05623000
CODEBNSC CLI   OPTFLAG,0          ARE WE OPTIMIZING?                    05624000
         BZ    CODEBNC            SKIP IF NOT (NORMAL PROCESSING)       05625000
         TM    0(R5),COMPLEX      ELSE IS LEFT ARGUMENT COMPLEX?        05626000
         BZ    CODEBNC            NORMAL PROCESSING IF LEFT ARG SIMPLE  05627000
*                                                                       05628000
*        NOW WE GENERATE CODE FOR THE LEFT ARGUMENT AND SEE IF THE      05629000
*        LAST ITEM GENERATED IS  L A1,$$NULL. IF SO, THEN WE            05630000
*        CAN OPTIMIZE, ELSE WE MERGE BACK INTO THE STANDARD CIRCUIT     05631000
*                                                                       05632000
         BAL   R4,CODE1           CODE FOR LEFT ARG (COMPLEX BY VALUE)  05633000
         LR    R1,LC              COPY CODE POINTER                     05634000
         SH    R1,=H'4'           BACK OFF FOUR BYTES                   05635000
         CLC   0(4,R1),LA1NUL$    WAS LAST INSTRUCTION L A1,$$NULL      05636000
         BNE   CODBNSC1           SKIP IF NOT                           05637000
*                                                                       05638000
*        HERE IS THE CASE WE CAN OPTIMIZE                               05639000
*                                                                       05640000
         LR    LC,R1              DELETE THE USELESS LOAD OF NULL       05641000
         LR    R5,R7              GET POINTER TO RIGHT ARGUMENT         05642000
         BAL   R4,CODEVAL         FETCH BY VALUE (THIS IS RESULT)       05643000
         B     CODEDONE           ALL DONE                              05644000
*                                                                       05645000
*        HERE IF WE CANNOT OPTIMIZE, NOTE THAT WE ALREADY               05646000
*        GENERATED CODE FOR THE LEFT HAND SIDE                          05647000
*                                                                       05648000
CODBNSC1 TM    0(R7),COMPLEX+READV          CHECK RIGHT ARGUMENT        05649000
         BZ    CODEBN1A           TAKE MERGE IF SIMPLE RIGHT ARG        05650000
         B     CODEBN11           ELSE MERGE FOR BOTH ARGS COMPLEX      05651000
         EJECT                                                          05652000
*                                                                       05653000
*        SPECIAL PROCESSING FOR ADD AND SUBTRACT (+ AND -)              05654000
*                                                                       05655000
*                                                                       05656000
*        IF THE RIGHT ARGUMENT IS THE INTEGER ONE, SPECIAL CALLS TO     05657000
*        $$INCR AND $$DECR ARE GENERATED INSTEAD OF NORMAL CODE         05658000
*                                                                       05659000
CODEBNSA CLI   0(R7),OPNCN        IS RIGHT ARGUMENT A CONSTANT?         05660000
         BNE   CODEBNC            NORMAL PROCESSING IF NOT              05661000
         L     R1,0(,R7)          ELSE LOAD POINTER                     05662000
         CLI   VALUE(R1),0        CHECK FOR INTEGER CONSTANT            05663000
         BNE   CODEBNC            NOT SPECIAL CASE IF NOT INTEGER       05664000
         L     R1,VALUE+4(,R1)    LOAD VALUE OF INTEGER CONSTANT        05665000
         BCT   R1,CODEBNC         NORMAL PROCESSING UNLESS IT IS A 1    05666000
         LA    R6,12(,R6)         POINT TO $$INCR OR $$DECR DOPE VECTOR 05667000
         B     CODESRT            AND MERGE WITH UNOP PROCESSING        05668000
*                                                                       05669000
*        SPECIAL PROCESSING FOR IDENT,DIFFER                            05670000
*                                                                       05671000
*        IF THE RIGHT ARGUMENT IS NULL, THEN WE GENERATE ---            05672000
*                                                                       05673000
*        (CODE FOR LEFT ARG BY VALUE TO A1,A1+1)                        05674000
*        C     A1,$$NULL                                                05675000
*        BALR  RETURN,0           SET RETURN FOR TRACE, &LASTNO         05676000
*        BCR   NL,FRETURN         FOR DIFFER (LT FOR IDENT)             05677000
*                                                                       05678000
CODEBNSI C     R7,=A(NULBLK)      IS RIGHT ARGUMENT NULL?               05679000
         BNE   CODEBNC            NORMAL PROCESSING IF NOT              05680000
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE                05681000
         MVC   0(8,LC),CNULL$     GENERATE OUR SPECIAL CODE             05682000
         LA    LC,2(,LC)          ADJUST FOR EXTRA RR INSTRUCTION       05683000
         LA    R6,8(,R6)          POINT TO DOPE VECTOR WITH MODIFIED CC 05684000
         B     CODEOP0            MERGE TO COMPLETE THE BCR             05685000
*                                                                       05686000
*        HERE FOR BINARY OPERATOR TREATED AS FUNCTION                   05687000
*                                                                       05688000
CODENBNU STH   R3,2(,R2)          SAVE TEMP STACK POINTER               05689000
         OI    0(R2),OPTRFUNC+FUNCCODE      SET PROPER FLAGS            05690000
         BAL   R1,CODTMPST        GEN CODE TO STORE LEFT ARG ON STACK   05691000
         LR    R5,R7              COPY PTR TO RIGHT OPERAND             05692000
         BAL   R1,CODTMPST        GEN CODE TO STORE RIGHT ARG ON STACK  05693000
         B     CODEFN2            MERGE WITH FUNCTION CIRCUIT           05694000
         EJECT                                                          05695000
*                                                                       05696000
*        CALCSAD -- UTILITY ROUTINE TO CALCULATE S ADDRESSES            05697000
*                                                                       05698000
*        (R1)                     ACTUAL ADDRESS                        05699000
*        BAL   RF,CALCSAD                                               05700000
*        (R1)                     RESULTING S ADDRESS                   05701000
*                                                                       05702000
*        NOTE: THIS ROUTINE MODIFIES R1, ALL OTHER REGS ARE UNAFFECTED  05703000
*                                                                       05704000
*        IF THE ADDRESS IS IN ONE OF THE FIRST THREE 4K BLOCKS, THEN    05705000
*        A REFERENCE TO DB1,DB2 OR DB3 IS GENERATED.                    05706000
*                                                                       05707000
*        FOR THE REMAINING BLOCKS, A REFERENCE USING DB4 IS GENERATED   05708000
*        CALCSAD MAKES SURE THE CORRECT VALUE IS LOADED INTO DB4,       05709000
*        THE NECESSARY LOADS ARE GENERATED FROM THE BASE TABLE.         05710000
*        THE LOCATION OLDBASE KEEPS TRACK OF THE CURRENT SETTING OF     05711000
*        DB4 TO AVOID REDUNDANT LOADS. OLDBASE GETS CLEARED WHENEVER    05712000
*        THE VALUE IN DB4 IS DESTROYED (E.G. A FUNCTION CALL).          05713000
*                                                                       05714000
CALCSAD  STM   R2,R4,CALSDSV      SAVE WORK REGS                        05715000
         LA    R4,4095            MAXIMUM LEGAL DISPLACEMENT            05716000
         LA    R1,0(,R1)          STRIP UPPER BYTE OF ADDRESS           05717000
*                                                                       05718000
*        CHECK FOR REFERENCE TO FIRST BLOCK (DB1)                       05719000
*                                                                       05720000
         LR    R3,R1              COPY ADDRESS                          05721000
         SR    R3,DB1             CALCULATE DISPLACEMENT IN 1ST BLOCK   05722000
         CLR   R3,R4              LEGAL DISPLACEMENT?                   05723000
         BH    CALCSAD2           SKIP IF NOT                           05724000
         A     R3,=A(DB1*X'1000') ELSE SUPPLY DB1 AS BASE REG           05725000
         B     CALCSEX            JUMP TO EXIT                          05726000
*                                                                       05727000
*        CHECK FOR REFERENCE TO SECOND BLOCK (DB2)                      05728000
*                                                                       05729000
CALCSAD2 LR    R3,R1              COPY ADDRESS                          05730000
         S     R3,$$BAS2          CALCULATE DISPLACEMENT IN 2ND BLOCK   05731000
         CLR   R3,R4              LEGAL DISPLACEMENT?                   05732000
         BH    CALCSAD3           SKIP IF NOT                           05733000
         A     R3,=A(DB2*X'1000') ELSE SUPPLY DB2 AS BASE REG           05734000
         B     CALCSEX            JUMP TO EXIT                          05735000
*                                                                       05736000
*        CHECK FOR REFERENCE TO THIRD BLOCK (DB3)                       05737000
*                                                                       05738000
CALCSAD3 LR    R3,R1              COPY ADDRESS                          05739000
         S     R3,$$BAS3          CALCULATE DISPLACEMENT IN 3RD BLOCK   05740000
         LA    R3,0(,R3)          STRIP UPPER X'FF' BYTE                05741000
         CLR   R3,R4              LEGAL DISPLACEMENT?                   05742000
         BH    CALCSAD4           SKIP IF NOT                           05743000
         A     R3,=A(DB3*X'1000') ELSE SUPPLY DB3 AS BASE REG           05744000
*                                                                       05745000
*        COMMON EXIT POINT                                              05746000
*                                                                       05747000
CALCSEX  LR    R1,R3              PUT RESULT (S ADDRESS) IN PROPER REG  05748000
         LM    R2,R4,CALSDSV      RESTORE WORK REGS                     05749000
         BR    RF                 RETURN TO CALLER                      05750000
         EJECT                                                          05751000
*                                                                       05752000
*        CALCSAD (CONTINUED)                                            05753000
*                                                                       05754000
*        HERE IF WE HAVE A DB4 REFERENCE                                05755000
*                                                                       05756000
CALCSAD4 SR    R2,R2              INITIALIZE TO TEST $$BAS4             05757000
*                                                                       05758000
*        LOOP TO FIND CORRECT BASE REGISTER                             05759000
*                                                                       05760000
CALCSADL LR    R3,R1              COPY ADDRESS                          05761000
         S     R3,$$BAS4(R2)      CALCULATE DISPLACEMENT FOR NEXT BASE  05762000
         CLR   R3,R4              LEGAL DISPLACEMENT?                   05763000
         LA    R2,4(,R2)          BUMP POINTER ANYWAY (HENCE FUDGE)     05764000
         BH    CALCSADL           LOOP BACK IF ILLEGAL DISPLACEMENT     05765000
*                                                                       05766000
*        HERE WHEN WE HAVE FOUND THE ENTRY                              05767000
*                                                                       05768000
         A     R3,=A(DB4*X'1000') SUPPLY DB4 AS BASE REG                05769000
         CH    R2,OLDBASE         IS DB4 SET RIGHT?                     05770000
         BE    CALCSEX            ALL DONE IF SO                        05771000
*                                                                       05772000
*        HERE WE MUST GENERATE CODE TO LOAD DB4 WITH A NEW VALUE        05773000
*                                                                       05774000
         STH   R2,OLDBASE         REMEMBER NEW VALUE                    05775000
         MVC   0(2,LC),LDB4$      GENERATE L DB4,                       05776000
         AH    R2,BASES$          CALCULATE S ADDR FOR BASE TABLE REF   05777000
         STH   R2,2(,LC)          STORE IN CODE AS LOAD OPERAND         05778000
         LA    LC,4(,LC)          BUMP CODE POINTER                     05779000
         B     CALCSEX            ALL DONE                              05780000
         EJECT                                                          05781000
*                                                                       05782000
*        UTILITY ROUTINE TO GENERATE CODE AT START OF STATEMENT         05783000
*                                                                       05784000
*        THE NORMAL CALL -- BAL RF AURGEN GENERATES THE FOLLOWING --    05785000
*                                                                       05786000
*        AUR   0,2                                                      05787000
*        (BR   0)                                                       05788000
*        (NOP  OFFSET)                                                  05789000
*        (NOP  STMNO)                                                   05790000
*                                                                       05791000
*        THE STRANGE BR INSTRUCTION IS GENERATED IF THE HOST MACHINE    05792000
*        HAS IMPRECISE INTERRUPTS. IT ENSURES THAT THE AUR OVERFLOW     05793000
*        FOR &STLIMIT, OVERTIME ETC. IS RECOGNIZED CORRECTLY.           05794000
*                                                                       05795000
*        THE NOP INSTRUCTIONS ARE NOT GENERATED FOR EVERY STATEMENT.    05796000
*        THE LOCATION LASTNOP CONTAINS THE ADDRESS OF THE LAST POINT    05797000
*        AT WHICH THESE NOPS WERE GENERATED. THEY ARE REGENERATED IF    05798000
*        THE CURRENT LOCATION IS MORE THAN NOPBYTES PAST THE PREVIOUS   05799000
*        LOCATION (LASTNOP).                                            05800000
*                                                                       05801000
*        THE FIRST OF THE TWO NOPS (NOP OFFSET) IS PRESENT ONLY FOR     05802000
*        THE CASE OF CODE COMPILED AT EXECUTION TIME (CODE,EVAL). THE   05803000
*        SECOND HALFWORD IS AN OFFSET BACK TO THE START OF THE CODE     05804000
*        BLOCK (IN HALFWORDS) FOR USE BY THE GARBAGE COLLECTOR.         05805000
*        ALL SIXTEEN BITS MAY BE USED ALLOWING UP TO 128K BYTES OFFSET  05806000
*                                                                       05807000
*        THE SECOND NOP HAS THE CURRENT STATEMENT NUMBER IN THE SECOND  05808000
*        HALFWORD AND IS USED BY THE CALCSTNO ROUTINE TO TELL WHAT      05809000
*        STATEMENT AN ERROR OCCURS IN ETC.                              05810000
*                                                                       05811000
*        NOTE THAT IN THE CASE OF AN EXPRESSION, THE SECOND NOP IS      05812000
*        NOT REQUIRED, AND IS DELETED (SEE CODXENT)                     05813000
*                                                                       05814000
*        THE SECOND ENTRY POINT -- BAL RF,AURGENU -- IS USED WHEN THE   05815000
*        NOP INSTRUCTIONS MUST BE GENERATED REGARDLESS OF THE VALUE     05816000
*        IN LASTNOP. THIS IS USED AT THE END OF A SEQUENCE OF CODE.     05817000
*                                                                       05818000
*        THE FOLLOWING EQUATE DEFINES THE PERIODICITY CONSTANT,         05819000
*        LOWER VALUES SPEED GARBAGE COLLECTION AND CALCSTNO, BUT        05820000
*        GENERATE ADDITIONAL CODE                                       05821000
*                                                                       05822000
NOPBYTES EQU   200                200 BYTES BETWEEN NOPS                05823000
         EJECT                                                          05824000
*                                                                       05825000
*        AURGEN -- CONTINUED                                            05826000
*                                                                       05827000
*        ENTRY POINT FOR AURGENU CALL (GENERATE NOPS UNCONDITIONALLY)   05828000
*                                                                       05829000
AURGENU  STE   ZR,LASTNOP         CLEAR LASTNOP TO ENSURE NOP'S         05830000
*                                                                       05831000
*        NORMAL AURGEN ENTRY POINT                                      05832000
*                                                                       05833000
AURGEN   LH    R0,AUR$            LOAD AUR 0,2                          05834000
         STH   R0,0(,LC)          GENERATE IT                           05835000
         LA    LC,2(,LC)          PUSH PAST IT                          05836000
*                                                                       05837000
*        NOW TEST FOR GENERATION OF BR FOR IMPRECISE INTERRUPTS         05838000
*                                                                       05839000
         TM    INTFLAG+3,1        TEST INTERRUPT TYPE FLAG              05840000
         BNO   AURGEN0            SKIP IF PRECISE                       05841000
         LH    R0,BR0$            ELSE LOAD SPECIAL BR INSTRUCTION      05842000
         STH   R0,0(,LC)          GENERATE IT                           05843000
         LA    LC,2(,LC)          AND BUMP PAST IT                      05844000
*                                                                       05845000
*        TEST FOR GENERATION OF NOPS REQUIRED                           05846000
*                                                                       05847000
AURGEN0  LR    R0,LC              COPY CURRENT CODE LOCATION            05848000
         SH    R0,=Y(NOPBYTES)    BACK OFF BY CONSTANT                  05849000
         C     R0,LASTNOP         SHOULD WE GENERATE NOP'S              05850000
         BCR   NH,RF              RETURN IF NOT NEEDED YET              05851000
*                                                                       05852000
*        HERE WE SHOULD GENERATE A NEW SET OF NOP'S                     05853000
*                                                                       05854000
         ST    LC,LASTNOP         REMEMBER NEWEST LOCATION              05855000
         MVC   0(6,LC),NOP$       GENERATE TWO POSSIBLE NOP'S           05856000
         TM    STAGE,$EXECUTE     EXECUTE TIME (CODE EVAL)?             05857000
         BNO   AURGEN1            SKIP IF NOT CODE,EVAL CASE            05858000
*                                                                       05859000
*        HERE WE GENERATE THE NOP OFFSET FOR CODE,EVAL                  05860000
*                                                                       05861000
         LR    R0,LC              COPY CURRENT LOCATION                 05862000
         S     R0,CODSVREG+4*FR   SUBTRACT STARTING LOC = OFFSET        05863000
         SRL   R0,1               CONVERT BYTE OFFSET TO HALFWORDS      05864000
         STH   R0,2(,LC)          STORE OFFSET IN NOP                   05865000
         LA    LC,4(,LC)          BUMP PAST NOP                         05866000
*                                                                       05867000
*        HERE WE GENERATE THE NOP WITH THE STATEMENT NUMBER             05868000
*                                                                       05869000
AURGEN1  MVC   2(2,LC),BSTMNO     SET STATEMENT NUMBER                  05870000
         LA    LC,4(,LC)          BUMP CODE PTR PAST NOP                05871000
         BR    RF                 RETURN TO CALLER                      05872000
         EJECT                                                          05873000
*                                                                       05874000
*        TABLE OF GENERATED INSTRUCTIONS                                05875000
*                                                                       05876000
*                                                                       05877000
*        DO NOT ALTER THE ORDER IN WHICH THESE INSTRUCTIONS APPEAR      05878000
*        SINCE, IN MANY CASES, THERE ARE GROUPS TOGETHER, USED IN       05879000
*        MORE THAN ONE WAY                                              05880000
*                                                                       05881000
BRTN$    BR    RETURN                                                   05882000
STMA1$   STM   A1,A1+1,*-*                                              05883000
         ORG   *-2                                                      05884000
LAR0$    LA    R0,*-*                                                   05885000
         ORG   *-2                                                      05886000
FUNCM$   LA    R1,*-*                                                   05887000
         SR    PDR,R1                                                   05888000
BALFR2$  BAL   RETURN,FCODE(,DB4)                                       05889000
         B     $$FRVN                                                   05890000
BALRTN$  BAL   RETURN,*-*                                               05891000
         ORG   *-2                                                      05892000
BLEVLR$  B     $$EVLR                                                   05893000
LMA2$    EQU   *                                                        05894000
LMA2SM$  LM    A2,A2+1,*-*                                              05895000
         AR    A1,A1+1                                                  05896000
         STM   A2,A2+1,VALUE(A1)                                        05897000
LRA2A1$  LR    A2,A1                                                    05898000
         LR    A2+1,A1+1                                                05899000
LR2$     L     R2,*-*                                                   05900000
         ORG   *-2                                                      05901000
MVNCD$   MVI   *-*,NCODE                                                05902000
         ORG   *-2                                                      05903000
ARM$     LA    R1,*-*                                                   05904000
         SR    PDR,R1                                                   05905000
LRFSYS$  LR    FRETURN,SYS                                              05906000
BR0$     BR    0                                                        05907000
OMCOD$   O     A1,$$MCOD                                                05908000
         EJECT                                                          05909000
LA1NUL$  L     A1,$$NULL                                                05910000
LR1BR$   L     R1,VLABL(,A1)                                            05911000
         BALR  RETURN,R1                                                05912000
LR1BR1$  L     R1,*-*                                                   05913000
         BALR  RETURN,R1                                                05914000
BAL2LA$  BALR  R2,0                                                     05915000
         LA    FRETURN,*-*(R2)                                          05916000
         ORG   *-2                                                      05917000
LDB4$    L     DB4,*-*                                                  05918000
         ORG   *-2                                                      05919000
LMA1$    LM    A1,A1+1,*-*                                              05920000
         ORG   *-2                                                      05921000
BLRBAL$  BALR  R2,0                                                     05922000
         BAL   FRETURN,*-*(R2)                                          05923000
         ORG   *-2                                                      05924000
BLRB$    BALR  R2,0                                                     05925000
         B     *-*(R2)                                                  05926000
         ORG   *-2                                                      05927000
LFRBR$   L     FRETURN,*-*                                              05928000
BRFRTN$  BALR  RETURN,FRETURN                                           05929000
LFRTN$   L     FRETURN,*-*                                              05930000
         ORG   *-2                                                      05931000
STFR$    ST    FRETURN,*-*                                              05932000
         MVI   *-*,ECODE                                                05933000
         ORG   *-2                                                      05934000
$STOP$   BAL   RETURN,$$STOP                                            05935000
LA1SR$   LA    A1,*-*                                                   05936000
         SR    A1+1,A1+1                                                05937000
LA2SR$   LA    A2,*-*                                                   05938000
         SR    A2+1,A2+1                                                05939000
AR2SA1$  AR    A1,A1+1                                                  05940000
         STM   A2,A2+1,VALUE(A1)                                        05941000
LRFDB1$  LR    FRETURN,DB1                                              05942000
         BAL   RETURN,$$SERR                                            05943000
BALREFR$ BALR  RETURN,FRETURN                                           05944000
NOP$     NOP   0                                                        05945000
         NOP   0                                                        05946000
         ORG   *-2                                                      05947000
         EJECT                                                          05948000
CNULL$   C     A1,$$NULL                                                05949000
         BALR  RETURN,0                                                 05950000
         BCR   *-*,FRETURN                                              05951000
LSTCD$   BALR  RETURN,0                                                 05952000
         DS    H                  SPACE FOR AUR                         05953000
         ST    RETURN,$$LAST                                            05954000
BGOTO$   BAL   RETURN,$$GOTO                                            05955000
DGOTO$   BAL   RETURN,$$DGTO                                            05956000
BNMVL$   BAL   RETURN,$$NMVL                                            05957000
BALAV$   BAL   RETURN,$$ARMV                                            05958000
BALAN$   BAL   RETURN,$$ARMN                                            05959000
BALAV1$  BAL   RETURN,$$AR1V                                            05960000
BALAN1$  BAL   RETURN,$$AR1N                                            05961000
SDOTB$   BAL   RETURN,$$DOTD                                            05962000
SDLRB$   BAL   RETURN,$$DLRD                                            05963000
BALRD$   BAL   RETURN,$$READ                                            05964000
CMPSAD$  DC    S($$CMPR)                                                05965000
         BCR   *-*,FRETURN                                              05966000
LCMP$    DC    S($$LCMP)                                                05967000
IDNT$    DC    S($$IDNT)                                                05968000
SPTNL$   DC    S($$PTNL)                                                05969000
BLPATA$  BAL   RETURN,$$PATA                                            05970000
LAFING$  LA    FRETURN,$$FING                                           05971000
BDOIO$   B     $$DOIO                                                   05972000
BASES$   DC    S($$BAS4-4)        S ADDR OF FIRST BASE FOR CALCSAD      05973000
         TITLE 'SPITBOLC -- CODE LISTING ROUTINE'                       05974000
*                                                                       05975000
*        THIS ROUTINE IS USED TO LIST GENERATED CODE -- THE CODE        05976000
*        IS ELABORATELY LISTED IN SYMBOLIC SOURCE FORM AND IN HEX       05977000
*        THIS ROUTINE IS INCLUDED ONLY IN THE STANDARD MODULES          05978000
*                                                                       05979000
         AIF   (&LMOD EQ 1).SKIPS6                                      05980000
*        STATEMENTS TO BE LISTED START WITH X'3D' (INSTEAD OF X'3E')    05981000
*                                                                       05982000
*        USAGE OF REGISTERS                                             05983000
*                                                                       05984000
*        (R4)  REG FOR CALL TO PRINT ONE STATEMENT OF CODE              05985000
*        (R5)  ABSOLUTE CODE LOCATION                                   05986000
*        (R6)  BUFFER POINTER                                           05987000
*        (R7)  USED FOR INTERNAL AND EXTERNAL CALLS                     05988000
*        (RE)  PARAMETER REGISTER FOR INTERNAL CALLS                    05989000
*                                                                       05990000
*        LABEL PROCESSING --                                            05991000
*                                                                       05992000
*        THE SETTING OF THE FAILURE RETURN REGISTER FOR STATEMENTS      05993000
*        AND FOR THE NOT OPERATOR IS REPRESENTED BY THE USE OF LABELS   05994000
*        OF THE FORM L#NNNN, WHERE NNNN IS AN INTEGER                   05995000
*                                                                       05996000
*        THE LADR STACK IS USED TO HOLD LABEL LOCATIONS AND LABEL       05997000
*        NUMBERS -- USING THE OBSERVATION THAT ALL SUCH                 05998000
*        REFERENCE-LABEL PAIRS ARE NESTED                               05999000
*                                                                       06000000
         DROP  CB1                FIRST BASE NOT AVAILABLE              06001000
PRCODE   MVI   LINELEFT+1,1       SET FOR NEW PAGE                      06002000
         STE   ZR,CEXPCNT         CLEAR COUNT OF CONSTANT EXPRS         06003000
         ZAP   LCNT,=P'0'         ZERO COUNT OF LABELS                  06004000
         MVI   DUBLFLG,0          CODE LISTING IS ALWAYS SINGLE SPACED  06005000
         SP    STMNO,STMNO        ZERO STATEMENT COUNT                  06006000
         MVC   BUFR,BUFR-1        CLEAR BUFFER                          06007000
         MVC   BUFR(L'TTLCOD),TTLCOD        MOVE IN TITLE LINE          06008000
         BAL   R7,LISTER          LIST TITLE LINE                       06009000
         MVC   BUFR,BUFR-1        CLEAR BUFFER                          06010000
         BAL   R7,LISTER          PRINT A BLANK LINE                    06011000
         L     R5,CODEADR         INITIALIZE ABSOLUTE CODE LOC          06012000
         L     R3,WRKSTKAD        INITIALIZE STACK OF LABELS TO GENERAT 06013000
         ST    R3,LADR            STORE IN ADDRESS CELL                 06014000
         STE   ZR,0(R3)           ZERO OUT TOP CELL (NO LABELS YET)     06015000
         B     PRCODECC+4         JUMP TO FIND FIRST STATEMENT          06016000
*                                                                       06017000
*        THIS IS THE LOOP THROUGH STATEMENTS                            06018000
*                                                                       06019000
PRCODEC  CR    R5,LC              ARE WE ALL DONE?                      06020000
         BCR   NL,RF              RETURN IF WE ARE                      06021000
         AP    STMNO,PONE         ELSE INCREMENT STATEMENT NUMBER       06022000
         CLI   0(R5),X'3D'        SHOULD WE LIST CODE FOR THIS STMNT?   06023000
         BE    PRCODECY           SKIP IF YES                           06024000
         EJECT                                                          06025000
*                                                                       06026000
*        HERE WE LOOP TO NEXT STATEMENT IF CODE IS NOT TO BE LISTED     06027000
*                                                                       06028000
PRCODECC LA    R5,2(,R5)          BUMP CODE POINTER                     06029000
         CLI   0(R5),X'3E'        NORMAL START OF STATEMENT?            06030000
         BE    PRCODEC            JUMP TO PROCESS IT IF SO              06031000
         CLI   0(R5),X'3D'        NEXT STATEMENT (LIST FLAG SET)?       06032000
         BNE   PRCODECC           LOOP BACK TO SEARCH IF NOT            06033000
         B     PRCODEC            ELSE BACK TO PROCESS NEXT STATEMENT   06034000
*                                                                       06035000
*        HERE WE HAVE A STATEMENT WHICH IS TO BE LISTED                 06036000
*                                                                       06037000
PRCODECY MVI   0(R5),X'3E'        RESET STANDARD AUR OPCODE             06038000
         STE   ZR,VEXOFS          CLEAR EXPR LIST CNTR AND TOTAL        06039000
         MVC   BUFR,BUFR-1        CLEAR PRINT BUFFER                    06040000
         MVC   BUFR+21(28),STMNTTL          MOVE IN STATEMENT NUM...    06041000
         ED    BUFR+43(6),STMNO   EDIT STATEMENT NUMBER                 06042000
         BAL   R7,LISTER          LIST STATEMENT HEADER                 06043000
         MVC   BUFR,BUFR-1        CLEAR BUFFER TO BLANKS                06044000
*                                                                       06045000
*        THE FOLLOWING SECTION DOES A SERIAL SEARCH THROUGH THE         06046000
*        DATA AREA TO LOCATE A POSSIBLE LABEL FOR THIS STATEMENT        06047000
*                                                                       06048000
         LA    R1,4*HASHTBNS-4    POINT TO LAST HASH SLOT               06049000
         ST    R5,PRLOCSV         SAVE START OF STATEMENT CODE ADDRESS  06050000
*                                                                       06051000
*        LOOP THROUGH HASH SLOTS                                        06052000
*                                                                       06053000
PRCODLL1 LR    R2,R1              COPY CURRENT HASH SLOT OFFSET         06054000
         A     R2,HASHTBAD        POINT TO SLOT IN HASH TABLE           06055000
*                                                                       06056000
*        LOOP THROUGH VARIABLE BLOCKS ON ONE HASH CHAIN                 06057000
*                                                                       06058000
PRCODLL  L     R2,VLINK(,R2)      POINT TO NEXT BLOCK ON CHAIN          06059000
         N     R2,=X'00FFFFFF'    END OF CHAIN?                         06060000
         BZ    PRCODLLE           JUMP TO END OF LOOP IF END OF CHAIN   06061000
         CLC   VLABL+1(3,R2),PRLOCSV+1      DOES LABEL MATCH THIS LOC?  06062000
         BNE   PRCODLL            LOOP BACK IF NOT                      06063000
*                                                                       06064000
*        HERE WE HAVE FOUND A LABEL TO BE PRINTED                       06065000
*                                                                       06066000
         LA    RE,VNAME(,R2)      POINT TO NAME OF BLOCK                06067000
         LA    R6,BUFR+21         SET FOR START OF LABEL                06068000
         BAL   R7,PRCODST         PRINT STRING NAME                     06069000
         LA    R0,BUFR+29         POINT TO NORMAL OPCODE POSITION       06070000
         CR    R6,R0              ARE WE BEYOND IT?                     06071000
         BNL   *+6                SKIP IF SO                            06072000
         LR    R6,R0              ELSE MOVE POINTER OVER TO OPCODE      06073000
         MVC   0(8,R6),EQU#       MAKE  EQU *                           06074000
         BAL   R7,LISTER          LIST   LABEL  EQU  *                  06075000
         B     PRCODLLP           JUMP TO PRINT CODE FOR STATEMENT      06076000
         EJECT                                                          06077000
*                                                                       06078000
*        HERE TO MOVE TO NEXT HASH SLOT                                 06079000
*                                                                       06080000
PRCODLLE SH    R1,=H'4'           POINT TO NEXT HASH SLOT               06081000
         BNM   PRCODLL1           LOOP BACK IF MORE SLOTS TO GO         06082000
*                                                                       06083000
*        COME HERE AFTER DEALING WITH LABEL TO LIST THE CODE            06084000
*                                                                       06085000
PRCODLLP BAL   R4,PRCODEL         CALL ROUTINE TO LIST CODE FOR STMNT   06086000
         ST    R5,PRLOCSV         SAVE CURRENT CODE LOCATION            06087000
*                                                                       06088000
*        HERE WE LIST CODE FOR CONSTANT EXPRESSIONS REFERENCED IN THIS  06089000
*        STATEMENT. THE LIST IN THE 'VEXSTAK' CONTAINS TWO WORD ENTRIES 06090000
*        THE FIRST WORD POINTS TO THE CODE FOR THE EXPRESSION.          06091000
*        THE SECOND WORD CONTAINS THE NUMBER OF THE EXPRESSION          06092000
*                                                                       06093000
*        AFTER THE CALL TO PRCODEL, VEXOFS IS THE FINAL OFFSET IN THIS  06094000
*        LIST. VEXPTR IS USED AS A CONTROLLING COUNTER FOR THE LOOP     06095000
*                                                                       06096000
PRCODLLX LH    R1,VEXPTR          LOAD CURRENT POINTER (STARTS AT 0)    06097000
         CH    R1,VEXOFS          ALL DONE YET?                         06098000
         L     R5,PRLOCSV         RELOAD CODE POINTER IN CASE YES       06099000
         BE    PRCODEC            LOOP BACK IF ALL ENTRIES PROCESSED    06100000
         LA    R0,8(,R1)          ELSE UPDATE POINTER                   06101000
         STH   R0,VEXPTR          STORE INCREMENTED POINTER             06102000
         L     R5,0(LC,R1)        LOAD POINTER TO CODE                  06103000
         SR    R7,R7              SET TYPE CODE = INTEGER FOR PRCODNM   06104000
         L     RE,4(LC,R1)        LOAD ID NUMBER OF CONSTANT FOR MSG    06105000
         STH   RE,VEXNUM          SAVE NUMBER OF CURRENT ITEM           06106000
         MVC   BUFR,BUFR-1        CLEAR PRINT BUFFER                    06107000
         MVI   BUFR+21,C'*'       ADD * FOR COMMENT                     06108000
         MVC   BUFR+27(L'CONHED),CONHED     SET 'CODE TO COMPUTE CONS.' 06109000
         LA    R6,BUFR+27+L'CONHED          POINT PAST MESSAGE, MERGE   06110000
*                                                                       06111000
*        HERE TO ADD PROPER IDENTIFICATION NUMBER                       06112000
*                                                                       06113000
PRCODLLM BAL   R3,PRCODNM         PRINT INTEGER ID NUMBER               06114000
         BAL   R7,LISTER          LIST HEADER LINE                      06115000
         BAL   R4,PRCODEL         LIST CODE FOR EXPRESSION              06116000
         B     PRCODLLX           LOOP BACK FOR NEXT EXPR               06117000
         EJECT                                                          06118000
*                                                                       06119000
*        SUBROUTINE TO PRINT ONE SECTION OF CODE UP TO AN AUR           06120000
*                                                                       06121000
*        BAL   R4,PRCODEL                                               06122000
*        (R5)                     POINTER TO CURRENT CODE LOCATION      06123000
*                                                                       06124000
*        USED TO PRINT CODE FOR A STATEMENT OR A CONSTANT EXPRESSION    06125000
*                                                                       06126000
*        THIS IS ALSO THE LOOP FOR SUCCESSIVE INSTRUCTIONS              06127000
*                                                                       06128000
PRCODEL  MVC   BUFR,BUFR-1        CLEAR BUFFER                          06129000
         ST    R5,PRWRK           SAVE CODE LOCATION                    06130000
         UNPK  BUFR(6+1),PRWRK+1(3+1)       UNPACK TO PRINT IN HEX      06131000
         MVI   BUFR+6,C' '        BLANK EXTRA GARBAGE CHARACTER         06132000
         TR    BUFR(6),HEXPRT     TRANSLATE TO PRINTABLE HEX DIGITS     06133000
         UNPK  BUFR+9(4+1),0(2+1,R5)        UNPACK FIRST TWO BYTES      06134000
         MVI   BUFR+13,C' '       BLANK OUT EXTRA CHARACTER             06135000
         TR    BUFR+9(4),HEXPRT   TRANSLATE TO HEX DIGITS               06136000
         SR    RE,RE              CLEAR FOR IC                          06137000
         IC    RE,1(,R5)          LOAD SECOND BYTE                      06138000
         SRL   RE,4               ISOLATE REGISTER FOR LATER USE        06139000
         LA    R6,BUFR+36         INITIALIZE POINTER TO START OF VAR FL 06140000
         L     R3,LADR            GET ADDRESS OF CURRENT LABEL          06141000
         C     R5,0(R3)           SHOULD WE PRINT A LABEL AT THIS LOC?  06142000
         BNE   PRCOD1             SKIP IF NOT                           06143000
         MVC   BUFR+21(6),PREDIT  ELSE GET PATTERN TO PRINT LABEL       06144000
         ED    BUFR+22(5),4(R3)   EDIT LABEL INTO THE FORM L0NNNN       06145000
         MVI   BUFR+22,C'.'       SET 2ND CHARACTER AS .                06146000
         SH    R3,=H'8'           REMOVE TOP ENTRY ON LABEL STACK       06147000
         ST    R3,LADR            STORE NEW LABEL STACK ADDRESS         06148000
*                                                                       06149000
*        JUMP HERE WHEN THERE IS NO LABEL TO PRINT                      06150000
*                                                                       06151000
PRCOD1   TM    0(R5),X'C0'        TEST FOR 4 BYTE OPERATION             06152000
         BZ    PRCODRR            SKIP IF NOT                           06153000
         UNPK  BUFR+14(4+1),2(2+1,R5)       UNPACK SECOND 2 BYTE GROUP  06154000
         MVI   BUFR+18,C' '       BLANK OUT EXTRA CHARACTER             06155000
         TR    BUFR+14(4),HEXPRT  TRANSLATE TO HEX DIGITS               06156000
         EJECT                                                          06157000
*                                                                       06158000
*        WE NOW HAVE TO GENERATE THE SYMBOLIC LINE FOR A FOUR BYTE      06159000
*        INSTRUCTION -- THE POSSIBILITIES ARE LM,STM,BAL,L,LA,ST,MVI,B, 06160000
*        O,C. WE RELY ON KNOWLEDGE OF WHAT SPITBOL GENERATES,           06161000
*        IF AN INSTRUCTION IS INCOMPREHENSIBLE, NO SYMBOLIC IS LISTED   06162000
*                                                                       06163000
PRCODRX  CLC   0(2,R5),NOP$       IS THIS A NOP? (STATEMENT NUMBER)     06164000
         BE    PRCODNOP           SKIP IF SO (SPECIAL CASE)             06165000
         LA    R3,PRCRXTB         ELSE INITIALIZE OPCODE TABLE POINTER  06166000
         LA    R2,10              SET FOR 10 ENTRIES TO SEARCH          06167000
*                                                                       06168000
*        LOOP THROUGH POSSIBILITIES FOR FOUR BYTE INSTRUCS              06169000
*                                                                       06170000
PRCODRXC CLC   0(1,R3),0(R5)      IS THIS THE ONE?                      06171000
         BE    PRCODX1            SKIP IF YES                           06172000
         LA    R3,4(R3)           ELSE BUMP POINTER TO NEXT ENTRY       06173000
         BCT   R2,PRCODRXC        AND JUMP BACK IF MORE TO GO           06174000
*                                                                       06175000
*        EXIT POINT FOR 4 BYTE INSTRUCTION PROCESSING                   06176000
*                                                                       06177000
PRCODXL  LA    R5,4(,R5)          BUMP ABSOLUTE CODE LOC                06178000
         B     PRCODRD            MERGE WITH RR END OR PROCESSING       06179000
*                                                                       06180000
*        4-BYTE INSTRUCTION TABLE                                       06181000
*                                                                       06182000
PRCRXTB  DC    X'98'                                                    06183000
         DC    CL3'LM'                                                  06184000
         DC    X'90'                                                    06185000
         DC    CL3'STM'                                                 06186000
         DC    X'45'                                                    06187000
         DC    CL3'BAL'                                                 06188000
         DC    X'58'                                                    06189000
         DC    CL3'L'                                                   06190000
         DC    X'41'                                                    06191000
         DC    CL3'LA'                                                  06192000
         DC    X'50'                                                    06193000
         DC    CL3'ST'                                                  06194000
         DC    X'92'                                                    06195000
         DC    CL3'MVI'                                                 06196000
         DC    X'47'                                                    06197000
         DC    CL3'B'                                                   06198000
         DC    X'59'                                                    06199000
         DC    CL3'C'                                                   06200000
         DC    X'56'                                                    06201000
         DC    CL3'O'                                                   06202000
         EJECT                                                          06203000
*                                                                       06204000
*        COME HERE WHEN OP CODE IS LOCATED                              06205000
*                                                                       06206000
PRCODX1  MVC   BUFR+30(3),1(R3)   MOVE IN MNEMONIC                      06207000
         CLI   0(R5),X'92'        CHECK FOR CASE OF MVI                 06208000
         BE    PRCODX4            SKIP REG PRINT IF MVI                 06209000
         CLI   0(R5),X'47'        IS IT A B?                            06210000
         BE    PRCODX3            SKIP REG PRINT IF BRANCH              06211000
         BAL   R7,PRCODERG        PRINT REGISTER                        06212000
         MVI   0(R6),C','         MOVE IN A COMMA                       06213000
         LA    R6,1(R6)           BUMP POINTER PAST ,                   06214000
         TM    0(R5),X'80'        IS THIS A LM OR STM?                  06215000
         BZ    PRCODX3            SKIP IF NOT                           06216000
         MVC   BUFR+39(2),BUFR+36 COPY REG NAME (A1 OR A2)              06217000
         MVC   BUFR+41(3),PONE#   APPEND +1,                            06218000
         LA    R6,BUFR+44         SET NEW POINTER LOCATION              06219000
*                                                                       06220000
*        SKIP HERE IF NOT LM OR STM                                     06221000
*                                                                       06222000
PRCODX3  TM    1(R5),R2           CHECK FOR INDEX REGISTER R2           06223000
         BNO   PRCODX4            SKIP IF NOT                           06224000
         TM    1(R5),X'0F'-R2     FURTHER CHECK FOR R2 XR               06225000
         BNZ   PRCODX4            SKIP IF NOT R2                        06226000
*                                                                       06227000
*        THIS IS THE CASE OF THE LA FRETURN,... OR THE BAL FRETURN,...  06228000
*        (USING BASE REGISTER R2) AT THE BEGINNING OF A STATEMENT       06229000
*        THE SYMBOLIC LISTING FOR THIS USES LABELS OF THE FORM L.NNNN   06230000
*        THE LADR STACK HOLDS THE LABEL ADDRESSES TO BE PRINTED         06231000
*                                                                       06232000
         LR    R0,R5              COPY CURRENT CODE LOC                 06233000
         AH    R0,2(R5)           ADD DISPLACEMENT TO GET LABEL ADDRESS 06234000
         AP    LCNT,PONE          BUMP LABEL COUNT                      06235000
         L     R3,LADR            GET LABEL STACK ADDRESS               06236000
         LA    R3,8(R3)           MAKE ROOM FOR NEW ENTRY               06237000
         ST    R3,LADR            STORE NEW LABEL STACK POINTER         06238000
         ST    R0,0(R3)           STORE LABEL ADDRESS                   06239000
         MVC   4(3,R3),LCNT       STORE LABEL NUMBER                    06240000
         MVC   0(6,R6),PREDIT     MOVE IN PATTERN                       06241000
         ED    1(5,R6),LCNT       ADD L/NNNN TO CURRENT LINE            06242000
         MVI   1(R6),C'.'         CHANGE 2ND CHAR TO .                  06243000
         B     PRCODXL            LEAVE                                 06244000
*                                                                       06245000
*        CONTINUATION OF 4-BYTE INSTRUCTION SYMBOLIC FIELD PROCESSING   06246000
*                                                                       06247000
PRCODX4  MVC   PRWRK(1),2(R5)     PICK UP BASE REGISTER                 06248000
         NI    PRWRK,X'F0'        ISOLATE BASE REGISTER                 06249000
         CLI   PRWRK,16*SYS       CHECK FOR REF TO SYS REG              06250000
         BNE   PRCODX5            SKIP IF NOT SYS REF                   06251000
         EJECT                                                          06252000
*                                                                       06253000
*        THIS SECTION IS USED TO PRINT THE NAME OF A SPECIAL FIELD      06254000
*        IT IS USED FOR REFERENCES TO SYSTEM ROUTINES ON THE SYS        06255000
*        BASE REGISTER. OR REFERENCE TO SPECIAL FIELD IN THE USER AREA  06256000
*        SUCH AS $$LAST AND THE LOCATIONS OF ADDRESSES FOR OPERATORS    06257000
*        TREATED AS FUNCTIONS (E.G. $$QUS2 -- BINARY ?)                 06258000
*                                                                       06259000
PRCODX4J LA    R2,SYSUBNMS        INITIALIZE TABLE POINTER              06260000
         LA    R3,(ENDSSBNM-SYSUBNMS)/6     SET NUMBER OF ENTRIES IN TB 06261000
         MVC   0(2,R6),$$BAS#     SET $$ IN PLACE                       06262000
*                                                                       06263000
*        LOOP TO SEARCH THROUGH NAMES                                   06264000
*                                                                       06265000
PRCODX4L CLC   2(2,R5),0(R2)      IS THIS THE ONE?                      06266000
         BE    PRCODX4E           SKIP IF YES                           06267000
         LA    R2,6(R2)           ELSE STEP TO NEXT TABLE LOCATION      06268000
         BCT   R3,PRCODX4L        BACK FOR NEXT ENTRY                   06269000
*                                                                       06270000
*        IF WE FALL THROUGH, WE END UP USING THE LAST DUMMY ENTRY ????  06271000
*        WHICH INDICATES THAT SOMETHING FUNNY HAS BEEN FOUND            06272000
*                                                                       06273000
*                                                                       06274000
*        COME HERE WHEN NORMAL ENTRY IS FOUND                           06275000
*                                                                       06276000
PRCODX4E MVC   2(4,R6),2(R2)      MOVE IN ROUTINE NAME                  06277000
         B     PRCODXL            ALL DONE WITH THIS LINE               06278000
*                                                                       06279000
*        TABLE OF SYSTEM FUNCTION NAMES AND LOCATIONS                   06280000
*                                                                       06281000
SYSUBNMS EQU   *                                                        06282000
         NAME  CNC2,DLR2,DL1N,DL1V,DOT2,DVD2,EXP2,FING,IDNT             06283000
         NAME  ADD1,ADD2,ANYP,ARMN,ARMV,AR1N,AR1V,AST1,ATSP,BRKP,CMPR   06284000
         NAME  MLT2,NTNP,ORP2,PATA,POSP,PTN2,PTV2,READ                  06285000
         NAME  EXC1,PCT1,SLS1,PND1,BAR1,NOT2,QUS2,PCT2,PND2,ATS2,AMP2   06286000
         NAME  RPSP,RTBP,SPNP,SUB1,SUB2,TABP,STOP,SERR,FRVN             06287000
         NAME  LENP,DLRD,DOTD,EVLR,INTG,ASSN,RASN,BRKX                  06288000
         NAME  KGET,KPUT,INCR,DECR,PTNL,LCMP                            06289000
         NAME  NULL,LAST,GOTO,NMVL,DGTO,ATSD,MCOD                       06290000
ENDSSBNM EQU   *                                                        06291000
         DC    C'??????'          DUMMY ENTRY FOR USE IF NOT FOUND      06292000
         EJECT                                                          06293000
*                                                                       06294000
*        CHECK FOR AND DEAL WITH CASE OF DATA REFERENCE                 06295000
*                                                                       06296000
PRCODX5  LM    R1,R2,$$BAS2       LOAD $$BAS2,3 VALUES TO (R2,R3)       06297000
         CLI   PRWRK,16*DB2       DB2 REFERENCE?                        06298000
         BE    PRCODX5C           SKIP IF SO WITH R1 SET TO BASE        06299000
         LR    R1,R2              ELSE SET $$BAS3 IN PLACE              06300000
         CLI   PRWRK,16*DB3       TEST FOR DB3 REFERENCE                06301000
         BE    PRCODX5C           SKIP IF SO WITH BASE SET IN (R1)      06302000
         CLI   PRWRK,16*DB1       CHECK FOR DB1 REFERENCE               06303000
         BE    PRCODX5A           SKIP IF DB1 REFERENCE                 06304000
         CLI   PRWRK,16*DB4       CHECK FOR DB4 REFERENCE               06305000
         BNE   PRCODX9            JUMP IF NOT DB1-DB4 REFERENCE         06306000
*                                                                       06307000
*        REFERENCE TO DB4 COMES HERE                                    06308000
*                                                                       06309000
         L     R1,CODBASE         LOAD PREVIOUSLY SET DB4 VALUE IN CASE 06310000
         CLC   0(4,R5),BALFR2$    SPECIAL BAL RETURN,FCODE(,DB4) CASE?  06311000
         BNE   PRCODX5C           IF NOT, SKIP WITH R1 SET TO BASE      06312000
         MVC   0(11,R6),FCODE#    IF SO, SET 'FCODE(,DB4)'              06313000
         LA    R6,11(,R6)         BUMP PAST IT                          06314000
         B     PRCODXL            ALL DONE WITH THIS INSTRUCTION        06315000
*                                                                       06316000
*        HERE FOR A DB1 REFERENCE                                       06317000
*                                                                       06318000
PRCODX5A LR    R1,DREG            COPY $$BAS1 ADDRESS                   06319000
         CLC   2(2,R5),S$$BAS32   CHECK FOR $$BASXX REFERENCE           06320000
         BH    PRCODX5B           SKIP IF NOT                           06321000
         LH    RE,2(,R5)          LOAD S ADDRESS                        06322000
         SH    RE,S$$BAS1M        SUBTRACT TO GET OFFSET INTO TABLE     06323000
         L     R0,$$BAS1-4(RE)    LOAD ENTRY FROM BASE TABLE            06324000
         ST    R0,CODBASE         SAVE FOR LATER REFERENCES             06325000
         SRL   RE,2               DIVIDE BY 4 TO GET BASE NUMBER        06326000
         SR    R7,R7              SET INTEGER CODE FOR PRCODNM          06327000
         MVC   0(5,R6),$$BAS#     SET '$$BAS'                           06328000
         LA    R6,5(,R6)          BUMP PAST IT                          06329000
         BAL   R3,PRCODNM         PRINT BASE NUMBER                     06330000
         B     PRCODXL            DONE WITH INSTRUCTION                 06331000
*                                                                       06332000
*        HERE FOR DB1 REFERENCE NOT $$BAS TABLE REFERENCE               06333000
*                                                                       06334000
PRCODX5B CLC   2(2,R5),S$$USER    SPECIAL REFERENCE? ($$LAST OR OPTR)   06335000
         BH    PRCODX5C           SKIP IF NOT WITH R1=$$BAS1 VALUE      06336000
         B     PRCODX4J           IF SPECIAL FIELD, MERGE TO PRINT NAME 06337000
*                                                                       06338000
*        S CONSTANTS FOR ABOVE CHECKS, SINCE NO S LITERALS (UGH)        06339000
*                                                                       06340000
S$$BAS32 DC    S($$BAS32)         LAST REF FOR $$BASXX REFERENCE        06341000
S$$BAS1M DC    S($$BAS1-4)        BASE S ADDRESS FOR BASE REG TABLE     06342000
S$$USER  DC    S(DATABGN-VALUE-1) END OF SPECIAL VALUES IN DATA AREA    06343000
         EJECT                                                          06344000
*                                                                       06345000
*        HERE FOR REF TO VARIABLE OR CONSTANT, (R1) = BASE VALUE        06346000
*                                                                       06347000
PRCODX5C LH    R0,2(,R5)          LOAD S ADDRESS                        06348000
         N     R0,=X'00000FFF'    ISOLATE DISPLACEMENT                  06349000
         AR    R1,R0              ADD DISPLACEMENT TO BASE              06350000
         CLI   0(R5),X'41'        IS THIS A LA (ACTUAL BLOCK REF)       06351000
         LA    RE,VNAME(,R1)      POINT TO NAME POINTER IN CASE         06352000
         BE    PRCODX6            SKIP IF IT IS AN LA                   06353000
         MVI   0(R6),C'='         SET = IN CASE THIS IS A LITERAL       06354000
         TM    0(R5),X'80'        ELSE IS IT LM OR STM?                 06355000
         BZ    PRCODX7            SKIP IF NOT                           06356000
         CLI   VALUE-VALUE(R1),NCODE        IS OPERAND NULL?            06357000
         BE    PRCODX5M           SKIP IF SO (MUST BE VARIABLE BLOCK)   06358000
         CLI   VALUE-VALUE(R1),PCODE        IS OPERAND A PATTERN?       06359000
         BE    PRCODX5M           SKIP IF SO (MUST BE VARIABLE)         06360000
*                                                                       06361000
*        HERE FOR LITERAL, TEST FOR NUMERIC                             06362000
*                                                                       06363000
         L     R7,VALUE-VALUE(,R1)          LOAD FIRST WORD OF VALUE    06364000
         LTR   R7,R7              TEST TYPES                            06365000
         BP    PRCODX5F           SKIP IF NON-NUMERIC                   06366000
         LA    R6,1(,R6)          ELSE BUMP PAST EQUALS SIGN            06367000
         L     RE,VALUE-VALUE+4(,R1)        LOAD 2ND WORD OF CONSTANT   06368000
         BAL   R3,PRCODNM         PRINT VALUE OF LITERAL                06369000
         B     PRCODXL            ALL DONE                              06370000
*                                                                       06371000
*        NEXT POSSIBILITY IS A STRING LITERAL                           06372000
*                                                                       06373000
PRCODX5F CLI   VALUE-VALUE(R1),SCODE        IS IT A STRING?             06374000
         BNE   PRCODX5G           SKIP IF NOT                           06375000
         MVI   1(R6),C''''        SET ' MARK                            06376000
         LA    R6,2(R6)           BUMP POINTER PAST ='                  06377000
         LR    RE,R1              POINT TO VALUE                        06378000
         BAL   R7,PRCODST         AND PRINT STRING                      06379000
         MVI   0(R6),C''''        ADD A TERMINAL '                      06380000
         B     PRCODXL            LEAVE                                 06381000
*                                                                       06382000
*        NEXT POSSIBILITY IS A SIMPLE VARIABLE AS AN EXPRESSION         06383000
*                                                                       06384000
PRCODX5G CLI   VALUE-VALUE(R1),VCODE        IS IT *(VARIABLE) ?         06385000
         BNE   PRCODX5H           SKIP IF NOT                           06386000
         LA    RE,VNAME(,R7)      POINT TO NAME                         06387000
         MVI   1(R6),C'*'         MOVE A * INTO PLACE                   06388000
         LA    R6,2(,R6)          BUMP PAST =*                          06389000
         BAL   R7,PRCODST         PRINT THE NAME                        06390000
         B     PRCODXL            AND LEAVE                             06391000
         EJECT                                                          06392000
*                                                                       06393000
*        LAST POSSIBILITY IS REFERENCE TO A CONSTANT EXPRESSION         06394000
*                                                                       06395000
PRCODX5H CLI   VALUE-VALUE(R1),KCODE        TEST FOR CONSTANT EXPR      06396000
         BNE   PRCODXL            IF NOT, MUST BE GARBAGE, LEAVE        06397000
         MVC   0(5,R6),CONS##     SET 'CONS#'                           06398000
         LA    R6,5(,R6)          POINT PAST IT                         06399000
         L     R1,VALUE-VALUE(,R1)          LOAD RELATIVE CODE PTR      06400000
         A     R1,SUBEXTOP        MAKE CODE PTR ABSOLUTE                06401000
         LH    RE,VEXNUM          LOAD EXPR NUMBER IN CASE STM INSTRUC  06402000
         CLI   0(R5),X'98'        IS THIS AN LM INSTRUCTION?            06403000
         BNE   PRCODX5K           SKIP IF NOT (STM, RE SET OK)          06404000
         L     RE,CEXPCNT         ELSE LOAD COUNTER OF EXPR'S           06405000
         LA    RE,1(,RE)          INCREMENT COUNTER                     06406000
         ST    RE,CEXPCNT         STORE INCREMENTED COUNTER             06407000
         LH    R3,VEXOFS          LOAD CURRENT OFFSET INTO VEXSTAK      06408000
         LA    R0,8(,R3)          INCREMENT OFFSET                      06409000
         STH   R0,VEXOFS          STORE INCREMENTED POINTER             06410000
         ST    R1,0(LC,R3)        STORE POINTER TO CODE                 06411000
         ST    RE,4(LC,R3)        SAVE IDENTIFICATION NUJBER            06412000
*                                                                       06413000
*        MERGE HERE TO PRINT EXPRESSION NUMBER (NUMBER IS IN (RE) )     06414000
*                                                                       06415000
PRCODX5K SR    R7,R7              SET TYPE CODE = 0 = ICODE = INTEGER   06416000
         BAL   R3,PRCODNM         PRINT NUMBER                          06417000
         B     PRCODXL            DONE WITH THIS INSTRUCTION            06418000
*                                                                       06419000
*        COME HERE ON DATA REFERENCE BY VALUE IN VARIABLE BLOCK         06420000
*        FOR THIS WE GENERATE A REF TO VAL.VARIABLENAME                 06421000
*                                                                       06422000
PRCODX5M MVC   0(4,R6),VAL#       MOVE IN VAL.                          06423000
         LA    RE,VNAME-VALUE(,R1)          POINT TO NAME               06424000
         EJECT                                                          06425000
*                                                                       06426000
*        FNC. AND LBL. CASES MERGE HERE                                 06427000
*                                                                       06428000
PRCODX5N LA    R6,4(R6)           BUM POINTER PAST VAR. (OR FNC. LBL.)  06429000
*                                                                       06430000
*        LA CASE MERGES HERE                                            06431000
*                                                                       06432000
PRCODX6  BAL   R7,PRCODST         PRINT VARIABLE NAME                   06433000
         B     PRCODX11           AND JUMP TO TEST FOR POSSIBLE MVI     06434000
*                                                                       06435000
*        IF A REF TO THE DATA AREA IS NOT A LA,LM OR STM IT MUST BE     06436000
*        L     R1,LBL.VARNAME     FOR A GOTO                            06437000
*  OR    L     DB4,FNC.VARNAME    FOR A FUNCTION CALL                   06438000
*  OR    L     FRETURN,LBL.VARNAME                                      06439000
*                                                                       06440000
PRCODX7  CLI   0(R5),X'58'        DO WE HAVE A LOAD?                    06441000
         BNE   PRCODXL            LEAVE IF NOT (???)                    06442000
         SH    R1,=H'32'          REDUCE R1 TO GET + DISP IN FOLLOWING  06443000
         CLI   1(R5),16*FRETURN   TEST FOR L FRETURN, CASE              06444000
         BE    PRCODX8            SKIP ON THIS CASE TO GENERATE LBL.    06445000
         CLI   1(R5),16*R1        TEST FOR L  R1,  CASE                 06446000
         BE    PRCODX8            JUMP ON THIS CASE OF LBL.             06447000
         LA    RE,32+VNAME-VFUNC(,R1)       ELSE IS FUNC, POINT TO NAME 06448000
         MVC   0(4,R6),FNC#       PUT IN FNC.                           06449000
         B     PRCODX5N           AND MERGE                             06450000
*                                                                       06451000
*        COME HERE FOR REFERENCE TO LABEL FIELD                         06452000
*                                                                       06453000
PRCODX8  LA    RE,32+VNAME-VLABL(,R1)       POINT TO NAME FOR LABEL     06454000
         MVC   0(4,R6),LBL#       PUT IN LBL.                           06455000
         B     PRCODX5N           AND MERGE                             06456000
*                                                                       06457000
*        THIS SECTION CHECKS FOR AND DEALS WITH REFERENCES TO PDR       06458000
*        (TEMPORARY STACK LOCATION REFERENCES WITH THE EXCEPTION OF     06459000
*        THE LA USED IN ARRAY AND FUNCTION CALLS)                       06460000
*        THE FIELD PRINTED IS TEM.NN WHERE NN IS THE NUMBER OF THE      06461000
*        TEMPORARY                                                      06462000
*                                                                       06463000
PRCODX9  CLI   PRWRK,16*PDR       IS BASE REG PDR?                      06464000
         BNE   PRCODX12           SKIP IF NOT                           06465000
         CLI   0(R5),X'41'        IS THIS THE LA CASE                   06466000
         BE    PRCODX12           SKIP TO DEFAULT CASE IF YES           06467000
         LH    R1,2(R5)           PICK UP TEM STACK S ADDRESS           06468000
         N     R1,=A(X'FFFF')     AND OUT EXTENDED SIGN BIT             06469000
         S     R1,TEMSTKBS        SUBTRACT BASE ADDRESS                 06470000
         LCR   RE,R1              GET RIGHT SIGN                        06471000
         SRA   RE,3               DIVIDE TO GET TEMP NUMBER             06472000
         MVC   0(4,R6),TEM#       MOVE IN TEM#                          06473000
         LA    R6,4(R6)           BUMP POINTER PAST TEM.                06474000
         SR    R7,R7              INDICATE INTEGER TYPE                 06475000
         BAL   R3,PRCODNM         PRINT TEMP NUM                        06476000
         B     PRCODX11           ALL       DONE                        06477000
         EJECT                                                          06478000
*                                                                       06479000
*        IF WE GET HERE, USE THE DEFAULT DISPLACEMENT(,BASE) FORMAT     06480000
*                                                                       06481000
PRCODX12 LH    RE,2(,R5)          GET BASE-DISPLACEMENT                 06482000
         N     RE,=X'00000FFF'    MASK OUT BASE                         06483000
         SR    R7,R7              INDICATE INTEGER TYPE                 06484000
         BAL   R3,PRCODNM         PRINT DISPLACEMENT                    06485000
         SR    RE,RE              CLEAR FOR IC                          06486000
         IC    RE,2(,R5)          PICK UP BASE REG                      06487000
         SRA   RE,4               ISOLATE BASE REG                      06488000
         BZ    PRCODXL            ALL DONE IF ZERO BASE REG             06489000
         MVC   0(2,R6),LPC#       MOVE IN (,                            06490000
         LA    R6,2(R6)           BUMP POINTER PAST (,                  06491000
         BAL   R7,PRCODERG        PRINT REGISTER NAME                   06492000
         MVI   0(R6),C')'         ADD TERMINAL )                        06493000
         LA    R6,1(R6)           BUMP PAST )                           06494000
*                                                                       06495000
*        COME HERE WHEN WE ARE DONE PRINTING OPERAND FIELD              06496000
*                                                                       06497000
PRCODX11 CLI   0(R5),X'92'        TEST FOR MVI CASE                     06498000
         BNE   PRCODXL            ALL DONE WITH THIS LINE IF NOT        06499000
*                                                                       06500000
*        FOR MVI, ADD IMMEDIATE OPERAND AFTER COMMA                     06501000
*                                                                       06502000
         MVI   0(R6),C','         ADD A COMMA                           06503000
         LA    R6,1(,R6)          BUMP PAST THE COMMA                   06504000
         LA    R3,PRCODXL         SET EXIT ADDRESS                      06505000
         MVC   0(5,R6),NCODE#     SET 'NCODE'                           06506000
         LR    RE,R6              SAVE BUFFER POINTER                   06507000
         LA    R6,5(,R6)          BUMP BUFFER POINTER                   06508000
         CLI   1(R5),NCODE        IS IT REFERENCE TO NCODE?             06509000
         BCR   E,R3               ALL SET IF SO                         06510000
         MVI   0(RE),C'E'         ELSE CHANGE TO 'ECODE'                06511000
         CLI   1(R5),ECODE        DO WE HAVE A REF TO ECODE?            06512000
         BCR   E,R3               ALL SET IF SO                         06513000
         LR    R6,RE              ELSE RESET BUFFER POINTER             06514000
         SR    RE,RE              CLEAR FOR IC                          06515000
         IC    RE,1(,R5)          LOAD MVI OPERAND                      06516000
         SR    R7,R7              SET INTEGER TYPE                      06517000
         MVC   1(4,R6),5(R6)      BLANK OUT GARBAGE ('CODE')            06518000
         B     PRCODNM            EXIT VIA ROUTINE TO PRINT INTEGER     06519000
*                                                                       06520000
*        SECTION TO PRINT SYMBOLIC FIELD OF RR TYPE INSTRUCTIONS        06521000
*        THE POSSIBILITIES ARE LR,SR,BALR,BCR,AR                        06522000
*                                                                       06523000
PRCODRR  CLI   0(R5),X'18'        IS IT LR?                             06524000
         BNE   PRCODR1            SKIP IF NOT                           06525000
         MVC   BUFR+30(2),LR#     MOVE IN LR                            06526000
         B     PRCODR2            AND MERGE                             06527000
         EJECT                                                          06528000
*                                                                       06529000
*        HERE TEST FOR CASE OF SR                                       06530000
*                                                                       06531000
PRCODR1  CLI   0(R5),X'1B'        IS IT SR?                             06532000
         BNE   PRCODR3            SKIP IF NOT                           06533000
         MVC   BUFR+30(2),SR#     ELSE MOVE IN SR                       06534000
*                                                                       06535000
*        AR,SR,LR MERGE HERE -- IN THESE CASES, PRINT REG NAMES         06536000
*                                                                       06537000
PRCODR2  BAL   R7,PRCODERG        PRINT REG NAME                        06538000
*                                                                       06539000
*        BCR,BALR MERGE HERE TO PRINT SECOND REG NAME                   06540000
*                                                                       06541000
PRCODR2A MVI   0(R6),C','         MOVE IN COMMA                         06542000
         LA    R6,1(R6)           BUMP POINTER OVER ,                   06543000
*                                                                       06544000
*        BR MERGES HERE TO PRINT REGISTER NAME                          06545000
*                                                                       06546000
PRCODR2B IC    RE,1(,R5)          PICK UP SECOND REG                    06547000
         N     RE,=X'0000000F'    ISOLATE SECOND REG                    06548000
         BAL   R7,PRCODERG        PRINT SECOND REG NAME                 06549000
         B     PRCODRL            ALL DONE                              06550000
*                                                                       06551000
*        TEST FOR AND DEAL WITH BALR -- THIS IS A SPECIAL CASE SINCE    06552000
*        WE WANT TO PRINT BALR R2,0 NOT BALR R2,R0                      06553000
*                                                                       06554000
PRCODR3  CLI   0(R5),X'05'        IS THIS BALR?                         06555000
         BNE   PRCODR4            SKIP IF NOT                           06556000
         MVC   BUFR+30(4),BALR#   IF IT IS, MOVE IN OPCODE              06557000
         BAL   R7,PRCODERG        PRINT FIRST REG                       06558000
         TM    1(R5),X'0F'        TEST SECOND REG                       06559000
         BNZ   PRCODR2A           CARRY ON IF NON-ZERO                  06560000
         MVC   0(2,R6),CMZ#       ELSE MOVE IN ,0                       06561000
         B     PRCODRL            AND LEAVE                             06562000
*                                                                       06563000
*        HERE IS THE SPECIAL PROCESSING FOR BCR                         06564000
*        IF THE BRANCH IS UNCONDITIONAL, WE PRINT BR REGNAME            06565000
*        OTHERWISE, WE PRINT BCR MM,REGNAME WHERE MM IS A CODE          06566000
*                                                                       06567000
PRCODR4  CLI   0(R5),X'07'        IS THIS A BCR?                        06568000
         BNE   PRCODR6            SKIP IF NOT                           06569000
         TM    1(R5),X'F0'        IS THE BRANCH UNCONDITIONAL (CC=15)   06570000
         BO    PRCODR5            SKIP IF YES                           06571000
         MVC   BUFR+30(3),BCR#    ELSE SET BCR AS MNEMONIC              06572000
         N     RE,=X'000000FE'    CLEAR LOW ORDER BIT OF MASK           06573000
         LA    RE,CCTBL-2(RE)     POINT TO CORRECT BRANCH MNEMONIC      06574000
         MVC   BUFR+36(2),0(RE)   MOVE IT IN                            06575000
         LA    R6,2(R6)           BUMP POINTER PAST IT                  06576000
         B     PRCODR2A           MERGE TO PRINT SECOND REG NAME        06577000
         EJECT                                                          06578000
*                                                                       06579000
*        COME HERE FOR BR (UNCONDITIONAL BRANCH)                        06580000
*                                                                       06581000
PRCODR5  MVC   BUFR+30(2),BR#     SET BR MNEMONIC                       06582000
         B     PRCODR2B           JUMP TO PRINT REGNAME                 06583000
*                                                                       06584000
*        COME HERE TO CHECK FOR AUR, SUR                                06585000
*                                                                       06586000
PRCODR6  TM    0(R5),X'3E'        IS IT AUR (3E) OR SUR (3F)?           06587000
         BNO   PRCODR7            SKIP IF NOT                           06588000
         MVC   BUFR+30(15),AUR#   ELSE PUT AUR  SCNT,SINC IN BUFFER     06589000
         CLI   1(R5),SCNT*4+ZR    IS OPERAND SCNT,ZR?                   06590000
         BNE   *+10               SKIP IF NOT                           06591000
         MVC   BUFR+30+11(4),ZR#  ELSE REPLACE 2ND SCNT BY ZR           06592000
         B     PRCODRL            ALL DONE                              06593000
*                                                                       06594000
*        COME HERE TO CHECK FOR AR                                      06595000
*                                                                       06596000
PRCODR7  CLI   0(R5),X'1A'        CHECK FOR AR                          06597000
         BNE   PRCODRL            SKIP IF NOT (???)                     06598000
         MVC   BUFR+30(2),AR#     MOVE IN AR MNEMONIC                   06599000
         B     PRCODR2            JUMP TO PRINT REGNAMES                06600000
*                                                                       06601000
*        HERE FOR SPECIAL CASE OF STATEMENT NUMBER (NOP INSTRUCTION)    06602000
*                                                                       06603000
PRCODNOP MVC   BUFR+30(3),NOP#    SET NOP AS MNEMONIC                   06604000
         LH    RE,2(,R5)          LOAD STATEMENT NUMBER                 06605000
         SR    R7,R7              SET INTEGER TYPE                      06606000
         BAL   R3,PRCODNM         PRINT STATEMENT NUMBER                06607000
         B     PRCODXL            EXIT (FOUR BYTE INSTRUCTION)          06608000
*                                                                       06609000
*        EXIT POINT FOR RR TYPE INSTRUCTION PROCESSING                  06610000
*                                                                       06611000
PRCODRL  LA    R5,2(,R5)          BUMP CODE POINTER                     06612000
*                                                                       06613000
*        COMMON EXIT ROUTINE AT END OF LINE                             06614000
*                                                                       06615000
PRCODRD  BAL   R7,LISTER          LIST LINE                             06616000
         CLI   0(R5),X'3E'        CHECK FOR END OF CODE TO PRINT        06617000
         BCR   E,R4               RETURN TO PRCODEL CALLER IF SO        06618000
         CLI   0(R5),X'3D'        ELSE CHECK FOR MODIFIED END           06619000
         BCR   E,R4               RETURN TO PRCODEL CALLER IF SO        06620000
         B     PRCODEL            ELSE LOOP BACK                        06621000
         EJECT                                                          06622000
*                                                                       06623000
*        SUBROUTINE TO PRINT REGISTER NAME                              06624000
*                                                                       06625000
*        (RE)                     REGISTER NUMBER                       06626000
*        BAL   R7,PRCODERG                                              06627000
*                                                                       06628000
PRCODERG SLL   RE,3               REG NUMBER * 8                        06629000
         LA    R3,PRCRGNAM(RE)    POINT TO CORRECT TABLE LOCATION       06630000
         MVC   0(7,R6),1(R3)      MOVE CHARACTERS                       06631000
         IC    RE,0(,R3)          PICK UP NUMBER OF CHARACTERS          06632000
         AR    R6,RE              BUMP BUFFER POINTER                   06633000
         BR    R7                 LEAVE                                 06634000
*                                                                       06635000
*        TABLE OF REGISTER NAMES                                        06636000
*                                                                       06637000
PRCRGNAM DC    AL1(2)                                                   06638000
         DC    CL7'R0'                                                  06639000
         DC    AL1(2)                                                   06640000
         DC    CL7'R1'                                                  06641000
         DC    AL1(2)                                                   06642000
         DC    CL7'R2'                                                  06643000
         DC    AL1(2)                                                   06644000
         DC    CL7'FR'                                                  06645000
         DC    AL1(2)                                                   06646000
         DC    CL7'A1'                                                  06647000
         DC    AL1(4)                                                   06648000
         DC    CL7'A1+1'                                                06649000
         DC    AL1(2)                                                   06650000
         DC    CL7'A2'                                                  06651000
         DC    AL1(4)                                                   06652000
         DC    CL7'A2+1'                                                06653000
         DC    AL1(3)                                                   06654000
         DC    CL7'DB1'                                                 06655000
         DC    AL1(3)                                                   06656000
         DC    CL7'DB2'                                                 06657000
         DC    AL1(3)                                                   06658000
         DC    CL7'DB3'                                                 06659000
         DC    AL1(3)                                                   06660000
         DC    CL7'DB4'                                                 06661000
         DC    AL1(7)                                                   06662000
         DC    CL7'FRETURN'                                             06663000
         DC    AL1(6)                                                   06664000
         DC    CL7'RETURN'                                              06665000
         DC    AL1(3)                                                   06666000
         DC    CL7'SYS'                                                 06667000
         DC    AL1(3)                                                   06668000
         DC    CL7'PDR'                                                 06669000
         EJECT                                                          06670000
*                                                                       06671000
*        SUBROUTINE TO PRINT A STRING                                   06672000
*                                                                       06673000
*        USED TO PRINT LITERAL STRINGS AND VARIABLE NAMES               06674000
*                                                                       06675000
*        (RE)  POINTS TO STRING SPECIFIER                               06676000
*        BAL   R7,PRCODST                                               06677000
*                                                                       06678000
PRCODST  LH    R3,SLENGTH(,RE)    LOAD LENGTH FIELD                     06679000
         L     RE,0(,RE)          LOAD STRING POINTER                   06680000
         EX    R3,PRCODST2        MOVE IN CHARS OF STRING               06681000
         LA    R6,1(R6,R3)        BUMP POINTER                          06682000
         BR    R7                 RETURN                                06683000
*                                                                       06684000
PRCODST2 MVC   0(*-*,R6),SCHARS(RE)         MOVE LESS THAN 20 CHARS     06685000
         EJECT                                                          06686000
*                                                                       06687000
*        SUBROUTINE TO PRINT A NUMERIC VALUE AT (R6) CURSOR LOCATION    06688000
*        (R6) IS UPDATED -- LEADING BLANKS/ZEROS ARE SUPPRESSED         06689000
*                                                                       06690000
*        (R7,RE)                  NUMERIC CONSTANT TO BE PRINTED        06691000
*        BAL   R3,PRCODNM                                               06692000
*                                                                       06693000
PRCODNM  STM   R4,R5,PRWRK        SAVE REGISTERS                        06694000
         LR    R4,R7              COPY ARGUMENT TO PROPER REG           06695000
         LR    R5,RE              ...                                   06696000
         LA    R2,NUMTOSTG        POINT TO CONVERSION ROUTINE           06697000
         L     R0,PRCODNMC        PICK UP CONVERSION PARAMETERS         06698000
         BALR  R1,R2              CALL CONVERT ROUTINE                  06699000
         EX    R5,PRCODNMM        MOVE CHARACTERS INTO PLACE            06700000
         LA    R6,1(R5,R6)        UPDATE POINTER                        06701000
         LM    R4,R5,PRWRK        RESTORE REGS                          06702000
         BR    R3                 RETURN TO CALLER                      06703000
*                                                                       06704000
PRCODNMM MVC   0(*-*,R6),SCHARS(R4)         MOVE CHARACTERS INTO PLACE  06705000
         CNOP  0,4                ALLIGN CONVERSION PARAMETERS          06706000
PRCODNMC DC    AL1(0,14,0,7)      FORMAT=0, DIGS = 7(REAL), 14(DREAL)   06707000
         EJECT                                                          06708000
*                                                                       06709000
*        CONSTANTS FOR PRCODE                                           06710000
*                                                                       06711000
CCTBL    DC    C'GTLTNEEQGELE'    BRANCH CODE MNEMONICS                 06712000
PREDIT   DC    C'L'               EDIT PATTERN FOR LABELS               06713000
         DC    X'2120202020'      REST OF PATTERN                       06714000
HEXPRT   EQU   *-X'F0'            HEX TRANSLATION TABLE WITH ADR FUDGE  06715000
         DC    C'0123456789ABCDEF'          ACTUAL ENTRIES USED IN HEXT 06716000
TTLCOD   DC    C'  LOC    CODE        SYMBOLIC'                         06717000
STMNTTL  DC    C'*     STATEMENT NUMBER '                               06718000
STPAT    DC    X'2020202020'                                            06719000
         CNOP  0,4                ALLIGN FOLLOWING CONSTANT             06720000
DB4KON   DC    Y(0)               FIRST TWO BYTES ARE ZERO              06721000
         DC    S($$BAS4-16)       CONSTANT TO CALC BASE NUMBER          06722000
EQU#     DC    C' EQU   *'         EQU *                                06723000
PONE#    DC    C'+1,'             +1,                                   06724000
$$BAS#   DC    C'$$BAS'           $$BAS                                 06725000
FCODE#   DC    C'FCODE(,DB4)'     FCODE(,DB4)                           06726000
VAL#     DC    C'VAL.'            VAL.                                  06727000
FNC#     DC    C'FNC.'            FNC.                                  06728000
LBL#     DC    C'LBL.'            LBL.                                  06729000
TEM#     DC    C'TEM#'            TEM#                                  06730000
LPC#     DC    C'(,'              (,                                    06731000
NCODE#   DC    C'NCODE'           NCODE                                 06732000
LR#      DC    C'LR'              LR                                    06733000
SR#      DC    C'SR'              SR                                    06734000
BALR#    DC    C'BALR'            BALR                                  06735000
CMZ#     DC    C',0'              ,0                                    06736000
BCR#     DC    C'BCR'             BCR                                   06737000
BR#      DC    C'BR'              BR                                    06738000
AUR#     DC    C'AUR   SCNT,SINC' AUR   SCNT,SINC                       06739000
AR#      DC    C'AR'              AR                                    06740000
CONS##   DC    C'CONS#'           CONS#                                 06741000
ZR#      DC    C'ZR  '            ZR                                    06742000
NOP#     DC    C'NOP'             NOP                                   06743000
CONHED   DC    C'CODE TO COMPUTE CONS#'     CODE TO COMPUTE CONS#       06744000
.SKIPS6  ANOP                                                           06745000
         TITLE 'SPITBOLC -- COMPILE TIME READER ROUTINE'                06746000
*                                                                       06747000
*        NOTE: THIS ROUTINE AND THE THREE FOLLOWING IT ARE OMITTED      06748000
*        FROM THE LIBRARY ROUTINES (READER,LISTER,CONCPROC,ERROR)       06749000
*                                                                       06750000
*        CALLED BY BAL R7,READER                                        06751000
*                                                                       06752000
*        READS 80-BYTE CARD INTO INBUF                                  06753000
*                                                                       06754000
*        THROUGH THE USE OF (POSSIBLY NESTED) -COPY CARDS, SEVERAL      06755000
*        INPUT FILES MAY BE ACTIVE AT THE SAME TIME. THIS IS HANDELED   06756000
*        BY USING THE INPUTDCB STACK. THE BOTTOM (LOWEST) ENTRY IN THIS 06757000
*        STACK IS THE MAIN INPUT FILE POINTER (SYSIN). HIGHER ENTRIES   06758000
*        ARE MADE FOR -COPY CARDS. THE LOCATION RDDCBOFS HOLDS AN       06759000
*        OFFSET TO THE TOP ELEMENT WHICH CONTAINS THE CURRENT FILE PTR. 06760000
*                                                                       06761000
         AIF   (&LMOD EQ 1).SKIPS7                                      06762000
         USING SPITBOLC,CB1       GET FIRST BASE REG BACK               06763000
READER   STM   R4,R5,IOHOLD       SAVE I/O PARAM REGS                   06764000
         MVI   INBUF,C' '         SET A BLANK                           06765000
         MVC   INBUF+1(80-1),INBUF          CLEAR INPUT BUFFER          06766000
         LH    R5,RDDCBOFS        LOAD OFFSET INTO INPUT FILE STACK     06767000
*                                                                       06768000
*        MERGE BACK HERE FOR END OF FILE ON -COPY INPUT                 06769000
*                                                                       06770000
READERL  L     R0,INPUTDCB(R5)    LOAD APPROPRIATE FILE POINTER         06771000
         L     R2,=V(SYSMAXL)     POINT TO ROUTINE                      06772000
         BALR  R1,R2              GET INPUT RECORD LENGTH               06773000
         CH    R0,=H'80'          MUST NOT EXCEED 80 CHARS LONG         06774000
         BH    READIOER           TREAT AS I/O ERROR IF LONGER          06775000
         L     R0,INPUTDCB(R5)    ELSE RELOAD FILE POINTER              06776000
         LA    R4,INBUF           POINT TO INPUT BUFFER                 06777000
         L     R2,=V(SYSREAD)     POINT TO READ ROUTINE                 06778000
         BALR  R1,R2              CALL SYSTEM INPUT ROUTINE             06779000
         B     READIOER           JUMP IF INPUT ERROR                   06780000
         LTR   R0,R0              CHECK RECORD LENGTH READ              06781000
         BM    READEOF            SKIP ON END OF FILE                   06782000
*                                                                       06783000
*        MERGE BACK HERE AFTER SUPPLYING END CARD ON EOF                06784000
*                                                                       06785000
READER1  LM    R4,R5,IOHOLD       RESTORE REGS USED FOR I/O PARAMS      06786000
         MVC   BUFR,BUFR-1        BLANK OUTPUT BUFFER                   06787000
         MVC   BUFR+6(80),INBUF   MOVE CARD TO OUTPUT BUFFER            06788000
         CLI   IN72,0             TEST FOR 72 COLUMN MODE               06789000
         BCR   E,R7               RETURN IF NOT                         06790000
*                                                                       06791000
*        HERE DEAL WITH -IN72 OPTION (72 COLUMN READ)                   06792000
*                                                                       06793000
         MVI   SERIAL-1,C'.'      SET VISUAL DIVIDER                    06794000
         MVI   BUFR+6+72,C' '     BLANK OUT GARBAGE CHARACTER           06795000
         MVC   SERIAL,INBUF+72    MOVE SERIALIZATION TO OUTPUT          06796000
         MVI   INBUF+72,X'00'     SET SCAN TERMINATE CHAR IN COL 73     06797000
         CLI   SEQFLG,0           TEST FOR -SEQ OPTION                  06798000
         BCR   E,R7               LEAVE IF NO SEQUENCE CHECK            06799000
         EJECT                                                          06800000
*                                                                       06801000
*        HERE WE DO THE SEQUENCE CHECK                                  06802000
*                                                                       06803000
         CLC   SERIAL,SERIAL+8    CHECK FOR ALL BLANKS                  06804000
         BCR   E,R7               NO CHECK IF ALL BLANK                 06805000
         CLC   SERIAL,LASTSEQ     ELSE DO SEQUENCE CHECK                06806000
         BH    *+16               SKIP IF HIGHER (OK)                   06807000
         MVC   BUFR+90(14),=C'***SEQUENCE***'     ELSE SET MESSAGE      06808000
         OC    SUPRXEQ,NOXEQE     STOP XEQ IF -NOERRORS OPTION SET      06809000
         MVC   LASTSEQ,SERIAL     SAVE THIS VALUE FOR NEXT TEST         06810000
         BR    R7                 LEAVE                                 06811000
*                                                                       06812000
*        COME HERE ON END OF FILE                                       06813000
*                                                                       06814000
*        THERE ARE TWO POSSIBLE CASES --                                06815000
*                                                                       06816000
*        1)    END OF PRIMARY INPUT FILE. IN THIS CASE THE END CARD     06817000
*              IS MISSING AND WE SUPPLY ONE WITH AN ERROR MESSAGE.      06818000
*                                                                       06819000
*        2)    AN END OF FILE FROM A -COPY INPUT. IN THIS CASE, WE POP  06820000
*              THE POINTER TO THE INPUT FILE STACK AND CONTINUE         06821000
*              READING FROM THE PREVIOUS INPUT FILE.                    06822000
*                                                                       06823000
READEOF  SH    R5,=H'4'           POP OFFSET INTO FILE PTR STACK        06824000
         STH   R5,RDDCBOFS        STORE POPPED POINTER                  06825000
         BNM   READERL            LOOP BACK IF NOT PRIMARY INPUT FILE   06826000
         MVI   EOF,1              ELSE SET SPECIAL END OF FILE FLAG     06827000
         MVC   INBUF(3),=C'END'   SUPPLY MISSING END CARD               06828000
         B     READER1            MERGE WITH NORMAL READ CIRCUIT        06829000
*                                                                       06830000
*        HERE ON PERMANENT INPUT-OUTPUT ERROR                           06831000
*                                                                       06832000
READIOER MVI   FATAL,1            SET FATAL ERROR FLAG                  06833000
         ERR   17                 I/O ERROR MESSAGE                     06834000
         TITLE 'SPITBOLC -- COMPILE TIME LISTER ROUTINE'                06835000
*                                                                       06836000
*        CALLED BY                                                      06837000
*                                                                       06838000
*        BAL   R7,LISTER                                                06839000
*                                                                       06840000
*        PRINTS THE LINE STORED IN BUFR (WITH CONTROL CHARACTER AT      06841000
*                                                   BUFR - 1)           06842000
*        SKIPS OVER CREASES                                             06843000
*        TO SET FOR A NEW PAGE -- EXECUTE                               06844000
*                                                                       06845000
*        MVI   LINELEFT+1,1                                             06846000
*                                                                       06847000
LISTER   CLI   BUFR+90,C'*'       CHECK FOR SEQUENCE ERROR MSG          06848000
         BE    LISTERU            ALWAYS PRINT IF SEQUENCE ERROR        06849000
         CLI   LISTSW,0           ELSE CHECK -LIST MODE FLAG            06850000
         BCR   8,R7               SKIP OUT IF NO LIST                   06851000
*                                                                       06852000
*        BAL   R7,LISTERU         FOR UNCONDITIONAL LISTING             06853000
*                                                                       06854000
LISTERU  STM   R4,R7,IOHOLD       SAVE I/O PARAM REGS                   06855000
         LH    R1,LINELEFT        PICK UP COUNT OF LINES LEFT ON PAGE   06856000
         CLI   DUBLFLG,0          -DOUBLE OPTION SET?                   06857000
         BZ    *+6                SKIP IF NOT                           06858000
         BCTR  R1,0               IF IT IS, DECREMENT LINE COUNT 1 EXTR 06859000
         SH    R1,=H'1'           DECREMENT FOR LINE TO BE PRINTED      06860000
         BP    LISTER1            SKIP IF ROOM LEFT ON THIS PAGE        06861000
         AP    PAGENO,PONE        NEW PAGE -- BUMP PAGE COUNT           06862000
         MVC   OUTPAGE,=X'202020' MOVE PATTERN ONTO TITLE LINE          06863000
         ED    OUTPAGE-1(4),PAGENO          EDIT PAGE NUMBER            06864000
         LA    R4,OUTTITB         POINT TO TITLE LINE                   06865000
         LA    R5,111             SET LINE LENGTH = 111                 06866000
         BAL   R3,WLINE           CALL WRITE A LINE ROUTINE             06867000
         MVI   BUFR-1,C'0'        SET CARRIAGE CONTROL FOR BLANK LINE   06868000
         L     R1,PGDEPTH         RESET LINE COUNTER                    06869000
*                                                                       06870000
*        OUTPUT SUB-TITLE IF ONE HAS BEEN GIVEN                         06871000
*                                                                       06872000
         CLC   OUSTITL,OUSTITL-1  DO WE HAVE A SUB-TITLE?               06873000
         BE    LISTER1            SKIP IF NOT (ALL ZEROS)               06874000
         LA    R4,OUSTITL-1       POINT TO SUB-TITLE WITH CTL CHAR      06875000
         LA    R5,L'OUSTITL+1     SET LENGTH INCLUDING CTL CHAR         06876000
         BAL   R3,WLINE           OUTPUT THE SUB-TITLE                  06877000
         L     R1,PGDEPTH         RESET LINE COUNTER                    06878000
         SH    R1,=H'2'           ADJUST BY TWO FOR SUBTITLE            06879000
         EJECT                                                          06880000
*                                                                       06881000
*        JUMP HERE WHEN WE DO NOT NEED NEW PAGE                         06882000
*                                                                       06883000
LISTER1  STH   R1,LINELEFT        RE-STORE LINE COUNT                   06884000
         CLI   DUBLFLG,1          TEST FOR -DOUBLE SET                  06885000
         BNE   *+8                SKIP IF NOT                           06886000
         OI    BUFR-1,C'0'        SET FOR DOUBLE SPACE UNLESS NEW PAGE  06887000
         LA    R4,BUFR-1          POINT TO OUTPUT BUFFER WITH CTL CHAR  06888000
         LA    R5,133             SET LENGTH                            06889000
         BAL   R3,WLINE           OUTPUT THE LINE                       06890000
         MVI   BUFR-1,C' '        RESTORE BLANK CONTROL CHARACTER       06891000
         LM    R4,R7,IOHOLD       RELOAD I/O PARAM REGS                 06892000
         BR    R7                 RETURN TO CALLER                      06893000
*                                                                       06894000
*        LITTLE SUBROUTINE TO PRINT A LINE AT COMPILE TIME              06895000
*                                                                       06896000
*        (R4,R5)                  PARAMS SET FOR SYSWRITE (ADDR/LENGTH) 06897000
*        BAL   R3,WLINE                                                 06898000
*        -->   NORMAL RETURN                                            06899000
*                                                                       06900000
WLINE    L     R0,PRINTDCB        POINT TO SYSPRINT DCB                 06901000
         SR    R7,R7              INDICATE UNFORMATTED                  06902000
         L     R2,=V(SYSWRITE)    POINT TO OUTPUT ROUTINE               06903000
         BALR  R1,R2              CALL SYSTEM OUTPUT ROUTINE            06904000
         NOP   0                  ERROR NOT POSSIBLE ON SYSPRINT        06905000
         LTR   R0,R0              CHECK FOR LINE LIMIT EXCEEDED         06906000
         BCR   NZ,R3              RETURN IF NOT EXCEEDED                06907000
         MVI   FATAL,1            ELSE SIGNAL FATAL ERROR               06908000
         ERR   15                 GIVE ***PAGE LIMIT EXCEEDED*** MSG    06909000
         TITLE 'SPITBOLC -- CONTROL CARD INTERPRETATION ROUTINE'        06910000
*        THIS ROUTINE IS CALLED WITH                                    06911000
*                                                                       06912000
*        BAL   R7,CONCPROC                                              06913000
*                                                                       06914000
*        IT PROCESSES THE CONTROL CARD AND TRANSFERS TO READER WHICH    06915000
*        READS IN THE NEXT CARD AND RETURNS CONTROL TO THE CALLER       06916000
*                                                                       06917000
CONCPROC LA    R1,INBUF+1         POINT TO START OF CONTROL CARD        06918000
         ST    R1,FLAGLOC         SAVE LOCATION FOR POSSIBLE ERROR FLAG 06919000
*                                                                       06920000
*        REENTER HERE FOR CASE OF MULTIPLE ITEMS                        06921000
*                                                                       06922000
CONCPRCR LA    R2,CONCDICT        POINT TO CONTROL CARD DICTIONARY      06923000
         ST    R7,CONCSAV         SAVE LINKAGE                          06924000
         ST    RF,CONCSAV+4       SAVE (RF)                             06925000
         LA    R0,(CONCDICN-CONCDICT)/6     LOAD NUMBER OF ENTRIES      06926000
*                                                                       06927000
*        LOOP THROUGH ENTRIES IN DICTIONARY                             06928000
*                                                                       06929000
CONCPRLP CLC   0(4,R1),0(R2)      IS THIS THE ONE?                      06930000
         BNE   CONCPRE            SKIP IF NOT                           06931000
         LH    R2,4(,R2)          LOAD ROUTINE ADDRESS                  06932000
*                                                                       06933000
*        COME HERE TO BRANCH TO PROPER ROUTINE                          06934000
*                                                                       06935000
CONCPRGO LA    R0,1               GET A CONSTANT ONE FOR FLAG SETS      06936000
         LA    R2,CONCPROC(R2)    POINT TO ROUTINE                      06937000
         BALR  R2,R2              OFF TO ROUTINE SETTING RETURN         06938000
*                                                                       06939000
*        CONTROL CARD TYPES PERMITTING OTHER ITEMS TO FOLLOW COME HERE  06940000
*                                                                       06941000
         CLI   0(R1),C' '         IS THERE A BLANK?                     06942000
         BE    CONCDONE           JUMP TO READ IF SO (ALL DONE)         06943000
         CLI   0(R1),C','         ELSE IS THERE A COMMA?                06944000
         LA    R1,1(,R1)          BUMP POINTER                          06945000
         BCR   NE,R2              LOOP BACK IF NOT AT COMMA             06946000
         B     CONCPRCR           ELSE JUMP BACK TO SCAN NEXT ENTRY     06947000
*                                                                       06948000
*        SKIP HERE ON NO MATCH TO GO TO NEXT ENTRY                      06949000
*                                                                       06950000
CONCPRE  LA    R2,6(,R2)          POINT TO NEXT ENTRY                   06951000
         BCT   R0,CONCPRLP        SKIP BACK IF MORE TO GO               06952000
         BAL   R7,LISTERU         ALWAYS LIST GARBAGE CONTROL CARD      06953000
         L     R7,CONCSAV         RESTORE LINKAGE                       06954000
         B     READER             AND THEN IGNORE IT                    06955000
         EJECT                                                          06956000
*                                                                       06957000
*        -NOLIST,-UNLIST                                                06958000
*                                                                       06959000
CONCNOLI EQU   *                  -NOLIST ENTRY                         06960000
CONCUNLI SR    R0,R0              SET TO TURN OFF FLAG & MERGE          06961000
*                                                                       06962000
*        -LIST                                                          06963000
*                                                                       06964000
CONCLIST STC   R0,LISTSW          STORE LIST SWITCH                     06965000
         BR    R2                 RETURN FOR NEXT ENTRY                 06966000
*                                                                       06967000
*        -CODE                                                          06968000
*                                                                       06969000
CONCCODE MVI   CODESW,1           SET CODE SWITCH                       06970000
         MVI   AUR$,X'3D'         SET SPECIAL AUR TO GET CODE LIST      06971000
         BR    R2                 RETURN TO SCAN NEXT ITEM              06972000
*                                                                       06973000
*        -NOCODE                                                        06974000
*                                                                       06975000
CONCNOCO MVI   AUR$,X'3E'         SET CODE LIST OFF                     06976000
         BR    R2                 RETURN TO SCAN NEXT ITEM              06977000
*                                                                       06978000
*        -TITLE                                                         06979000
*                                                                       06980000
CONCTITL MVC   OUTITLE,BUFR+13    ACQUIRE SUPPLIED TITLE                06981000
         MVC   OUSTITL,OUSTITL-1  CLEAR SUB-TITLE                       06982000
         B     CONCEJEC           MERGE WITH EJECT                      06983000
*                                                                       06984000
*        -STITL                                                         06985000
*                                                                       06986000
CONCSTIT MVC   OUSTITL,BUFR+13    ACQUIRE SUB-TITLE, MERGE EJECT        06987000
*                                                                       06988000
*        -EJECT                                                         06989000
*                                                                       06990000
CONCEJEC MVI   LINELEFT+1,1       SET FOR NEW PAGE                      06991000
         B     CONCDONE           ALL DONE, JUMP TO END                 06992000
*                                                                       06993000
*        -SINGLE                                                        06994000
*                                                                       06995000
CONCSING SR    R0,R0              SET TO TURN OFF FLAG & MERGE          06996000
*                                                                       06997000
*        -DOUBLE                                                        06998000
*                                                                       06999000
CONCDOUB STC   R0,DUBLFLG         STORE VALUE OF -DOUBLE FLAG           07000000
         BR    R2                 RETURN FOR NEXT ITEM                  07001000
         EJECT                                                          07002000
*                                                                       07003000
*        -NOFAIL                                                        07004000
*                                                                       07005000
CONCNOFA SR    R0,R0              SET TO TURN OFF & MERGE               07006000
*                                                                       07007000
*        -FAIL                                                          07008000
*                                                                       07009000
CONCFAIL STC   R0,FAILSET         STORE FAIL VALUE                      07010000
         BR    R2                 RETURN FOR NEXT ITEM                  07011000
*                                                                       07012000
*        -IN80                                                          07013000
*                                                                       07014000
CONCIN80 SR    R0,R0              SET TO TURN OFF -IN72 SW & MERGE      07015000
         LA    RF,INBUF+80        SET LOCATION OF STOP CHARACTER        07016000
         MVI   INBUF+80,X'00'     SET STOP CHARACTER IN PLACE           07017000
         B     CONCINMR           JUMP TO MERGE POINT                   07018000
*                                                                       07019000
*        -IN72                                                          07020000
*                                                                       07021000
CONCIN72 LA    RF,INBUF+72        POINT TO STOP CHARACTER, MERGE        07022000
*                                                                       07023000
*        -IN72, -IN80 MERGE HERE                                        07024000
*                                                                       07025000
CONCINMR STC   R0,IN72            SET MODE FLAG                         07026000
         ST    RF,STOPLOC         REMEMBER LOCATION OF STOP CHARACTER   07027000
         BR    R2                 RETURN FOR NEXT ITEM                  07028000
*                                                                       07029000
*        -NOSEQ                                                         07030000
*                                                                       07031000
CONCNOSE SR    R0,R0              SET TO TURN SWITCH OFF & MERGE        07032000
*                                                                       07033000
*        -SEQUENCE                                                      07034000
*                                                                       07035000
CONCSEQU STC   R0,SEQFLG          STORE VALUE OF SEQ FLAG               07036000
         STD   ZR,LASTSEQ         CLEAR LAST SEQ TO 8X'00'              07037000
         BR    R2                 RETURN FOR NEXT ITEM                  07038000
*                                                                       07039000
*        -NOOPTIMIZE                                                    07040000
*                                                                       07041000
CONCNOOP SR    R0,R0              SET TO CLEAR OPTIMIZE FLAG, MERGE     07042000
*                                                                       07043000
*        -OPTIMIZE                                                      07044000
*                                                                       07045000
CONCOPTI STC   R0,OPTFLAG         SET PROPER VALUE IN OPTIMIZE FLAG     07046000
         BR    R2                 RETURN FOR NEXT ITEM                  07047000
         EJECT                                                          07048000
*                                                                       07049000
*        -EXECUTE                                                       07050000
*                                                                       07051000
CONCEXEC SR    R0,R0              SET TO ALLOW EXECUTION                07052000
*                                                                       07053000
*        -NOEXECUTE                                                     07054000
*                                                                       07055000
CONCNOEX STC   R0,BYPASXEQ        SET FLAG PROPERLY                     07056000
         BR    R2                 ALL DONE, LOOP BACK                   07057000
*                                                                       07058000
*        -ERRORS                                                        07059000
*                                                                       07060000
CONCERRO SR    R0,R0              SET TO TURN OF ERROR FLAG, MERGE      07061000
*                                                                       07062000
*        -NOERRORS                                                      07063000
*                                                                       07064000
CONCNOER STC   R0,NOXEQE          SET VALUE OF -NOERRORS SWITCH         07065000
         BR    R2                 ALL DONE                              07066000
*                                                                       07067000
*        -NOPRINT                                                       07068000
*                                                                       07069000
CONCNOPR SR    R0,R0              SET TO TURN OFF PRINT SWITCH          07070000
*                                                                       07071000
*        -PRINT                                                         07072000
*                                                                       07073000
CONCPRIN STC   R0,PRINFLG         SET PRINT SWITCH PROPERLY             07074000
         BR    R2                 ALL DONE                              07075000
*                                                                       07076000
*        -SPACE                                                         07077000
*                                                                       07078000
CONCSPAC NI    INBUF+7,X'0F'      MASK OUT ZONES ON COUNT               07079000
         CLC   LINELEFT+1(1),INBUF+7        ARE THERE ENOUGH LINES?     07080000
         BNH   CONCEJEC           TREAT AS -EJECT IF NOT                07081000
         SR    RF,RF              ELSE CLEAR RF FOR FOLLOWING IC        07082000
         IC    RF,INBUF+7         PICK UP COUNT                         07083000
         MVC   BUFR,BUFR-1        CLEAR BUFFER                          07084000
*                                                                       07085000
*        LOOP TO SPACE ONE LINE AT A TIME                               07086000
*                                                                       07087000
CONCSLP  BAL   R7,LISTER          LIST A BLANK LINE                     07088000
         BCTR  RF,0               DECREASE COUNT                        07089000
         LTR   RF,RF              TEST IT                               07090000
         BP    CONCSLP            BACK FOR ANOTHER LINE IF MORE TO GO   07091000
         B     CONCDONE           ALL DONE WITH SPACE CARD              07092000
         EJECT                                                          07093000
*                                                                       07094000
*        -COPY                                                          07095000
*                                                                       07096000
CONCCOPY STM   R4,R5,IOHOLD       SAVE REGS                             07097000
         TRT   INBUF+5(80),SCANTB1          SCAN TO START OF FILENAME   07098000
         LR    R4,R1              COPY START OF FILE NAME ADDRESS       07099000
         LR    R5,R4              COPY POINTER                          07100000
*                                                                       07101000
*        LOOP TO SCAN TO END OF FILE NAME                               07102000
*                                                                       07103000
         BALR  R2,0               SET START OF LOOP ADDRESS             07104000
         CLI   1(R5),C' '         TERMINATING BLANK?                    07105000
         LA    R5,1(,R5)          BUMP POINTER                          07106000
         BCR   NE,R2              LOOP BACK IF BLANK NOT FOUND          07107000
*                                                                       07108000
*        HERE WITH FILE NAME SCANNED OUT                                07109000
*                                                                       07110000
         SR    R5,R4              GET LENGTH OF FILENAME                07111000
         L     R2,=V(SYSDCB)      POINT TO SYSTEM ROUTINE               07112000
         BALR  R1,R2              CALL SYSTEM ROUTINE TO GET FILE PTR   07113000
         B     CONCOPER           ERROR IF FILE CANNOT BE OPENED        07114000
*                                                                       07115000
*        HERE WE HAVE THE FILE POINTER IN (R0)                          07116000
*                                                                       07117000
         LH    R5,RDDCBOFS        LOAD CURRENT FILE PTR OFFSET          07118000
         LA    R5,4(,R5)          PUSH POINTER                          07119000
         CH    R5,=Y(MAXCOPY*4)   CHECK FOR NESTED TOO DEEP             07120000
         BNH   CONCCOP3           SKIP IF OK                            07121000
*                                                                       07122000
*        HERE ON ANY KIND OF ERROR                                      07123000
*                                                                       07124000
CONCOPER BAL   R7,LISTERU         UNCONDITIONALLY LIST CONTROL CARD     07125000
         ERR   13                 AND SIGNAL ERROR (BAD -COPY CARD)     07126000
*                                                                       07127000
*        HERE TO STORE FILE POINTER AND EXIT                            07128000
*                                                                       07129000
CONCCOP3 STH   R5,RDDCBOFS        STORE NEW FILE PTR OFFSET             07130000
         ST    R0,INPUTDCB(R5)    STORE FILE POINTER IN STACK           07131000
         LM    R4,R5,IOHOLD       RELOAD REGS AND MERGE TO EXIT         07132000
*                                                                       07133000
*        MERGE HERE AFTER PROCESSING CONTROL CARD                       07134000
*                                                                       07135000
CONCDONE CLI   PRINFLG,0          SHOULD WE PRINT CONTROL CRD?          07136000
         BE    *+8                SKIP IF NOT                           07137000
         BAL   R7,LISTER          ELSE LIST CONTROL CARD                07138000
         L     R7,CONCSAV         RELOAD REGISTERS                      07139000
         L     RF,CONCSAV+4       . . . .                               07140000
         B     READER             AND JUMP TO READ NEXT CARD            07141000
         EJECT                                                          07142000
*                                                                       07143000
*        CONTROL CARD DICTIONARY                                        07144000
*                                                                       07145000
CONCDICT EQU   *                                                        07146000
         CONC  LIST               -LIST                                 07147000
         CONC  UNLI               -UNLIST                               07148000
         CONC  STIT               -STITL                                07149000
         CONC  TITL               -TITLE                                07150000
         CONC  EJEC               -EJECT                                07151000
         CONC  CODE               -CODE                                 07152000
         CONC  ERRO               -ERRORS                               07153000
         CONC  NOER               -NOERRORS                             07154000
         CONC  SPAC               -SPACE                                07155000
         CONC  SING               -SINGLE                               07156000
         CONC  DOUB               -DOUBLE                               07157000
         CONC  NOCO               -NOCODE                               07158000
         CONC  NOLI               -NOLIST                               07159000
         CONC  PRIN               -PRINT                                07160000
         CONC  NOPR               -NOPRINT                              07161000
         CONC  FAIL               -FAIL                                 07162000
         CONC  NOFA               -NOFAIL                               07163000
         CONC  SEQU               -SEQUENCE                             07164000
         CONC  NOSE               -NOSEQUENCE                           07165000
         CONC  IN72               -IN72                                 07166000
         CONC  IN80               -IN80                                 07167000
         CONC  OPTI               -OPTIMIZE                             07168000
         CONC  NOOP               -NOOPTIMIZE                           07169000
         CONC  EXEC               -EXECUTE                              07170000
         CONC  NOEX               -NOEXECUTE                            07171000
         CONC  COPY               -COPY                                 07172000
CONCDICN EQU   *                  END OF DICTIONARY                     07173000
         TITLE 'SPITBOLC -- COMPILE TIME ERROR MESSAGE ROUTINE'         07174000
*                                                                       07175000
*        CALLED BY THE MACRO                                            07176000
*                                                                       07177000
*        ERR   NN                 TO GENERATE ERROR MESSAGE NN          07178000
*                                                                       07179000
*        FATAL IS A FLAG WHICH HAS THREE SETTINGS  --                   07180000
*                                                                       07181000
*              0                  NORMAL ERROR                          07182000
*              1                  FATAL ERROR                           07183000
*              2                  ERROR IN END CARD                     07184000
*                                                                       07185000
ERROR    CLI   LISTSW,0           CHECK LIST SWITCH                     07186000
         BNE   *+8                SKIP IF SWITCH IS ON                  07187000
         BAL   R7,LISTERU         ELSE UNCONDITIONAL LIST OF BUFR       07188000
         OC    SUPRXEQ,NOXEQE     SET FLAG IF -NOERRORS OPTION SET      07189000
         MVI   0(LC),C' '         SETUP BUFFER JUST BEYOND CODE         07190000
         MVC   1(86,LC),0(LC)     CLEAR TO BLANKS                       07191000
         L     R2,FLAGLOC         LOAD LOCATION FOR ERROR FLAG          07192000
         LA    R0,INBUF-1         POINT TO START OF BUFFER WITH FUDGE   07193000
         SR    R2,R0              COMPUTE CURRENT OFFSET IN BUFFER      07194000
         AR    R2,LC              POINT TO LOCATION IN OUR OUTPUT BUFR  07195000
         MVI   6(R2),C'|'         SET ERROR FLAG                        07196000
         LH    R0,LINELEFT        COUNT OF LINES LEFT ON PAGE           07197000
         SH    R0,=H'3'           MINUS 3 FOR FLAG, MESSAGE, BLANK      07198000
         STH   R0,LINELEFT        STORE DECREMENTED VALUE               07199000
         LR    R4,LC              POINT TO BUFFER                       07200000
         LA    R5,86              SET LENGTH                            07201000
         BAL   R3,WLINE           PRINT ERROR FLAG                      07202000
         MVI   1(LC),C'*'         SET A *                               07203000
         MVC   2(70,LC),1(LC)     PROPAGATE STARS                       07204000
         SR    R2,R2              CLEAR FOR IC                          07205000
         IC    R2,0(,RE)          GET LENGTH OF ERROR MESSAGE           07206000
         EX    R2,ERRMOV          MOVE IN ERROR MESSAGE                 07207000
         LA    R5,6+6+1+1(,R2)    LENGTH OF MSG AND ******              07208000
         BAL   R3,WLINE           PRINT ERROR MESSAGE                   07209000
         LA    R5,1               SET TO PRINT ONE CHARACTER            07210000
         BAL   R3,WLINE           PRINT A BLANK LINE UNDER MSG          07211000
         MVC   0(6,LC),LRFDB1$    GEN LR FRETURN,DB1 BAL RETURN,$$SERR  07212000
         LA    LC,6(,LC)          BUMP CODE POINTER                     07213000
         AP    ERRCOUNT,=P'1'     INCREMENT ERROR COUNT                 07214000
         CLI   FATAL,1            TEST CASES                            07215000
         BH    XEQGO              START EXECUTION IF END CARD ERROR     07216000
         BE    ENDJOB             END OF JOB IF FATAL ERROR             07217000
         MVI   ERRFLG,1           ELSE SET FLAG FOR ERROR IN ERROR      07218000
         EJECT                                                          07219000
*                                                                       07220000
*        COME HERE TO SCAN TO END OF STATEMENT                          07221000
*                                                                       07222000
ERROR1   CLI   SCANFL,TRM         ARE WE AT END OF STATEMENT?           07223000
         BE    *+12               SKIP IF SO                            07224000
         BAL   RF,SCAN            ELSE SCAN NEXT ELEMENT                07225000
         B     ERROR1             BACK TO SEE IF IT IS END OF STATEMENT 07226000
         MVI   ERRFLG,0           RESET ERROR IGNORE FLAG               07227000
         B     CMPILE             GO COMPILE NEXT STATEMENT             07228000
*                                                                       07229000
ERRMOV   MVC   6+1(*-*,LC),1(RE)  MOVE ERROR MESSAGE INTO BUFFER        07230000
*                                                                       07231000
*        COME HERE TO TERMINATE JOB ON A FATAL ERROR                    07232000
*                                                                       07233000
ENDJOB   LA    R0,12              SET RETURN CODE TO INDICATE ERROR     07234000
         L     R2,=V(SYSEOJ)      LOAD ADDRESS OF EOJ ROUTINE           07235000
         BR    R2                 RETURN TO SYSTEM INTERFACE            07236000
*                                                                       07237000
*        ERROR MESSAGES                                                 07238000
*                                                                       07239000
1        ERRM  'MISSING OPERAND'                                        07240000
2        ERRM  'UNBALANCED () OR <>'                                    07241000
3        ERRM  'ILLEGAL USE OF < '                                      07242000
4        ERRM  'ILLEGAL USE OF , '                                      07243000
5        ERRM  'ILLEGAL USE OF ) '                                      07244000
6        ERRM  'ILLEGAL USE OF > '                                      07245000
7        ERRM  'MISSING OPERATOR'                                       07246000
8        ERRM  'EXPRESSION IS TOO COMPLEX FOR THE COMPILER'             07247000
10       ERRM  'ILLEGAL USE OF = '                                      07248000
11       ERRM  'ERROR IN GO TO FIELD'                                   07249000
12       ERRM  'PROGRAM TOO LONG FOR AVAILABLE STORAGE'                 07250000
13       ERRM  'INVALID -COPY CARD'                                     07251000
14       ERRM  'TIME LIMIT EXCEEDED'                                    07252000
15       ERRM  'PAGE LIMIT EXCEEDED'                                    07253000
16       ERRM  'ERROR IN NUMERIC ITEM'                                  07254000
17       ERRM  'NON-RECOVERABLE INPUT ERROR'                            07255000
18       ERRM  'UNMATCHED QUOTE'                                        07256000
19       ERRM  'MISSING END CARD SUPPLIED'                              07257000
20       ERRM  'LABEL HAS BEEN PREVIOUSLY DEFINED'                      07258000
21       ERRM  'ILLEGAL TRANSFER ADDRESS'                               07259000
22       ERRM  'UNDEFINED TRANSFER ADDRESS'                             07260000
24       ERRM  'ILLEGAL CHARACTER'                                      07261000
         TITLE 'SPITBOLC -- RUN TIME PATCH ROUTINE'                     07262000
*                                                                       07263000
*        THIS ROUTINE IS CALLED TO READ PATCH CARDS AT RUN TIME         07264000
*        THE FORMAT OF THESE CARDS IS SIMILAR TO THAT USED IN DOS ---   07265000
*                                                                       07266000
*REP  AAAAAA NNNDDDD,DDDD,DDDD,DDDD   . . .                             07267000
*                                                                       07268000
*        AAAAAA IS THE ASSEMBLY ADDRESS OF THE START OF THE PATCH       07269000
*        NNN IS THE ESD NUMBER (IGNORED BY THE PATCHER ROUTINE)         07270000
*        DDDD,DDDD ARE 4 HEX DIGIT GROUPS OF DATA                       07271000
*                                                                       07272000
*                                                                       07273000
*                                                                       07274000
*        MAIN ENTRY POINT                                               07275000
*                                                                       07276000
PATCHER  BAL   R7,READER          READ A CARD                           07277000
         CLC   INBUF(4),=C'-REP'  IS IT REALLY A REP CARD?              07278000
         BCR   NE,RF              RETURN IF NOT A REP CARD              07279000
         BAL   R7,LISTERU         LIST PATCH CARD                       07280000
         TR    INBUF+6(6),HEXTABL TRANSLATE HEX DIGITS OF ADDRESS       07281000
         PACK  PAKWRK+1(3+1),INBUF+6(6+1)  PACK PATCH ADDRESS           07282000
         L     R2,PAKWRK          LOAD ADDRESS                          07283000
         AR    R2,CB1             GET ACTUAL CORE ADDRESS               07284000
         LA    R3,INBUF+13+3      INITIALIZE POINTER TO PATCH DATA      07285000
*                                                                       07286000
*        THIS LOOP ENTERS ONE TWO BYTE (4 HEX DIGIT) PATCH              07287000
*                                                                       07288000
PATCHLP  TR    0(4,3),HEXTABL     TRANSLATE HEX DIGITS                  07289000
         PACK  PAKWRK+2(2+1),0(4+1,R3)      PACK UP DIGITS              07290000
         MVC   0(2,R2),PAKWRK+2   MOVE DATA TO NEW LOCATION             07291000
         CLI   4(R3),C' '         DO WE HAVE A BLANK NEXT?              07292000
         BE    PATCHER            IF YES -- ALL DONE -- GET NEXT CARD   07293000
         LA    R3,5(R3)           IF MORE, BUMP INPUT POINTER           07294000
         LA    R2,2(R2)           BUMP CORE POINTER                     07295000
         B     PATCHLP            AND GO BACK FOR NEXT PATCH            07296000
*                                                                       07297000
*        WORK AREAS AND CONSTANTS FOR PATCHER                           07298000
*                                                                       07299000
HEXTABL  EQU   *-C'A'             TRANSLATE TABLE TO CONVERT HEX        07300000
         DC    YL1(10,11,12,13,14,15)       TRANSLATE A,B,C,D,E,F       07301000
PAKWRK   DC    F'0'               WORK AREA FOR PATCHER                 07302000
         ORG   HEXTABL+C'0'       REST OF HEXTABL                       07303000
         DC    YL1(0,1,2,3,4,5,6,7,8,9)     TRANSLATE DIGITS            07304000
.SKIPS7  ANOP                                                           07305000
         TITLE 'SPITBOLC -- OBJECT MODULE RESTART ROUTINE'              07306000
*                                                                       07307000
*        THIS IS THE JOB INITIALIZATION ROUTINE FOR USE IN THE CASE     07308000
*        OF A RESTART FROM A GENERATED OBJECT MODULE. IT IS LOCATED IN  07309000
*        THE COMPILER SECTION TO SAVE SPACE IN THE TWO PHASE VERSION.   07310000
*        THE OBJECT MODULE DOES NOT INCLUDE ANY RLD INFORMATION. THUS   07311000
*        THE NECESSARY RELOCATION MUST BE PERFORMED IN THIS ROUTINE.    07312000
*        THIS ROUTINE SHOULD BE ALTERED TO TOLERATE BATCHING            07313000
*                                                                       07314000
*        THIS ROUTINE IS INCLUDED ONLY IN THE LIBRARY MODULES.          07315000
*                                                                       07316000
         AIF   (&LMOD EQ 0).SKIPLLL                                     07317000
         DROP  CB1,CB2,CB3,CB4    KILL COMPILER BASE REGS               07318000
         ENTRY SYSSTART           ENTRY POINT FROM INTERFACE            07319000
SYSSTART BALR  FRETURN,0          ESTABLISH A BASE REGISTER             07320000
         USING *,FRETURN          TELL ASSEMBLER                        07321000
         SDR   ZR,ZR              SET STANDARD ZERO REGISTER            07322000
         LR    FR,DB1             SET ADDRESS OF START OF DYNAMIC CORE  07323000
         L     DB1,SPITLADN       LOAD ADDR OF START OF OLD DATA AREA   07324000
         L     SYS,SPITLAD        OLD DATA AREA STARTING ADDRESS        07325000
         A     SYS,DATASIZE       OLD END OF DATA AREA ADDR (RELOCAD)   07326000
         LA    A1,RELOCAD         ADDR OF ROUTINE TO RELOC BY DATA AREA 07327000
         MVC   SYSCONS(LSYS),SYSCONS-SPITBOLD(FR) MOVE INTERFACE STUFF  07328000
         L     R2,=V(SYSSETP)     LOAD INTERFACE ROUTINE ADDRESS        07329000
         BALR  R1,R2              GIVE INTERFACE NEW DATA AREA ADDRESS  07330000
         NOP   0                  IMPOSSIBLE TO HAVE ERROR RETURN       07331000
         ST    FR,DYNAMB          START OF NEW DYNAMIC MEMORY           07332000
         LR    PDR,FR             COPY STARTING ADDRESS                 07333000
         A     PDR,DATASIZE       PUSH TO END OF NEW AREA               07334000
         ST    PDR,HICINUSE       ALSO HIGHEST LOCATION IN USE          07335000
         SH    PDR,=Y(STACKTOP)   STANDARD STACK OFFSET                 07336000
*                                                                       07337000
*        NOW RELOCATE $$BASXX BASE TABLE ENTRIES                        07338000
*                                                                       07339000
         SR    A2,A2              OFFSET INTO BASE TABLE                07340000
         LR    R1,DB1             FIRST POINTER                         07341000
         SH    R1,=Y(VALUE)       INTRODUCE STANDARD OFFSET             07342000
         ST    R1,$$BAS1          STORE RELOCATED VALUE                 07343000
         BAL   A2+1,RLOAD2        MERGE INTO LOOP, SETTING LOOP ADDR    07344000
*                                                                       07345000
*        LOOP THROUGH ENTRIES IN BASE TABLE                             07346000
*                                                                       07347000
RLOAD1   LA    R1,$$BAS1(A2)      POINT TO NEXT ENTRY                   07348000
         BALR  RETURN,A1          CALL RELOCAD ROUTINE TO RELOCATE      07349000
         BCR   Z,R2               ALL DONE IF NON-RELOC, GOTO RLOAD3    07350000
*                                                                       07351000
*        MERGE AT THIS POINT WHEN DEALING WITH $$BAS1                   07352000
*                                                                       07353000
RLOAD2   LA    A1+1,VALUE(,R1)    POINT TO BLOCK ITSELF                 07354000
         LA    R1,CBLKBOT(,A1+1)  POINT TO CBLKBOT FIELD                07355000
         BALR  RETURN,A1          RELOCATE IT (RELOCAD)                 07356000
         LA    R1,VBLKNXT(,A1+1)  POINT TO VBLKNXT FIELD                07357000
         BALR  RETURN,A1          RELOCATE IT (RELOCAD)                 07358000
         LA    A2,4(,A2)          INCREMENT BASE TABLE OFFSET           07359000
         BALR  R2,A2+1            BACK TO RLOAD1, SETTING END ADDRESS   07360000
         EJECT                                                          07361000
*                                                                       07362000
*        HERE AFTER PROCESSING BASE TABLE, NOW RELOCATE MISC POINTERS   07363000
*                                                                       07364000
RLOAD3   LA    A2,NDRELOC*4-4     OFFSET TO LAST POINTER                07365000
*                                                                       07366000
*        RELOCATE VARIOUS POINTERS TO DATA AREA                         07367000
*                                                                       07368000
         BALR  R2,0               SET START OF LOOP ADDRESS             07369000
RLOAD4   LA    R1,FDRELOC(A2)     POINT TO ENTRY                        07370000
         BALR  RETURN,A1          RELOCATE IT (RELOCAD)                 07371000
         SH    A2,=H'4'           STEP BACK TO NEXT ENTRY               07372000
         BCR   NM,R2              LOOP BACK (RLOAD4) IF MORE TO GO      07373000
*                                                                       07374000
*        NOW DEAL WITH SCANMODE AND ANYTPTR                             07375000
*                                                                       07376000
         L     R0,QPATSBAD        LOAD ADDRESS OF QPATSUBS              07377000
         ST    R0,SCANMODE        STORE AS VALUE OF SCANMODE            07378000
         LA    R1,ANYTPTR         POINT TO CURRENT ANY TABLE PTR        07379000
         BALR  RETURN,A1          RELOCATE IT (RELOCAD)                 07380000
*                                                                       07381000
*        NOW START THE LOOP THROUGH THE VARIABLE HASH TABLE             07382000
*                                                                       07383000
         L     A2,HASHTBAD        POINT TO HASH TABLE                   07384000
*                                                                       07385000
*        LOOP THROUGH SLOTS IN HASH TABLE                               07386000
*                                                                       07387000
RLOADHL  LA    R1,VLINK(,A2)      POINT TO VAR BLOCK POINTER            07388000
*                                                                       07389000
*        LOOP THROUGH VARIABLE BLOCKS ON ONE HASH CHAIN                 07390000
*                                                                       07391000
RLOAD5   BALR  RETURN,A1          RELOCATE AND LOAD VAR BLOCK POINTER   07392000
         BZ    RLOAD10            SKIP IF END OF CHAIN                  07393000
         LR    A2+1,R1            POINT TO VARIABLE BLOCK               07394000
         LA    R1,VNAME(,A2+1)    POINT TO NAME FIELD                   07395000
         BALR  RETURN,A1          TRY TO RELOCATE IT                    07396000
         BNZ   RLOAD7             SKIP IF PTR WAS INTO DATA AREA        07397000
*                                                                       07398000
*        HERE WE HAVE A NAME POINTER INTO THE INITV TBL IN SPITBOLR     07399000
*                                                                       07400000
         S     R1,SPITRAD         MAKE POINTER RELATIVE                 07401000
         A     R1,SPITRADN        ADD NEW BASE ADDRESS TO MAKE ABSOLUTE 07402000
         ST    R1,VNAME(,A2+1)    STORE RELOCATED NAME POINTER          07403000
         AH    R1,VNAME+SLENGTH(,A2+1)      STEP PAST NAME IN INITV TBL 07404000
         LR    A1+1,R1            COPY INITV ENTRY POINTER              07405000
         TM    SCHARS+1(A1+1),INITK         KEYWORD PRESENT?            07406000
         BNO   *+8                SKIP IF NOT                           07407000
         LA    R1,1(,R1)          IF SO, STEP PAST IT                   07408000
         TM    SCHARS+1(A1+1),INITP         STANDARD PATTERN?           07409000
         BNO   RLOAD6             SKIP IF NOT                           07410000
         EJECT                                                          07411000
*                                                                       07412000
*        HERE WE MUST RELOCATE A STANDARD PATTERN POINTER               07413000
*                                                                       07414000
         L     R0,VALUE(,A2+1)    LOAD OLD PATTERN POINTER              07415000
         S     R0,SPITXAD         MAKE POINTER RELATIVE                 07416000
         A     R0,SPITXADN        ADD NEW STARTING ADDRESS              07417000
         ST    R0,VALUE(,A2+1)    STORE RELOCATED POINTER               07418000
         LA    R1,2(,R1)          STEP PAST PATTERN OFFSET IN INITV TBL 07419000
*                                                                       07420000
*        NOW TEST FOR STANDARD FUNCTION POINTER                         07421000
*                                                                       07422000
RLOAD6   TM    SCHARS+1(A1+1),INITF         IS THERE A STANDARD FUNC?   07423000
         BNO   RLOAD7             SKIP IF NOT                           07424000
         MVC   VFUNC+1(3,A2+1),SCHARS+1+1(R1)         IF SO, SET IT     07425000
         B     RLOAD8             SKIP                                  07426000
*                                                                       07427000
*        HERE IF NO STANDARD FUNCTION POINTER                           07428000
*                                                                       07429000
RLOAD7   MVC   VFUNC+1(3,A2+1),NOFNAD       SET STANDARD NO FUNCTION AD 07430000
*                                                                       07431000
*        NOW WE DEAL WITH THE LABEL POINTER                             07432000
*                                                                       07433000
RLOAD8   LA    R1,VLABL(,A2+1)    POINT TO LABEL POINTER                07434000
         BALR  RETURN,A1          TRY TO RELOCATE AS DATA AREA PTR      07435000
         BNZ   RLOAD9             SKIP IF IT WAS DATA AREA PTR          07436000
         S     R1,SPITXAD         ELSE IT WAS STANDARD, MAKE IT REL     07437000
         A     R1,SPITXADN        ADD NEW BASE POINTER                  07438000
         ST    R1,VLABL(,A2+1)    STORE RELOCATED VALUE                 07439000
*                                                                       07440000
*        HERE AFTER COMPLETELY RELOCATING VAR BLOCK EXCEPT FOR VLINK    07441000
*                                                                       07442000
RLOAD9   LA    R1,VLINK(,A2+1)    POINT TO HASH FORWARD LINK PTR        07443000
         B     RLOAD5             LOOP BACK                             07444000
*                                                                       07445000
*        HERE AFTER DEALING WITH ALL VARIABLE BLOCKS ON ONE HASH CHAIN  07446000
*                                                                       07447000
RLOAD10  LA    A2,4(,A2)          POINT TO NEXT SLOT                    07448000
         C     A2,HASHTBEN        MORE SLOTS TO GO?                     07449000
         BL    RLOADHL            LOOP BACK IF MORE TO GO               07450000
*                                                                       07451000
*        NOW WE MUST DEAL WITH CONSTANT BLOCKS AND PATTERN STRUCTURES   07452000
*                                                                       07453000
         SR    DB4,DB4            INITIALIZE BASE TABLE OFFSET          07454000
         LH    A2,=H'-8'          BXH INCREMENT                         07455000
*                                                                       07456000
*        START LOOP THROUGH 4K BLOCKS (BASE TABLE ENTRIES)              07457000
*                                                                       07458000
RLOAD11  L     A2+1,$$BAS1(DB4)   LOAD NEXT BASE TABLE POINTER          07459000
         LA    A2+1,VALUE(,A2+1)  POINT TO ACTUAL BLOCK                 07460000
         LA    DB2,CBLKEND(,A2+1) POINT TO END OF BLOCK                 07461000
         L     A2+1,CBLKBOT(,A2+1)          POINT TO LOWEST CONSTANT    07462000
         AR    A2+1,A2            BACK OFF BY 8 FOR BXH                 07463000
         EJECT                                                          07464000
*                                                                       07465000
*        LOOP THROUGH CONSTANTS IN ONE 4K BLOCK                         07466000
*                                                                       07467000
RLOAD12  TM    0(DB2),RELOCBIT+EXPRBIT      RELOCATABLE OR VCODE?       07468000
         BZ    RLOAD17            SKIP TO END OF LOOP IF NOT            07469000
         LR    R1,DB2             ELSE COPY POINTER                     07470000
         BALR  RETURN,A1          RELOCATE IT AND LOAD                  07471000
         CLI   0(DB2),PCODE       DOES IT POINT TO A PATTERN STRUCTURE? 07472000
         BNE   RLOAD17            SKIP TO END OF LOOP IF NOT            07473000
*                                                                       07474000
*        HERE WE MUST RELOCATE ALL POINTERS IN A PATTERN STRUCTURE      07475000
*                                                                       07476000
         LA    A1+1,0(,R1)        COPY PATTERN PTR, CLEAR UPPER BYTE    07477000
         L     DB3,SPITPADN       NEW SPITBOLP ADDRESS                  07478000
         S     DB3,SPITPAD        MINUS OLD = SPITBOLP RELOC FACTOR     07479000
         LM    R0,R1,PNOTHEN(A1+1)          LOAD PNOTHEN, PNOOR PTRS    07480000
         AR    R0,DB3             RELOCATE THEM                         07481000
         AR    R1,DB3             . . . .                               07482000
         STM   R0,R1,PNOTHEN(A1+1)          STORE RELOCATED POINTERS    07483000
         LA    R2,PATS(,A1+1)     POINT TO FIRST PATTERN NODE           07484000
         AH    A1+1,PTLENG(,A1+1) POINT TO END OF PATTERN NODES         07485000
*                                                                       07486000
*        LOOP THROUGH NODES IN PATTERN STRUCTURE                        07487000
*                                                                       07488000
RLOAD13  L     R0,CODELOC(,R2)    LOAD PATTERN CODE POINTER             07489000
         AR    R0,DB3             RELOCATE AS SPITBOLP POINTER          07490000
         ST    R0,CODELOC(,R2)    STORE RELOCATED POINTER               07491000
         TM    PFLAGS(R2),PSPANFLG          POINTER TO MASTER SPAN TBL? 07492000
         BNO   RLOAD13A           SKIP IF NOT                           07493000
*                                                                       07494000
*        HERE FOR SPECIAL CASE OF PTR TO MASTER SPAN TABLE              07495000
*                                                                       07496000
         L     R0,PARAM1(,R2)     LOAD POINTER                          07497000
         S     R0,SPITRAD         MAKE RELATIVE                         07498000
         A     R0,SPITRADN        COMPUTE RELOCATED VALUE               07499000
         ST    R0,PARAM1(,R2)     STORE RELOCATED VALUE                 07500000
         B     RLOAD15            JUMP TO SKIP PAST NODE                07501000
*                                                                       07502000
*        HERE IF NOT SPECIAL CASE OF MASTER SPAN TABLE POINTER          07503000
*                                                                       07504000
RLOAD13A TM    PFLAGS(R2),PRELOC2 TEST FOR RELOCATABLE PARAMS           07505000
         BZ    RLOAD15            SKIP IF NEITHER RELOCATABLE           07506000
         BM    RLOAD14            SKIP IF PARAM1 RELOCATABLE            07507000
*                                                                       07508000
*        COME HERE IF PARAM2 IS RELOCATABLE                             07509000
*                                                                       07510000
         LA    R1,PARAM2(,R2)     POINT TO SECOND PARAMETER             07511000
         BALR  RETURN,A1          RELOCATE IT                           07512000
         B     RLOAD15            JUMP TO SKIP PAST NODE                07513000
*                                                                       07514000
*        HERE IF PARAM1 IS RELOCATABLE                                  07515000
*                                                                       07516000
RLOAD14  LA    R1,PARAM1(,R2)     POINT TO FIRST PARAMETER              07517000
         BALR  RETURN,A1          RELOCATE IT                           07518000
         EJECT                                                          07519000
*                                                                       07520000
*        HERE TO BUMP PAST FULLY RELOCATED NODE                         07521000
*                                                                       07522000
RLOAD15  TM    PFLAGS(R2),PARM1+PARM2       TEST NUMBER OF PARAMETERS   07523000
         LA    R2,LPRM0-PATS(,R2) BUMP PAST STANDARD STUFF ANYWAY       07524000
         BZ    RLOAD16            SKIP IF NO PARAMETERS                 07525000
         BM    *+8                SKIP IF ONLY ONE PARAMETER            07526000
         LA    R2,4(,R2)          SKIP PAST PARAM2                      07527000
         LA    R2,4(,R2)          SKIP PAST PARAM1                      07528000
*                                                                       07529000
*        HERE WE ARE POINTING TO THE NEXT NODE                          07530000
*                                                                       07531000
RLOAD16  CR    R2,A1+1            MORE NODES TO GO?                     07532000
         BL    RLOAD13            LOOP BACK IF SO                       07533000
*                                                                       07534000
*        HERE WE MOVE TO THE NEXT CONSTANT IN THIS 4K BLOCK             07535000
*                                                                       07536000
RLOAD17  BXH   DB2,A2,RLOAD12     LOOP BACK IF MORE TO GO IN THIS BLOCK 07537000
*                                                                       07538000
*        HERE WE LOOP TO THE NEXT 4K BLOCK                              07539000
*                                                                       07540000
         LA    DB4,4(,DB4)        INCREMENT BASE TABLE OFFSET           07541000
         CH    DB4,CURBASE        ANY MORE TO GO?                       07542000
         BNH   RLOAD11            SKIP BACK IF NOT                      07543000
*                                                                       07544000
*        REINITIALIZE UNDEFINED OPERATOR TABLE                          07545000
*                                                                       07546000
         L     R0,=A(XER09002-FCODE)        POINT TO FIRST ERROR LOC    07547000
         SR    R1,R1              SET OFFSET TO FIRST ENTRY             07548000
         LA    R2,NOPTRS          SET NUMBER OF ENTRIES TO REINITIALIZE 07549000
         BALR  DB4,0              GET ADDRESS OF LOOP IN REG            07550000
         ST    R0,OPTRTABL(R1)    STORE AN ENTRY                        07551000
         SH    R0,=H'2'           BACK OFF TO NEXT ERROR LOC            07552000
         LA    R1,4(,R1)          BUMP TABLE POINTER                    07553000
         BCTR  R2,DB4             LOOP BACK TILL ALL SET                07554000
*                                                                       07555000
*        AT THIS POINT ALL RELOCATION IS COMPLETE                       07556000
*                                                                       07557000
         ZAP   GCOLCNT,=P'0'      RESET GARBAGE COLLECTION COUNT        07558000
         MVC   CSECTAD(32),CSECTADN         SET NEW CSECT ADDRESSES     07559000
         L     SYS,SPITAAD        LOAD STANDARD SYSTEM AREA BASE REG    07560000
         L     RETURN,RLOADTRA    LOAD ADDRESS OF XEQ MERGE POINT       07561000
         LR    FRETURN,RETURN     SET UP BASE REGISTER FOR XEQGOGO      07562000
         L     R1,SPITRAD         ADDRESS OF SPITBOLR                   07563000
         USING SPITBOLR,R1        TELL ASSEMBLER                        07564000
         B     EXECUTE            JUMP TO EXECUTE SECTION               07565000
         DROP  R1                 DROP TEMPORARY BASE REG               07566000
         EJECT                                                          07567000
*                                                                       07568000
*        CONSTANTS FOR RELOAD ROUTINE                                   07569000
*                                                                       07570000
NOFNAD   DC    AL3($$NOFN-FCODE)  UNDEFINED FUNCTION TRANSFER ADDRESS   07571000
QPATSBAD DC    A(QPATSUBS)        DEFAULT SETTING FOR SCANMODE          07572000
*                                                                       07573000
*        NEW CSECT ADDRESSES                                            07574000
*                                                                       07575000
         EXTRN SPITBOLL,SPITBOLH  OLD DATA REGIONS (OBJECT MODULE)      07576000
CSECTADN DS    0F                 START OF NEW CSECT ADDRESSES          07577000
SPITCADN DC    A(SPITBOLC)        COMPILER                              07578000
SPITRADN DC    A(SPITBOLR)        ROOT PHASE                            07579000
SPITPADN DC    A(SPITBOLP)        PATTERN MATCH ROUTINES                07580000
SPITXADN DC    A(SPITBOLX)        NON-ADDRESSABLE EXECUTION ROUTINES    07581000
SPITAADN DC    A(SPITBOLA)        ADDRESSABLE EXECUTION ROUTINES, DATA  07582000
SPITFADN DC    A(SPITBOLF)        STANDARD FUNCTION DEFINITIONS         07583000
SPITLADN DC    A(SPITBOLL)        LOW CORE OF OLD DATA AREA             07584000
SPITHADN DC    A(SPITBOLH)        HIGH CORE OF OLD DATA AREA            07585000
*                                                                       07586000
RLOADTRA DC    A(XEQGOGO)         ADDRESS OF EXECUTION MERGE POINT      07587000
         EJECT                                                          07588000
*                                                                       07589000
*        THE ORIGINAL DATA AREA WAS SEPARATED INTO TWO PARTS BY THE     07590000
*        OBJECT MODULE GENERATOR (SPITBOLL AND SPITBOLH). THIS ROUTINE  07591000
*        DETERMINES WHICH SECTION WAS REFERENCED AND PERFORMS           07592000
*        RELOCATION --                                                  07593000
*                                                                       07594000
*        (R1)                     POINTS TO FIELD TO BE RELOCATED       07595000
*        (A1)                     POINTS TO RELOCAD ROUTINE             07596000
*        BALR  RETURN,A1                                                07597000
*        (CC)                     NON-ZERO IF RELOCATION SUCCESSFUL     07598000
*                                 ZERO IF NOT A DATA AREA POINTER       07599000
*        (R1)                     RELOCATED POINTER                     07600000
*                                 UNCHANGED POINTER IF CC=ZERO          07601000
*                                                                       07602000
*        THE RELOCATED POINTER IS ALSO STORED BACK INTO THE FIELD       07603000
*                                                                       07604000
RELOCAD  L     A1,0(,R1)          LOAD POINTER TO BE RELOCATED          07605000
         LA    R0,0(,A1)          STRIP UPPER BYTE                      07606000
         C     R0,SPITLAD         BELOW OLD AREA?                       07607000
         BL    RELOCADX           EXIT IF SO (NOT IN DATA AREA)         07608000
         CR    R0,SYS             ABOVE OLD DYNAMIC AREA?               07609000
         BH    RELOCADX           SKIP IF SO (NOT IN DATA AREA          07610000
*                                                                       07611000
*        HERE WE HAVE A POINTER WHICH MUST BE RELOCATED                 07612000
*                                                                       07613000
         C     R0,SPITHAD         LOW CORE OR HIGH CORE SECTION?        07614000
         BNL   RELOCADH           SKIP IF HIGH CORE SECTION             07615000
*                                                                       07616000
*        HERE WE HAVE A POINTER TO THE LOW CORE SECTION TO RELOCATE     07617000
*                                                                       07618000
         S     A1,SPITLAD         SUBTRACT OLD BASE                     07619000
         A     A1,SPITLADN        ADD NEW BASE                          07620000
         B     RELOCADR           SKIP TO RETURN                        07621000
*                                                                       07622000
*        HERE WE HAVE A POINTER TO THE HIGH CORE SECTION TO RELOCATE    07623000
*                                                                       07624000
RELOCADH S     A1,SPITHAD         SUBTRACT OLD BASE                     07625000
         A     A1,SPITHADN        ADD NEW BASE                          07626000
*                                                                       07627000
*        MERGE HERE AFTER RELOCATING POINTER                            07628000
*                                                                       07629000
RELOCADR ST    A1,0(,R1)          STORE RELOCATED POINTER               07630000
         LR    R1,A1              COPY TO RESULT REG                    07631000
         LA    A1,RELOCAD         RESET CALL REGISTER                   07632000
         BR    RETURN             RETURN TO CALLER (CC = NON-ZERO)      07633000
*                                                                       07634000
*        HERE IF POINTER IS NOT TO DATA AREA                            07635000
*                                                                       07636000
RELOCADX CR    R0,R0              SET CC = ZERO                         07637000
         LR    R1,A1              COPY NON-RELOCATED POINTER            07638000
         LA    A1,RELOCAD         RESTORE CALL REGISTER                 07639000
         BR    RETURN             RETURN TO CALLER (CC = ZERO)          07640000
         DROP  FRETURN            THROUGH WITH THIS BASE REG            07641000
.SKIPLLL ANOP                                                           07642000
         TITLE 'SPITBOLC -- CONSTANTS'                                  07643000
*                                                                       07644000
*        MISCELLANEOUS CONSTANTS                                        07645000
*                                                                       07646000
         DS    0F                 ALLIGN                                07647000
FULWRDAJ DC    X'FFFFFFFC'        ALLIGN TO FULLWORD                    07648000
TEMSTKBS DC    Y(0)               BASE FOR TEMPORARY LOCATIONS          07649000
         DC    S(TEM#1+8(PDR))    . . . .                               07650000
NULBLK   DC    A(OPNCN*256*256*256)         NULL OPND BLOCK FOR EXPAN   07651000
B$$ECON  B     $$ECON             BRANCH TO END CONSTANT EXPR CODE      07652000
PONE     DC    P'1'               DECIMAL ONE                           07653000
*                                                                       07654000
*        STANDARD COMPILE TIME SETTINGS OF CONTROL CARD SWITCHES        07655000
*                                                                       07656000
SWITCHD  EQU   *                  START OF DEFAULTS                     07657000
         DC    AL1(0)             -NOCODE                               07658000
         DC    AL1(0)             -SINGLE                               07659000
         DC    AL1(1)             -FAIL                                 07660000
         DC    AL1(1)             -IN72                                 07661000
         DC    AL1(1)             -LIST                                 07662000
         DC    AL1(0)             -ERRORS                               07663000
         DC    AL1(1)             -OPTIMIZE                             07664000
         DC    AL1(0)             -NOPRINT                              07665000
         DC    AL1(0)             -NOSEQUENCE                           07666000
*                                                                       07667000
PATCHC   DC    10A(0)             SPITBOLC PATCH AREA                   07668000
*                                                                       07669000
*        LITERALS                                                       07670000
*                                                                       07671000
         LTORG ,                  PLACE LITERALS HERE                   07672000
         TITLE 'SPITBOLC -- ROUTINE TO LINK TO EXECUTION'               07673000
         AIF   (&LMOD EQ 1).SKIPSS2                                     07674000
*                                                                       07675000
*        COME HERE AT END OF COMPILATION, PRINT STATISTICS              07676000
*                                                                       07677000
XEQGO    BALR  CB1,0              ENSURE ADDRESSABILITY                 07678000
         USING *,CB1              TELL ASSEMBLER ABOUT NEW BASE VALUE   07679000
         ST    LC,ENDCODAD        SAVE END OF GENERATED CODE            07680000
         MVI   LINELEFT+1,1       SET FOR NEW PAGE                      07681000
         MVC   OUSTITL,OUSTITL-1  CLEAR SUBTITLE                        07682000
         MVI   DUBLFLG,1          DOUBLE SPACE THIS OUTPUT              07683000
         L     R2,=V(SYSTIME)     LOAD ADDRESS OF TIMER ROUTINE         07684000
         BALR  R1,R2              CALL TIMER ROUTINE                    07685000
         NOP   0                  NO ERROR RETURN POSSIBLE              07686000
         S     R0,TIME            SUBTRACT START TIME                   07687000
         MVC   BUFR,BUFR-1        CLEAR OUTPUT BUFFER                   07688000
         CVD   R0,SCANWRK         CONVERT COMPILATION TIME TO DECIMAL   07689000
         MVC   BUFR(33),CTIMEN    MOVE IN COMP TIME MSG + EDIT PATTERN  07690000
         ED    BUFR+16(9),SCANWRK+4         EDIT COMPILATION TIME       07691000
         BAL   R7,LISTERU         LIST COMPILATION TIME                 07692000
         LR    R0,LC              COPY CURRENT CODE POINTER             07693000
         S     R0,CODEADR         SUBTRACT STARTING ADDRESS             07694000
*                                                                       07695000
*        NOW PREPARE TO PRINT STATISTICS ON SPACE USAGE                 07696000
*                                                                       07697000
         LA    LC,3(,LC)          PUSH LC LAST FULLWORD                 07698000
         N     LC,FULWRDAJ        ADJUST TO FULLWORD BOUNDARY           07699000
         ST    R0,0(,LC)          STORE LENGTH OF CODE                  07700000
         MVC   4(12,LC),STRUSED   SET STRUSED, VARUSED, CONUSED         07701000
         A     R0,STRUSED         COMPUTE TOTAL USED                    07702000
         A     R0,VARUSED         . . . .                               07703000
         A     R0,CONUSED         . . . .                               07704000
         ST    R0,16(,LC)         STORE TOTAL                           07705000
         L     R0,HICINUSE        GET END OF CORE AFTER SUBEX GONE      07706000
         SR    R0,LC              COMPUTE MEMORY AVAILABLE              07707000
         SH    R0,=Y(STACKTOP)    ADJUST FOR PDR OFFSET FACTOR          07708000
         ST    R0,20(,LC)         STORE AVAILABLE MEMORY                07709000
         MVC   BUFR(34),BUFR-1    BLANK BUFFER                          07710000
         MVC   BUFR(L'MEMMSG),MEMMSG        SET MEMORY USAGE MESSAGE    07711000
         BAL   R7,LISTERU         LIST LINE                             07712000
         LA    A1+1,6             SET SIX LINES TO PRINT                07713000
         LR    A1,LC              SET POINTER TO 1ST QUANTITY TO PRINT  07714000
         LA    A2,MEMMSGS         POINT TO MESSAGES                     07715000
         MVC   BUFR(40),BUFR-1    CLEAR BUFFER                          07716000
         EJECT                                                          07717000
*                                                                       07718000
*        LOOP TO PRINT VARIOUS QUANTITIES                               07719000
*                                                                       07720000
XEQGOML  MVC   BUFR(10),0(A2)     MOVE PROPER CAPTION                   07721000
         LA    A2,10(,A2)         BUMP POINTER                          07722000
         MVC   BUFR+18(7),MSGMEME EDIT PATTERN FOR SPACE USED           07723000
         L     R0,0(,A1)          LOAD QUANTITY TO CONVERT              07724000
         LA    A1,4(,A1)          POINT TO NEXT QUANTITY                07725000
         CVD   R0,SCANWRK         CONVERT TO DECIMAL                    07726000
         ED    BUFR+17(8),SCANWRK+4         EDIT PARAMETER VALUE        07727000
         BAL   R7,LISTERU         LIST LINE                             07728000
         BCT   A1+1,XEQGOML       LOOP BACK TILL ALL PRINTED            07729000
*                                                                       07730000
*        NOW PRINT COMMENT ERRORS ENCOUNTERED                           07731000
*                                                                       07732000
         MVC   BUFR(40),BUFR-1    CLEAR BUFFER                          07733000
         MVC   BUFR(L'XEQGONOE),XEQGONOE    SET NO ERRORS MSG IN CASE   07734000
         CP    ERRCOUNT,=P'0'     ANY COMPILATION ERRORS?               07735000
         BZ    XEQGOPRE           SKIP IF NO ERRORS                     07736000
         MVC   BUFR(25),XEQGONER  ELSE SET MSG & EDIT PATTERN FOR ERRS  07737000
         ED    BUFR+19(6),ERRCOUNT          EDIT COUNT OF ERRORS        07738000
*                                                                       07739000
*        MERGE HERE TO PRINT 'NO ERRORS' OR 'NUMBER OF ERRORS...'       07740000
*                                                                       07741000
XEQGOPRE BAL   R7,LISTERU         LIST LINE                             07742000
         B     XEQGOZR            JUMP TO NEXT SECTION                  07743000
*                                                                       07744000
*        CONSTANTS FOR STATISTICS PRINTOUT                              07745000
*                                                                       07746000
CTIMEN   DC    C'COMPILATION TIME '                                     07747000
         DC    X'202021204B202020'                                      07748000
         DC    C' SECONDS'                                              07749000
*                                                                       07750000
MEMMSG   DC    C'MEMORY USAGE (DECIMAL BYTES)'                          07751000
*                                                                       07752000
MEMMSGS  DC    CL10'CODE:'        CAPTIONS FOR SPACE USAGE              07753000
         DC    CL10'STRINGS:'                                           07754000
         DC    CL10'VARIABLES:'                                         07755000
         DC    CL10'CONSTANTS:'                                         07756000
         DC    CL10'TOTAL:'                                             07757000
         DC    CL10'AVAILABLE:'                                         07758000
*                                                                       07759000
MSGMEME  DC    X'20202020202120'  EDIT PATTERN FOR SPACE USED           07760000
*                                                                       07761000
XEQGONOE DC    C'SUCCESSFUL COMPILATION'                                07762000
*                                                                       07763000
XEQGONER DC    C'COMPILATION ERRORS  '                                  07764000
         DC    X'2020202020'                                            07765000
         EJECT                                                          07766000
*                                                                       07767000
*        HERE WE SCAN DOWN THE CONSTANT HASH TABLE CHAINS RESETTING     07768000
*        THE CONSTANTS TO THEIR STANDARD EXECUTION TIME FORMAT          07769000
*                                                                       07770000
XEQGOZR  LA    R1,63*4            SET OFFSET TO LAST HASH SLOT          07771000
         SR    R0,R0              CLEAR FOR IC                          07772000
*                                                                       07773000
*        LOOP THROUGH HASH SLOTS                                        07774000
*                                                                       07775000
XEQGOL1  L     R2,CHASH(R1)       LOAD POINTER TO FIRST ITEM ON CHAIN   07776000
*                                                                       07777000
*        LOOP THROUGH ITEMS ON ONE HASH CHAIN                           07778000
*                                                                       07779000
XEQGOL2  LA    R3,0(,R2)          COPY POINTER AND STRIP UPPER BYTE     07780000
         LTR   R3,R3              END OF CHAIN?                         07781000
         BZ    XEQGOC             SKIP IF END OF CHAIN                  07782000
         L     R2,CHASHL(,R3)     LOAD POINTER TO NEXT BLOCK ON CHAIN   07783000
         XC    VALUE+1(3,R3),VALUE+1(R3)    CLEAR CHASHL FIELD          07784000
         CLI   VALUE(R3),SCODE    IS THIS A STRING CONSTANT?            07785000
         BNE   XEQGOL2            DONE IF REAL OR INTEGER               07786000
         MVC   VALUE+1(3,R3),CSADR+1(R3)    ELSE MOVE STRING POINTER    07787000
         IC    R0,CSLENGTH(,R3)   LOAD 360 LENGTH OF STRING             07788000
         ST    R0,VALUE+4(,R3)    STORE LENGTH, SET SOFFSET = 0         07789000
         B     XEQGOL2            LOOP BACK                             07790000
*                                                                       07791000
*        HERE TO MOVE TO NEXT HASH SLOT                                 07792000
*                                                                       07793000
XEQGOC   SH    R1,=H'4'           BACK OFF TO NEXT HASH SLOT            07794000
         BNM   XEQGOL1            LOOP BACK IF MORE SLOTS TO GO         07795000
         EJECT                                                          07796000
*                                                                       07797000
*        NOW WE CHECK FOR LISTING OF GENERATE CODE                      07798000
*                                                                       07799000
         CLI   CODESW,0           CODE LISTING REQUIRED?                07800000
         BE    *+8                SKIP IF NOT                           07801000
         BAL   RF,PRCODE          ELSE LIST GENERATE CODE               07802000
*                                                                       07803000
*        SAVE LIMITS OF DYNAMIC STORAGE                                 07804000
*                                                                       07805000
         LA    LC,3(LC)           PUSH UP LC TO PREPARE FOR FULLWRDADJ  07806000
         N     LC,FULWRDAJ        PUT ON FULLWORD                       07807000
         ST    LC,DYNAMB          SAVE LOWER BOUND OF DYNAMIC STORAGE   07808000
         L     R2,=V(SYSTIME)     GET TIMER ROUTINE ADDRESS             07809000
         BALR  R1,R2              CALL ROUTINE                          07810000
         NOP   0                  NO ERROR RETURN POSSIBLE              07811000
         ST    R0,TIME            SAVE TIME                             07812000
         L     PDR,SUBEXBOT       START OF CONSTANT CODE ADDR           07813000
         LR    R5,PDR             SAVE IN R5 (A1+1) FOR LATER           07814000
         N     PDR,=X'FFFFFFF8'   ADJUST TO DOUBLW WORD BOUNDARY        07815000
         SH    PDR,=Y(STACKTOP)   CALCULATE INITIAL VALUE OF PDR        07816000
         L     FR,DYNAMB          GET LOWER LIMIT OF DYNAMIC STORAGE    07817000
         SER   SINC,SINC          INDICATE CONSTANT EXPR EVALUATION     07818000
         SER   SCNT,SCNT          CLEAR STATEMENT COUNT REGISTER        07819000
         XI    STAGE,$EXECUTE+$COMPILE      INDICATE EXECUTE TIME       07820000
*                                                                       07821000
*        LOAD EXECUTION BASE REGISTER                                   07822000
*                                                                       07823000
         L     SYS,=A(SPITBOLA)   SET EXECUTE BASE REG                  07824000
         ST    PDR,PDRLOC         SAVE INITIAL PDR LOCATION FOR FAILURE 07825000
*                                                                       07826000
*        INITIALIZE UNDEFINED OPERATORS TO UNDEFINED                    07827000
*                                                                       07828000
         L     R0,=A(XER09002-FCODE)        POINT TO 1ST ERROR MESSAGE  07829000
         SR    R1,R1              SET OFFSET TO FIRST ENTRY             07830000
         LA    R2,NOPTRS          SET NUMBER OF ENTRIES TO INITIALIZE   07831000
         BALR  DB4,0              SET LOOP ADDRESS REGISTER             07832000
         ST    R0,OPTRTABL(R1)    STORE AN ENTRY                        07833000
         SH    R0,=H'2'           BACK OFF TO PREVIOUS MESSAGE          07834000
         LA    R1,4(,R1)          BUMP POINTER                          07835000
         BCTR  R2,DB4             LOOP BACK IF MORE TO GO               07836000
         EJECT                                                          07837000
*                                                                       07838000
*        MISCELLANEOUS HOUSE KEEPING                                    07839000
*                                                                       07840000
         XC    ZTBL,ZTBL          CLEAR TABLE OF ZEROS                  07841000
         MVI   BREAKTBL+CTCHARS,X'FF'       SET NONZERO IN BREAK TABLE  07842000
         XC    BREAKTBL+CTCHARS+1(255),BREAKTBL+CTCHARS+1  ZERO REST    07843000
         MVC   XEQVALS(LXEQVALS),XEQINIT    INITIALIZE XEQ WORK AREAS   07844000
         MVC   V$MAXLN(8),=F'5000,50000'    SET &MAXLNGTH, &STLIMIT     07845000
         MVI   V$INPUT+3,1        SET &INPUT = 1                        07846000
         MVI   V$OUTPUT+3,1       SET &OUTPUT = 1                       07847000
         LCR   R0,PDR             GET A NEGATIVE FLAG FOR STACK END     07848000
         ST    R0,FBLOKLOC(,PDR)  AND PLACE IT ON THE STACK             07849000
         STE   ZR,PNAME(,PDR)     SET PNAME FLD NOT IN USE (FOR GCOL)   07850000
         LM    DB2,DB3,$$BAS2     INITIALIZE PTRS TO 2ND, 3RD 4K BLOCKS 07851000
*                                                                       07852000
*        HERE WE GO                                                     07853000
*                                                                       07854000
         MVI   CRELFLG,1          TELL GCOL TO PROCESS CONSTANTS        07855000
         CLI   SUPRXEQ,0          CAN WE EXECUTE?                       07856000
         LR    RETURN,A1+1        COPY JUMP ADDRESS                     07857000
         BE    EXECUTE            IF WE CAN EXEUTE, DO IT               07858000
         MVI   BYPASXEQ,1         ELSE SUPPRESS EXECUTION               07859000
         B     EXECUTE            AND JUMP TO LET XEQ GIVE MESSAGE      07860000
         DROP  CB1,CB2,CB3,CB4    DROP COMPILER BASE REGS               07861000
*                                                                       07862000
*        LITERALS AND PATCH SPACE FOR XEQGO                             07863000
*                                                                       07864000
         DC    5A(0)                                                    07865000
         LTORG ,                                                        07866000
.SKIPSS2 ANOP                                                           07867000
         TITLE 'SPITBOLR -- START OF CONTROL SECTION'                   07868000
*                                                                       07869000
*        THE SPITBOLR CONTROL SECTION CONTAINS ROUTINES, CONSTANTS AND  07870000
*        WORK AREAS USED BY THE COMPILER AND EXECUTE PACKAGE            07871000
*                                                                       07872000
*        IN THE TWO PHASE VERSION, THIS IS THE ROOT PHASE               07873000
*                                                                       07874000
         BEGIN R                  START OF SPITBOLR, SPITBLLR CSECT     07875000
         USING SPITBOLA,SYS       SYSTEM BASE REG FOR TOUEINS           07876000
         TITLE 'SPITBOLR -- STRING TO NUMERIC CONVERSION ROUTINE'       07877000
*                                                                       07878000
*        THIS ROUTINE IS USED BOTH AT COMPILE AND EXECUTE TIME TO       07879000
*        CONVERT A STRING TO A NUMERIC VALUE-- THE RESULT OF THE        07880000
*        CONVERSION IS IN THE STANDARD 8-BYTE FORMAT AND IS DETERMINED  07881000
*        AS FOLLOWS --                                                  07882000
*                                                                       07883000
*        THE RESULT IS AN INTEGER           IF THE STRING IS A SIGNED   07884000
*                                           OR UNSIGNED INTEGER IN THE  07885000
*                                           RANGE -2**31-1 < N < 2**31  07886000
*                                                                       07887000
*        THE RESULT IS A REAL               IF THE STRING IS A FLOATING 07888000
*                                           POINT NUMBER WITH 8 OR      07889000
*                                           FEWER SIGNIFICANT DIGITS    07890000
*                                                                       07891000
*        THE RESULT IS A DREAL              IF THE STRING IS A FLOATING 07892000
*                                           POINT NUMBER WITH MORE THAN 07893000
*                                           8 SIGNIFICANT DIGITS OR AN  07894000
*                                           EXPONENT WITH A 'D'         07895000
*                                                                       07896000
*                                                                       07897000
*        CALLING SEQUENCE --                                            07898000
*                                                                       07899000
*        (R2)                     ADDRESS OF STGTONUM ROUTINE           07900000
*        (A1)                     STARTING ADDRESS (MINUS SCHARS)       07901000
*        (A1+1)                   360 LENGTH                            07902000
*        BALR  R1,R2                                                    07903000
*        => ERROR RETURN IF UNCONVERTIBLE                               07904000
*        => NORMAL RETURN                                               07905000
*        (A1,A1+1)                NUMERIC RESULT                        07906000
*                                                                       07907000
*        ALL OTHER REGISTERS ARE SAVED AND RESTORED EXCEPT (R0)         07908000
*                                                                       07909000
         EJECT                                                          07910000
*                                                                       07911000
*        ENTRY POINT                                                    07912000
*                                                                       07913000
         USING STGTONUM,R2        BASE REGISTER SET BY CALLER           07914000
STGTONUM STM   R6,R10,STNSV       SAVE WORK REGS                        07915000
         ST    R1,STNRTN          SAVE RETURN POINT                     07916000
         LR    R6,R2              SWITCH BASE REGISTERS                 07917000
         DROP  R2                 TELL ASSEMBLER                        07918000
         USING STGTONUM,R6        ...                                   07919000
         CH    A1+1,=H'15'        MORE THAN 15 DIGITS?                  07920000
         BNL   STN7               IF SO, SKIP TO TRY AS REAL            07921000
         CLI   SCHARS(A1),C'0'    IS FIRST CHARACTER A DIGIT?           07922000
         BL    STN2               SKIP IF NOT (MAY BE A SIGN)           07923000
*                                                                       07924000
*        COME HERE TO TRY FOR INTEGER WITH NO LEADING SIGN              07925000
*                                                                       07926000
STN0     EX    A1+1,STNT1         CHECK FOR ALL DIGITS                  07927000
         BNZ   STN7               SKIP TO TRY AS REAL IF NOT ALL DIGITS 07928000
         EX    A1+1,STNP1         PACK UP DIGITS IF OK                  07929000
*                                                                       07930000
*        COME HERE TO CONVERT INTEGER TO BINARY                         07931000
*                                                                       07932000
STN1     CVB   A1+1,STNWRK        CONVERT TO BINARY                     07933000
*                                                                       07934000
*        THIS IS AN INTERRUPT LOCATION (INTEGER DIVIDE ON TOO LARGE)    07935000
*        ON INTERRUPT, AN EXIT TO STNE (CONVERSION ERROR) IS TAKEN      07936000
*                                                                       07937000
STN1A    NOPR  1                  ENSURE PRECISE INTERRUPT              07938000
         SR    A1,A1              IF OK, INDICATE INTEGER RESULT        07939000
         L     R6,STNSV           RESTORE R6                            07940000
         L     R1,STNRTN          RELOAD RETURN POINT                   07941000
         B     4(,R1)             GIVE SUCCESSFUL RETURN                07942000
*                                                                       07943000
STNT1    TRT   SCHARS(*-*,A1),SCANTB3       TEST FOR DIGITS (NO SIGN)   07944000
STNP1    PACK  STNWRK,SCHARS(*-*,A1)        PACK (NO SIGN)              07945000
*                                                                       07946000
*        COME HERE IF FIRST CHARACTER IS NOT A DIGIT                    07947000
*                                                                       07948000
STN2     SH    A1+1,=H'1'         DECREMENT LENGTH FOR POSSIBLE SIGN    07949000
         BM    STNE               ONE CHARACTER NOT A DIGIT IS AN ERROR 07950000
         EX    A1+1,STNT2         TEST FOR ALL DIGITS AFTER SIGN        07951000
         BNZ   STN6               SKIP IF NOT ALL DIGITS                07952000
         EX    A1+1,STNP2         ELSE PACK UP DIGITS                   07953000
         CLI   SCHARS(A1),C'-'    DID WE HAVE A MINUS SIGN?             07954000
         BNE   STN5               SKIP IF NOT                           07955000
         NI    STNWRK+7,X'FD'     CHANGE PACKED SIGN TO MINUS           07956000
         B     STN1               AND JUMP BACK TO CONVERT TO BINARY    07957000
*                                                                       07958000
STNT2    TRT   SCHARS+1(*-*,A1),SCANTB3     TEST FOR DIGITS WITH SIGN   07959000
STNP2    PACK  STNWRK,SCHARS+1(*-*,A1)      PACK DIGITS WITH SIGN       07960000
         EJECT                                                          07961000
*                                                                       07962000
*        COME HERE FOR LEADING "SIGN" NOT A MINUS SIGN                  07963000
*                                                                       07964000
STN5     CLI   SCHARS(A1),C'+'    IS IT PLUS SIGN?                      07965000
         BE    STN1               SKIP BACK IF SO TO CONVERT TO BINARY  07966000
*                                                                       07967000
*        COME HERE IF NOT INTEGER WITH SIGN AFTER ALL                   07968000
*                                                                       07969000
STN6     LA    A1+1,1(,A1+1)      ADJUST LENGTH BACK FOR SIGN FUDGE     07970000
*                                                                       07971000
*        COME HERE IF NOT INTEGER -- CHECK FOR POSSIBLE BLANKS          07972000
*                                                                       07973000
STN7     LA    A1+1,1(,A1+1)      ADJUST TO GET REAL LENGTH             07974000
         CLI   SCHARS(A1),C' '    TEST FOR LEADING BLANK                07975000
         BE    STNBL              SKIP IF LEADING BLANKS                07976000
         LA    R2,SCHARS-1(A1,A1+1)         POINT TO LAST CHARACTER     07977000
         CLI   0(R2),C' '         DO WE HAVE A TRAILING BLANK?          07978000
         BE    STNBLD             SKIP IF TRAILING BLANK(S)             07979000
*                                                                       07980000
*        COME HERE TO TRY FOR REAL WITH POSSIBLE SIGN                   07981000
*                                                                       07982000
         CLI   SCHARS(A1),C'-'    DO WE HAVE AN INITIAL MINUS?          07983000
         BNE   STN7A              SKIP IF NOT                           07984000
         MVI   STNFLG,STNM        ELSE SET FLAG FOR NEGATIVE            07985000
         LA    A1,1(,A1)          PUSH CHARACTER POINTER                07986000
         BCT   A1+1,STN9          AND SKIP, DECREMENTING LENGTH         07987000
*                                                                       07988000
*        COME HERE IF NOT A MINUS SIGN TO START                         07989000
*                                                                       07990000
STN7A    CLI   SCHARS(A1),C'+'    DO WE HAVE A PLUS SIGN?               07991000
         BNE   STN8               SKIP IF NOT                           07992000
         LA    A1,1(,A1)          ELSE BUMP PAST PLUS SIGN              07993000
         BCTR  A1+1,0             DECREMENT LENGTH                      07994000
*                                                                       07995000
*        COME HERE FOR POSITIVE REAL                                    07996000
*                                                                       07997000
STN8     MVI   STNFLG,0           SET POSITIVE                          07998000
*                                                                       07999000
*        COME HERE WITH SIGN FLAG SET ALL READY TO GO                   08000000
*                                                                       08001000
STN9     LA    R9,1               GET CONSTANT OF ONE FOR GENERAL USE   08002000
         SR    R0,R0              CLEAR R0,R1 FOR DIGIT COLLECTION      08003000
         SR    R1,R1              ... DIGS ARE COLLECTED AS PACKED DEC  08004000
         SR    R2,R2              SET SCALE = 0                         08005000
         LR    R7,R9              (R7)=1 BEFORE DEC PT. 0 AFTER DEC PT. 08006000
         EJECT                                                          08007000
*                                                                       08008000
*        LOOP TO COLLECT DIGITS                                         08009000
*                                                                       08010000
STN10    CLI   SCHARS(A1),C'0'    IS THIS A DIGIT?                      08011000
         BL    STN13A             SKIP IF IT IS NOT A DIGIT             08012000
*                                                                       08013000
*        COME HERE FOR A DIGIT                                          08014000
*                                                                       08015000
         CL    R0,=X'0FFFFFFF'    CHECK FOR 16 DIGITS COLLECTED ALREADY 08016000
         BH    STN12              SKIP IF SO (IGNORE DIGIT)             08017000
         SLDL  R0,4               MAKE ROOM FOR NEW DIGIT               08018000
         IC    R10,SCHARS(A1)     LOAD CHARACTER                        08019000
         N     R10,=X'0000000F'   REMOVE ZONE BITS                      08020000
         OR    R1,R10             STICK IN NEW DIGIT                    08021000
         BCTR  R2,0               ADJUST SCALE (WITH NEXT INSTRUCTION)  08022000
*                                                                       08023000
*        COME HERE WHEN DIGIT IS SKIPPED (SCALING IS REVERSED)          08024000
*                                                                       08025000
STN12    AR    R2,R7              COMPLETE ADJUSTMENT OF SCALE          08026000
*                                                                       08027000
*        JUMP HERE AFTER DEC POINT                                      08028000
*                                                                       08029000
STN13    AR    A1,R9              PUSH CHARACTER POINTER                08030000
         BCT   A1+1,STN10         LOOP BACK IF MORE CHARACTERS          08031000
*                                                                       08032000
*        FALL THROUGH HERE IF STRING EXHAUSTED (NO EXPONENT)            08033000
*                                                                       08034000
         BCT   R7,STN14           SKIP IF WE HAD DEC POINT, ELSE ERROR  08035000
*                                                                       08036000
*        COME HERE FOR ALL CONVERSION ERRORS                            08037000
*                                                                       08038000
STNE     LM    R6,R10,STNSV       RESTORE REGS                          08039000
         L     R1,STNRTN          RELOAD RETURN POINT                   08040000
         BR    R1                 GIVE ERROR RETURN                     08041000
*                                                                       08042000
*        COME HERE IF NOT A DIGIT                                       08043000
*                                                                       08044000
STN13A   BCT   R7,STN14           DECREMENT R7, SKIP IF ALREADY HAD A . 08045000
         CLI   SCHARS(A1),C'.'    ELSE IS THIS A DEC POINT?             08046000
         BE    STN13              SKIP BACK IF SO, ELSE FALL OUT        08047000
         EJECT                                                          08048000
*                                                                       08049000
*        HERE AFTER LOOP (EITHER NO CHRS LEFT OR STOPPED BY NON-DIGIT)  08050000
*        CONVERT COLLECTED DIGITS TO BINARY INTEGER IN A1,A1+1          08051000
*                                                                       08052000
STN14    STM   A1,A1+1,STNSV2     SAVE SCAN REGISTERS                   08053000
         SR    A1,A1              CLEAR HIGH ORDER OF RESULT            08054000
         LR    R10,R0             SA0E HIGH ORDER DIGITS COLLECTED      08055000
         BAL   R7,STNCVB          CONVERT LOW ORDER TO BINARY INTO A1+1 08056000
         LTR   R1,R10             RECALL (AND TEST) HIGH ORDER DIGITS   08057000
         BZ    STN16              SKIP IF NONE (REAL CASE)              08058000
         OI    STNFLG,STND        ELSE SET FOR DREAL RESULT             08059000
         LR    R10,A1+1           SAVE CONVERTED LOW ORDER              08060000
         BAL   R7,STNCVB          CONVERT HIGH ORDER DIGS TO BINARY     08061000
         M     A1,=F'100000000'   MULTIPLY BY 10**8 FOR LOW ORDER DIGS  08062000
         ALR   A1+1,R10           ADD IN LOW ORDER                      08063000
         BC    12,*+6             SKIP IF NO CARRY                      08064000
         AR    A1,R9              ELSE ADD 1 (CARRY) TO HI ORDER RESULT 08065000
*                                                                       08066000
*        COME HERE TO CONVERT INTEGER IN A1,A1+1 TO FLOATING POINT      08067000
*                                                                       08068000
STN16    STM   A1,A1+1,STNWRK     STORE INTEGER                         08069000
         LM    A1,A1+1,STNSV2     RESTORE SCAN REGS                     08070000
         MVI   STNWRK,X'4E'       SUPPLY EXPONENT                       08071000
         LD    FA,STNWRK          LOAD UNNORMALIZED FLOATING POINT      08072000
         ADR   FA,ZR              NORMALIZE                             08073000
         TM    STNFLG,STNM        TEST SIGN FLAG                        08074000
         BNO   STN20              SKIP IF NOT MINUS                     08075000
         LCDR  FA,FA              ELSE SET FLOATING POINT NUM NEGATIVE  08076000
*                                                                       08077000
*        COME HERE TO TEST FOR EXPONENT                                 08078000
*                                                                       08079000
STN20    LTR   A1+1,A1+1          DO WE HAVE ANY CHARS LEFT?            08080000
         BZ    STN30              SKIP IF NOT TO SCALING SECTION        08081000
         CLI   SCHARS(A1),C'E'    DO WE HAVE AN E?                      08082000
         BE    STN21              SKIP IF SO                            08083000
         CLI   SCHARS(A1),C'D'    DO WE HAVE A D?                       08084000
         BNE   STNE               ANYTHING ELSE IS AN ERROR             08085000
         OI    STNFLG,STND        ELSE SET FLAG FOR DREAL RESULT        08086000
*                                                                       08087000
*        COME HERE WHEN WE ACTUALLY HAVE AN EXPONENT                    08088000
*                                                                       08089000
STN21    SR    A1+1,R9            DECREMENT COUNT FOR D OR E            08090000
         CLI   SCHARS+1(A1),C'+'  DO WE HAVE A PLUS SIGN?               08091000
         BE    STN22              SKIP IF SO                            08092000
         CLI   SCHARS+1(A1),C'-'  ELSE DO WE HAVE A MINUS SIGN?         08093000
         BNE   STN23              SKIP IF NOT                           08094000
         OI    STNFLG,STNEM       SET FOR EXPONENT MINUS                08095000
         EJECT                                                          08096000
*                                                                       08097000
*        COME HERE AFTER FINDING AN EXPONENT SIGN                       08098000
*                                                                       08099000
STN22    AR    A1,R9              PUSH CHARACTER POINTER FOR SIGN       08100000
         SR    A1+1,R9            DECREMENT COUNT FOR SIGN              08101000
*                                                                       08102000
*        COME HERE TO CONVERT EXPONENT                                  08103000
*                                                                       08104000
STN23    SR    A1+1,R9            DECREMENT TO GET 360 LENGTH OF EXPON  08105000
         CLR   A1+1,R9            MUST BE ZERO OR ONE                   08106000
         BH    STNE               ERROR IF NEGATIVE OR HIGHER THAN 1    08107000
         EX    A1+1,STNT2         CHECK FOR DIGITS                      08108000
         BNZ   STNE               ERROR IF NOT                          08109000
         EX    A1+1,STNP2         ELSE PACK DIGITS                      08110000
         CVB   R9,STNWRK          CONVERT EXPONENT TO BINARY            08111000
         TM    STNFLG,STNEM       WAS EXPONENT NEGATIVE?                08112000
         BNO   *+6                SKIP IF NOT                           08113000
         LCR   R9,R9              ELSE COMPLEMENT IT                    08114000
         AR    R2,R9              ADD EXPONENT TO SCALE                 08115000
*                                                                       08116000
*        COME HERE TO SCALE THE FLOATING POINT NUMBER BY MULTIPLYING    08117000
*        BY 10**N WHERE N IS THE SCALE                                  08118000
*                                                                       08119000
STN30    LA    R1,SCALER          POINT TO SCALING SUBROUTINE           08120000
         LR    R6,R2              GET VALUE OF SCALE                    08121000
         DROP  R6                 DROP OUR BASE REGISTER                08122000
         BALR  R7,R1              MULTIPLY REAL BY 10**SCALE            08123000
         USING *,R7               OUR NEW BASE REGISTER                 08124000
*                                                                       08125000
*        COME HERE WHEN WE ARE ALL READY WITH FLOATING POINT NUMBER     08126000
*                                                                       08127000
STN33    SDR   ZR,ZR              CLEAR ZR BACK TO ZERO                 08128000
         STD   FA,STNWRK          STORE RESULTING FPT NUMBER            08129000
         TM    STNFLG,STND        TEST FOR DREAL TO BE RETURNED         08130000
         BO    STN40              SKIP IF SO                            08131000
         EJECT                                                          08132000
*                                                                       08133000
*        COME HERE IF REAL IS TO BE RETURNED                            08134000
*                                                                       08135000
         XC    STNWRK+1(3),STNWRK+1         CLEAR UPPER 3 BYTES OF FRAC 08136000
         AD    FA,STNWRK          ADD LOW ORDER TO ROUND CORRECTLY      08137000
         STE   FA,STNWRK          STORE SHORT FORM ROUNDED RESULT       08138000
         L     A1+1,STNWRK        LOAD INTO RESULT REGISTER             08139000
         L     A1,=X'80000000'    SUPPLY REAL TYPE CODE                 08140000
         LM    R6,R10,STNSV       RESTORE REGS                          08141000
         L     R1,STNRTN          RELOAD RETURN POINT                   08142000
         B     4(,R1)             RETURN TO CALLER                      08143000
*                                                                       08144000
*        COME HERE IF DREAL IS TO BE RETURNED                           08145000
*                                                                       08146000
STN40    XC    STNWRK+1(6),STNWRK+1         CLEAR ALL BUT LOW ORDER BYT 08147000
         AD    FA,STNWRK          ADD TO ROUND                          08148000
         STD   FA,STNWRK          STORE ROUNDED RESULT                  08149000
         LM    A1,A1+1,STNWRK     LOAD INTO RESULT REGS                 08150000
         SRDL  A1,8               POSITION FOR DREAL                    08151000
         AL    A1,=X'C0000000'    SUPPLY WCODE FOR DREAL                08152000
         LM    R6,R10,STNSV       RESTORE REGS                          08153000
         L     R1,STNRTN          RELOAD RETURN POINT                   08154000
         B     4(,R1)             RETURN TO CALLER                      08155000
         DROP  R7                 DROP OUR NEW BASE REG                 08156000
*                                                                       08157000
*        SCALING INSTRUCTIONS                                           08158000
*                                                                       08159000
STNS     DDR   FA,ZR              SCALE DOWN IF S < 0                   08160000
         MDR   FA,ZR              SCALE UP IF S > 0                     08161000
*                                                                       08162000
*        SUBROUTINE TO CONVERT TO BINARY                                08163000
*                                                                       08164000
*        (R1)                     PACKED DECIMAL DIGITS                 08165000
*        BAL   R7,STNCVB                                                08166000
*        (A1+1)                   BINARY RESULT                         08167000
*                                                                       08168000
         USING STGTONUM,R6        STANDARD STGTONUM BASE REGISTER       08169000
STNCVB   SR    R0,R0              CLEAR HIGH ORDER                      08170000
         SLDL  R0,4               MAKE ROOM FOR PACKED DEC SIGN         08171000
         STM   R0,R1,STNWRK       STORE PACKED NUMBER                   08172000
         OI    STNWRK+7,X'0C'     SUPPLY PACKED PLUS SIGN               08173000
         CVB   A1+1,STNWRK        CONVERT TO BINARY                     08174000
*                                                                       08175000
*        THIS IS AN INTERRUPT LOCATION (DATA -- CODES > X'F9')          08176000
*        ON INTERRUPT -- AN EXIT TO STNE (CONVERSION ERROR) IS TAKEN    08177000
*                                                                       08178000
STNCVBE  NOPR  1                  ENSURE PRECISE INTERRUPT              08179000
         BR    R7                 IF NO ERROR ON CONVERT -- RETURN      08180000
         EJECT                                                          08181000
*                                                                       08182000
*        SECTION TO REMOVE LEADING BLANKS                               08183000
*                                                                       08184000
STNBL    LA    A1,1(,A1)          CRANK PAST LEADING BLANK              08185000
         BCT   A1+1,STNBL2        SKIP DECREMENTING CHARS LEFT          08186000
         B     STNE               ELSE ALL BLANKS, SIGNAL CONVERT ERROR 08187000
*                                                                       08188000
*        COME HERE TO TEST FOR ANOTHER LEADING BLANK                    08189000
*                                                                       08190000
STNBL2   CLI   SCHARS(A1),C' '    DO WE HAVE ANOTHER LEADING BLANK      08191000
         BE    STNBL              IF SO, LOOP BACK TO DELETE IT         08192000
*                                                                       08193000
*        COME HERE TO DELETE TRAILING BLANKS                            08194000
*                                                                       08195000
STNBLDL  LA    R2,SCHARS-1(A1,A1+1)         POINT TO LAST CHARACTER     08196000
         CLI   0(R2),C' '         TEST FOR TRAILING BLANK               08197000
         BE    STNBLD             SKIP IF ANOTHER TRAILING BLANK        08198000
         BCT   A1+1,STN0          ELSE REENTER WITH COUNT PROPERLY SET  08199000
         B     STN0               JUMP EVEN IF ONLY ONE CHARACTER LEFT  08200000
*                                                                       08201000
*        COME HERE AFTER DETECTING THE INITIAL TRAILING BLANK           08202000
*                                                                       08203000
STNBLD   BCT   A1+1,STNBLDL       DECR CHAR COUNT (ALWAYS BRANCHES)     08204000
         DROP  R6                 DROP ORIGNAL BASE REGISTER            08205000
         TITLE 'SPITBOLR -- NUMERIC TO STRING ROUTINE'                  08206000
*                                                                       08207000
*        (A1,A1+1) (R4,R5)        NUMERIC ITEM (INTEGER,REAL OR DREAL)  08208000
*        (R0)                     FORMAT -- SEE BELOW                   08209000
*        L     R2,=A(NUMTOSTG)                                          08210000
*        BALR  R1,R2                                                    08211000
*        (A1,A1+1)                STRING ADDR(-SCHARS) 360 LENGTH       08212000
*        (CONDITION CODE)         SET TO ZERO IF TABLE LOOKUP USED      08213000
*                                 (I.E. NO NEED TO COPY RESULT)         08214000
*                                                                       08215000
*        THE FOUR BYTE FORMAT DESCRIPTION CONSISTS OF THE FOLLOWING     08216000
*                                                                       08217000
*        DC    AL1(DREAL FORMAT, DREAL NDIGS, REAL FORMAT, REAL NDIGS)  08218000
*                                                                       08219000
*        NDIGS IS THE NUMBER OF DIGITS (DSECRIBED FURTHER BELOW)        08220000
*                                                                       08221000
*        FORMAT IS A NUMBER FROM 0 TO 5 AS FOLLOWS --                   08222000
*                                                                       08223000
*        0)    FIXED IF POSSIBLE, ELSE FLOATING -- TRAILING ZEROS       08224000
*              SUPPRESSED -- NDIGS = NUMBER OF SIGNIFICANT DIGITS       08225000
*                                                                       08226000
*        1)    SAME AS 0 BUT WITHOUT SUPPRESSION OF TRAILING ZEROS      08227000
*                                                                       08228000
*        2)    FLOATING FORMAT (FORTRAN E ) NDIGS = NUM DEC PLACES      08229000
*              TRAILING ZEROS (IN FRACTION) SUPPRESSED                  08230000
*                                                                       08231000
*        3)    LIKE 2 BUT WITH NO SUPPRESSION OF TRAILING ZEROS         08232000
*                                                                       08233000
*        4)    FIXED FORMAT (FORTRAN F) NDIGS = NUM DEC PLACES -- USES  08234000
*              FLOATING FORMAT IF MORE THAN 8 (REAL) OR 16(DREAL)       08235000
*              SIGNIFICANT DIGITS WOULD BE DISPLAYED -- TRAILING ZEROS  08236000
*              ARE SUPPRESSED                                           08237000
*                                                                       08238000
*        5)    LIKE 4 BUT WITH NO SUPPRESSION OF TRAILING ZEROS         08239000
*                                                                       08240000
         EJECT                                                          08241000
*                                                                       08242000
*        ENTRY POINT                                                    08243000
*                                                                       08244000
         USING *,R2               BASE REGISTER SET BY CALLER           08245000
NUMTOSTG LCR   A1,A1              TEST TYPE OF ARGUMENT                 08246000
         BO    NTSR               SKIP IF REAL                          08247000
         BP    NTSD               SKIP IF DREAL                         08248000
*                                                                       08249000
*        COME HERE IF INTEGER                                           08250000
*                                                                       08251000
         CL    A1+1,=F'100'       IS IT IN RANGE 0 <= N < 100 ?         08252000
         BL    NTSI1              SKIP IF SO (SPECIAL ROUTINE)          08253000
*                                                                       08254000
*        CONVERT INTEGER GREATER THAN 100 OR NEGATIVE                   08255000
*                                                                       08256000
         CVD   A1+1,NTSWRK        CONVERT TO DECIMAL                    08257000
         MVC   NTSRSL(11),=X'2020202020202020202020'  SET EDIT PATTERN  08258000
         LR    R0,R1              SAVE RETURN POINT                     08259000
         EDMK  NTSRSL(11),NTSWRK+2          GET STRING MARKING 1ST DIG  08260000
         LA    A1,0(,R1)          SAVE 1ST DIGIT LOC (STRIP UPPER BYTE) 08261000
         LR    R1,R0              RESTORE RETURN ADDRESS                08262000
         BNM   *+10               SKIP IF NON-NEGATIVE                  08263000
         BCTR  A1,0               IF NEGATIVE, BACK OFF POINTER         08264000
         MVI   0(A1),C'-'         AND SUPPLY A MINUS SIGN               08265000
         LA    A1+1,NTSRSL+10     POINT TO LAST CHARACTER               08266000
         SR    A1+1,A1            CALCULATE 360 LENGTH OF RESULT        08267000
         SH    A1,=Y(SCHARS)      ADJUST FOR SCHARS OFFSET              08268000
         BR    R1                 RETURN TO CALLER                      08269000
*                                                                       08270000
*        COME HERE FOR INTEGER IN RANGE 0 <= N < 100                    08271000
*                                                                       08272000
NTSI1    CH    A1+1,=H'10'        IS IT LESS THAN 10 ?                  08273000
         BL    NTSI2              SKIP IF SO                            08274000
*                                                                       08275000
*        COME HERE TO CONVERT INTEGER IN THE RANGE 10 <= N < 100        08276000
*                                                                       08277000
         AR    A1+1,A1+1          DOUBLE TO FORM INDEX                  08278000
         LA    A1,NTSD2-2*10-SCHARS(A1+1)   POINT TO PROPER TABLE LOC   08279000
         LA    A1+1,1             SET 360 LENGTH = 1                    08280000
         CR    R0,R0              SET CC = ZERO FOR NO MOVE NEEDED      08281000
         BR    R1                 RETURN TO CALLER                      08282000
*                                                                       08283000
*        COME HERE TO CONVERT INTEGER IN RANGE 0 <= N < 10              08284000
*                                                                       08285000
NTSI2    LA    A1,NTSD1-SCHARS(A1+1)        POINT TO PROPER TABLE LOC   08286000
         SR    A1+1,A1+1          SET 360 LENGTH = 0                    08287000
         BR    R1                 RETURN TO CALLER                      08288000
         EJECT                                                          08289000
*                                                                       08290000
*        COME HERE FOR DREAL                                            08291000
*                                                                       08292000
NTSD     SRL   R0,16              POSITION TO GET DREAL FORMAT PARAMS   08293000
         LCR   A1,A1              RESTORE A1                            08294000
         SLDL  A1,8               POSITION DREAL                        08295000
         STM   A1,A1+1,NTSWRK     STORE LONG FORM REAL IN WORK AREA     08296000
         LD    ZR,TENTO16         LOAD 10**16 FOR DREAL                 08297000
         B     NTSRM              JUMP TO MERGE                         08298000
*                                                                       08299000
*        COME HERE FOR REAL                                             08300000
*                                                                       08301000
NTSR     ST    A1+1,NTSWRK        STORE REAL IN WORK AREA               08302000
         STE   ZR,NTSWRK+4        CLEAR LOW ORDER BYTES OF LONG REAL    08303000
         LD    ZR,TENTO8          LOAD 10**8 FOR REAL                   08304000
*                                                                       08305000
*        MERGE HERE FOR REAL (ZR=10**8) AND DREAL (ZR=10**16)           08306000
*                                                                       08307000
NTSRM    LD    FA,NTSWRK          LOAD LONG FORM REAL                   08308000
         LPER  FA,FA              FORCE POSITIVE                        08309000
         STH   R0,NTSFRM          SAVE FORMAT PARAMETERS                08310000
         STM   R6,R10,NTSSAV      SAVE REGISTERS                        08311000
         SR    R9,R9              CLEAR FOR IC                          08312000
         IC    R9,NTSDGS          LOAD NUMBER OF DIGITS                 08313000
         LR    R10,R9             COPY NUMBER OF DIGITS                 08314000
         SLL   R10,3              * 8 TO FORM POWERS OF TEN TABLE INDEX 08315000
         CLI   NTSFRM,4           IS THIS FORMAT TYPE 4 OR 5 ?          08316000
         BL    NTS2               SKIP IF NOT                           08317000
*                                                                       08318000
*        COME HERE FOR FORMAT CASES 4,5 (FIXED)                         08319000
*                                                                       08320000
*        FOR THESE FORMATS, WE MULTIPLY BY 10**NDIGS -- IF THE RESULT   08321000
*        EXCEEDS 10**8(REAL) OR 10**16(DREAL) AFTER ROUNDING, WE SKIP   08322000
*        TO USE FLOATING FORMAT -- OTHERWISE, WE BRANCH TO THE STRING   08323000
*        CREATION ROUTINE WITH NPLACES=NDIGS, EXPONENT=0                08324000
*                                                                       08325000
         MD    FA,POWTEN(R10)     MULTIPLY BY 10**NDIGS                 08326000
         AD    FA,=D'0.5'         ROUND                                 08327000
         CDR   FA,ZR              IS IT TOO BIG?                        08328000
         BNL   NTS1               SKIP IF TOO LARGE FOR FIXED FORMAT    08329000
*                                                                       08330000
*        COME HERE FOR OK FIXED FORMAT OR ZERO IN ANY FORMAT            08331000
*                                                                       08332000
NTS0     LR    R6,R9              SET NPLACES = NDIGS                   08333000
         SR    R7,R7              SET EXPONENT = 0                      08334000
         B     NTSN               JUMP TO MAKE OUR STRING               08335000
         EJECT                                                          08336000
*                                                                       08337000
*        COME HERE WHEN NUMBER IS TOO LARGE FOR FIXED FORMAT            08338000
*                                                                       08339000
NTS1     LD    FA,NTSWRK          RELOAD NUMBER AND MERGE FLOATING FMT  08340000
*                                                                       08341000
*        COME HERE FOR FORMAT CASES 0,1,2,3                             08342000
*                                                                       08343000
*        FOR THESE CASES WE FIND Q SUCH THAT                            08344000
*                                                                       08345000
*        10**(NDIGS-1) <= N*10**Q < 10**NDIGS                           08346000
*                                                                       08347000
*        Q IS COMPUTED APPROXIMATELY AS NDIGS-E(LOG16/LOG10)            08348000
*        WHERE E IS THE HEXADECIMAL EXPONENT                            08349000
*                                                                       08350000
NTS2     LTER  FA,FA              FIRST TEST FOR ZERO CASE              08351000
         BZ    NTS0               ALWAYS FIXED FORMAT FOR ZERO CASE     08352000
         IC    R0,NTSWRK          LOAD EXPONENT                         08353000
         N     R0,=X'0000007F'    REMOVE CHARACTERISTIC SIGN            08354000
         SH    R0,=H'64'          REMOVE EXPONENT BIAS                  08355000
         MH    R0,=H'1233'        E * LOG16/LOG10 * 2**10               08356000
         SRA   R0,10              DIVIDED BY 2**10 = E(LOG16/LOG10)     08357000
         SR    R0,R9              E(LOG16/LOG10)-NDIGS                  08358000
         LCR   R6,R0              NDIGS-E(LOG16/LOG10)                  08359000
         ST    R1,NTSRTN          SAVE RETURN POINT                     08360000
         LA    R1,SCALER          POINT TO SCALING ROUTINE              08361000
         BALR  R7,R1              USE IT TO MULTIPLY FA * 10**Q         08362000
         L     R1,NTSRTN          RELOAD RETURN POINT                   08363000
*                                                                       08364000
*        THIS APPROXIMATION MAY BE ONE OFF -- CHECK FOR THIS            08365000
*                                                                       08366000
         LCR   R6,R0              RESTORE ESTIMATE OF Q                 08367000
         CD    FA,POWTEN-8(R10)   COMPARE WITH 10**(NDIGS-1)            08368000
         BNL   *+12               SKIP IF OK THAT WAY                   08369000
         MD    FA,TENTO1          ELSE MULTIPLY BY 10                   08370000
         AH    R6,=H'1'           AND ADJUST SCALE ACCORDINGLY          08371000
         AD    FA,=D'0.5'         ADD 0.5 TO ROUND                      08372000
         CD    FA,POWTEN(R10)     CHECK AGAINST 10**NDIGS               08373000
         BL    *+10               SKIP IF OK (LESS THAN 10**NDIGS)      08374000
         DD    FA,TENTO1          ELSE DIVIDE BY 10                     08375000
         BCTR  R6,0               AND ADJUST Q ACCORDINGLY              08376000
         CLI   NTSFRM,1           TEST FOR FLOATING FORMATS 2,3         08377000
         BH    NTSS2              SKIP IF SO                            08378000
         EJECT                                                          08379000
*                                                                       08380000
*        COME HERE FOR FORMATS 0,1 (FLOATING/FIXED)                     08381000
*                                                                       08382000
*        IF 0<=Q<=NDIGS, THEN USE FIXED FORMAT -- PLACES=Q,EXPONENT=0   08383000
*        OTHERWISE, WE TREAT AS FLOATING FORMAT                         08384000
*                                                                       08385000
         SR    R7,R7              CLEAR EXPONENT IN CASE WE ARE OK      08386000
         CLR   R6,R9              ARE WE IN RANGE 0 <= Q <= NDIGS       08387000
         BNH   NTSN               JUMP TO MAKE STRING IF SO (PLACES=Q)  08388000
*                                                                       08389000
*        COME HERE FOR FLOATING -- PLACES=NDIGS, EXPONENT=NDIGS-Q       08390000
*                                                                       08391000
NTSS2    LR    R7,R9              COPY NDIGS                            08392000
         SR    R7,R6              SET EXPONENT=NDIGS-Q                  08393000
         LR    R6,R9              SET PLACES=NDIGS                      08394000
*                                                                       08395000
*        COME HERE TO DO ACTUAL CONVERSION --                           08396000
*                                                                       08397000
*        (FA)                     REAL -- SCALED TO INTEGER AND ROUNDED 08398000
*        (R7)                     EXPONENT TO BE PRINTED                08399000
*        (R6)                     NUMBER OF DECIMAL PLACES              08400000
*                                                                       08401000
NTSN     AW    FA,=X'4E00000000000000'      RIGHT JUSTIFY BINARY POINT  08402000
         L     R0,NTSWRK          SAVE SIGN OF REAL                     08403000
         STD   FA,NTSWRK          STORE "INTEGERIZED" REAL              08404000
         MVI   NTSWRK,0           CLEAR EXPONENT                        08405000
         LM    A1,A1+1,NTSWRK     LOAD DOUBLE LENGTH INTEGER            08406000
         D     A1,=F'1000000000'  SEPARATE HIGH AND LOW ORDER PARTS     08407000
         CVD   A1,NTSWRK2         CONVERT LOW ORDER TO DECIMAL          08408000
         CVD   A1+1,NTSWRK        CONVERT HIGH ORDER TO DECIMAL         08409000
         IC    R0,NTSWRK2+3       SAVE 1ST TWO DIGS OF LO ORDER         08410000
         MVO   NTSWRK2-1(5),NTSWRK+3(5)     PUT HI ORDER NEXT TO LO ORD 08411000
         STC   R0,NTSWRK2+3       RESTORE SAVED DIGITS                  08412000
         MVI   NTSRSL,X'20'       SET EDIT CHARACTER                    08413000
         MVC   NTSRSL+1(18),NTSRSL          PROPAGATE TO GET PATTERN    08414000
         LNR   R6,R6              NEGATIVE OF NUM DEC PLACES            08415000
         LA    R6,NTSRSL+16(R6)   POINT TWO BEFORE DEC PT POS           08416000
         MVC   0(3,R6),=X'21204B' SET SIGNIFICANCE START AND DEC POINT  08417000
         LR    R5,R1              SAVE RETURN LOCATION                  08418000
         LA    R1,1(,R6)          INITIALIZE IN CASE SIGNIFICANCE FORCD 08419000
         OI    NTSWRK2+7,X'0D'    SET NEG SIGN TO ENSURE DEC POINT      08420000
         EDMK  NTSRSL+1(18),NTSWRK2-1       DO GREAT BIG EDIT AND MARK  08421000
         LA    A1,0(,R1)          SAVE LOC OF FIRST SIGIFICANT DIGIT    08422000
         LR    R1,R5              RESTORE RETURN LOCATION               08423000
         LTR   R0,R0              TEST SIGN OF ORIGINAL REAL            08424000
         BNM   *+10               SKIP IF POSITIVE                      08425000
         BCTR  A1,0               ELSE BACK OFF ONE CHARACTER           08426000
         MVI   0(A1),C'-'         AND SUPPLY A MINUS SIGN               08427000
         LA    A1+1,NTSRSL+18     POINT TO LAST CHARACTER               08428000
         TM    NTSFRM,1           TEST FOR TRAILING ZERO SUPPRESSION    08429000
         BO    NTSN4              SKIP IF NONE WANTED                   08430000
         EJECT                                                          08431000
*                                                                       08432000
*        LOOP TO REMOVE TRAILING ZEROS                                  08433000
*                                                                       08434000
         BALR  R10,0              SET START OF LOOP ADDRESS FOR SPEED   08435000
NTSN3    CLI   0(A1+1),C'0'       IS LAST CHARACTER A ZERO?             08436000
         BNE   NTSN4              SKIP IF NOT                           08437000
         BCTR  A1+1,R10           ELSE DELETE IT AND LOOP BACK          08438000
*                                                                       08439000
*        COME HERE TO DEAL WITH EXPONENT                                08440000
*                                                                       08441000
NTSN4    LTR   R7,R7              IS EXPONENT NON-ZERO?                 08442000
         BNZ   NTSN5              SKIP IF SO                            08443000
         CLI   NTSFRM,3           ELSE IS THIS FORMAT TYPE 3?           08444000
         BNO   NTSN6              IN ANY OTHER FORMAT, SKIP 0 EXPONENT  08445000
*                                                                       08446000
*        COME HERE IF AN EXPONENT IS TO BE PRINTED                      08447000
*                                                                       08448000
NTSN5    MVC   1(4,A1+1),=X'C5212121'       SET "E" AND EDIT PATTERN    08449000
         CD    ZR,TENTO9          TEST REAL/DREAL CASES                 08450000
         BNH   *+8                SKIP IF REAL                          08451000
         MVI   1(A1+1),C'D'       ELSE REPLACE "E" BY "D"               08452000
         CVD   R7,NTSWRK          CONVERT EXPONENT TO DECIMAL           08453000
         ED    1(4,R5),NTSWRK+6   EDIT EXPONENT INTO PLACE              08454000
         MVI   2(A1+1),C'+'       SET A PLUS SIGN TENTATIVELY           08455000
         BNM   *+8                SKIP IF IT WAS PLUS (OR ZERO)         08456000
         MVI   2(A1+1),C'-'       ELSE SET A MINUS SIGN FOR EXPONENT    08457000
         LA    A1+1,4(,A1+1)      BUMP PAST PRINTED EXPONENT            08458000
*                                                                       08459000
*        EXIT POINT                                                     08460000
*                                                                       08461000
NTSN6    SR    A1+1,A1            GET 360 LENGTH OF STRING              08462000
         LM    R6,R10,NTSSAV      RESTORE REGS                          08463000
         SDR   ZR,ZR              RESTORE OUR ZERO REGISTER             08464000
         SH    A1,=Y(SCHARS)      PUT IN OFFSET (ALSO CC = NONZERO)     08465000
         BR    R1                 RETURN TO CALLER                      08466000
         DROP  R2                 DROP BASE REGISTER FOR NUMTOSTG       08467000
         TITLE 'SPITBOLR -- CONVERSION ROUTINES -- COMMON AREA'         08468000
*                                                                       08469000
*        SCALING ROUTINE USED BY NUMTOSTG AND STGTONUM                  08470000
*                                                                       08471000
*        (FA)                     REAL TO BE SCALED                     08472000
*        (R6)                     POWER OF TEN                          08473000
*        (R1)                     BASE REG SET BY CALLER                08474000
*        BALR  R7,R1                                                    08475000
*        (FA)                     (FA)*10**(R6)                         08476000
*                                                                       08477000
         USING SCALER,R1          BASE REG SET BY CALLER                08478000
SCALER   SLA   R6,3               ARGUMENT * 8 AND TEST IT              08479000
         BCR   Z,R7               IMMEDIATE RETURN IF ZERO              08480000
         BM    SCALED             JUMP ON CASE OF ARGUMENT NEGATIVE     08481000
*                                                                       08482000
*        HERE FOR POSITIVE EXPONENT -- LOOP TO SCALE BY 10**16          08483000
*                                                                       08484000
SCALEUL  CH    R6,=Y(8*16)        MORE THAN 16 STEPS TO GO?             08485000
         BNH   SCALEU1            SKIP IF NOT                           08486000
         MD    FA,TENTO16         ELSE MULTIPLY BY 10**16               08487000
         SH    R6,=Y(8*16)        DECREMENT COUNT LEFT                  08488000
         B     SCALEUL            AND LOOP BACK                         08489000
*                                                                       08490000
*        COME HERE TO SCALE UP BY 10**16 OR LESS                        08491000
*                                                                       08492000
SCALEU1  MD    FA,POWTEN(R6)      MULTIPLY BY CORRECT POWER OF TEN      08493000
         BR    R7                 RETURN TO CALLER                      08494000
*                                                                       08495000
*        COME HERE WHEN ARGUMENT IS NEGATIVE TO SCALE DOWN              08496000
*                                                                       08497000
SCALED   LPR   R6,R6              MAKE SCALE POSITIVE                   08498000
*                                                                       08499000
*        LOOP TO SCALE DOWN IN STEPS OF 10**16                          08500000
*                                                                       08501000
SCALEDL  CH    R6,=Y(8*16)        MORE THAN 16 STEPS TO GO?             08502000
         BNH   SCALED1            SKIP IF NOT                           08503000
         DD    FA,TENTO16         ELSE DIVIDE BY 10**16                 08504000
         SH    R6,=Y(8*16)        DECREMENT COUNT LEFT                  08505000
         B     SCALEDL            LOOP BACK                             08506000
*                                                                       08507000
*        COME HERE TO SCALE DOWN BY 10**16 OR LESS                      08508000
*                                                                       08509000
SCALED1  DD    FA,POWTEN(R6)      DIVIDE BY PROPER POWER OF TEN         08510000
         BR    R7                 RETURN TO CALLER                      08511000
         DROP  R1                 DROP SCALER BASE REGISTER             08512000
         EJECT                                                          08513000
*                                                                       08514000
*        POWERS OF TEN TABLE                                            08515000
*                                                                       08516000
         DS    0D                 ALLIGN ON DOUBLE WORD BOUNDARY        08517000
POWTEN   EQU   *+8                ZERO ENTRY IS 1 (10**0)               08518000
         DC    D'0.1,1,10,100,1E3,1E4,1E5,1E6,1E7,1E8'                  08519000
         DC    D'1E9,1E10,1E11,1E12,1E13,1E14,1E15,1E16'                08520000
TENTO1   EQU   POWTEN+1*8         10**1 = 10                            08521000
TENTO8   EQU   POWTEN+8*8         10**8 = 100000000                     08522000
TENTO9   EQU   POWTEN+9*8         10**9 = 1000000000                    08523000
TENTO16  EQU   POWTEN+16*8        10**16 = 10000000000000000            08524000
*                                                                       08525000
*        CHARACTER TABLES FOR SMALL INTEGERS (ACTUAL DEFINITIONS ARE    08526000
*        TO BE FOUND OVERLAYING THE FIRST PART OF SCANTB3)              08527000
*                                                                       08528000
*NTSD2   DC    C'101112131415161718192021222324'                        08529000
*        DC    C'252627282930313233343536373839'                        08530000
*        DC    C'404142434445464748495051525354'                        08531000
*        DC    C'555657585960616263646566676869'                        08532000
*        DC    C'707172737475767778798081828384'                        08533000
*        DC    C'858687888990919293949596979899'                        08534000
*                                                                       08535000
*NTSD1   DC    C'0123456789'                                            08536000
         TITLE 'SPITBOLR -- SCAN TABLES'                                08537000
*                                                                       08538000
*        TABLE 3                                                        08539000
*        -------                                                        08540000
*                                                                       08541000
*        COMPILE TIME USE -- SCAN OUT INTEGER (TESTING FOR "REAL" CHRS) 08542000
*                                                                       08543000
*        EXECUTE TIME USE -- (1)  CHECK FOR VALID INTEGER IN STGTONUM   08544000
*                            (2)  PROVIDE MASTER SPAN TABLE             08545000
*                                                                       08546000
*        THE MASTER SPAN TABLE IS USED TO PROVIDE ALL REQUIRED          08547000
*        SPAN TABLES FOR ONE CHARACTER CASES. IT ACTUALLY REQUIRES      08548000
*        255 BYTES OF NON-ZERO BYTES FOLLOWED BY A ZERO BYTE            08549000
*        FOLLOWED BY 255 NON-ZERO BYTES. THE REQUIREMENT FOR 255        08550000
*        NONZERO BYTES AT THE START IS MET BY PLACING THE &ALPHABET     08551000
*        TABLE AT THIS LOCATION (WHOSE LAST 255 BYTES ARE NON-ZERO).    08552000
*        THE ENDING 255 NONZERO BYTES ARE THEN LARGELY SUPPLIED BY      08553000
*        OVERLAP WITH SCANTB3. NOTE THAT THE CORRECT SPAN TABLE         08554000
*        FOR THE CHARACTER X LIES AT THE ADDRESS SPANTABL-X.            08555000
*                                                                       08556000
*        TABLE FOR &ALPHABET (ALSO USED BY REPLACE)                     08557000
*                                                                       08558000
ALPHBET  DS    0D                 ALLIGN FOR FAST COPY IN REPLACE       08559000
         DC    X'000102030405060708090A0B0C0D0E0F'                      08560000
         DC    X'101112131415161718191A1B1C1D1E1F'                      08561000
         DC    X'202122232425262728292A2B2C2D2E2F'                      08562000
         DC    X'303132333435363738393A3B3C3D3E3F'                      08563000
         DC    X'404142434445464748494A4B4C4D4E4F'                      08564000
         DC    X'505152535455565758595A5B5C5D5E5F'                      08565000
         DC    X'606162636465666768696A6B6C6D6E6F'                      08566000
         DC    X'707172737475767778797A7B7C7D7E7F'                      08567000
         DC    X'808182838485868788898A8B8C8D8E8F'                      08568000
         DC    X'909192939495969798999A9B9C9D9E9F'                      08569000
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'                      08570000
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'                      08571000
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'                      08572000
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'                      08573000
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'                      08574000
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'                      08575000
*                                                                       08576000
*        REFERENCE POINT FOR MASTER SPAN TABLE                          08577000
*                                                                       08578000
SPANTBL  EQU   *-CTCHARS          PROVIDE STANDARD OFFSET               08579000
         DC    X'00'              OUR ONE BYTE OF ZEROS                 08580000
         DC    C'XXXXXXXXXXXXXXX' 15 NON-ZERO BYTES (+240 FROM SCANTB3) 08581000
         EJECT                                                          08582000
*                                                                       08583000
*        SCANTB3 STARTS HERE (SEE PREVIOUS PAGE)                        08584000
*                                                                       08585000
SCANTB3  TABL  1                  INITIALIZE TABLE TO TERMINATORS       08586000
SCANTB3  FOR   '0123456789',0     SCAN PAST INTEGERS                    08587000
         ORG                                                            08588000
*                                                                       08589000
*        THE FOLLOWING CHARACTER TABLES USED IN THE NUMTOSTG ROUTINE    08590000
*        OVERLAY UNUSED SECTIONS OF SCANTB3                             08591000
*                                                                       08592000
         ORG   SCANTB3            POSITION TO START OF TABLE            08593000
NTSD1    DC    C'0123456789'                                            08594000
NTSD2    DC    C'101112131415161718192021222324'                        08595000
         DC    C'252627282930313233343536373839'                        08596000
         DC    C'404142434445464748495051525354'                        08597000
         DC    C'555657585960616263646566676869'                        08598000
         DC    C'707172737475767778798081828384'                        08599000
         DC    C'858687888990919293949596979899'                        08600000
*                                                                       08601000
         ORG   ,                  REPOSITION TO END OF TABLE            08602000
*                                                                       08603000
*        NOTE -- SCAN TABLES 1,2 ARE IN SPITBOLC FOLLOWING SCAN         08604000
         TITLE 'SPITBOLR -- INTERRUPT HANDLING ROUTINE'                 08605000
*                                                                       08606000
*        THIS ROUTINE HANDLES PROGRAM INTERRUPTS -- SUITABLE LINKAGE    08607000
*        MUST BE ESTABLISHED IN THE SYSTEM INTERFACE -- WHEN A PROGRAM  08608000
*        INTERRUPT OCCURS, THE SYSTEM INTERFACE SHOULD PASS CONTROL AS  08609000
*        FOLLOWS --                                                     08610000
*                                                                       08611000
*        (8=DREG)                 POINTS TO DATA AREA                   08612000
*                                 SYSPSW, SYSREGS STORED AT INTERRUPT   08613000
*        (15)                     POINTS TO SYSINTR                     08614000
         BR    15                                                       08615000
*                                                                       08616000
         ENTRY SYSINTR            ENTRY POINT FROM SYSTEM INTERFACE     08617000
         USING SYSINTR,15         BASE REG SET BY INTERFACE             08618000
SYSINTR  DS    0H                 START OF INTERRUPT ROUTINE            08619000
*                                                                       08620000
*        FIRST CHECK FOR OVERFLOW OF STATEMENT COUNT IN FR 0            08621000
*                                                                       08622000
*        NOTE THAT IF STATEMENT COUNT OVERFLOW OCCURS ON TRANSFER TO    08623000
*        ANY SYSTEM LABEL (LIKE END) OR A TRACED LABEL (INCLUDING       08624000
*        FALLING THROUGH TO THAT LABEL) THE STATEMENT NUMBER GIVEN WITH 08625000
*        ERROR MESSAGE WILL BE THAT OF LAST STATEMENT EXECUTED          08626000
*                                                                       08627000
         CLI   SYSPSW+3,INTEXOV   PRECISE EXPONENT OVERFLOW INTRUP?     08628000
         BE    SPINTR1            SKIP IF SO (MAY BE AUR)               08629000
         CLC   SYSPSW+2(2),=AL2(IINEXOV)    IMPRECISE EXP OVERFLOW?     08630000
         BNE   SPINTR2            SKIP IF NOT (CANNOT BE AUR CASE)      08631000
*                                                                       08632000
*        HERE WE HAVE A POSSIBLE AUR INTERRUPT                          08633000
*                                                                       08634000
SPINTR1  L     12,SYSPSW+4        LOAD INTERRUPT ADDRESS                08635000
         BCTR  12,0               BACK OFF TWO BYTES                    08636000
         BCTR  12,0               .                                     08637000
         CLI   0(12),X'3E'        WAS IT AN AUR?                        08638000
         BNE   SPINTR2            SKIP IF NOT AN AUR                    08639000
         MVC   SYSREGS+5(3),=AL3(STMOVER)   SET EXIT ADDRESS IF AUR     08640000
         B     SPINTR6            AND MERGE TO EXIT                     08641000
         EJECT                                                          08642000
*                                                                       08643000
*        HERE WE INITIATE THE SEARCH FOR A VALID INTERRUPT IN THE TABLE 08644000
*                                                                       08645000
SPINTR2  LA    10,SPINTBL         POINT TO INTERRUPT TABLE              08646000
         LA    11,(SPINTBLE-SPINTBL)/9      LOAD NUMBER OF ENTRIES      08647000
*                                                                       08648000
*        LOOP CHECKING ENTRIES IN TABLE                                 08649000
*                                                                       08650000
SPINTR3  CLC   SYSPSW+5(3),3(10)  DOES INTERRUPT ADDRESS MATCH?         08651000
         BNE   SPINTR4            SKIP IF NOT, NO MATCH                 08652000
         CLC   SYSPSW+3(1),0(10)  CORRECT PRECISE INTERRUPT CODE?       08653000
         BE    SPINTR5            SKIP IF SO (MATCH)                    08654000
         CLC   SYSPSW+2(2),1(10)  ELSE CHECK FOR IMPRECISE CODE         08655000
         BE    SPINTR5            SKIP IF MATCH                         08656000
*                                                                       08657000
*        HERE IF NO MATCH, MOVE TO NEXT TABLE ENTRY                     08658000
*                                                                       08659000
SPINTR4  LA    10,9(,10)          POINT TO NEXT ENTRY                   08660000
         BCT   11,SPINTR3         LOOP BACK IF MORE TO GO               08661000
         L     2,=V(SYSABEND)     IF NO MORE, LOAD BOMB ADDRESS         08662000
         BALR  1,2                AND BOMB                              08663000
*                                                                       08664000
*        HERE IF WE HAVE A MATCH IN THE TABLE                           08665000
*                                                                       08666000
SPINTR5  MVC   SYSREGS+5(3),6(10) SET EXIT ADDRESS (FOR REG 1)          08667000
*                                                                       08668000
*        MERGE HERE FROM AUR CASE                                       08669000
*                                                                       08670000
SPINTR6  LM    0,15,SYSREGS       RELOAD REGISTERS (RETURN TO REG 1)    08671000
         BR    1                  JUMP TO EXIT ADDRESS FOR INTERRUPT    08672000
*                                                                       08673000
         DROP  15                 DROP SYSINTR BASE REGISTER            08674000
         EJECT                                                          08675000
*                                                                       08676000
*        INTERRUPT TABLE -- THIS TABLE CONTAINS AN ENTRY FOR EACH       08677000
*        LEGITIMATE PROGRAM INTERRUPT POSSIBLE                          08678000
*                                                                       08679000
*        THE FORMAT OF EACH NINE BYTE ENTRY IS AS FOLLOWS:              08680000
*                                                                       08681000
*        BYTE 0                   PRECISE INTERRUPT CODE                08682000
*        BYTES 1-2                IMPRECISE INTERRUPT CODE              08683000
*        BYTES 3-5                INTERRUPT ADDRESS                     08684000
*        BYTES 6-8                EXIT ADDRESS AFTER INTERRUPT          08685000
*                                                                       08686000
*        THESE ENTRIES ARE GENERATED WITH THE INTRUP MACRO:             08687000
*                                                                       08688000
*        INTRUP    PSWADDRESS,TYPE,EXITADDRESS                          08689000
*                                                                       08690000
*        TYPE IS ONE OF THE FOLLOWING:                                  08691000
*                                                                       08692000
*        DATA                     DATA EXCEPTION                        08693000
*        IDVD                     INTEGER DIVIDE EXCEPTION              08694000
*        EXOV                     EXPONENT OVERFLOW EXCEPTION           08695000
*        FDVD                     FLOATING POINT DIVIDE EXCEPTION       08696000
*                                                                       08697000
*        DEFINITION OF INTERRUPT CODES:                                 08698000
*                                                                       08699000
INTDATA  EQU   X'07'              DATA PRECISE CODE                     08700000
INTIDVD  EQU   X'09'              IDVD PRECISE CODE                     08701000
INTEXOV  EQU   X'0C'              EXOV PRECISE CODE                     08702000
INTFDVD  EQU   X'0F'              FDVD PRECISE CODE                     08703000
IINDATA  EQU   X'1000'            DATA IMPRECISE CODE                   08704000
IINIDVD  EQU   X'0800'            IDVD IMPRECISE CODE                   08705000
IINEXOV  EQU   X'0200'            EXOV IMPRECISE CODE                   08706000
IINFDVD  EQU   X'0040'            FDVD IMPRECISE CODE                   08707000
*                                                                       08708000
SPINTBL  EQU   *                  START OF INTERRUPT TABLE              08709000
         INTRUP    STN1A,IDVD,STNE          INTEGER TOO LARGE STGTONUM  08710000
         INTRUP    STNCVBE,DATA,STNE        CODES > X'F9' STGTONUM      08711000
         INTRUP    DREALIL,EXOV,DREALO      DREAL OVERFLOW              08712000
         INTRUP    DREALIL,FDVD,DREALDZ     DREAL DIVISION BY ZERO      08713000
         INTRUP    REALIL,EXOV,REALO        REAL OVERFLOW               08714000
         INTRUP    REALIL,FDVD,REALDZ       REAL DIVISION BY ZERO       08715000
         INTRUP    EXPWRE,EXOV,EXPWRO       REAL OR DREAL ** OVERFLOW   08716000
         INTRUP    DVDII,IDVD,DVDIZ         INTEGER DIVISION BY ZERO    08717000
SPINTBLE EQU   *                  END OF INTERRUPT TABLE                08718000
         TITLE 'SPITBOLR -- TIMER OVERFLOW ROUTINE'                     08719000
*                                                                       08720000
*        THIS ROUTINE IS ENTERED FROM THE SYSTEM INTERFACE ON           08721000
*        DETECTION OF TIME LIMIT OVERFLOW. THE FOLLOWING                08722000
*        IS THE CALLING SEQUENCE --                                     08723000
*                                                                       08724000
*        (8=DREG)                 POINTS TO DATA AREA                   08725000
*        (15)                     POINTS TO SYSOVTM                     08726000
*        BALR  14,15                                                    08727000
*        -->   RETURN HERE AFTER SETTING FLAGS ETC.                     08728000
*                                                                       08729000
*        SYSOVTIM PROCEEDS AS FOLLOWS --                                08730000
*                                                                       08731000
*        THE OVERTIME FLAG IS SET IN THE STAGE BYTE                     08732000
*                                                                       08733000
*        AFTER SAVING THE VALUE IN THE STATEMENT COUNT REGISTER         08734000
*        A VALUE IS SET TO CAUSE APPARENT OVERFLOW OF THE STATEMENT     08735000
*        COUNT AT THE START OF THE NEXT STATEMENT. THE STATEMENT        08736000
*        OVERFLOW ROUTINE EXAMINES THE OVERTIME FLAG IN STAGE           08737000
*        TO DETERMINE WHAT REALLY HAPPENED. NOTE THAT THIS              08738000
*        MANIPULATION OF SCNT HAS NO EFFECT AT COMPILE TIME             08739000
*                                                                       08740000
         ENTRY SYSOVTM            ENTRY POINT FROM INTERFACE            08741000
         USING SYSOVTM,15         BASE REG SET BY INTERFACE             08742000
SYSOVTM  OI    STAGE,$OVERTIM     SET OVERTIME FLAG                     08743000
         STE   SCNT,SCNTTSAV      SAVE CURRENT STATEMENT COUNT          08744000
         LE    SCNT,=X'7FFFFFFF'  LOAD MAX VALUE TO GET OVERFLOW        08745000
         BR    14                 RETURN TO SYSTEM INTERFACE            08746000
         DROP  15                 DROP BASE REG                         08747000
         TITLE 'SPITBOLR -- PHASE LOAD ROUTINES'                        08748000
*                                                                       08749000
*        THESE ROUTINES PROVIDE THE NECCESSARY CALLS TO THE SYSTEM      08750000
*        PHASE LOADING ROUTINE WHEN OPERATING IN THE TWO PHASE VERSION  08751000
*                                                                       08752000
*        HERE TO LOAD COMPILER AND ENTER IT AT EXECUTION TIME           08753000
*                                                                       08754000
*        (R1)                     POINTS TO THIS ROUTINE                08755000
*                                                                       08756000
COMPILER LR    DB2,R1             SET NEW BASE REGISTER                 08757000
         USING COMPILER,DB2       TELL ASSEMBLER                        08758000
         STM   0,15,CODSVREG      SAVE REGS FOR COMPILER                08759000
         CLC   SPITCAD,SPITPAD    ONE OR TWO PHASE VERSION?             08760000
         BNE   COMPILEE           SKIP IF ONE PHASE                     08761000
*                                                                       08762000
*        HERE WE MUST LOAD IN THE COMPILER PHASE                        08763000
*                                                                       08764000
         L     R2,=V(SYSPHASE)    LOAD ADDRESS OF SYSTEM LOAD ROUTINE   08765000
         L     R0,COMVCON         LOAD VCON FOR COMPILER                08766000
         LA    R4,COMNAME         POINT TO NAME                         08767000
         BALR  R1,R2              LOAD PHASE INTO MEMORY                08768000
         NOP   0                  NO ERROR RETURN ALLOWED               08769000
         L     R4,CODSVREG+R4*4   RESTORE OLD VALUE IN R4 FOR COMPILE   08770000
*                                                                       08771000
*        NOW BRANCH INTO THE COMPILER                                   08772000
*                                                                       08773000
COMPILEE L     R1,=A(CODXENT)     LOAD ADDRESS OF BRANCH POINT          08774000
         BR    R1                 OFF TO IT                             08775000
         DROP  DB2                DROP BASE REG                         08776000
         EJECT                                                          08777000
*                                                                       08778000
*        HERE TO LOAD EXECUTE PHASE                                     08779000
*                                                                       08780000
*        (RETURN)                 TRANSFER LOCATION IN EXECUTE PACKAGE  08781000
*                                                                       08782000
EXECUTE  CLC   SPITCAD,SPITPAD    ONE PHASE VERSION?                    08783000
         BCR   NE,RETURN          IMMEDIATE JUMP TO EXECUTE IF SO       08784000
         BALR  R1,0               GET A TEMPORARY BASE REG              08785000
         USING *,R1               TELL ASSEMBLER                        08786000
         L     R2,=V(SYSPHASE)    POINT TO SYSTEM PHASE LOAD ROUTINE    08787000
         L     R0,XEQVCON         LOAD VCON FOR EXECUTE PHASE           08788000
         ST    R4,CODSVREG+R4*4   SAVE R4 VALUE OVER INTERFACE CALL     08789000
         LA    R4,XEQNAME         POINT TO NAME OF EXECUTE PHASE        08790000
         BALR  R1,R2              CALL PHASE LOAD ROUTINE               08791000
         NOP   0                  NO ERROR RETURN ALLOWED               08792000
         L     R4,CODSVREG+R4*4   RESTORE POSSIBLE CODE POINTER TO R4   08793000
         BR    RETURN             JUMP TO EXECUTE                       08794000
         DROP  R1                 DROP TEMP BASE REG                    08795000
*                                                                       08796000
*        PARAMETERS FOR SYSPHASE (DEPEND ON SETTING OF &LMOD)           08797000
*                                                                       08798000
         AIF   (&LMOD EQ 0).PHASE1                                      08799000
COMVCON  DC    V(SPITBLLC)        VCON FOR COMPILER                     08800000
COMNAME  DC    CL8'SPITBLLC'      NAME                                  08801000
XEQVCON  DC    V(SPITBLLP)        EXECUTE VCON                          08802000
XEQNAME  DC    CL8'SPITBLLP'      EXECUTE NAME                          08803000
.PHASE1  ANOP                                                           08804000
         AIF   (&LMOD EQ 1).PHASE2                                      08805000
COMVCON  DC    V(SPITBOLC)        VCON FOR COMPILER                     08806000
COMNAME  DC    CL8'SPITBOLC'      NAME                                  08807000
XEQVCON  DC    V(SPITBOLP)        EXECUTE VCON                          08808000
XEQNAME  DC    CL8'SPITBOLP'      EXECUTE NAME                          08809000
.PHASE2  ANOP                                                           08810000
         TITLE 'SPITBOLR -- VARIABLE HASH LOCATE ROUTINE'               08811000
*                                                                       08812000
*        THIS ROUTINE IS USED AT COMPILE AND EXECUTE TIME TO BUILD      08813000
*        AND LOCATE VARIABLE BLOCKS (SEE INITIAL SECTION FOR FORMATS)   08814000
*                                                                       08815000
*        CALLING SEQUENCE                                               08816000
*                                                                       08817000
*        LOCATE VARIABLE BLOCK BY NAME (COMPILE AND EXECUTE USAGE)      08818000
*                                                                       08819000
*        (A1,A1+1) (R4,R5)        SPECIFIER FOR STRING NAME             08820000
*        L     R2,=A(VARLOC)                                            08821000
*        BALR  R1,R2                                                    08822000
*        -->   NORMAL RETURN (A1) HAS ADDRESS OF VARIABLE BLOCK         08823000
*                                                                       08824000
*        THESE CALLS DO NOT DISTURB ANY REGISTERS EXCEPT R0,R1,R2       08825000
*        AND A1,A1+1 (R4,R5).                                           08826000
*                                                                       08827000
*        THE HASHING ALGORITHM USED IS AS FOLLOWS --                    08828000
*                                                                       08829000
*        NAMES SHORTER THAN 8 CHARACTERS ARE RIGHT FILLED WITH          08830000
*        HEXADECIMAL ZEROS. THEN THE FIRST FOUR BYTES ARE EXCLUSIVE     08831000
*        OR'ED INTO THE SECOND FOUR BYTES AND THE RESULT IS EXCLUSIVE   08832000
*        OR'ED WITH THE 360 LENGTH OF THE ORIGINAL NAME. THE HASH       08833000
*        FUNCTION IS THE 127 RESIDUE OF THIS QUANTITY                   08834000
         EJECT                                                          08835000
*                                                                       08836000
*        ENTRY POINT                                                    08837000
*                                                                       08838000
         USING VARLOC,R2          BASE REGISTER SET BY CALLER           08839000
VARLOC   STM   A1,A2+1,VARLOCSV   STORE ARGUMENT, SAVE A2,A2+1          08840000
         STM   R1,R2,VARLOCLK     SAVE LINKAGE, ADDRESS                 08841000
         AH    A1,VARLOCSV+SOFFSET          ADD OFFSET TO POINT TO NAME 08842000
         LH    A1+1,VARLOCSV+SLENGTH        LOAD 360 LENGTH OF NAME     08843000
         CH    A1+1,=H'7'         CHECK FOR LENGTH LESS THAN 8 CHARS    08844000
         BL    VARLOC1            SKIP IF LESS THAN 8 CHARS             08845000
*                                                                       08846000
*        HERE FOR NAMES LONGER THAN 7 CHARACTERS                        08847000
*                                                                       08848000
         MVC   VARLOCHS,SCHARS(A1)          MOVE FIRST 8 CHARS OF NAME  08849000
         B     VARLOC2            JUMP TO MERGE                         08850000
*                                                                       08851000
*        HERE FOR NAMES LESS THAN 8 CHARS LONG                          08852000
*                                                                       08853000
VARLOC1  STD   ZR,VARLOCHS        CLEAR AREA TO X'00'                   08854000
         EX    A1+1,VARLOCM       MOVE CHARS WE HAVE (LEFT JUST)        08855000
*                                                                       08856000
*        MERGE HERE TO COMPUTE HASH                                     08857000
*                                                                       08858000
VARLOC2  LM    A2,A2+1,VARLOCHS   LOAD 8 BYTES OF NAME                  08859000
         XR    A2+1,A2            EXCLUSIVE OR FIRST 4, NEXT 4 BYTES    08860000
         XR    A2+1,A1+1          EXCLUSIVE OR LENGTH                   08861000
         SR    A2,A2              CLEAR FOR DIVIDE                      08862000
         D     A2,=F'127'         DIVIDE (REMAINDER TO A2)              08863000
         SLL   A2,2               *4 TO INDEX HASH TABLE                08864000
         A     A2,HASHTBAD        POINT TO HASH SLOT (-VLINK OFFSET)    08865000
         ST    A2,VARLOCSL        SAVE POINTER TO HASH SLOT             08866000
*                                                                       08867000
*        SET PROPER CONDITIONS FOR SHORT/LONG STRINGS                   08868000
*                                                                       08869000
         LA    A2+1,VARLOCS       ASSUME SHORT STRING                   08870000
         CLI   VARLOCSV+SLENGTH,0 IS IT A SHORT STRING?                 08871000
         BZ    VARLOC3            SKIP IF SO                            08872000
         LA    A2+1,VARLOCL       ELSE SET FOR LONG STRING CASE         08873000
         LA    R0,256             SET CRANK FOR LONG STRING LOOP        08874000
*                                                                       08875000
*        LOOP TO SEARCH EXISTING BLOCKS ON HASH CHAIN                   08876000
*                                                                       08877000
VARLOC3  L     A2,VLINK(,A2)      POINT TO NEXT BLOCK ON CHAIN          08878000
         N     A2,=X'00FFFFFF'    IS THIS THE END OF CHAIN?             08879000
         BZ    VARLOC8            SKIP IF THIS IS THE END OF THE CHAIN  08880000
         CH    A1+1,VNAME+SLENGTH(,A2)      ELSE DO LENGTHS MATCH?      08881000
         BNE   VARLOC3            LOOP BACK FOR NEXT BLOCK IF NOT       08882000
         L     R1,VNAME(,A2)      ELSE LOAD NAME BASE POINTER           08883000
         AH    R1,VNAME+SOFFSET(,A2)        ADD OFFSET TO POINT TO NAME 08884000
         BR    A2+1               JUMP TO PROPER (SHORT/LONG) SECTION   08885000
         EJECT                                                          08886000
*                                                                       08887000
*        HERE WE HAVE THE LOOP TO COMPARE LONG NAMES                    08888000
*                                                                       08889000
VARLOCL  CLC   SCHARS(256,R1),SCHARS(A1)    COMPARE 256 BYTE CHUNK      08890000
         BNE   VARLOC5            SKIP IF NO MATCH                      08891000
         AR    R1,R0              ELSE PUSH STRING POINTERS             08892000
         AR    A1,R0              . . . .                               08893000
         SR    A1+1,R0            DECREMENT LENGTH                      08894000
         CR    A1+1,R0            CHECK LENGTH REMAINING                08895000
         BNL   VARLOCL            LOOP BACK IF MORE THAN 256 CHRS LEFT  08896000
         EX    A1+1,VARLOCC       ELSE COMPARE REMAINING CHARACTERS     08897000
*                                                                       08898000
*        MERGE HERE WITH CORRECT CONDITION CODE FOR LONG STRING COMPARE 08899000
*                                                                       08900000
VARLOC5  LM    A1,A1+1,VARLOCHS   RELOAD STRING NAME ADDR/LENGTH        08901000
         BNE   VARLOC3            LOOP BACK FOR NEXT BLOCK IF NO MATCH  08902000
         B     VARLOC6            ELSE JUMP ON A MATCH                  08903000
*                                                                       08904000
*        HERE TO COMPARE SHORT STRINGS                                  08905000
*                                                                       08906000
VARLOCS  EX    A1+1,VARLOCC       COMPARE NAMES                         08907000
         BNE   VARLOC3            LOOP BACK FOR NEXT BLOCK IF NO MATCH  08908000
*                                                                       08909000
*        COME HERE IF WE LOCATE A MATCHING VARIABLE BLOCK               08910000
*                                                                       08911000
VARLOC6  LR    A1,A2              COPY VARIABLE BLOCK ADDRESS           08912000
         B     VARLOCX            JUMP TO EXIT                          08913000
         EJECT                                                          08914000
*                                                                       08915000
*        HERE IF BLOCK WAS NOT LOCATED                                  08916000
*                                                                       08917000
VARLOC8  L     A2,DATACUR         LOAD POINTER TO CURRENT 4K BLOCK      08918000
         L     R1,VBLKNXT(,A2)    LOAD PTR TO SPACE FOR NEXT VAR BLK    08919000
         LA    R0,VARSIZ(,R1)     BUMP PAST NEW BLOCK                   08920000
         C     R0,CBLKBOT(,A2)    IS THERE ROOM?                        08921000
         BNH   VARLOC20           SKIP IF THERE IS ROOM                 08922000
*                                                                       08923000
*        HERE WE HAVE INSUFFICIENT ROOM IN THE CURRENT 4K BLOCK         08924000
*                                                                       08925000
         TM    STAGE,$CLEARFG     TEST FOR CALL FROM CLEAR              08926000
         BNO   *+10               SKIP IF NOT                           08927000
         SR    A1,A1              ELSE SET RESULT = 0 = BLOCK NOT FOUND 08928000
         B     VARLOCX            JUMP TO EXIT                          08929000
         LA    R2,GET4KBLK        POINT TO ROUTINE TO GET 4K BLOCK      08930000
         BALR  R1,R2              ALLOCATE A NEW 4K BLOCK               08931000
         L     R2,VARLOCLK+4      RELOAD BASE REG SETTING               08932000
         B     VARLOC8            LOOP BACK TO USE NEW BLOCK            08933000
*                                                                       08934000
*        HERE WHEN WE HAVE FOUND ROOM FOR THE VARIABLE BLOCK            08935000
*                                                                       08936000
VARLOC20 ST    R0,VBLKNXT(,A2)    STORE UPDATED VAR BLK POINTER         08937000
         MVC   0(VARSIZ,R1),MODVAR          MOVE IN MODEL BLOCK         08938000
         SH    R1,=Y(VALUE)       BACK OFF TO GET VALUE OFFSET          08939000
         L     A2,VARLOCSL        RECALL REMEMBERED HASH SLOT LOCATION  08940000
         MVC   VLINK+1(3,R1),VLINK+1(A2)    LINK BLOCK TO HEAD OF CHAIN 08941000
         ST    R1,VLINK(,A2)      STORE NEW HEAD OF CHAIN POINTER       08942000
         CH    A1+1,=Y(MAXSSTL)   COULD THIS BE A STANDARD VARIABLE?    08943000
         BH    VARLOC30           SKIP IF NOT TO EXIT                   08944000
         CLI   SCHARS(A1),X'FF'   DOES IT BEGIN WITH X'FF'              08945000
         BE    VARLOC30           IF SO, CANNOT BE STANDARD VAR         08946000
*                                                                       08947000
*        HERE WE SEE IF THERE IS A STANDARD VARIABLE WITH THIS NAME     08948000
*                                                                       08949000
         LA    A2,0(A1+1,A1+1)    GET 2 * 360 LENGTH                    08950000
         LH    A2,INITHDR(A2)     LOAD PTR TO LIST FOR THIS LENGTH      08951000
         A     A2,VARLOCB         MAKE PTR ABSOLUTE, SUPPLY SCODE       08952000
         SR    R0,R0              CLEAR FOR IC                          08953000
*                                                                       08954000
*        LOOP TO CHECK FOR MATCH                                        08955000
*                                                                       08956000
VARLOC22 EX    A1+1,VARLOCCS      CHECK FOR MATCH WITH THIS ENTRY       08957000
         BL    VARLOC30           IF HIGH, NOT THERE, SINCE IN ORDER    08958000
         BE    VARLOC24           SKIP IF WE FIND A MATCH               08959000
         IC    R0,SCHARS-1(,A2)   ELSE LOAD LENGTH OF ENTRY             08960000
         AR    A2,R0              POINT TO NEXT ENTRY                   08961000
         B     VARLOC22           LOOP BACK TO CHECK NEXT ENTRY         08962000
         EJECT                                                          08963000
*                                                                       08964000
*        HERE WHEN WE FIND A MATCH WITH A STANDARD VARIABLE             08965000
*                                                                       08966000
VARLOC24 ST    A1+1,VNAME+4(,R1)  STORE LENGTH OF NAME, OFFSET = 0      08967000
         ST    A2,VNAME(,R1)      STORE NAME POINTER AND SCODE          08968000
         LA    A2,SCHARS+1(A2,A1+1)         PUSH POINTER PAST NAME      08969000
         LR    A2+1,A2            COPY POINTER                          08970000
*                                                                       08971000
*        TEST FOR KEYWORD                                               08972000
*                                                                       08973000
         TM    0(A2),INITK        TEST FOR KEYWORD                      08974000
         BNO   VARLOC25           SKIP IF NO KEYWORD ASSOCIATION        08975000
         MVC   VKEY(1,R1),1(A2+1) IF SO, MOVE INTO PLACE                08976000
         LA    A2+1,1(,A2+1)      BUMP PAST KEYWORD NUMBER              08977000
*                                                                       08978000
*        TEST FOR PATTERN VALUE                                         08979000
*                                                                       08980000
VARLOC25 TM    0(A2),INITP        TEST FOR PATTERN VALUE                08981000
         BNO   VARLOC26           SKIP IF NOT PATTERN (AVOID THE MVI)   08982000
         CNOP  0,4                ALLIGN VARLOCG2 PARAMETER WORD        08983000
         BAL   A1+1,VARLOCG2      SET PATTERN VALUE IF SO               08984000
         DC    AL1(VALUE+1)       LOCATION OF VALUE                     08985000
         DC    AL3(SPITBOLX)      PATTERN OFFSET                        08986000
         MVI   VALUE(R1),PCODE    SUPPLY PATTERN CODE                   08987000
*                                                                       08988000
*        TEST FOR FUNCTION VALUE                                        08989000
*                                                                       08990000
VARLOC26 TM    0(A2),INITF        TEST FOR FUNCTION DEFINED             08991000
         BNO   VARLOC27           SKIP IF NOT                           08992000
         MVC   VFUNC+1(3,R1),1(A2+1)        ELSE SET FUNCTION ADDR      08993000
         LA    A2+1,3(,A2+1)      BUMP PAST FUNCTION ADDRESS            08994000
*                                                                       08995000
*        TEST FOR OPERATOR DV POINTER                                   08996000
*                                                                       08997000
         CNOP  0,4                ALLIGN VARLOCG2 PARAMETERS            08998000
VARLOC27 TM    0(A2),INITO        TEST FOR OPERATOR DV POINTER          08999000
         BAL   A1+1,VARLOCG2      SET OPERATOR DV ADDRESS IF SO         09000000
         DC    AL1(VDVPTR+1)      ADDRESS FOR OPERATOR DV PTR           09001000
         DC    AL3(SPITBOLC)      DOPE VECTOR OFFSET                    09002000
*                                                                       09003000
*        TEST FOR LABEL                                                 09004000
*                                                                       09005000
         TM    0(A2),INITL        TEST FOR LABEL ASSOCIATION            09006000
         BAL   A1+1,VARLOCG2      SET LABEL ADDRESS IF SO               09007000
         DC    AL1(VLABL+1)       ADDRESS FOR LABEL                     09008000
         DC    AL3(SPITBOLX)      OFFSET FOR LABEL                      09009000
         EJECT                                                          09010000
*                                                                       09011000
*        HERE WITH ALL SPECIAL FIELDS FOR STANDARD VARIABLE FILLED IN   09012000
*                                                                       09013000
         LR    A1,R1              PUT RESULT IN PROPER REGISTER         09014000
         TM    STAGE,$EXECUTE     EXECUTE TIME?                         09015000
         BO    VARLOCX            IF SO, JUMP TO RETURN TO CALLER       09016000
         L     R1,VARUSED         ELSE LOAD SPACE USED FOR VARIABLES    09017000
         LA    R1,32(,R1)         BUMP FOR SPACE USED BY THIS BLOCK     09018000
         ST    R1,VARUSED         STORE INCREMENTED VALUE               09019000
         B     VARLOCX            AND THEN JUMP TO EXIT                 09020000
*                                                                       09021000
*        LITTLE SUBROUTINE TO LOAD OFFSET FOR STANDARD VAR FIELD        09022000
*                                                                       09023000
VARLOCG2 BNO   4(,A1+1)           RETURN IF THIS ATTRIBUTE NOT PRESENT  09024000
         MVC   VARLOCHS(2),1(A2+1)          GET OFFSET                  09025000
         LA    A2+1,2(,A2+1)      BUMP PAST OFFSET                      09026000
         LH    A1,VARLOCHS        LOAD OFFSET                           09027000
         A     A1,0(,A1+1)        ADD BASE ADDRESS                      09028000
         ST    A1,VARLOCHS        STORE ABSOLUTE ADDRESS                09029000
         SRL   A1,24              POSITION OFFSET IN VARIABLE BLOCK     09030000
         AR    A1,R1              POINT TO LOCATION FOR MOVE            09031000
         MVC   0(3,A1),VARLOCHS+1 MOVE ADDRESS INTO PLACE               09032000
         B     4(,A1+1)           RETURN PAST PARAMETERS                09033000
*                                                                       09034000
*        HERE IF THIS IS NOT A STANDARD VARIABLE                        09035000
*                                                                       09036000
VARLOC30 TM    STAGE,$EXECUTE     EXECUTE TIME?                         09037000
         BNO   VARLOC35           SKIP IF NOT (PURE COMPILE TIME)       09038000
         TM    STAGE,$COMPILE     CASE OF CODE,EVAL?                    09039000
         BNO   VARLOC34           SKIP IF NOT                           09040000
*                                                                       09041000
*        HERE FOR VARIABLE BLOCK BUILT DURING CODE, EVAL                09042000
*                                                                       09043000
         L     R0,VARLOCSV        LOAD ARGUMENT STRING POINTER          09044000
         S     R0,CODSVREG+4*A1   GET OFFSET FROM BASE                  09045000
         STH   R0,VARLOCSV+SOFFSET          SET PROPER OFFSET           09046000
         MVC   VARLOCSV(4),CODSVREG+4*A1    SET PROPER BASE POINTER     09047000
*                                                                       09048000
*        MERGE HERE FOR NORMAL COMPILE TIME, OR CODE,EVAL CASE          09049000
*                                                                       09050000
*                                                                       09051000
*        HERE FOR NEW BLOCK BUILT AT EXECUTE TIME                       09052000
*                                                                       09053000
VARLOC34 MVC   VNAME(8,R1),VARLOCSV         SET PROPER NAME INTO PLACE  09054000
         LR    A1,R1              PUT RESULT IN PROPER REGISTER         09055000
         B     VARLOCX            JUMP TO RETURN TO CALLER              09056000
         EJECT                                                          09057000
*                                                                       09058000
*        HERE FOR NEW BLOCK BUILT AT COMPILE TIME                       09059000
*                                                                       09060000
VARLOC35 LA    A1,SCHARS(,A1)     POINT TO ACTUAL STRING                09061000
         LA    A1+1,1(,A1+1)      GET ACTUAL LENGTH                     09062000
         LTR   A2,R1              SAVE BLOCK PTR, SET CC NON-ZERO       09063000
         LM    R0,R1,STRUSED      LOAD STRUSED, VARUSED                 09064000
         AR    R0,A1+1            INCREMENT STRING SPACE                09065000
         LA    R1,32(,R1)         INCREMENT VARIABLE SPACE USED         09066000
         STM   R0,R1,STRUSED      STORE INCREMENTED COUNTS              09067000
         LA    R2,HIGHCORE        POINT TO HIGHCORE ROUTINE             09068000
         DROP  R2                 DROP VARLOC BASE REGISTER             09069000
         BALR  R1,R2              MOVE STRING TO HIGH CORE              09070000
         LA    R0,SCHARS          GET STANDARD OFFSET                   09071000
         SR    A1,R0              ADJUST HIGH CORE STRING POINTER       09072000
         BCTR  A1+1,0             ADJUST TO 360 LENGTH                  09073000
         STM   A1,A1+1,VNAME(A2)  STORE ADDRESS, LENGTH OF NAME         09074000
         MVI   VNAME(A2),SCODE    SET STRING CODE                       09075000
         LR    A1,A2              SET RESULT IN PROPER REGISTER         09076000
*                                                                       09077000
*        COMMON EXIT POINT                                              09078000
*                                                                       09079000
VARLOCX  LM    A2,A2+1,VARLOCSV+8 RELOAD CLOBBERED REGS                 09080000
         LM    R1,R2,VARLOCLK     RELOAD LINKAGE, ADDRESS               09081000
         BR    R1                 RETURN TO CALLER                      09082000
         EJECT                                                          09083000
*                                                                       09084000
*        EXECUTE TARGET INSTRUCTIONS                                    09085000
*                                                                       09086000
VARLOCM  MVC   VARLOCHS(*-*),SCHARS(A1)     MOVE CHARS OF NAME FOR HASH 09087000
VARLOCC  CLC   SCHARS(*-*,R1),SCHARS(A1)    COMPARE FOR HASH SEARCH     09088000
VARLOCCS CLC   SCHARS(*-*,A1),SCHARS(A2)    COMPARE FOR STANDARD VAR SR 09089000
*                                                                       09090000
*        CONSTANT TO ADJUST BASE POINTER TO STANDARD VARIABLE TABLE     09091000
*                                                                       09092000
         DS    0F                 ALLIGN                                09093000
VARLOCB  DC    AL1(SCODE)         CODE FOR STRING                       09094000
         DC    AL3(SPITBOLR)      BASE ADDRESS                          09095000
*                                                                       09096000
*        MODEL VARIABLE BLOCK                                           09097000
*                                                                       09098000
MODVAR   DC    AL1(NCODE)         CODE FOR NULL VALUE                   09099000
         DC    7AL1(0)            REMAINING 7 BYTES OF VALUE            09100000
         DC    AL1(0)             VFLAGS = 0, NO FLAGS SET              09101000
         DC    AL3(0)             VLINK = 0                             09102000
         DC    AL1(0)             VKEY = 0                              09103000
         DC    AL3($$NOFN-FCODE)  UNDEFINED FUNCTION CODE               09104000
         DC    AL1(1)             VPHASE = 1                            09105000
         DC    AL3($$NOGO)        VLABL = UNDEFINED LABEL TRANSFER      09106000
         DC    AL4(0)             VIOPTR = 0                            09107000
*                                                                       09108000
*        TABL OF HEADERS TO BLOCKS OF ENTRIES BY NAME LENGTH            09109000
*                                                                       09110000
INITHDR  DC    Y(INITVR1-SCHARS+1-SPITBOLR) NAMES OF LENGTH 1           09111000
         DC    Y(INITVR2-SCHARS+1-SPITBOLR) NAMES OF LENGTH 2           09112000
         DC    Y(INITVR3-SCHARS+1-SPITBOLR) NAMES OF LENGTH 3           09113000
         DC    Y(INITVR4-SCHARS+1-SPITBOLR) NAMES OF LENGTH 4           09114000
         DC    Y(INITVR5-SCHARS+1-SPITBOLR) NAMES OF LENGTH 5           09115000
         DC    Y(INITVR6-SCHARS+1-SPITBOLR) NAMES OF LENGTH 6           09116000
         DC    Y(INITVR7-SCHARS+1-SPITBOLR) NAMES OF LENGTH 7           09117000
         DC    Y(INITVR8-SCHARS+1-SPITBOLR) NAMES OF LENGTH 8           09118000
         DC    Y(INITVR9-SCHARS+1-SPITBOLR) NAMES OF LENGTH 9           09119000
*                                                                       09120000
MAXSSTL  EQU   9-1                360 LENGTH OF LONGEST STANDARD VAR    09121000
         TITLE 'SPITBOLR -- ROUTINE TO ALLOCATE NEW 4K VARIABLE BLOCK'  09122000
*                                                                       09123000
*        GET4KBLK                                                       09124000
*                                                                       09125000
*        THIS ROUTINE ALLOCATES A FRESH 4K BLOCK IN HIGH CORE FOR       09126000
*        VARIABLES AND STORES ITS ADDRESS IN THE BASE REGISTER TABLE    09127000
*                                                                       09128000
*        CALLING SEQUENCE                                               09129000
*                                                                       09130000
*        LA    R2,GET4KBLK                                              09131000
*        BALR  R1,R2                                                    09132000
*        =>    NORMAL RETURN                                            09133000
*                                                                       09134000
*        NO REGISTERS ARE AFFECTED EXCEPT R0,R1,R2                      09135000
*                                                                       09136000
         USING GET4KBLK,R2        BASE REG SET BY CALLER                09137000
GET4KBLK ST    R1,GET4KLK         SAVE LINKAGE                          09138000
         STM   R4,R5,GET4KSV      SAVE REGS FOR HIGHCORE PARAMETERS     09139000
         LA    R5,4096-1          GET SIZE - 1                          09140000
         LA    R5,1(,R5)          GET 4096 = SIZE OF BLOCK              09141000
         LA    R2,HIGHCORE        POINT TO HIGH CORE ROUTINE            09142000
         DROP  R2                 KILL CLOBBERED BASE REG               09143000
         NI    HICINUSE+3,X'F8'   SET FOR DOUBLE WORD ALLIGNMENT        09144000
         CR    R0,R0              SET CC = 0 TO INHIBIT MOVE            09145000
         BALR  R1,R2              ALLOCATE 4K IN HIGH CORE              09146000
         USING *,R1               SET NEW BASE REGISTER                 09147000
         LH    R5,CURBASE         LOAD OFFSET TO CURRENT BASE           09148000
         LA    R5,4(,R5)          PUSH TO NEXT ENTRY                    09149000
         CH    R5,=H'128'         TOO MANY BLOCKS ALREADY?              09150000
         BL    *+8                SKIP IF OK                            09151000
         XERR  06,002             ELSE ISSUE ERROR MESSAGE              09152000
         STH   R5,CURBASE         STORE NEW OFFSET                      09153000
         ST    R4,DATACUR         STORE AS ADDRESS OF CURRENT BLOCK     09154000
         LA    R0,CBLKEND(,R4)    POINT TO LAST 8 BYTE BLOCK            09155000
         ST    R0,CBLKBOT(,R4)    STORE IN FIELD AT END OF BLOCK        09156000
         ST    R4,VBLKNXT(,R4)    STORE START AS NEXT VAR BLK ADDR      09157000
         SH    R4,=Y(VALUE)       INTRODUCE STANDARD OFFSET             09158000
         ST    R4,$$BAS1(R5)      STORE NEW POINTER IN BASE TABLE       09159000
         MVI   $$BAS3,X'FF'       MAKE SURE OF X'FF' BYTE IN 3RD ENTRY  09160000
         LM    R4,R5,GET4KSV      RELOAD SAVED REGS                     09161000
         L     R1,GET4KLK         RELOAD LINKAGE                        09162000
         BR    R1                 RETURN TO CALLER                      09163000
         DROP  R1                 DROP BASE REG SET ABOVE               09164000
         TITLE 'SPITBOLR -- HIGHCORE -- ALLOCATE SPACE AT TOP OF CORE'  09165000
*                                                                       09166000
*        ROUTINE TO ALLOCATE SPACE AT TOP OF CORE                       09167000
*        NOTE THAT FOR ANY GARBAGE COLLECTION CALL THE FOLLOWING        09168000
*        REGISTERS MUST HAVE THEIR PROPER EXECUTION TIME VALUES         09169000
*        FR,DB1,SYS,PDR  ALSO A1 FOR GBGCL1 CALL                        09170000
*                                                                       09171000
*        CONDITIONS ON ENTRY                                            09172000
*                                                                       09173000
*        STAGE                    $COMPILE SET IF COMPILE TIME CALL     09174000
*                                 $EXECUTE ON IF EXECUTION TIME CALL    09175000
*                                 $GBGCLF SET IF COLLECT = GBGCLF       09176000
*                                                                       09177000
*        CONDITION CODE           ZERO      NOTHING TO MOVE             09178000
*                                 NONZERO   MOVE BLOCK FROM (R4)        09179000
*                                                                       09180000
*        (R4)                     BLOCK ADDRESS                         09181000
*        (R5)                     BLOCK LENGTH                          09182000
*        (R2)                     ADDRESS OF HIGHCORE                   09183000
*        BALR  R1,R2              STANDARD CALL                         09184000
*        (R4)                     NEW BLOCK ADDRESS                     09185000
*        (R1)                     MAY HAVE UPPER BYTE STRIPPED          09186000
*                                 ALL REGS EXCEPT R0 RESTORED OR RELOC  09187000
*                                                                       09188000
         USING SPITBOLA,SYS       BASE REGISTER AVAILABLE AT XEQ TIME   09189000
         USING HIGHCORE,R2        TELL ASSEMBLER OF BASE REGISTER       09190000
HIGHCORE STM   R4,R6,HICORESV     SAVE SCRATCH REGISTERS                09191000
         L     R6,HICINUSE        LOAD OLD HI CORE IN USE ADDRESS       09192000
         SR    R6,R5              MINUS LENGTH TO MOVE IN= 'TO' ADDR    09193000
         ST    R6,HICINUSE        STORE ADDRESS OF ALLOCATED BLOCK      09194000
         TM    STAGE,$EXECUTE     CHECK FOR COMPILE TIME CALL           09195000
         BNO   HICOREC            OFF TO SPECIAL CODE IF COMPILE TIME   09196000
         TM    STAGE,$COMPILE     CASE OF CODE,EVAL?                    09197000
         BNO   HICORE0            SKIP IF NOT                           09198000
         ST    PDR,HICORPDR       ELSE SAVE PDR VALUE                   09199000
         L     PDR,CODSVREG+4*PDR LOAD XEQ PDR VALUE                    09200000
*                                                                       09201000
*        COME HERE TO TEST FOR COLLECT NEEDED                           09202000
*                                                                       09203000
HICORE0  LA    R5,7(,R5)          PUSH OVER DOUBLE WORD BOUND           09204000
         N     R5,=X'FFFFFFF8'    AND PUT ON DOUBLE WORD BOUND          09205000
         LR    R0,R5              COPY LENGTH                           09206000
         A     R0,CODSVREG+4*FR   GET ENDING ADDRESS FOR TEST           09207000
         CR    R0,PDR             WOULD WE OVER LAP?                    09208000
         BL    HICORE1            SKIP IF NOT                           09209000
         TM    STAGE,$COMPILE     CASE OF CODE,EVAL?                    09210000
         USING SPITBOLC,CB1,CB2,CB3         BASE REG FOR FOLLOWING JUMP 09211000
         BO    CODXCOR            JUMP FOR CODE,EVAL OUT OF CORE IF SO  09212000
         DROP  CB1,CB2,CB3        DROP BASE REGS FOR COMPILER           09213000
         TM    STAGE,$GBGCLF      DO WE NEED A FUNCTION COLLECT?        09214000
         BO    HICGBGF            IF SET, OFF TO DO GBGCLF              09215000
         BAL   RETURN,GBGCL1      COLLECT SAVING A1 OVER CALL           09216000
         B     HICORE0            AND GO BACK FOR ANOTHER TEST          09217000
         EJECT                                                          09218000
*                                                                       09219000
*        COME HERE WHEN THERE IS SUFFICIENT CORE FOR EXPANSION          09220000
*                                                                       09221000
HICORE1  L     R4,PDRLOC          LOAD PDR CURRENT LOC TO RELOCATE      09222000
         SR    R4,R5              GET RELOCATED ADDRESS                 09223000
         ST    R4,PDRLOC          AND STORE IT BACK                     09224000
         NI    STAGE,X'FF'-$GBGCLF          TURN OFF SPCL GBG FLAG      09225000
*                                                                       09226000
*        LOOP TO RELOCATE PDRPTR ENTRIES ON STCK                        09227000
*                                                                       09228000
HICORE2  LA    R6,0(R4,R5)        GET CURRENT STACK ADDRESS             09229000
         L     R4,PDRBPTR(,R6)    GET BACKPOINTER AT THIS LEVEL         09230000
         SR    R4,R5              RELOCATE IT                           09231000
         ST    R4,PDRBPTR(,R6)    RE STORE IT                           09232000
         CE    ZR,FBLOKLOC(,R6)   TEST USAGE OF STACK ABOVE US          09233000
         BL    HICORE2            LOOP BACK IF NEXT LEVEL = FUNCTION    09234000
         BH    HICORE3            IF FBLOCLOC NEGATIVE, END OF STK      09235000
*                                                                       09236000
*        COME HERE FOR AN UNEVALUATED EXPRESSION CALL ABOVE US          09237000
*                                                                       09238000
         TM    EVLINK(R6),X'30'   TEST TO SEE WHO CALLED UNEVAL EXP     09239000
         BNZ   HICORE2            IF CC NE 0 EVAL FUNCTION ABOVE        09240000
*                                                                       09241000
*        COME HERE FOR PATTERN MATCHING ON LEVEL ABOVE                  09242000
*                                                                       09243000
         L     R0,PATSPACE+PSAVPS1(,R6)     GET PS1 TO RELOCATE         09244000
         SR    R0,R5              RELOCATE IT                           09245000
         ST    R0,PATSPACE+PSAVPS1(,R6)     STORE RELOCATED PS1         09246000
         L     R0,PATSPACE+PSAVPS2(,R6)     LOAD PS2 TO RELOCATE IT     09247000
         SR    R0,R5              RELOCATE IT                           09248000
         ST    R0,PATSPACE+PSAVPS2(,R6)     STORE NEW PS2 VALUE         09249000
         LA    R0,0(R4,R5)        GET OLD PDR ABOVE US                  09250000
         C     R0,PATSPACE+PSAVPB(,R6)      TEST FOR ENDPAT ABOVE US    09251000
         BNE   HICORE2            IF NOT IN ENDPAT, DONE WITH THIS LEVL 09252000
*                                                                       09253000
*        COME HERE WHEN PATTERN MATCH ABOVE IS DONE EXCEPT FOR DOTS     09254000
*                                                                       09255000
         ST    R4,PATSPACE+PSAVPB(,R6)      STORE RELOCATED PDR FOR END 09256000
         L     R0,PATSPACE+PSAVMINR(,R6)    VALUE IN MINR MUST BE RELOC 09257000
         SR    R0,R5              RELOCATE IT                           09258000
         ST    R0,PATSPACE+PSAVMINR(,R6)    STORE NEW VALUE             09259000
         L     R0,PATSPACE+PSAVCP(,R6)      AND CP MUST BE RELOCATED    09260000
         SR    R0,R5              RELOCATE IT                           09261000
         ST    R0,PATSPACE+PSAVCP(,R6)      STORE NEW CP VALUE          09262000
         B     HICORE2            BACK TO TAKE CRE OF STD STUFF         09263000
*                                                                       09264000
*        COME HERE WHEN ENTIRE STACK HAS BEEN RELOCATED                 09265000
*                                                                       09266000
HICORE3  LR    R4,PDR             LOAD MOVE 'FROM' ADDRESS              09267000
         SR    PDR,R5             RELOCATE PDR                          09268000
         LA    R5,STACKTOP-1(,R6) GET END OF STACK-1 FOR LENGTH CALC    09269000
         SR    R5,R4              MINUS BOTTOM ADDR = 360 LENGTH        09270000
         LR    R6,PDR             LOAD MOVE 'TO' ADDRESS                09271000
         EJECT                                                          09272000
*                                                                       09273000
*        COME HERE TO MOVE A BLOCK IN CORE                              09274000
*        (R4)                     'FROM' ADDRESS                        09275000
*        (R6)                     'TO' ADDRESS                          09276000
*        (R5)                     360 LENGTH FOR MOVE                   09277000
*                                                                       09278000
*        CONDITIONS ON ENTRY                                            09279000
*                                                                       09280000
HICOREM  LA    R0,256             GET STANDARD MOVE CONSTANT            09281000
         CR    R5,R0              ARE WE SMALL ENOUGH FOR ONE MOVE?     09282000
         BL    HICOREMS           OFF TO MOVE SMALL PIECE IF <=256      09283000
*                                                                       09284000
*        LOOP TO MOVE 256 CHARACTERS AT A TIME                          09285000
*                                                                       09286000
HICOREML MVC   0(256,R6),0(R4)    MOVE A LARGE PIECE                    09287000
         AR    R6,R0              PUSH 'TO' POINTER                     09288000
         AR    R4,R0              PUSH 'FROM' POINTER                   09289000
         SR    R5,R0              DECREMENT LENGTH LEFT                 09290000
         CR    R5,R0              SMALL ENOUGH FOR ONE MOVE?            09291000
         BNL   HICOREML           LOOP BACK IF NOT                      09292000
*                                                                       09293000
*        COME HERE TO MOVE LAST PIECE                                   09294000
*                                                                       09295000
HICOREMS EX    R5,HICOREMV        DO VARIABLE LENGTH MOVE               09296000
         LM    R4,R5,HICORESV     RESTORE 'FROM' INFO & LENGTH          09297000
         L     R6,HICINUSE        LOAD NEW BLOCK ADDRESS                09298000
*                                                                       09299000
*        COME HERE WITH 'TO', 'FROM' & LENGTH PTRS SET UP FOR MOVEIN    09300000
*                                                                       09301000
HICOREC1 SPM   R1                 RESET ENTRY CONDITION CODE            09302000
         BZ    HICOREX            IF ZERO, NOTHING TO MOVE              09303000
         LA    R1,0(,R1)          CLEAR OUT CC TO FORCE EXIT NEXT CALL  09304000
         BCT   R5,HICOREM         GET 360 LENGTH AND OFF TO MOVE        09305000
         B     HICOREM            JUMP EVEN IF BCT FALLS THROUGH        09306000
*                                                                       09307000
HICOREMV MVC   0(*-*,R6),0(R4)    VARIABLE LENGTH MVC                   09308000
         EJECT                                                          09309000
*                                                                       09310000
*        COME HERE TO EXIT FROM HICORE ROUTINE                          09311000
*                                                                       09312000
HICOREX  LR    R4,R6              COPY ADDRESS OF NEW BLOCK             09313000
         L     R6,HICORESV+8      RESTORE REGISTER 6                    09314000
         TM    STAGE,$COMPILE+$EXECUTE      CODE,EVAL CASE?             09315000
         BCR   NO,R1              IMMEDIATE EXIT IF NOT                 09316000
         ST    PDR,CODSVREG+4*PDR STORE NEW XEQ PDR VALUE               09317000
         ST    PDR,CODSVREG+4*PDR ELSE STORE NEW XEQ PDR VALUE          09318000
         L     PDR,HICORPDR       RELOAD CALLING VALUE                  09319000
         BR    R1                 AND RETURN                            09320000
*                                                                       09321000
*        COME HERE TO DO GBGCLF CALL FOR COLLECT                        09322000
*                                                                       09323000
HICGBGF  NI    STAGE,X'FF'-$GBGCLF          TURN OFF SPECIAL FLAG       09324000
         B     GBGCLF             AND CALL COLLECT                      09325000
*                                                                       09326000
*        COME HERE TO ALLOCATE CORE DURING COMPILE                      09327000
*                                                                       09328000
HICOREC  C     R6,SUBEXTOP        WILL WE BE ABOVE SUBEXPRESSIONS?      09329000
         BH    HICOREC1           OFF TO TEST CASES IF SO               09330000
*                                                                       09331000
*        COME HERE IF WE MUST MOVE DOWN SUBEXPRESSIONS                  09332000
*                                                                       09333000
         LA    R6,2*1024+1(,R5)   MOVE DOWN 2K, PUT ON HALFWORD         09334000
         N     R6,=X'FFFFFFFE'    PUT ON HALFWORD                       09335000
         L     R0,ESTACKS         END OF COMPILER WORK STACKS           09336000
         AH    R0,=Y(2048)        ADD 2K SAFETY MARGIN                  09337000
         L     R4,SUBEXBOT        GET ADDR OF START OF SUBEXPRESSIONS   09338000
         CR    R0,R4              WILL THERE BE CONFLICT?               09339000
         BNL   CMPLNORM           ISSUE ERROR IF OUT OF ROOM            09340000
         L     R5,SUBEXTOP        GET END OF EXPRESSION ADDRESS         09341000
         SR    R5,R6              GET RELOCATED TOP                     09342000
         ST    R5,SUBEXTOP        AND RESTORE                           09343000
         LCR   R6,R6              GET NEGATIVE MOVE AMOUNT              09344000
         LA    R6,0(R6,R4)        GET 'TO' ADDRESS                      09345000
         ST    R6,SUBEXBOT        STORE UPDATED STARTING POINTER        09346000
         SR    R5,R6              GET REAL LENGTH OF BLOCK              09347000
         BCT   R5,HICOREM         GET 360 LENGTH AND OFF TO MOVE        09348000
*                                                                       09349000
*        COME HERE IF NO ROOM LEFT AT COMPILE TIME                      09350000
*                                                                       09351000
CMPLNORM MVI   FATAL,1            SET FLAG FOR FATAL ERROR              09352000
         ERR   12                 AND ISSUE PROGRAM TOO LONG MESSAGE    09353000
         DROP  R2                 GET RID OF BASE REGISTER              09354000
         TITLE 'SPITBOLR -- CONSTANTS'                                  09355000
*                                                                       09356000
*        HEADER FOR INITIAL PAGE PRINTED BY INTERFACE                   09357000
*                                                                       09358000
         ENTRY SYSHEAD            MAKE LOCATION KNOWN TO INTERFACE      09359000
SYSHEAD  EQU   *                  START OF HEADER LINES                 09360000
         HEDR  '1S P I T B O L  360 -- VERSION 2.3'          (34)  V2.3 09361000
         DC    AL1(64)                                             V2.3 09362000
         DC    C'0COPYRIGHT (C) 1971, 2001 ROBERT B K DEWAR' (42)  V2.3 09363000
         DC    C' AND KENNETH E BELCHER'                     (22)  V2.3 09364000
         DC    AL1(63)                                             V2.3 09365000
         DC    C'0LICENSED UNDER THE GPL, '                  (25)  V2.3 09366000
         DC    C'SEE HTTP://WWW.SNOBOL4.COM FOR DETAILS'     (38)  V2.3 09367000
         DC    X'00'              END OF HEADERS                   V2.3 09367010
         ORG   SYSHEAD+X'A9'      RE-ORG FOR TFS 2.2.1 - 2.2.6     V2.3 09367020
*                                                                       09368000
*        BATCHING FLAG (WE ONLY PERMIT BATCHING IN STANDARD MODULES)    09369000
*                                                                       09370000
         ENTRY SYSBATCH                                                 09371000
SYSBATCH DC    AL1(1-&LMOD)                                             09372000
*                                                                       09373000
*        VALUES OF STANDARD EXECUTION WORK AREAS NEEDING INITIALIZING   09374000
*                                                                       09375000
XEQINIT  DS    0F                 DEFINE START OF VALUES + ALLIGN       09376000
         BALR  DB3,DB1            IOASSCOD                              09377000
         DC    H'0'               . . . .                               09378000
         DC    X'00000000'        ANCHMODE (&ANCHOR = 0)                09379000
         DC    A(QPATSUBS)        SCANMODE (&FULLSCAN = 0)              09380000
         DC    A(0)               ANYTPTR = 0 (NO TABLE YET)            09381000
         TM    CTCHARS(R2),0      ANYMASK = 0                           09382000
         LA    DB2,*-*            LTRCLA,GBGLA                          09383000
         DC    PL3'-1'            GCOLCNT = 0 (-1 FOR CALL IN ECON)     09384000
         DC    X'00'              CLLCTFL = 0                           09385000
         DS    0F                 ALLIGN                                09386000
         DC    X'7FFF3CAF'        STSTART = OVERFLOW - 50000            09387000
         XERR  00,000             ERR MSG (PARAMS GET FILLED IN)        09388000
*                                                                       09389000
*        THE FOLLOWING CONSTANTS GIVE THE ADDRESSES OF THE COMPILER     09390000
*        AND EXECUTE PACGAGE. IF THEY ARE THE SAME, THEN WE MUST BE     09391000
*        IN A TWO PHASE VERSION. ELSE WE ARE IN THE SINGLE PHASE VERSN  09392000
*                                                                       09393000
CMPADR   DC    AL3(SPITBOLC)      ADDRESS OF COMPILER                   09394000
XEQADR   DC    AL3(SPITBOLP)      ADDRESS OF EXECUTE PACKAGE            09395000
         EJECT                                                          09396000
*                                                                       09397000
*        LITERALS                                                       09398000
*                                                                       09399000
         LTORG ,                  LITERALS FOR SPITBOLR                 09400000
*                                                                       09401000
*        PATCH SPACE                                                    09402000
*                                                                       09403000
PATCHR   DC    10A(0)             INITIALIZE TO ZEROS                   09404000
         TITLE 'SPITBOLR -- VARLOCF -- STANDARD VARIABLE TABLES'        09405000
*                                                                       09406000
*        THESE TABLES DESCRIBE VARIABLE BLOCKS HAVING ANY OF THE        09407000
*        FOLLOWING SPECIAL PROPERTIES --                                09408000
*                                                                       09409000
*        K     KEYWORD ASSOCIATION                                      09410000
*        P     STANDARD PATTERN VALUE                                   09411000
*        F     STANDARD FUNCTION DEFINITION                             09412000
*        O     OPERATOR DOPE VECTOR POINTER                             09413000
*        L     STANDARD LABEL ASSOCIATION                               09414000
*                                                                       09415000
*        EACH ENTRY HAS THE FOLLOWING FORMAT --                         09416000
*                                                                       09417000
*        BYTE 1                   LENGTH OF ENTRY IN BYTES              09418000
*                                                                       09419000
*        FOLLOWING BYTES          FULL VARIABLE NAME IN EBCDIC          09420000
*                                                                       09421000
*        BYTE AFTER NAME          FLAGS                                 09422000
INITK    EQU   1                  ON => KEYWORD ASSOCIATION             09423000
INITP    EQU   2                  ON => STANDARD PATTERN VALUE          09424000
INITF    EQU   4                  ON => SYSTEM FUNCTION DEFINITION      09425000
INITO    EQU   8                  ON => OPERATOR DV POINTER             09426000
INITL    EQU   16                 ON => STANDARD LABEL ASSOCIATION      09427000
*                                                                       09428000
*        THE FOLLOWING FIELDS ARE PRESENT ONLY IF THE CORRESPONDING     09429000
*        FLAG BIT IS SET IN THE FLAG BYTE                               09430000
*                                                                       09431000
*        ONE BYTE                 KEYWORD NUMBER                        09432000
*                                                                       09433000
*        TWO BYTES                OFFSET TO PATTERN VALUE IN SPITBOLX   09434000
*                                                                       09435000
*        THREE BYTES              ADDRESS OF FUNCTION                   09436000
*                                                                       09437000
*        TWO BYTES                OFFSET TO OPERATOR DV IN SPITBOLC     09438000
*                                                                       09439000
*        TWO BYTES                OFFSET TO STANDARD LABEL IN SPITBOLX  09440000
*                                                                       09441000
*        NOTE THERE IS NO PROVISION FOR STANDARD INPUT/OUTPUT           09442000
*        ASSOCIATIONS (INPUT,OUTPUT,PUNCH). THESE BLOCKS MUST BE PRE-   09443000
*        CONSTRUCTUED AND THE CORRECT POINTERS AND FLAGS PREINITIALIZED 09444000
*                                                                       09445000
*        ALL ENTRIES FOR NAMES OF A GIVEN LENGTH ARE TOGETHER IN        09446000
*        ALPHABETICAL ORDER ENDED BY A DUMMY ENTRY STARTING WITH X'FF'  09447000
         EJECT                                                          09448000
*                                                                       09449000
*        FORMAT OF MACRO CALL                                           09450000
*                                                                       09451000
*        INITV                    NAME,TYPE                             09452000
*                                                                       09453000
*        NAME IS THE NAME OF THE VARIABLE FOR WHICH AN ENTRY IS         09454000
*        TO BE CREATED (THE NAME OF THE ENTRY IS E$NAME)                09455000
*                                                                       09456000
*        TYPE IS A SERIES OF LETTERS INDICATING WHICH ATTRIBUTES ARE    09457000
*        PRESENT. FOR EXAMPLE KF MEANS A KEYWORD AND FUNCTION           09458000
*                                                                       09459000
INITVR1  EQU   *                  START OF TABLE FOR ONE CHAR NAMES     09460000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09461000
*                                                                       09462000
INITVR2  EQU   *                  START OF TABLE FOR TWO CHAR NAMES     09463000
         INITV                    EQ,OF                                 09464000
         INITV                    GE,OF                                 09465000
         INITV                    GT,OF                                 09466000
         INITV                    LE,OF                                 09467000
         INITV                    LT,OF                                 09468000
         INITV                    NE,OF                                 09469000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09470000
*                                                                       09471000
INITVR3  EQU   *                  START OF TABLE FOR THREE CHAR NAMES   09472000
         INITV                    ANY,OF                                09473000
         INITV                    ARB,PK                                09474000
         INITV                    ARG,F                                 09475000
         INITV                    BAL,KP                                09476000
         INITV                    END,L                                 09477000
         INITV                    LEN,OF                                09478000
         INITV                    LEQ,OF                                09479000
         INITV                    LGE,OF                                09480000
         INITV                    LGT,OF                                09481000
         INITV                    LLE,OF                                09482000
         INITV                    LLT,OF                                09483000
         INITV                    LNE,OF                                09484000
         INITV                    POS,OF                                09485000
         INITV                    REM,PK                                09486000
         INITV                    TAB,OF                                09487000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09488000
         EJECT                                                          09489000
*                                                                       09490000
INITVR4  EQU   *                  START OF TABLE FOR FOUR CHAR NAMES    09491000
         INITV                    CODE,KF                               09492000
         INITV                    COPY,F                                09493000
         INITV                    DATA,F                                09494000
         INITV                    DATE,F                                09495000
         INITV                    DUMP,FK                               09496000
         INITV                    DUPL,F                                09497000
         INITV                    EVAL,F                                09498000
         INITV                    FAIL,PK                               09499000
         INITV                    ITEM,F                                09500000
         INITV                    LOAD,F                                09501000
         INITV                    LPAD,F                                09502000
         INITV                    RPAD,F                                09503000
         INITV                    RPOS,OF                               09504000
         INITV                    RTAB,OF                               09505000
         INITV                    SIZE,F                                09506000
         INITV                    SPAN,OF                               09507000
         INITV                    STNO,K                                09508000
         INITV                    TIME,F                                09509000
         INITV                    TRIM,KF                               09510000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09511000
*                                                                       09512000
INITVR5  EQU   *                  START OF TABLE FOR FIVE CHAR NAMES    09513000
         INITV                    ABEND,K                               09514000
         INITV                    ABORT,KLP                             09515000
         INITV                    APPLY,F                               09516000
         INITV                    ARBNO,F                               09517000
         INITV                    ARRAY,F                               09518000
         INITV                    BREAK,OF                              09519000
         INITV                    CLEAR,F                               09520000
         INITV                    FENCE,PK                              09521000
         INITV                    FIELD,F                               09522000
         INITV                    IDENT,OF                              09523000
         INITV                    INPUT,KF                              09524000
         INITV                    LOCAL,F                               09525000
         INITV                    OPSYN,F                               09526000
         INITV                    PUNCH                                 09527000
         INITV                    REMDR,F                               09528000
         INITV                    TABLE,F                               09529000
         INITV                    TRACE,KF                              09530000
         INITV                    VALUE,F                               09531000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09532000
         EJECT                                                          09533000
*                                                                       09534000
INITVR6  EQU   *                  START OF TABLE FOR SIX CHAR NAMES     09535000
         INITV                    ANCHOR,K                              09536000
         INITV                    BREAKX,OF                             09537000
         INITV                    DEFINE,F                              09538000
         INITV                    DETACH,F                              09539000
         INITV                    DIFFER,OF                             09540000
         INITV                    FTRACE,K                              09541000
         INITV                    LASTNO,K                              09542000
         INITV                    NOTANY,OF                             09543000
         INITV                    OUTPUT,KF                             09544000
         INITV                    RETURN,L                              09545000
         INITV                    REWIND,F                              09546000
         INITV                    STOPTR,F                              09547000
         INITV                    SUBSTR,F                              09548000
         INITV                    UNLOAD,F                              09549000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09550000
*                                                                       09551000
INITVR7  EQU   *                  START OF TABLE FOR SEVEN CHAR NAMES   09552000
         INITV                    COLLECT,F                             09553000
         INITV                    CONVERT,F                             09554000
         INITV                    ENDFILE,F                             09555000
         INITV                    ERRTYPE,K                             09556000
         INITV                    FRETURN,L                             09557000
         INITV                    INTEGER,OF                            09558000
         INITV                    NRETURN,L                             09559000
         INITV                    REPLACE,F                             09560000
         INITV                    REVERSE,F                             09561000
         INITV                    RTNTYPE,K                             09562000
         INITV                    SETEXIT,F                             09563000
         INITV                    STCOUNT,K                             09564000
         INITV                    STLIMIT,K                             09565000
         INITV                    SUCCEED,PK                            09566000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09567000
*                                                                       09568000
INITVR8  EQU   *                  START OF TABLE FOR EIGHT CHAR NAMES   09569000
         INITV                    ALPHABET,K                            09570000
         INITV                    CONTINUE,L                            09571000
         INITV                    DATATYPE,F                            09572000
         INITV                    ERRLIMIT,K                            09573000
         INITV                    FNCLEVEL,K                            09574000
         INITV                    FULLSCAN,K                            09575000
         INITV                    MAXLNGTH,K                            09576000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09577000
*                                                                       09578000
INITVR9  EQU   *                  START OF TABLE FOR NINE CHAR NAMES    09579000
         INITV                    PROTOTYPE,F                           09580000
         DC    X'FFFF'            DUMMY ENTRY TO END LIST               09581000
         TITLE 'SPITBOLP -- START OF CONTROL SECTION'                   09582000
*                                                                       09583000
*        THE SPITBOLP CONTROL SECTION CONTAINS ALL THE PATTERN MATCHING 09584000
*        ROUTINES -- THESE ROUTINES ARE ADDRESSABLE UNDER EITHER THE    09585000
*        PBASE REGISTER OR UNDER RETURN WHICH IS THE PATTERN ROUTINE    09586000
*        TRANSFER REGISTER                                              09587000
*                                                                       09588000
         BEGIN P                  START OF SPITBOLP, SPITBLLP CSECT     09589000
         TITLE 'SPITBOLP -- FORMAT OF PATTERN MATCH STACKS'             09590000
*                                                                       09591000
*        THE PATTERN MATCHING PROCESS IS DRIVEN BY THREE STACKS         09592000
*                                                                       09593000
*        STACK ONE -- BACKUP STACK                                      09594000
*        ------------------------                                       09595000
*                                                                       09596000
*        THIS STACK CONTAINS AN ENTRY FOR EACH PATTERN ELEMENT          09597000
*        WHICH EXTENDS OR HAS AN ALTERNATIVE -- THE TOP ELEMENT         09598000
*        ON THIS STACK POINTS TO THE MOST RECENT SUCH PATTERN           09599000
*                                                                       09600000
*        EACH ENTRY HAS THE FOLLOWING FORMAT                            09601000
*                                                                       09602000
*                                                                       09603000
*        +-------------------------------------------------------+      09604000
*        |                        S1PATOFS                       |      09605000
*        +-------------------------------------------------------+      09606000
*        |                        S1OLDCP                        |      09607000
*        +-------------------------------------------------------+      09608000
*        |                        S1NEWCP                        |      09609000
*        +-------------------------------------------------------+      09610000
*                                                                       09611000
*                                                                       09612000
*        DEFINITIONS OF OFFSETS OF FIELDS IN STACK 1 ENTRY              09613000
*        -------------------------------------------------              09614000
*                                                                       09615000
S1PATOFS EQU   0                  OFFSET TO PATTERN NODE MAKING ENTRY   09616000
*                                                                       09617000
S1OLDCP  EQU   4                  CURSOR POSITION BEFORE MATCH          09618000
*                                                                       09619000
S1NEWCP  EQU   8                  UPDATED CURSOR AFTER EXTENSION        09620000
*                                                                       09621000
*        PATTERNS ONLY MAKE AN ENTRY ON THIS STACK IF THEY HAVE AN      09622000
*        EXTENSION ROUTINE OR AN ALTERNATIVE OR BOTH (THE FEW           09623000
*        EXCEPTIONS TO THIS RULE ARE NOTED IN THE RELATED ROUTINES)     09624000
*                                                                       09625000
*        AT THE BOTTOM OF THE PATTERN STACK THERE IS A SPECIAL ENTRY    09626000
*        WHICH HANDLES MOVING OF THE ANCHOR IF ALLOWED                  09627000
*        IT HAS A PATTERN OFFSET OF ZERO WHICH ALWAYS POINTS TO THE     09628000
*        ANCHEXT EXTEND ROUTINE -- SEE PATTERN BLOCK FORMAT             09629000
*                                                                       09630000
*        (PS1)                    POINTS TO THE NEXT AVAILABLE LOCATION 09631000
*        (PS2)                    POINTS PAST THE LAST LOCATION         09632000
*        (BPS)                    CONTAINS THE INCREMENT (12)           09633000
*                                                                       09634000
*        (THIS STACK BUILDS UP IN CORE)                                 09635000
*                                                                       09636000
*        IN ADDITION TO THIS STANDARD USAGE -- THE STAR PATTERN         09637000
*        (UNEVALUATED EXPRESSION) USES THE S1OLDCP FIELD IN A SPECIAL   09638000
*        WAY -- SEE PO$EXP1 FOR DETAILS OF THIS                         09639000
*                                                                       09640000
*        RELOCATABLE FIELDS       S1OLDCP (FOR EXP SPECIAL CASE)        09641000
         EJECT                                                          09642000
*                                                                       09643000
*        STACK TWO                                                      09644000
*        ---------                                                      09645000
*                                                                       09646000
*        THIS STACK IS USED FOR TWO QUITE DIFFERENT PURPOSES            09647000
*                                                                       09648000
*        1)    TO SAVE THE CURSOR FOR $ . ARBNO -- SEE PO$MARK          09649000
*                                                                       09650000
*        +-------------------------------------------------------+      09651000
*        |                        S2CP                           |      09652000
*        +-------------------------------------------------------+      09653000
*        |                        ///////                        |      09654000
*        +-------------------------------------------------------+      09655000
*        |                        ///////                        |      09656000
*        +-------------------------------------------------------+      09657000
*                                                                       09658000
*                                                                       09659000
*        2)    TO SAVE PATTERN BASE AND OFFSET (PB) AND (PO) ON A       09660000
*              RECURSIVE PATTERN MATCH (UNEVALUATED EXPRESSION)         09661000
*                                                                       09662000
*        +-------------------------------------------------------+      09663000
*        |                        S2PB                           |      09664000
*        +-------------------------------------------------------+      09665000
*        |                        S2PO                           |      09666000
*        +-------------------------------------------------------+      09667000
*        |                        ///////                        |      09668000
*        +-------------------------------------------------------+      09669000
*                                                                       09670000
*                                                                       09671000
*        DEFINITIONS OF OFFSETS OF FIELDS IN STACK 2 ENTRY              09672000
*        -------------------------------------------------              09673000
*                                                                       09674000
S2CP     EQU   0                  SAVE CURSOR POINTER FOR $ . ARBNO     09675000
S2PB     EQU   0                  SAVE PATTERN BASE (PB) ON PAT RECURSN 09676000
S2PO     EQU   4                  SAVE PATTERN OFFSET (PO) ON PAT RECUR 09677000
*                                                                       09678000
*        S2OFS(PS2)               POINTS TO CURRENT ACTIVE ENTRY        09679000
*        (PS1)                    POINTS TO LOWEST AVAILABLE ENTRY      09680000
*        (BPS)                    CONTAINS THE DECREMENT (12)           09681000
*                                                                       09682000
*        (THIS STACK BUILDS DOWN IN CORE)                               09683000
*                                                                       09684000
*        RELOCATABLE FIELDS       S2PB (S2CP IS SAFE BECAUSE TOO SMALL) 09685000
         EJECT                                                          09686000
*                                                                       09687000
*        STACK ONE -- SPECIAL ENTRY FOR DOT ASSIGNMENT                  09688000
*        ---------------------------------------------                  09689000
*                                                                       09690000
*        THE FOLLOWING SPECIAL ENTRY IS MADE ON STACK ONE IN THE CASE   09691000
*        OF A DOT ASSIGNMENT. AT THE END OF PATTERN MATCHING (ON        09692000
*        A SUCCESSFUL MATCH), THE PATTERN STACK IS SCANNED FOR          09693000
*        THE DOTFLG FLAG WHICH INDICATES THIS TYPE OF ENTRY AND THE     09694000
*        APPROPRIATE ASSIGNMENTS ARE MADE                               09695000
*                                                                       09696000
*        +-------------------------------------------------------+      09697000
*        |                         S1PO                          |      09698000
*        +-------------+-----------------------------------------+      09699000
*        |   DOTLOC    |                    S1PB                 |      09700000
*        +-------------+-------------+---------------------------+      09701000
*        |           S1BCP           |           S1ECP           |      09702000
*        +---------------------------+---------------------------+      09703000
*                                                                       09704000
S1PO     EQU   0                  PATTERN OFFSET FOR DOT PATTERN        09705000
DOTLOC   EQU   4                  LOCATION FOR DOTFLG                   09706000
DOTFLG   EQU   MCODE              FLAG TO SIGNAL DOT ENTRY              09707000
*                                                                       09708000
*        DOTFLG OCCUPIES THE TYPE CODE POSITION IN THE PATTERN          09709000
*        ADDRESS WORD THAT IS SOMETIMES SAVED ON STACK1                 09710000
*        THE ONLY OTHER FLAGS THAT MAY APPEAR IN THIS BYTE ARE PCODE    09711000
*        FOUND WITH A NORMAL PB STACK ENTRY (DEFERRED EXPRESSION)       09712000
*        X'80' OR X'40' USED TO SAVE AND RESTORE FAILSW FOR EXTENSION   09713000
*        ROUTINES AND AS A FLAG OVER EXTEND CALLS                       09714000
*        THE CHOICE FOR DOTFLG IS LIMITED BY THE FOLLOWING CONSTRAINTS  09715000
*        RELOCBIT MUST BE ON, TO MAKE SURE THIS IS PROCESSED BY THE     09716000
*        GARBAGE COLLECTOR PTRPROCV CALL                                09717000
*        IT SHOULD NOT BE SCODE, AS IN THE FUTURE THE GARBAGE COLLECTOR 09718000
*        MAY DO SPECIAL THINGS WITH STRING POINTERS                     09719000
*                                                                       09720000
S1PB     EQU   4                  PATTERN BASE FOR DOT PATTERN          09721000
S1BCP    EQU   8                  CURSOR AT START OF MATCHED PART       09722000
S1ECP    EQU   10                 CURSOR AT END OF MATCHED PART         09723000
*                                                                       09724000
*        RELOCATABLE FIELDS       S1PB                                  09725000
         TITLE 'SPITBOLP -- PATTERN MATCH ROUTINES'                     09726000
*                                                                       09727000
*        THESE ROUTINES PERFORM THE FUNCTION OF MATCHING ONE PATTERN    09728000
*        ELEMENT. THE FOLLOWING ARE THE CONDITIONS ON ENTRY --          09729000
*                                                                       09730000
*        (CP)                     CURSOR POINTER                        09731000
*                                 (NUMBER OF REMAINING UNMATCHED CHARS) 09732000
*                                                                       09733000
*        (PB)                     PATTERN BLOK POINTER                  09734000
*                                                                       09735000
*                                                                       09736000
*        (PO)                     OFFSET FROM (PB) OF PATTERN ELEMENT   09737000
*                                                                       09738000
*        (FSADR)                  ADDRESS OF LAST CHAR IN STG + 1       09739000
*                                                                       09740000
*                                                                       09741000
*                                                                       09742000
*        MOST OF THE ROUTINES EXIST IN TWO VERSIONS -- ONE TO BE USED   09743000
*        WHEN THERE IS NO ALTERNATIVE AND THE OTHER FOR USE WHEN        09744000
*        AN ALTERNATIVE IS PRESENT                                      09745000
*                                                                       09746000
*        NOTE THAT EVERY PATTERN ROUTINE FOR THE "NOOR" CASE IS         09747000
*        PRECEDED BY A HALF WORD OFFSET TO THE CODE FOR THE "OR" CASE   09748000
*        THIS IS TO ASSIST THE ALTERNATION ROUTINE IN CONTRUCTION OF    09749000
*        PATTERNS WHERE BLOCKS MAY BE SUPPLIED WITH ALTERNATIVES AND    09750000
*        MUST BE MODIFIED ACCORDINGLY                                   09751000
*                                                                       09752000
*        THE DEFERRED ENTRY POINTS FOR POS,RPOS,TAB,RTAB, AND LEN       09753000
*        MUST BE 14 BYTES BEHIND THE NON-DEFERRED CASES TO SATISFY      09754000
*        THE PATTERN CONSTRUCTION ROUTINES                              09755000
*                                                                       09756000
         EJECT                                                          09757000
*                                                                       09758000
*        THESE PATTERN ROUTINES BRANCH TO ONE OF THE FOLLOWING EXIT     09759000
*        POINTS ---                                                     09760000
*                                                                       09761000
*        BACKUP                   USED WHEN AN ELEMNT HAVING NO         09762000
*                                 ALTERNATE FAILS -- CP,PO SETTINGS     09763000
*                                 ARE IRRELEVANT                        09764000
*                                 (BACKS UP ON PATTERN STACK ONE)       09765000
*                                                                       09766000
*        LBACKUP                  LIKE BACKUP, BUT USED WHEN THE        09767000
*                                 FAILURE IS A LENGTH FAIL              09768000
*                                                                       09769000
*        FAIL                     USED WHEN AN ELEMENT WHICH HAS AN     09770000
*                                 ALTERNATIVE FAILS -- CP,PO MUST BE    09771000
*                                 (TAKES THE ALTERNATIVE)               09772000
*                                                                       09773000
*        LFAIL                    LIKE FAIL, BUT USED WHEN THE          09774000
*                                 FAILURE IS A LENGTH FAIL              09775000
*                                                                       09776000
*        SUCC                     USED ON SUCCESSFUL MATCH OF AN        09777000
*                                 ELEMENT WITH NO ALTERNATE -- PO MUST  09778000
*                                 BE SET AS ON ENTRY, AND CP UPDATED    09779000
*                                 PAST THE MATCHED PART                 09780000
*                                 (TAKES THE "THEN" BRANCH)             09781000
*                                                                       09782000
*        SUCCS                    USED ON SUCCESSFUL MATCH OF AN        09783000
*                                 ELEMENT WITH AN ALTERNATIVE -- PO,CP  09784000
*                                 MUST BE SET AS ON ENTRY -- NCP IS SET 09785000
*                                 TO THE NEW VALUE OF CP AFTER MATCHING 09786000
*                                 (MAKES PO,CP ENTRY ON STACK 1 AND     09787000
*                                  BRANCHES TO "THEN" PATTERN)          09788000
*                                                                       09789000
*        SUCCSN                   USED WHEN AN ELEMENT HAVING AN        09790000
*                                 ALTERNATIVE SUCCESSFULLY MATCHES THE  09791000
*                                 NULL STRING                           09792000
*                                 (SAME ACTION AS SUCCS SAVING AN LR)   09793000
*                                                                       09794000
*        SUCCSP                   LIKE SUCCS BUT USED WHEN THE STACK    09795000
*                                 ONE ENTRY HAS ALREADY BEEN MADE BY    09796000
*                                 THE CALLER (BUT STACK PTRS UNMOVED)   09797000
         EJECT                                                          09798000
*                                                                       09799000
*        THE ROUTINES DESCRIBED ON THE PRECEDING PAGE AND ALL EXTENSION 09800000
*        ROUTINES EXIST IN TWO VERSIONS -- ONE FOR FULLSCAN AND ONE     09801000
*        FOR QUICKSCAN ROUTINES -- THE SETTING OF THE BASE REGISTER     09802000
*        DETERMINES WHICH SET ARE USED -- PBASE IS SET ON ENTRY TO A    09803000
*        PATTERN ACCORDING TO THE VALUE OF THE KEYWORD &FULLSCAN        09804000
*                                                                       09805000
*                                                                       09806000
*        HANDLING OF QUICKSCAN HEURISTICS                               09807000
*        --------------------------------                               09808000
*                                                                       09809000
*        THE SWITCH FAILSW IS USED AS A FLAG FOR LENGTH FAILURE         09810000
*        ALL PATTERNS WHICH CAN EXTEND SET FAILSW=FF TO INDICATE        09811000
*        TENTATIVE LENGTH FAILURE (THIS INCLUDES THE INITIAL ANCHOR     09812000
*        MOVEMENT IN UNANCHORED MODE) ANY PATTERN ELEMENT WHICH FAILS   09813000
*        WITH A LENGTH FAILURE BRANCHES TO LFAIL OR LBACKUP WHICH BOTH  09814000
*        LEAVE THE LENGTH-FAIL SETTING OF FAILSW UNCHANGED. ANY PATTERN 09815000
*        ELEMENT WHICH FAILS FOR ANY OTHER REASON BRANCHES TO FAIL OR   09816000
*        BACKUP WHICH SET FAILSW NON-ZERO TO INDICATE THAT AT LEAST     09817000
*        ONE ELEMENT HAS NOT LENGTH FAILED AND THAT THEREFORE EXTENSION 09818000
*        SHOULD BE ATTEMPTED -- THAT IS, WE ONLY INHIBIT EXTENSION IF   09819000
*        ALL SUCCEEDING PATTERN ELEMENTS CAUSE LENGTH FAILURE           09820000
*                                                                       09821000
*                                                                       09822000
*        ANOTHER HEURISTIC ACTIVE IN QUICKSCAN MODE IS THE TEST FOR     09823000
*        MINIMUM NUMBER OF CHARACTERS REMAINING -- THE MINMATCH FIELD   09824000
*        OF EVERY PBLOK CONTAINS THE MINIMUM NUMBER OF CHARACTERS       09825000
*        NECCESSARY FOR A SUCCESSFUL MATCH FOR THAT PBLOK AND ALL       09826000
*        PBLOKS CHAINED FROM IT -- THE SUCC AND SUCCS ROUTINES COMPARE  09827000
*        THIS FIELD AGAINST CP AND LFAIL OR LBACKUP IF THERE ARE TOO    09828000
*        FEW CHARACTERS REMAINING -- A COMPLICATION OCCURS WHEN WE      09829000
*        GO DOWN A LEVEL TO MATCH A SUB PATTERN (UNEVALUATED EXPR)      09830000
*        IN THIS CASE, THE REGISTER MINR IS USED TO HOLD THE NEGATIVE   09831000
*        OF THE MINIMUM NUMBER OF CHARACTERS REQUIRED FOR COMPLETION    09832000
*        OF MATCHING ON ALL HIGHER LEVELS -- THUS THE ACTUAL TEST MADE  09833000
*        IS WHETHER (CP+MINR) IS AT LEAST MINMATCH CHARS                09834000
*                                                                       09835000
*        ANOTHER HEURISTIC INVOLVES THE ASSUMPTION THAT UNEVALUATED     09836000
*        EXPRESSIONS MATCH AT LEAST ONE CHARACTER. THIS HEURISTIC IS    09837000
*        APPLIED BY SETTING A VALUE OF ONE IN THE MINMATCH FIELD OF     09838000
*        AFFECTED NODES -- NO SPECIAL CODE IS REQUIRED.                 09839000
*                                                                       09840000
*        THE FINAL HEURISTIC INVOLVES THE EXTENSION OF ARBNO -- THIS    09841000
*        AVOIDS GETTING STUCK IN A LOOP MATCHING NULL -- SEE ARBNO      09842000
*        AND ITS EXTENSION ROUTINE ARBNOEXT FOR DETAILS                 09843000
         EJECT                                                          09844000
PATSUBS  EQU   *                  START OF PATTERN SUBROUTINES          09845000
         DROP  DB1                DB1 NOT AVAILABLE IN MATCH            09846000
         USING SPITBOLA,SYS       BASE REG FOR SYSTEM ROUTINES          09847000
         USING QPATSUBS,PBASE     SYMBOLS NEEDED ARE DEFINED IN         09848000
*                                 QUICKSCAN ROUTINES                    09849000
*                                                                       09850000
*        POS ENTRY POINTS                                               09851000
*                                                                       09852000
*        FOR INTEGER CASE --                                            09853000
*        PARAM1                   POS ARGUMENT                          09854000
*        EXTEND                   NONE                                  09855000
*                                                                       09856000
*        FOR DEFERRED EXPRESSION CASE --                                09857000
*        PARAM1                   NOT USED                              09858000
*        PARAM2                   EXPRESSION POINTER                    09859000
*        EXTEND                   NONE                                  09860000
*                                                                       09861000
*                                                                       09862000
*                                                                       09863000
*        EXPRESSION ARGUMENT -- "NOOR" POINTER                          09864000
*                                                                       09865000
         DC    Y(PO$POSD-*)       OFFSET TO CODE FOR "OR" CASE          09866000
         USING *,RETURN           PATTERN ROUTINE BASE REG              09867000
PN$POSD  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       09868000
         XERN  01,001             EVALUTED RESULT OF DEFERRED ARGUMENT  09869000
*                                 TO POS IS NOT AN INTEGER              09870000
         XERN  13,001             EVALUTED RESULT OF DEFERRED ARGUMENT  09871000
*                                 TO POS IS NEGATIVE                    09872000
*                                                                       09873000
*        INTEGER ARGUMENT -- "NOOR" POINTER                             09874000
*                                                                       09875000
         DC    Y(PO$POS-*)        OFFSET TO CODE FOR "OR" CASE          09876000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  09877000
PN$POS   LH    R1,PSTGLEN(,PDR)   LOAD SUBJECT STRING LENGTH            09878000
         SR    R1,CP              SUBTRACT NUMBER OF CHARS LEFT         09879000
         C     R1,PARAM1(PB,PO)   COMPARE THIS LOC WITH ARG             09880000
         BE    SUCC               SUCCEED IF EQUAL                      09881000
         BH    LBACKUP            IF TOO FAR, LENGTH-FAIL               09882000
         EJECT                                                          09883000
*                                                                       09884000
*        POS ENTRY POINTS -- CONTINUED                                  09885000
*                                                                       09886000
*                                                                       09887000
*        POS FAILURE ROUTINE -- THIS ROUTINE OPTIMIZES THE OCCURENCE    09888000
*        OF POS AS THE FIRST ITEM IN A PATTERN -- IN UNANCHORED MODE    09889000
*        THE ANCHOR IS MERELY MOVED TO THE POINT OF OCCURENCE AND FUR-  09890000
*        THER ANCHOR MOVEMENT INHIBITED                                 09891000
*                                                                       09892000
         CH    PO,=Y(PATS)        SEE IF POS IS FIRST ELEMENT           09893000
         BNE   BACKUP             IN ANY OTHER CASE, NORMAL FAILURE     09894000
         CLI   ANCLOC(PDR),X'80'  CHECK FOR UNANCHORED MODE             09895000
         BE    PABORT             PATTERN ABORTS IN ANCHORED MODE       09896000
         C     PB,ORGPB(,PDR)     MUST BE ORIGINAL PATTERN BASE         09897000
         BNE   BACKUP             IF NOT, CAN'T OPTIMIZE                09898000
         S     CP,PARAM1(PB,PO)   SUBTRACT POS PARAMETER                09899000
         BM    PABORT             PATTERN ABORTS IF THIS IS OFF END     09900000
         ST    CP,STACK1+S1NEWCP(,PDR)      STORE AS ANCHOR MOVEMENT    09901000
         MVI   ANCLOC(PDR),X'80'  SET TO PREVENT FURTHER ANCHOR MOVMENT 09902000
         B     SUCC               SUCCEED                               09903000
*                                                                       09904000
*        EXPRESSION ARGUMENT -- "OR" CASE                               09905000
*                                                                       09906000
         USING *,RETURN           PATTERN ROUTINE BASE REG              09907000
PO$POSD  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       09908000
         XERR  01,001             EVALUATED RESULT OF DEFERRED ARGUMENT 09909000
*                                 TO POS IS NOT AN INTEGER              09910000
         XERR  13,001             EVALUATED RESULT OF DEFERRED ARGUMENT 09911000
*                                 TO POS IS NEGATIVE                    09912000
*                                                                       09913000
*        INTEGER ARGUMENT -- "OR" CASE                                  09914000
*                                                                       09915000
         NOPR  0                  SPACE CORRECTLY                       09916000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  09917000
PO$POS   LH    R1,PSTGLEN(,PDR)   LOAD SUBJECT STRING LENGTH            09918000
         SR    R1,CP              CALCULATE LOCATION FROM START         09919000
         C     R1,PARAM1(PB,PO)   CHECK FOR MATCH WITH ARGUMENT         09920000
         BE    SUCCSN             IF EQUAL, SUCCEED WITH NO CP MOVE     09921000
         BH    LFAIL              IF PAST, LENGTH FAILURE               09922000
         B     FAIL               ELSE NORMAL FAILURE                   09923000
         EJECT                                                          09924000
*                                                                       09925000
*        ENTRY POINTS FOR RPOS                                          09926000
*                                                                       09927000
*        FOR INTEGER CASE --                                            09928000
*        PARAM1                   INTEGER ARGUMENT TO RPOS              09929000
*        EXTEND                   NONE                                  09930000
*                                                                       09931000
*        FOR DEFERRED EXPRESSION CASE --                                09932000
*        PARAM1                   NOT USED                              09933000
*        PARAM2                   EXPRESSION POINTER                    09934000
*        EXTEND                   NONE                                  09935000
*                                                                       09936000
*                                                                       09937000
*                                                                       09938000
*        EXPRESSION ARGUMENT -- "NOOR" CASE                             09939000
*                                                                       09940000
         USING *,RETURN           PATTERN ROUTINE BASE REG              09941000
         DC    Y(PO$RPOSD-*)      OFFSET TO CODE FOR "OR" CASE          09942000
PN$RPOSD BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       09943000
         XERN  01,002             EVALUTED RESULT OF DEFERRED ARGUMENT  09944000
*                                 TO RPOS IS NOT AN INTEGER             09945000
         XERN  13,002             EVALUTED RESULT OF DEFERRED ARGUMENT  09946000
*                                 TO RPOS IS NEGATIVE                   09947000
*                                                                       09948000
*        INTEGER ARGUMENT -- "NOOR" CASE                                09949000
*                                                                       09950000
         DC    Y(PO$RPOS-*)       OFFSET TO CODE FOR "OR" CASE          09951000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  09952000
PN$RPOS  C     CP,PARAM1(PB,PO)   CHECK FOR MATCH WITH ARGUMENT         09953000
         BH    BACKUP             NORMAL FAIL IF NOT THERE YET          09954000
         BE    SUCC               SUCCEED IF THERE IS A MATCH           09955000
         B     LBACKUP            LENGTH FAIL IF ALREADY PAST           09956000
*                                                                       09957000
*        EXPRESSION ARGUMENT -- "OR" CASE                               09958000
*                                                                       09959000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          09960000
PO$RPOSD BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       09961000
         XERR  01,002             EVALUATED RESULT OF DEFERRED ARGUMENT 09962000
*                                 TO RPOS IS NOT AN INTEGER             09963000
         XERR  13,002             EVALUATED RESULT OF DEFERRED ARGUMENT 09964000
*                                 TO RPOS IS NEGATIVE                   09965000
*                                                                       09966000
*        INTEGER ARGUMENT -- "OR" CASE                                  09967000
*                                                                       09968000
         NOPR  0                  SPACE CORRECTLY                       09969000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  09970000
PO$RPOS  C     CP,PARAM1(PB,PO)   CHECK FOR MATCH WITH ARGUMENT         09971000
         BH    FAIL               NORMAL FAIL IF NOT THERE YET          09972000
         BE    SUCCSN             ON MATCH, SUCCEED WITH NO CP MOVE     09973000
         B     LFAIL              LENGTH FAIL IF PAST ALREADY           09974000
         EJECT                                                          09975000
*                                                                       09976000
*        ENTRY POINTS FOR RTAB                                          09977000
*                                                                       09978000
*        FOR INTEGER CASE --                                            09979000
*        PARAM1                   ARGUMENT TO RTAB                      09980000
*        EXTEND                   NONE                                  09981000
*                                                                       09982000
*        FOR DEFERRED EXPRESSION CASE --                                09983000
*        PARAM1                   NOT USED                              09984000
*        PARAM2                   EXPRESSION POINTER                    09985000
*        EXTEND                   NONE                                  09986000
*                                                                       09987000
*                                                                       09988000
*                                                                       09989000
*        EXPRESSION ARGUMENT -- "NOOR" CASE                             09990000
*                                                                       09991000
         DC    Y(PO$RTABD-*)      OFFSET TO CODE FOR "OR" CASE          09992000
         USING *,RETURN           PATTERN ROUTINE BASE REG              09993000
PN$RTABD BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       09994000
         XERN  01,003             EVALUTED RESULT OF DEFERRED ARGUMENT  09995000
*                                 TO RTAB IS NOT AN INTEGER             09996000
         XERN  13,003             EVALUTED RESULT OF DEFERRED ARGUMENT  09997000
*                                 TO RTAB IS NEGATIVE                   09998000
*                                                                       09999000
*        INTEGER ARGUMENT -- "NOOR" CASE                                10000000
*                                                                       10001000
         DC    Y(PO$RTAB-*)       OFFSET TO CODE FOR "OR" CASE          10002000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  10003000
PN$RTAB  C     CP,PARAM1(PB,PO)   TEST CURRENT LOCATION AGAINST ARG     10004000
         L     CP,PARAM1(PB,PO)   LOAD NEW CURSOR POSITION IN CASE OK   10005000
         BNL   SUCC               OK IF AT OR BEHIND INDICATED LOC      10006000
         B     LBACKUP            ELSE LENGTH FAIL                      10007000
*                                                                       10008000
*        EXPRESSION ARGUMENT -- "OR" CASE                               10009000
*                                                                       10010000
         USING *,RETURN           PATTERN ROUTINE BASE REG              10011000
PO$RTABD BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       10012000
         XERR  01,003             EVALUATED RESULT OF DEFERRED ARGUMENT 10013000
*                                 TO RTAB IS NOT AN INTEGER             10014000
         XERR  13,003             EVALUATED RESULT OF DEFERRED ARGUMENT 10015000
*                                 TO RTAB IS NEGATIVE                   10016000
*                                                                       10017000
*        INTEGER ARGUMENT -- "OR" CASE                                  10018000
*                                                                       10019000
         NOPR  0                  SPACE CORRECTLY                       10020000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  10021000
PO$RTAB  L     NCP,PARAM1(PB,PO)  LOAD PARAMETER                        10022000
         CR    NCP,CP             CHECK AGAINST NUMBER OF CHARS LEFT    10023000
         BNH   SUCCS              ALL OK IF NOT BEHIND CURRENT LOC      10024000
         B     LFAIL              ELSE LENGTH FAIL                      10025000
         EJECT                                                          10026000
*                                                                       10027000
*        ENTRY POINTS FOR TAB                                           10028000
*                                                                       10029000
*        FOR INTEGER CASE --                                            10030000
*        PARAM1                   TAB ARGUMENT                          10031000
*        EXTEND                   NONE                                  10032000
*                                                                       10033000
*        FOR DEFERRED EXPRESSION CASE --                                10034000
*        PARAM1                   NOT USED                              10035000
*        PARAM2                   EXPRESSION POINTER                    10036000
*        EXTEND                   NONE                                  10037000
*                                                                       10038000
*                                                                       10039000
*        EXPRESSION ARGUMENT -- "NOOR" CASE                             10040000
*                                                                       10041000
         DC    Y(PO$TABD-*)       OFFSET TO CODE FOR "OR" CASE          10042000
         USING *,RETURN           PATTERN ROUTINE BASE REG              10043000
PN$TABD  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       10044000
         XERN  01,004             EVALUTED RESULT OF DEFERRED ARGUMENT  10045000
*                                 TO TAB IS NOT AN INTEGER              10046000
         XERN  13,004             EVALUTED RESULT OF DEFERRED ARGUMENT  10047000
*                                 TO TAB IS NEGATIVE                    10048000
*                                                                       10049000
*        INTEGER ARGUMENT -- "NOOR" CASE                                10050000
*                                                                       10051000
         DC    Y(PO$TAB-*)        OFFSET TO CODE FOR "OR" CASE          10052000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  10053000
PN$TAB   L     R1,PARAM1(PB,PO)   LOAD TAB ARGUMENT                     10054000
         LH    NCP,PSTGLEN(,PDR)  LOAD SUBJECT STRING LENGTH            10055000
         SR    NCP,R1             MINUS ARG = NUM CHARS TO BE LEFT      10056000
         CLR   NCP,CP             CHECK FOR PLUS, LE O6D CURSOR LOC     10057000
         LR    CP,NCP             LOAD NEW CURSOR LOCATION              10058000
         BNH   SUCC               SUCCEED IF NOT BEHIND CURRENT LOC     10059000
         B     LBACKUP            ELSE LENGTH FAIL                      10060000
         EJECT                                                          10061000
*                                                                       10062000
*        TAB ENTRY POINTS -- CONTINUED                                  10063000
*                                                                       10064000
*                                                                       10065000
*        EXPRESSION ARGUMENT -- "OR" CASE                               10066000
*                                                                       10067000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10068000
PO$TABD  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       10069000
         XERR  01,004             EVALUATED RESULT OF DEFERRED ARGUMENT 10070000
*                                 TO TAB IS NOT AN INTEGER              10071000
         XERR  13,004             EVALUATED RESULT OF DEFERRED ARGUMENT 10072000
*                                 TO TAB IS NEGATIVE                    10073000
*                                                                       10074000
*        INTEGER ARGUMENT -- "OR" CASE                                  10075000
*                                                                       10076000
         NOPR  0                  SPACE CORRECTLY                       10077000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  10078000
PO$TAB   L     R1,PARAM1(PB,PO)   LOAD TAB ARGUMENT                     10079000
         LH    NCP,PSTGLEN(,PDR)  LOAD SUBJECT STRING LENGTH            10080000
         SR    NCP,R1             GET NUM OF CHARS WHICH WILL BE LEFT   10081000
         CLR   NCP,CP             CHECK FOR PLUS, LE O6D CURSOR LOC     10082000
         BNH   SUCCS              SUCCEED IF NOT BEHIND CURRENT LOC     10083000
         B     LFAIL              ELSE LENGTH FAILURE                   10084000
         EJECT                                                          10085000
*                                                                       10086000
*        ENTRY POINTS FOR LEN                                           10087000
*                                                                       10088000
*        FOR INTEGER CASE --                                            10089000
*        PARAM1                   LEN ARGUMENT                          10090000
*        EXTEND                   NONE                                  10091000
*                                                                       10092000
*        FOR DEFERRED EXPRESSION CASE --                                10093000
*        PARAM1                   NOT USED                              10094000
*        PARAM2                   EXPRESSION POINTER                    10095000
*        EXTEND                   NONE                                  10096000
*                                                                       10097000
*                                                                       10098000
*        EXPRESSION ARGUMENT -- "NOOR" CASE                             10099000
*                                                                       10100000
         DC    Y(PO$LEND-*)       OFFSET TO CODE FOR "OR" CASE          10101000
         USING *,RETURN           PATTERN ROUTINE BASE REG              10102000
PN$LEND  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       10103000
         XERN  01,005             EVALUTED RESULT OF DEFERRED ARGUMENT  10104000
*                                 TO LEN IS NOT AN INTEGER              10105000
         XERN  13,005             EVALUTED RESULT OF DEFERRED ARGUMENT  10106000
*                                 TO LEN IS NEGATIVE                    10107000
*                                                                       10108000
*        INTEGER ARGUMENT -- "NOOR" CASE                                10109000
*                                                                       10110000
         DC    Y(PO$LEN-*)        OFFSET TO CODE FOR "OR" CASE          10111000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  10112000
PN$LEN   S     CP,PARAM1(PB,PO)   SUBTRACT ARG FROM NUM CHARS LEFT      10113000
         BNM   SUCC               SUCCEED IF NOT OFF END OF STRING      10114000
         B     LBACKUP            ELSE LENGTH FAILURE                   10115000
*                                                                       10116000
*        EXPRESSION ARGUMENT -- "OR" CASE                               10117000
*                                                                       10118000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10119000
PO$LEND  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1       10120000
         XERR  01,005             EVALUATED RESULT OF DEFERRED ARGUMENT 10121000
*                                 TO LEN IS NOT AN INTEGER              10122000
         XERR  13,005             EVALUATED RESULT OF DEFERRED ARGUMENT 10123000
*                                 TO LEN IS NEGATIVE                    10124000
*                                                                       10125000
*        INTEGER ARGUMENT -- "OR" CASE                                  10126000
*                                                                       10127000
         NOPR  0                  SPACE CORRECTLY                       10128000
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG  10129000
PO$LEN   LR    NCP,CP             COPY CURRENT LOCATION                 10130000
         S     NCP,PARAM1(PB,PO)  SUBTRACT ARG FROM NUM CHARS LEFT      10131000
         BNM   SUCCS              SUCCEED WITH STACK IF NOT OFF END     10132000
         B     LFAIL              ELSE LENGTH FAILURE                   10133000
         EJECT                                                          10134000
*                                                                       10135000
*        ENTRY POINTS FOR @                                             10136000
*                                                                       10137000
*        FOR NAME CASE --                                               10138000
*        PARAM1                   NAME BASE                             10139000
*        PARAM2                   NAME OFFSET                           10140000
*        EXTEND                   NONE                                  10141000
*                                                                       10142000
*        FOR DEFERRED EXPRESSION ARGUMENT --                            10143000
*        PARAM1                   NOT USED                              10144000
*        PARAM2                   EXPRESSION POINTER                    10145000
*        EXTEND                   NONE                                  10146000
*                                                                       10147000
*        EXPRESSION ARGUMENT -- "NOOR" CASE                             10148000
*                                                                       10149000
         DC    Y(PO$@D-*)         OFFSET TO CODE FOR "OR" CASE          10150000
         USING *,RETURN           PATTERN BASE REG                      10151000
PN$@D    BAL   NCP,DEFEXPN        EVAL EXPR TO GET NAME, MERGE *+14     10152000
*                                                                       10153000
*        NORMAL ARGUMENT -- "NOOR" CASE                                 10154000
*                                                                       10155000
         DC    Y(PO$@-*)          OFFSET TO CODE FOR "OR" CASE          10156000
         USING *,RETURN           PATTERN BASE REG                      10157000
PN$@     L     BPS,PARAM1(PB,PO)  LOAD NAME BASE                        10158000
         A     BPS,PARAM2(PB,PO)  ADD NAME OFFSET                       10159000
*                                                                       10160000
*        DEFERRED CASE MERGES HERE                                      10161000
*                                                                       10162000
         LH    R2,PSTGLEN(,PDR)   LOAD SUBJECT STRING LENGTH            10163000
         SR    R2,CP              MINUS NUMBER OF CHARACTERS LEFT       10164000
         SR    R1,R1              INDICATE INTEGER RESULT               10165000
         BAL   NCP,PATASSGN       ASSIGN WITH OUTPUT ASSOC CHECK        10166000
         B     SUCC               AND SUCCEED                           10167000
*                                                                       10168000
*        EXPRESSION ARGUMENT -- "OR" CASE                               10169000
*                                                                       10170000
         USING *,RETURN           PATTERN BASE REG                      10171000
PO$@D    BAL   NCP,DEFEXPN        EVAL EXPR TO GET NAME, MERGE *+14     10172000
*                                                                       10173000
*        NORMAL ARGUMENT -- "OR" CASE                                   10174000
*                                                                       10175000
         DC    Y(0)               SPACE FOR PROPER MERGE FROM DEFEXPN   10176000
         USING *,RETURN           PATTERN BASE REG                      10177000
PO$@     L     BPS,PARAM1(PB,PO)  LOAD NAME BASE                        10178000
         A     BPS,PARAM2(PB,PO)  ADD NAME OFFSET                       10179000
*                                                                       10180000
*        DEFERRED CASE MERGES HERE                                      10181000
*                                                                       10182000
         LH    R2,PSTGLEN(,PDR)   LOAD SUBJECT STRING LENGTH            10183000
         SR    R2,CP              MINUS NUMBER OF CHARACTERS LEFT       10184000
         SR    R1,R1              INDICATE INTEGER RESULT               10185000
         BAL   NCP,PATASSGN       ASSIGN WITH OUTPUT ASSOC CHECK        10186000
         B     SUCCSN             AND SUCCEED WITH NO CURSOR MOVEMENT   10187000
         EJECT                                                          10188000
*                                                                       10189000
*        ENTRY POINTS FOR ANY (NORMAL CASES -- NOT DEFERRED)            10190000
*                                                                       10191000
*        PARAM1                   POINTER TO TBLOK CONTAINING BIT TABLE 10192000
*        PARAM2                   TM    CTCHARS(R2),BITMASK             10193000
*        EXTEND                   NONE                                  10194000
*                                                                       10195000
*        ONE 256-CHARACTER TBLOK IS USED FOR 8 ANY OR NOTANY PATTERNS   10196000
*        THE MASK IN THE TM INSTRUCTION HAS THE SELECTED BIT ON         10197000
*        THE TBLOK BYTES HAVE THE PROPER BIT ON FOR SELECTED CHARS      10198000
*                                                                       10199000
*                                                                       10200000
*        CASE OF "NOOR" POINTER                                         10201000
*                                                                       10202000
         DC    Y(PO$ANY-*)        OFFSET TO CODE FOR "OR" CASE          10203000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10204000
PN$ANY   LCR   R1,CP              MINUS NUMBER OF CHARS LEFT            10205000
         BZ    LBACKUP            LENGTH FAIL IF NO CHARS LEFT          10206000
         SR    R2,R2              CLEAR FOR FOLLOWING IC                10207000
         IC    R2,0(R1,FSADR)     PICK UP CHARACTER TO BE TESTED        10208000
         A     R2,PARAM1(PB,PO)   ADD TABLE ADDRESS                     10209000
         EX    0,PARAM2(PB,PO)    EXECUTE THE TM INSTRUCTION            10210000
         BNO   BACKUP             FAIL IF BIT NOT ON                    10211000
         BCT   CP,SUCC            STEP CURSOR AND SUCCEED               10212000
         B     SUCC               SUCCEED EVEN IF BCT FALLS THROUGH     10213000
*                                                                       10214000
*        CASE OF "OR" POINTER PRESENT                                   10215000
*                                                                       10216000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10217000
PO$ANY   LCR   R1,CP              MINUS NUMBER OF CHARACTERS LEFT       10218000
         BZ    LFAIL              LENGTH FAIL IF NO CHARS LEFT          10219000
         SR    R2,R2              CLEAR FOR FOLLOWING IC                10220000
         IC    R2,0(R1,FSADR)     LOAD CHARACTER TO BE TESTED           10221000
         A     R2,PARAM1(PB,PO)   ADD TABLE ADDRESS                     10222000
         EX    0,PARAM2(PB,PO)    EXECUTE THE TM INSTRUCTION            10223000
         BNO   FAIL               TAKE ALTERNATIVE IF BIT IS NOT ON     10224000
         LR    NCP,CP             COPY OLD LOCATION                     10225000
         BCT   NCP,SUCCS          UPDATE POINTER AND SUCCEED            10226000
         B     SUCCS              SUCCEED EVEN IF BCT FALLS THROUGH     10227000
         EJECT                                                          10228000
*                                                                       10229000
*        ANY ENTRY POINTS -- CONTINUED                                  10230000
*                                                                       10231000
*        DEFERRED ARGUMENT CASE                                         10232000
*                                                                       10233000
*        PARAM1                   NOT USED                              10234000
*        PARAM2                   EXPRESSION POINTER                    10235000
*        EXTEND                   NONE                                  10236000
*                                                                       10237000
*                                                                       10238000
*                                                                       10239000
*        CASE OF "NOOR" POINTER                                         10240000
*                                                                       10241000
         DC    Y(PO$ANYD-*)       OFFSET TO CODE FOR "OR" CASE          10242000
         USING *,RETURN           PATTER BASE REG                       10243000
PN$ANYD  LTR   CP,CP              TEST FOR NO MORE CHARS LEFT           10244000
         BZ    LBACKUP            LENGTH FAIL IF SO                     10245000
         BAL   NCP,DEFEXPS        GET A STRING                          10246000
         XERN  01,006             EVALUTED RESULT OF DEFERRED ARGUMENT  10247000
*                                 TO ANY IS NOT A STRING                10248000
         XERN  13,006             EVALUTED RESULT OF DEFERRED ARGUMENT  10249000
*                                 TO ANY IS NULL                        10250000
         BZ    BACKUP             FAIL IF NO MATCH FOUND                10251000
         BCT   CP,SUCC            ELSE CRANK CURSOR AND SUCCEED         10252000
         B     SUCC               BRANCH EVEN IF BCT FALLS THROUGH      10253000
*                                                                       10254000
*        CASE OF "OR" POINTER PRESENT                                   10255000
*                                                                       10256000
PO$ANYD  LTR   CP,CP              TEST FOR NO MORE CHARS LEFT           10257000
         BZ    LFAIL              LENGTH FAIL IF NO MORE LEFT           10258000
         BAL   NCP,DEFEXPS        ELSE GET A STRING                     10259000
         XERR  01,006             EVALUATED RESULT OF DEFERRED ARGUMENT 10260000
*                                 TO ANY IS NOT A STRING                10261000
         XERR  13,006             EVALUATED RESULT OF DEFERRED ARGUMENT 10262000
*                                 TO ANY IS NULL                        10263000
         BZ    FAIL               FAIL IF NO MATCH                      10264000
         LR    NCP,CP             ELSE MOVE CURSOR                      10265000
         BCT   NCP,SUCCS          SUCCEED CRANKING POINTER              10266000
         B     SUCCS              SUCCEED EVEN IF BCT FALLS THROUGH     10267000
         EJECT                                                          10268000
*                                                                       10269000
*        ENTRY POINTS FOR NOTANY (NORMAL CASES -- NOT DEFFERED)         10270000
*                                                                       10271000
*        PARAM1                   POINTER TO TBLOK CONTAINING BIT TABLE 10272000
*        PARAM2                   TM   CTCHARS(R2),BITMASK              10273000
*        EXTEND                   NONE                                  10274000
*                                                                       10275000
*        ONE 256 CHARACTER TBLOK IS USED FOR UP TO 8 ANY AND NOTANY     10276000
*        PATTERNS. THE MASK IN THE TM INSTRUCTION HAS THE SELECTED BIT  10277000
*        ON. THE TBLOK BYTES HAVE THIS BIT ON FOR SELECTED CHARACTERS.  10278000
*                                                                       10279000
*                                                                       10280000
*        CASE OF "NOOR" POINTER                                         10281000
*                                                                       10282000
         DC    Y(PO$NANY-*)       OFFSET TO CODE FOR "OR" CASE          10283000
         USING *,RETURN           PATTERN BASE REG                      10284000
PN$NANY  LCR   R1,CP              MINUS NUMBER OF CHARS LEFT            10285000
         BZ    LBACKUP            LENGTH FAIL IF NO CHARS LEFT          10286000
         SR    R2,R2              ELSE CLEAR FOR FOLLOWING IC           10287000
         IC    R2,0(R1,FSADR)     PICK UP CHARACTER TO BE TESTED        10288000
         A     R2,PARAM1(PB,PO)   ADD TABLE ADDRESS                     10289000
         EX    0,PARAM2(PB,PO)    EXECUTE TM INSTRUCTION                10290000
         BO    BACKUP             FAIL IF BIT IS ON                     10291000
         BCT   CP,SUCC            ELSE STEP CURSOR AND SUCCEED          10292000
         B     SUCC               SUCCEED EVEN IF BCT FALLS THROUGH     10293000
*                                                                       10294000
*        CASE OF "OR" POINTER PRESENT                                   10295000
*                                                                       10296000
         USING *,RETURN           PATTERN ROUTINE BASE REGISTER         10297000
PO$NANY  LCR   R1,CP              MINUS NUMBER OF CHARACTERS LEFT       10298000
         BZ    LFAIL              LENGTH FAIL IF NO CHARS LEFT          10299000
         SR    R2,R2              ELSE CLEAR FOR FOLLOWING IC           10300000
         IC    R2,0(R1,FSADR)     LOAD CHARACTER TO BE TESTED           10301000
         A     R2,PARAM1(PB,PO)   ADD TABLE ADDRESS                     10302000
         EX    0,PARAM2(PB,PO)    EXECUTE THE TM INSTRUCTION            10303000
         BO    FAIL               FAIL IF BIT IS ON                     10304000
         LR    NCP,CP             ELSE COPY OLD LOCATION                10305000
         BCT   NCP,SUCCS          SET NEW CURSOR POSITION AND SUCCEED   10306000
         B     SUCCS              SUCCEED EVEN IF BCT FALLS THROUGH     10307000
         EJECT                                                          10308000
*                                                                       10309000
*        NOTANY ENTRY POINTS -- CONTINUED                               10310000
*                                                                       10311000
*        DEFERRED ARGUMENT CASE                                         10312000
*                                                                       10313000
*        PARAM1                   NOT USED                              10314000
*        PARAM2                   EXPRESSION POINTER                    10315000
*        EXTEND                   NONE                                  10316000
*                                                                       10317000
*                                                                       10318000
*        CASE OF "NOOR" POINTER                                         10319000
*                                                                       10320000
         DC    Y(PO$NANYD-*)      OFFSET TO CODE FOR "OR" CASE          10321000
         USING *,RETURN           PATTERN BASE                          10322000
PN$NANYD LTR   CP,CP              TEST FOR NO MORE CHARS LEFT           10323000
         BZ    LBACKUP            LENGTH FAIL IF NO MORE                10324000
         BAL   NCP,DEFEXPS        ELSE GET A STRING                     10325000
         XERN  01,007             EVALUTED RESULT OF DEFERRED ARGUMENT  10326000
*                                 TO NOTANY IS NOT A STRING             10327000
         XERN  13,007             EVALUTED RESULT OF DEFERRED ARGUMENT  10328000
*                                 TO NOTANY IS NULL                     10329000
         BNZ   BACKUP             FAIL ON MATCH                         10330000
         BCT   CP,SUCC            ELSE SUCCEED BUMPING CURSOR           10331000
         B     SUCC               BRANCH EVEN IF BCT FALLS THROUGH      10332000
*                                                                       10333000
*        CASE OF "OR" POINTER PRESENT                                   10334000
*                                                                       10335000
PO$NANYD LTR   CP,CP              TEST FOR NO MORE CHARS                10336000
         BZ    LFAIL              LENGTH FAIL IF NO MORE CHARS          10337000
         BAL   NCP,DEFEXPS        ELSE GET STRING                       10338000
         XERR  01,007             EVALUATED RESULT OF DEFERRED ARGUMENT 10339000
*                                 TO NOTANY IS NOT A STRING             10340000
         XERR  13,007             EVALUATED RESULT OF DEFERRED ARGUMENT 10341000
*                                 TO NOTANY IS NULL                     10342000
         BNZ   FAIL               FAIL ON MATCH                         10343000
         LR    NCP,CP             MOVE CURSOR TO "NEW" REG              10344000
         BCT   NCP,SUCCS          SUCCEED BUMPING CURSOR                10345000
         B     SUCCS              BRANCH EVEN IF BCT FALLS THROUGH      10346000
         EJECT                                                          10347000
*                                                                       10348000
*        ENTRY POINTS FOR SPAN (NORMAL CASE -- NOT DEFERRED)            10349000
*                                                                       10350000
*        PARAM1                   TBLOK ADDRESS                         10351000
*        EXTEND                   NONE                                  10352000
*                                                                       10353000
*                                                                       10354000
*        CASE OF "NOOR" POINTER                                         10355000
*                                                                       10356000
         DC    Y(PO$SPAN-*)       OFFSET TO CODE FOR "OR" CASE          10357000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10358000
PN$SPAN  L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS                    10359000
         LTR   R1,CP              COPY AND TEST NUMBER OF CHARS LEFT    10360000
         BZ    LBACKUP            LENGTH FAILURE IF NO CHARS LEFT       10361000
         BCTR  R1,0               ADJUST COUNT OF CHARS LEFT FOR 360    10362000
         LR    NCP,FSADR          END OF STRING ADDRESS                 10363000
         SR    NCP,CP             MINUS NUM CHARS LEFT = CURRENT LOC    10364000
         LA    R0,256             CONSTANT 256 LOADED                   10365000
         CR    R1,R0              DO WE HAVE A SHORT STRING LEFT?       10366000
         BL    PN$SPN2            SKIP IF YES                           10367000
PN$SPN3  TRT   0(256,NCP),CTCHARS(R2)       CHECK 256 CHARACTERS        10368000
         BC    7,PN$SPN4          SKIP IF WE HIT AN UNMATCHED CHAR      10369000
         AR    NCP,R0             PUSH POINTER                          10370000
         SR    R1,R0              DECREASE SIZE LEFT                    10371000
         CR    R1,R0              IS STRING LEFT SHORT YET?             10372000
         BNL   PN$SPN3            BACK IN LOOP IF NOT                   10373000
PN$SPN2  EX    R1,SPANTRT         CHECK LAST CHARACTERS                 10374000
         BC    7,PN$SPN4          SKIP IF UNMATCHED CHARACTER           10375000
         SR    CP,CP              ELSE POINT TO END OF STRING           10376000
         B     SUCC               AND SUCCEED                           10377000
PN$SPN4  SR    R1,FSADR           STOP CHR - END STG = -NUM CHARS LEFT  10378000
         LCR   NCP,R1             GET PROPER UPDATED POINTER            10379000
         CR    NCP,CP             WERE ANY CHARACTERS MATCHED?          10380000
         LR    CP,NCP             LOAD UPDATED CURSOR LOCATION          10381000
         BL    SUCC               AND SUCCEED IF CHARS WERE MATCHED     10382000
         B     BACKUP             ELSE FAIL IF NO CHARS MATCHED         10383000
         EJECT                                                          10384000
*                                                                       10385000
*        SPAN ENTRY POINTS -- CONTINUED                                 10386000
*                                                                       10387000
*        DEFERRED CASE (PO$SPAND AND PN$SPAND MERGE TO SAVE SPACE)      10388000
*                                                                       10389000
*        PARAM1                   NOT USED                              10390000
*        PARAM2                   EXPRESSION POINTER                    10391000
*        EXTEND                   NONE                                  10392000
*                                                                       10393000
         DC    Y(PO$SPAND-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE  10394000
         USING *,RETURN           PATTERN ROUTINE BASE                  10395000
PN$SPAND EQU   *                  ENTRY POINT FOR "NOOR" CASE           10396000
PO$SPAND LTR   CP,CP              TEST FOR NO MORE CHARS                10397000
         BZ    LFAIL              LENGTH FAIL IF NO MORE CHARS          10398000
         BAL   NCP,DEFEXPS        GET A STRING                          10399000
         USING *,NCP              BASE REGISTER SET BY DEFEXPS          10400000
         XERR  01,008             EVALUATED RESULT OF DEFERRED ARGUMENT 10401000
*                                 TO SPAN IS NOT A STRING               10402000
         XERR  13,008             EVALUATED RESULT OF DEFERRED ARGUMENT 10403000
*                                 TO SPAN IS NULL                       10404000
         BZ    FAIL               FAILURE IF NO MATCH ON FIRST CHAR     10405000
         CH    R2,H1              IS ARGUMENT ONLY ONE CHARACTER?       10406000
         BE    PO$SPND1           SKIP TO USE IN CORE TBL IF 1 CHAR     10407000
         SR    R0,R0              INITIALIZE A REGISTER TO              10408000
         BCTR  R0,0               ALL ONE BITS FOR TABLE                10409000
         LR    R1,R0              COPY FOR TWO WORD STORE               10410000
         STM   R0,R1,8(PDR)       MAKE FIRST DBLWRD OF TABLE            10411000
         MVC   16(248,PDR),8(PDR) FINISH FILLING TABLE                  10412000
         SR    BPS,BPS            GET A ZERO CONSTANT                   10413000
         SR    R1,R1              CLEAR FOR USE IN LOOP                 10414000
*                                                                       10415000
*        LOOP TO PLUG SELECTED CHARS ZERO                               10416000
*                                                                       10417000
PO$SPNDL IC    R1,SCHARS(,RETURN) LOAD CHARACTER                        10418000
         STC   BPS,8(PDR,R1)      PLUG TO ZERO = NON-STOP CHARACTER     10419000
         LA    RETURN,1(,RETURN)  POINT TO NEXT CHAR                    10420000
         BCT   R2,PO$SPNDL        LOOP BACK IF MORE CHARS TO GO         10421000
*                                                                       10422000
*        PREPARE AND MERGE TO STANDARD ROUTINE                          10423000
*                                                                       10424000
         LA    BPS,12             RESTORE BPS                           10425000
         LA    R2,8-CTCHARS(,PDR) POINT TO TABLE FOR MERGE              10426000
         LA    RETURN,PO$SPAN     POINT BASE REG FOR STANDARD ROUTINE   10427000
         B     PO$SPNM-PO$SPAN(,RETURN)     JUMP TO MERGE POINT         10428000
*                                                                       10429000
*        COME HERE IF RETURNED ARGUMENT IS ONE CHARACTER LONG           10430000
*                                                                       10431000
PO$SPND1 L     R2,=A(SPANTBL)     LOAD ADDRESS OF SPITBOL TBL OF 1 CHAR 10432000
         SR    R1,R1              CLEAR FOR IC OF ARGUMENT CHARACTER    10433000
         IC    R1,SCHARS(,RETURN) LOAD ARGUMENT CHARACTER               10434000
         SR    R2,R1              GET TABLE ADDRESS FOR THIS CHARACTER  10435000
         LA    RETURN,PO$SPAN     SET UP BASE REGISTER FOR STANDARD SPN 10436000
         B     PO$SPNM-PO$SPAN(,RETURN)     AND JUMP TO MERGE POINT     10437000
         DROP  NCP,RETURN         DROP UNNECESSARY BASE REGISTERS       10438000
         EJECT                                                          10439000
*                                                                       10440000
*        ENTRY POINTS FOR SPAN (CONTINUED)                              10441000
*                                                                       10442000
*                                                                       10443000
*        CASE OF "OR" POINTER PRESENT                                   10444000
*                                                                       10445000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10446000
PO$SPAN  L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS                    10447000
*                                                                       10448000
*        DEFERRED CASE PO$SPAND MERGES HERE                             10449000
*                                                                       10450000
PO$SPNM  LTR   R1,CP              COPY AND TEST NUMBER OF CHARS LEFT    10451000
         BZ    LFAIL              LENGTH FAIL IF NO CHARS LEFT          10452000
         BCTR  R1,0               ELSE SUBTRACT ONE TO GET 360 LENGTH   10453000
         LR    NCP,FSADR          END OF STRING ADDRESS                 10454000
         SR    NCP,CP             MINUS NUM CHARS LEFT = CURRENT LOC    10455000
         LA    R0,256             CONSTANT 256                          10456000
         CR    R1,R0              DO WE HAVE A SHORT STRING LEFT?       10457000
         BL    PO$SPN2            SKIP IF SHORT                         10458000
PO$SPN3  TRT   0(256,NCP),CTCHARS(R2)       CHECK 256 CHARACTERS        10459000
         BC    7,PO$SPN4          SKIP IF UNMATCHED CHARACTER           10460000
         AR    NCP,R0             ELSE CRANK CHARACTER POINTER 256      10461000
         SR    R1,R0              SUBTRACT 256 FROM LENGTH              10462000
         CR    R1,R0              IS STRING LEFT SHORT YET?             10463000
         BNL   PO$SPN3            STAY IN LOOP IF NOT                   10464000
PO$SPN2  EX    R1,SPANTRT         CHECK LAST CHARACTERS                 10465000
         BC    7,PO$SPN4          SKIP IF CHARACTER UNMATCHED           10466000
         SR    NCP,NCP            ELSE POINT TO END OF STG              10467000
         B     SUCCS              AND SUCCEED WITH A STACK              10468000
PO$SPN4  SR    R1,FSADR           STOP CHR-END STG = -NUM CHARS LEFT    10469000
         LCR   NCP,R1             GET UPDATED CURSOR LOCATION           10470000
         CR    NCP,CP             WERE ANY CHARS MATCHED                10471000
         BL    SUCCS              SUCCEED WITH STACK IF CHARS MATCHED   10472000
         B     FAIL               ELSE FAIL IF NO CHARS MATCHED         10473000
*                                                                       10474000
SPANTRT  TRT   0(*-*,NCP),CTCHARS(R2)       TRT FOR LAST CHARACTERS     10475000
         EJECT                                                          10476000
*                                                                       10477000
*        BREAKX ENTRY POINTS                                            10478000
*                                                                       10479000
*        CASE OF DEFERRED ARGUMENT                                      10480000
*                                                                       10481000
*        PARAM1                   NOT USED                              10482000
*        PARAM2                   EXPRESSION POINTER                    10483000
*        EXTEND                   BRKXDEXT                              10484000
*                                                                       10485000
*                                                                       10486000
         DC    Y(PO$BRKXD-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE  10487000
         USING *,RETURN           PATTERN BASE REG                      10488000
PN$BRKXD EQU   *                  ENTRY POINT FOR "NOOR" CASE           10489000
PO$BRKXD ST    CP,S1OLDCP(,PS1)   SAVE CURRENT CURSOR ON STACK          10490000
         LR    NCP,CP             SET FOR MERGE WITH EXTENSION ROUTINE  10491000
*                                                                       10492000
*        REENTER HERE WHEN EXTENDING                                    10493000
*                                                                       10494000
PO$BKXD1 LTR   CP,NCP             COPY CURSOR AND TEST FOR END          10495000
         BZ    LFAIL              LENGTH FAIL IF SO                     10496000
         BAL   NCP,DEFEXPS        GET A STRING                          10497000
         USING *,RETURN           RETURN WILL HAVE PROPER VALUE         10498000
         XERR  01,009             EVALUATED RESULT OF DEFERRED ARGUMENT 10499000
*                                 TO BREAKX IS NOT A STRING             10500000
         XERR  13,009             EVALUATED RESULT OF DEFERRED ARGUMENT 10501000
*                                 TO BREAKX IS NULL                     10502000
         LR    R0,R2              COPY LENGTH OF RETURNED STRING        10503000
         LR    R2,RETURN          SAVE STRING STARTING ADDRESS          10504000
         LR    RETURN,NCP         SET UP PROMISED BASE REGISTER         10505000
         LR    NCP,CP             GET 'NEW' CURSOR                      10506000
         L     CP,S1OLDCP(,PS1)   RESTORE OLD CURSOR                    10507000
         BNZ   MATCHBKX           IMMEDIATE SUCCESS IF BREAK CHAR FND   10508000
         SR    R1,R1              CLEAR FOR IC USAGE                    10509000
         CH    R0,H1              CHECK FOR ONE CHAR BREAK              10510000
         BE    PO$BKXD2           OFF TO SPECIAL CODE IF ONE CHAR CASE  10511000
         STD   ZR,8(,PDR)         STORE FIRST TABLE WORD                10512000
         MVC   16(248,PDR),8(PDR) FINISH FILLING TABLE                  10513000
         EJECT                                                          10514000
*                                                                       10515000
*        BREAKX ENTRY POINTS (CONTINUED)                                10516000
*                                                                       10517000
*        LOOP TO PLUG SELECTED CHARACTERS (DEFFERED CASE)               10518000
*                                                                       10519000
PO$BKXDL IC    R1,SCHARS(,R2)     PICK UP NEXT CHARACTER                10520000
         STC   BPS,8(PDR,R1)      PLUG TO NON-ZERO = STOP CHARACTER     10521000
         LA    R2,1(,R2)          BUMP CHARACTER POINTER                10522000
         BCT   R0,PO$BKXDL        LOOP BACK IF MORE CHARS TO GO         10523000
*                                                                       10524000
*        NOW MERGE INTO STANDARD ROUTINE                                10525000
*                                                                       10526000
         LA    RETURN,PO$BRKX     POINT BASE REG FOR STANDARD ROUTINE   10527000
         LA    R2,8-CTCHARS(,PDR) POINT TO TABLE FOR MERGE              10528000
         B     PO$BRKXM-PO$BRKX(,RETURN)    MERGE WITH STD ROUTINE      10529000
*                                                                       10530000
*        COME HERE TO USE SPITBOL TABLE FOR ONE CHARACTER BREAK         10531000
*                                                                       10532000
PO$BKXD2 IC    R1,SCHARS(,R2)     LOAD ARGUMENT CHARACTER               10533000
         L     R2,PSAVDB1(,PDR)   LOAD POINTER TO DATA AREA             10534000
         LA    R2,BREAKTBL-SPITBOLD(,R2)    POINT TO MASTER BREAK TABLE 10535000
         SR    R2,R1              GET BREAK TABLE ADDRESS FOR THIS CASE 10536000
         LA    RETURN,PO$BRKX     SET UP BASE REGISTER FOR MERGE        10537000
         B     PO$BRKXM-PO$BRKX(,RETURN)    MERGE WITH STD ROUTINE      10538000
         EJECT                                                          10539000
*                                                                       10540000
*        BREAKX ENTRY POINTS -- CONTINUED                               10541000
*                                                                       10542000
*        NORMAL CASE -- NOT DEFFERRED                                   10543000
*                                                                       10544000
*        PARAM1                   TBLOK POINTER                         10545000
*        EXTEND                   BRKXEXT                               10546000
*                                                                       10547000
*                                                                       10548000
         DC    Y(PO$BRKX-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE  10549000
         USING *,RETURN           PATTERN BASE REG                      10550000
PN$BRKX  EQU   *                  ENTRY POINT FOR "NOOR" CASE           10551000
PO$BRKX  LR    NCP,CP             INITIALIZE CURSOR                     10552000
*                                                                       10553000
*        REENTER HERE WHEN EXTENDING                                    10554000
*                                                                       10555000
PO$BRKX1 L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS                    10556000
*                                                                       10557000
*        MERGE HERE FROM DEFERRED CASE                                  10558000
*                                                                       10559000
PO$BRKXM LTR   R1,NCP             TEST NUMBER OF CHARS LEFT             10560000
         BZ    LFAIL              LENGTH FAIL IF NONE LEFT              10561000
         BCTR  R1,0               ADJUST FOR 360                        10562000
         LCR   NCP,NCP            MINUS NUM CHARS LEFT                  10563000
         AR    NCP,FSADR          POINT TO CURRENT NEXT CHAR            10564000
         LA    R0,256             CRANK FOR LOOP                        10565000
         CR    R1,R0              CHECK FOR 256 CHARS OR LESS           10566000
         BL    PO$BRKX2           SKIP IF SO                            10567000
*                                                                       10568000
*        LOOP TO TEST 256 CHARS AT A TIME                               10569000
*                                                                       10570000
PO$BRKX3 TRT   0(256,NCP),CTCHARS(R2)       TEST 256 CHARS              10571000
         BNZ   PO$BRKX4           SKIP IF BREAK CHAR FOUND              10572000
         AR    NCP,R0             ELSE PUSH STRING POINTER              10573000
         SR    R1,R0              DECREMENT COUNT                       10574000
         CR    R1,R0              HOW MANY CHARS LEFT?                  10575000
         BNL   PO$BRKX3           LOOP BACK IF STILL MORE THAN 256      10576000
*                                                                       10577000
*        COME HERE TO TEST LAST CHARACTERS                              10578000
*                                                                       10579000
PO$BRKX2 EX    R1,BREAKTRT        TEST LAST CHARS                       10580000
         BZ    LFAIL              LENGTH FAIL IF NOTHING FOUND          10581000
*                                                                       10582000
*        COME HERE WHEN BREAK CHAR IS FOUND                             10583000
*                                                                       10584000
PO$BRKX4 LCR   NCP,R1             MINUS LOC OF BREAK CHAR               10585000
         AR    NCP,FSADR          SET NCP PROPERLY                      10586000
         B     MATCHBKX           FINISH MATCH IN PROPER MODE           10587000
         EJECT                                                          10588000
*                                                                       10589000
*        ENTRY POINTS FOR BREAK (NORMAL CASE -- NOT DEFERRED)           10590000
*                                                                       10591000
*        PARAM1                   POINTER TO TBLOK                      10592000
*        EXTEND                   NONE                                  10593000
*                                                                       10594000
*                                                                       10595000
*        CASE OF "NOOR" POINTER                                         10596000
*                                                                       10597000
         DC    Y(PO$BREAK-*)      OFFSET TO CODE FOR "OR" CASE          10598000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10599000
PN$BREAK L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS                    10600000
         LTR   R1,CP              COPY AND TEST NUMBER OF CHARS LEFT    10601000
         BZ    LBACKUP            FAIL IF NO CHARS LEFT                 10602000
         BCTR  R1,0               ELSE MINUS ONE FOR 360 LENGTH         10603000
         LR    NCP,FSADR          ADDRESS OF END OF STRING              10604000
         SR    NCP,CP             MINUS CHARS LEFT = CURRENT ADDRESS    10605000
         LA    R0,256             GET CONSTANT 256                      10606000
         CR    R1,R0              IS IT A SHORT STRING LEFT             10607000
         BL    PN$BRK2            IF SO, SKIP                           10608000
PN$BRK3  TRT   0(256,NCP),CTCHARS(R2)       CHECK 256 CHARACTERS        10609000
         BC    7,PN$BRK4          BRANCH IF A BREAK CHARACTER FOUND     10610000
         AR    NCP,R0             ELSE CRANK CHARACTER LOCATION         10611000
         SR    R1,R0              CRANK DOWN COUNT OF CHARS LEFT        10612000
         CR    R1,R0              IS IT SMALL YET                       10613000
         BNL   PN$BRK3            SKIP BACK IN LOOP IF NOT              10614000
PN$BRK2  EX    R1,BREAKTRT        TEST REMAINING CHARACTERS             10615000
         BC    8,LBACKUP          LENGTH FAIL IF NO BREQK CHAR FOUND    10616000
PN$BRK4  LCR   CP,R1              MINUS LOCATION OF STOP CHARACTER      10617000
         AR    CP,FSADR           PLUS STG END ADDR = NUM CHARS LEFT    10618000
         B     SUCC               SUCCEED                               10619000
         EJECT                                                          10620000
*                                                                       10621000
*        BREAK ENTRY POINTS -- CONTINUED                                10622000
*                                                                       10623000
*        DEFERRED CASE (PO$BRKD AND PN$BRKD MERGE TO SAVE SPACE)        10624000
*                                                                       10625000
*        PARAM1                   NOT USED                              10626000
*        PARAM2                   EXPRESSION POINTER                    10627000
*        EXTEND                   NONE                                  10628000
*                                                                       10629000
         DC    Y(PO$BRKD-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE  10630000
         USING *,RETURN           PATTERN ROUTINE BASE                  10631000
PN$BRKD  EQU   *                  ENTRY POINT FOR "NOOR" CASE           10632000
PO$BRKD  LTR   CP,CP              TEST FOR NO MORE CHARS LEFT           10633000
         BZ    LFAIL              LENGTH FAIL IF SO                     10634000
         BAL   NCP,DEFEXPS        GET A STRING                          10635000
         USING *,NCP              BASE REGISTER SET BY DEFEXPS          10636000
         XERR  01,010             EVALUATED RESULT OF DEFERRED ARGUMENT 10637000
*                                 TO BREAK IS NOT A STRING              10638000
         XERR  13,010             EVALUATED RESULT OF DEFERRED ARGUMENT 10639000
*                                 TO BREAK IS NULL                      10640000
         BNZ   SUCCSN             JUST SUCCEED IF BRK CHAR FOUND        10641000
         SR    R1,R1              CLEAR FOR IC USAGE                    10642000
         CH    R2,H1              CHECK FOR ONE CHARACTER CASE          10643000
         BE    PO$BRKD1           OFF TO SPECIAL CODE IF ONE CHARACTER  10644000
         STD   ZR,8(,PDR)         INITIALIZE FIRST TABLE WORD           10645000
         MVC   16(248,PDR),8(PDR) FINISH CLEARING TABLE                 10646000
*                                                                       10647000
*        LOOP TO PLUG SELECTED CHARS NON-ZERO                           10648000
*                                                                       10649000
PO$BRKDL IC    R1,SCHARS(,RETURN) PICK UP NEXT CHARACTER                10650000
         STC   BPS,8(PDR,R1)      PLU TO NON-ZERO = STOP CHARACTER      10651000
         LA    RETURN,1(,RETURN)  POINT TO NEXT CHAR                    10652000
         BCT   R2,PO$BRKDL        LOOP BACK TILL CHARS EXHAUSTED        10653000
*                                                                       10654000
*        NOW PREPARE TO MERGE WITH NORMAL ROUTINE                       10655000
*                                                                       10656000
         LA    R2,8-CTCHARS(,PDR) POINT TO TABLE FOR MERGE              10657000
         LA    RETURN,PO$BREAK    SET BASE REG FOR STANDARD ROUTINE     10658000
         B     PO$BRKM            MERGE WITH STANDARD ROUTINE           10659000
*                                                                       10660000
*        COME HERE TO USE SPITBOL TABLE FOR ONE CHARACTER BREAK         10661000
*                                                                       10662000
PO$BRKD1 IC    R1,SCHARS(,RETURN) LOAD ARGUMENT CHARACTER               10663000
         L     R2,PSAVDB1(,PDR)   LOAD POINTER TO DATA AREA             10664000
         LA    R2,BREAKTBL-SPITBOLD(,R2)    POINT TO MASTER BREAK TABLE 10665000
         SR    R2,R1              CALCULATE TABLE ADDRSS                10666000
         LA    RETURN,PO$BREAK    SET BASE REG FOR STANDARD ROUTINE     10667000
         B     PO$BRKM            MERGE WITH STANDARD ROUTINE           10668000
         DROP  RETURN,NCP         DROP BASE REGISTERS                   10669000
         EJECT                                                          10670000
*                                                                       10671000
*        ENTRY POINTS FOR BREAK (CONTINUED)                             10672000
*                                                                       10673000
*                                                                       10674000
*                                                                       10675000
*        CASE OF "OR" POINTER PRESENT                                   10676000
*                                                                       10677000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10678000
PO$BREAK L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS                    10679000
*                                                                       10680000
*        DEFERRED CASE PO$BRKD MERGES HERE                              10681000
*                                                                       10682000
PO$BRKM  LTR   R1,CP              COPY AND TEST NUMBER OF CHARS LEFT    10683000
         BZ    LFAIL              LENGTH FAIL IF NO CHARS LEFT          10684000
         BCTR  R1,0               ELSE MINUS ONE FOR 360 LENGTH         10685000
         LR    NCP,FSADR          ADDRESS OF END OF STRING              10686000
         SR    NCP,CP             MINUS CHARS LEFT = CURRENT ADDRESS    10687000
         LA    R0,256             CONSTANT 256                          10688000
         CR    R1,R0              DO WE HAVE A SHORT STRING LEFT?       10689000
         BL    PO$BRK2            SKIP IF SHORT                         10690000
PO$BRK3  TRT   0(256,NCP),CTCHARS(R2)       CHECK 256 CHARS             10691000
         BC    7,PO$BRK4          SKIP IF BREAK CHARACTER FOUND         10692000
         AR    NCP,R0             ELSE BUMP CHARACTER POINTER BY 256    10693000
         SR    R1,R0              COUNT LENGTH LEFT DOWN 256 CHARS      10694000
         CR    R1,R0              IS STRING LEFT SHORT YET?             10695000
         BNL   PO$BRK3            LOOP BACK IF NOT                      10696000
PO$BRK2  EX    R1,BREAKTRT        TEST LAST CHARACTERS                  10697000
         BC    8,LFAIL            LENGTH FAIL IF NO BREAK CHAR FOUND    10698000
PO$BRK4  LCR   NCP,R1             MINUS ADDRESS OF STOP CHARACTER       10699000
         AR    NCP,FSADR          ADD END OF STG ADDR TO GET NUM CHARS  10700000
         B     SUCCS              AND SUCCEED                           10701000
*                                                                       10702000
BREAKTRT TRT   0(*-*,NCP),CTCHARS(R2)       CHECK FINAL CHARACTERS      10703000
         EJECT                                                          10704000
*                                                                       10705000
*        FAIL ENTRY POINTS                                              10706000
*                                                                       10707000
*        EXTEND                   NONE                                  10708000
*                                                                       10709000
*                                                                       10710000
*        NOTE -- STRICTLY, WE COULD INDICATE LENGTH FAILURE FOR FAIL    10711000
*        SINCE EXTENSION IS CLEARLY USELESS                             10712000
*        HOWEVER, WHEN FAIL IS USED, HE MUST BE INTERESTED IN HOW THE   10713000
*        PATTERN IS BEING MATCHED, SO WE GIVE AN ORDINARY FAIL          10714000
*                                                                       10715000
*                                                                       10716000
*        CASE OF "NOOR" POINTER                                         10717000
*                                                                       10718000
         DC    Y(PO$FAIL-*)       OFFSET TO CODE FOR "OR" CASE          10719000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10720000
PN$FAIL  B     BACKUP             AUTOMATIC FAILURE                     10721000
*                                                                       10722000
*        CASE OF "OR" POINTER PRESENT                                   10723000
*                                                                       10724000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10725000
PO$FAIL  B     FAIL               AUTOMATICALLY TAKE ALTERNATIVE        10726000
         EJECT                                                          10727000
*                                                                       10728000
*        ENTRY POINTS FOR NULL PATTERN                                  10729000
*                                                                       10730000
*        EXTEND                   NONE                                  10731000
*                                                                       10732000
*        CASE OF "NOOR" POINTER                                         10733000
*                                                                       10734000
         DC    Y(PO$NULL-*)       OFFSET TO CODE FOR "OR" CASE          10735000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10736000
PN$NULL  B     SUCC               JUST SUCCEED                          10737000
*                                                                       10738000
*        CASE OF "OR" PATTERN PRESENT                                   10739000
*                                                                       10740000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10741000
PO$NULL  B     SUCCSN             SUCCEED WITH NO CP MOVEMENT           10742000
         EJECT                                                          10743000
*                                                                       10744000
*        ENTRY POINTS FOR ABORT                                         10745000
*                                                                       10746000
*        EXTEND                   NONE                                  10747000
*                                                                       10748000
*        "OR" AND "NOOR" CASES MERGE FOR ABORT                          10749000
*                                                                       10750000
         DC    Y(PO$ABORT-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE  10751000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10752000
PN$ABORT EQU   *                  ENTRY FOR "NOOR" CASE                 10753000
PO$ABORT B     PABORT             AUTOMATIC PATTERN ABORTION            10754000
         EJECT                                                          10755000
*                                                                       10756000
*        ENTRY POINTS FOR SUCCEED                                       10757000
*                                                                       10758000
*        EXTEND                   SUCCEXT                               10759000
*                                                                       10760000
*                                                                       10761000
*        "OR" AND "NOOR" CASES MERGE FOR SUCCEED                        10762000
*                                                                       10763000
         DC    Y(PO$SUCC-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE  10764000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10765000
PN$SUCC  EQU   *                  ENTRY FOR "NOOR" CASE                 10766000
PO$SUCC  B     SUCCSN             JUST SUCCEED WITH NO CHARS            10767000
         EJECT                                                          10768000
*                                                                       10769000
*        ENTRY POINTS FOR REM                                           10770000
*                                                                       10771000
*        EXTEND                   NONE                                  10772000
*                                                                       10773000
*        CASE OF "NOOR" POINTER                                         10774000
*                                                                       10775000
         DC    Y(PO$REM-*)        OFFSET TO CODE FOR "OR" CASE          10776000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10777000
PN$REM   SR    CP,CP              CLEAR COUNT OF CHARS LEFT             10778000
         B     SUCC               AND SUCCEED                           10779000
*                                                                       10780000
*        CASE OF "OR" POINTER PRESENT                                   10781000
*                                                                       10782000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10783000
PO$REM   SR    NCP,NCP            SET NCP TO END OF STRING              10784000
         B     SUCCS              AND SUCCEED                           10785000
         EJECT                                                          10786000
*                                                                       10787000
*        ENTRY POINTS FOR FENCE                                         10788000
*                                                                       10789000
*        EXTEND                   FENCEEXT                              10790000
*                                                                       10791000
*                                                                       10792000
*        "OR" AND "NOOR" CASES MERGE FOR FENCE                          10793000
*                                                                       10794000
         DC    Y(PO$FENCE-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE  10795000
PN$FENCE EQU   *                  ENTRY FOR "NOOR" CASE                 10796000
PO$FENCE B     SUCCSN             SUCCEED WITH NO CURSOR MOVEMENT       10797000
         EJECT                                                          10798000
*                                                                       10799000
*        ENTRY POINTS FOR ARB                                           10800000
*                                                                       10801000
*        EXTEND                   ARBEXT                                10802000
*                                                                       10803000
*                                                                       10804000
*        "OR" AND "NOOR" CASES MERGE FOR ARB                            10805000
*                                                                       10806000
         DC    Y(PO$ARB-*)        (DUMMY) OFFSET TO CODE FOR "OR" CASE  10807000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10808000
PN$ARB   EQU   *                  ENTRY FOR "NOOR" CASE                 10809000
PO$ARB   B     MATCHARB           GO TO ROUTINE APPROPRIATE TO SCAN MOD 10810000
         EJECT                                                          10811000
*                                                                       10812000
*        ENTRY POINTS FOR ARBNO                                         10813000
*                                                                       10814000
*        PARAM1                   BACK POINTER TO START -- SEE $$ARBN   10815000
*        EXTEND                   ARBNOEXT                              10816000
*                                                                       10817000
*                                                                       10818000
         DC    Y(PO$ARBNO-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE  10819000
         USING *,RETURN           PATTERN BASE                          10820000
PN$ARBNO EQU   *                  ENTRY POINT FOR "NOOR" CASE           10821000
PO$ARBNO B     MATCHABN           JUMP TO SPECIAL MATCH ROUTINE         10822000
         EJECT                                                          10823000
*                                                                       10824000
*        ENTRY POINTS FOR BAL                                           10825000
*                                                                       10826000
*        EXTEND                   BALEXT                                10827000
*                                                                       10828000
*                                                                       10829000
*        "OR" AND "NOOR" CASES MERGE FOR BAL                            10830000
*                                                                       10831000
         DC    Y(PO$BAL-*)        (DUMMY) OFFSET TO CODE FOR "OR" CASE  10832000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10833000
PN$BAL   EQU   *                  ENTRY FOR "NOOR" CASE                 10834000
PO$BAL   LTR   NCP,CP             ANY CHARS LEFT?                       10835000
         BNZ   MATCHBAL           IS SO, -> ROUTINE APPROPRIATE TO MODE 10836000
         B     LFAIL              ELSE LENGTH FAIL                      10837000
         EJECT                                                          10838000
*                                                                       10839000
*        ENTRY POINTS FOR STRING OF 256 CHARS OR LESS                   10840000
*                                                                       10841000
*        PARAM1                   STG BASE       (PARAMS CONTAIN NOR-)  10842000
*        PARAM2                   LENGTH/OFFSET  (MAL STRING SPECIFIER) 10843000
*        EXTEND                   NONE                                  10844000
*                                                                       10845000
*        NOTE THAT WE NEVER NEED TO SIGNAL LENGTH FAILURE IN THIS       10846000
*        SINCE IT IS IRRELEVANT IN FULLSCAN MODE, AND IN QUICKSCAN      10847000
*        WE WOULD NOT HAVE BEEN CALLED UNLESS THERE WERE ENOUGH         10848000
*        CHARACTERS FOR A SUCCESSFUL MATCH                              10849000
*                                                                       10850000
*                                                                       10851000
*        CASE OF "NOOR" POINTER                                         10852000
*                                                                       10853000
         DC    Y(PO$STRS-*)       OFFSET TO CODE FOR "OR" CASE          10854000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10855000
PN$STRS  L     R1,PARAM1(PB,PO)   LOAD STRING POINTER                   10856000
         AH    R1,PARAM1+SOFFSET(PB,PO)     ADD IN OFFSET               10857000
         LH    R2,PARAM1+SLENGTH(PB,PO)     LOAD LENGTH - 1             10858000
         LR    NCP,FSADR          POINT NCP TO END OF STG               10859000
         SR    NCP,CP             MINUS CHARS LEFT = CURRENT LOCATION   10860000
         EX    R2,STRSCLC         COMPARE CHARACTERS                    10861000
         BNE   BACKUP             FAIL IF NO MATCH                      10862000
         BCTR  CP,0               ADJUST ONE FOR 360 LENGTH FUDGE       10863000
         SR    CP,R2              MINUS NUM CHARS-1                     10864000
         BNM   SUCC               SUCCEED UNLESS OF END OF STG          10865000
         B     LBACKUP            IN WHICH CASE, LENGTH FAILURE         10866000
*                                                                       10867000
*        CASE OF "OR" POINTER PRESENT                                   10868000
*                                                                       10869000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10870000
PO$STRS  L     R1,PARAM1(PB,PO)   LOAD STRING POINTER                   10871000
         AH    R1,PARAM1+SOFFSET(PB,PO)     ADD IN OFFSET               10872000
         LH    R2,PARAM1+SLENGTH(PB,PO)     LOAD LENGTH - 1             10873000
         LR    NCP,FSADR          POINT NCP TO END OF STG               10874000
         SR    NCP,CP             MINUS NUM CHARS LEFT = CURRENT LOC    10875000
         EX    R2,STRSCLC         COMPARE CHARACTERS                    10876000
         BNE   FAIL               TAKE ALTERNATIVE IF NO MATCH          10877000
         LR    NCP,CP             COPY OLD POSITION                     10878000
         BCTR  NCP,0              MINUS ONE CHAR FOR 360 FUDGE          10879000
         SR    NCP,R2             SUBTRACT NUMBER OF CHARS - 1          10880000
         BNM   SUCCS              SUCCEED UNLESS OF END OF STG          10881000
         B     LFAIL              IN WHICH CASE, LENGTH FAILURE         10882000
*                                                                       10883000
STRSCLC  CLC   0(*-*,NCP),SCHARS(R1)        COMPARE CHARACTERS          10884000
         EJECT                                                          10885000
*                                                                       10886000
*        ENTRY POINTS FOR STRING LONGER THAN 256 CHARACTERS             10887000
*                                                                       10888000
*        PARAM1                   STG BASE       (PARAMS CONTAIN NOR-)  10889000
*        PARAM2                   LENGTH/OFFSET  (MAL STRING SPECIFIER) 10890000
*        EXTEND                   NONE                                  10891000
*                                                                       10892000
*                                                                       10893000
*        "OR"/"NOOR" CASES MERGE FOR LONG STRINGS                       10894000
*        (THIS PATTERN IS SO RARE THAT WE WILL TOLERATE THE UNNEEDED    10895000
*        STACK ENTRY IN THE "NOOR" CASE TO SAVE SPACE HERE)             10896000
*                                                                       10897000
         DC    Y(PO$STRL-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE  10898000
         USING *,RETURN           SET PATTERN ROUTINE BASE REG          10899000
PN$STRL  EQU   *                  ENTRY FOR "NOOR" CASE                 10900000
PO$STRL  LH    R1,PARAM1+SLENGTH(PB,PO)     LOAD LENGTH - 1             10901000
         L     R2,PARAM1(PB,PO)   LOAD STRING POINTER                   10902000
         AH    R2,PARAM1+SOFFSET(PB,PO)     ADD IN STRING OFFSET        10903000
         LR    NCP,FSADR          POINT NCP PAST END OF STG             10904000
         SR    NCP,CP             MINUS NUM CHARS LEFT = CURRENT LOC    10905000
         LA    R0,256             GET CRANK CONSTANT                    10906000
PO$STRL1 CLC   0(256,NCP),0(R2)   CHECK 256 BYTE CHUNK                  10907000
         BNE   FAIL               FAIL IF NO MATCH                      10908000
         AR    NCP,R0             PUSH PATTERN STG CHARACTER PTR        10909000
         AR    R2,R0              PUSH TEST STG CHARACTER PTR           10910000
         SR    R1,R0              CRANK COUNT DOWN                      10911000
         CR    R1,R0              DO WE HAVE MORE THAN 256 CHARS LEFT   10912000
         BH    PO$STRL1           BACK IN LOOP IF YES                   10913000
         EX    R1,STRLCLC         ELSE COMPARE REMAINING CHARACTERS     10914000
         BNE   FAIL               FAIL IF THEY DO NOT MATCH             10915000
         LH    R1,PARAM1+SLENGTH(,PB)       RELOAD LENGTH - 1           10916000
         LR    NCP,CP             COPY CURRENT LOCATION                 10917000
         BCTR  NCP,0              MINUS ONE FOR 360 FUDGE               10918000
         SR    NCP,R1             MINUS NUMBER OF CHARS-1               10919000
         BNM   SUCCS              SUCCEED UNLESS OFF END OF STG         10920000
         B     LFAIL              IN WHICH CASE, LENGTH FAILURE         10921000
*                                                                       10922000
STRLCLC  CLC   0(*-*,NCP),SCHARS(R2)        COMPARE LAST CHARACTERS     10923000
         EJECT                                                          10924000
*                                                                       10925000
*        ENTRY POINTS FOR EXPRESSION                                    10926000
*                                                                       10927000
*        THIS IS ONE OF THE MORE COMPLICATED PATTERN MATCH ROUTINES     10928000
*                                                                       10929000
*        EVERY PATTERN WHICH REFERENCES AN EXPRESSION CONSISTS OF       10930000
*        TWO LINKED NODES -- THE FIRST NODE HAS A PARAMETER POINTER     10931000
*        TO THE CODE -- TWO CASES ARE POSSIBLE ON MATCHING THIS FIRST   10932000
*        NODE (EXP1) --                                                 10933000
*                                                                       10934000
*        1)    THE EXPRESSION IS A STRING OR IS CONVERTIBLE TO A STRING 10935000
*              IN THIS CASE, WE SEE IF THE STRING MATCHES -- IF IT DOES 10936000
*              NOT, THEN WE FAIL TO TAKE THE ALTERNATIVE -- IF IT DOES  10937000
*              MATCH, THEN WE BYPASS THE SECOND NODE AND CONTINUE       10938000
*              AFTER MAKING A NOTHING ENTRY ON STACK 2 -- THIS ENTRY    10939000
*              IS JUST PUT THERE TO BE REMOVED BY EXP1EXT IF BACKUP     10940000
*              OCCURS SUBSEQUENTLY                                      10941000
*                                                                       10942000
*        2)    THE ARGUMENT IS A PATTERN -- IN THIS CASE, WE MAKE       10943000
*              AN ENTRY ON STACK 2 TO SAVE THE PB FOR THIS PATTERN      10944000
*              AND THE PO FOR THE EXP2 NODE -- (MINR) IS SET TO         10945000
*              ACCOUNT FOR THE CHARS WHICH REMAIN AT THIS LEVEL         10946000
*              AND WE PROCEED TO MATCH THE NEW PATTERN AFTER SETTING PB 10947000
*                                                                       10948000
*                                                                       10949000
*        IF WE BACKUP "OUT OF" THE EXPRESSION PATTERN WE GO THROUGH     10950000
*        THE EXTENSION ROUTINE FOR EXP1 WHICH MERELY REMOVES THE        10951000
*        ENTRY ON STACK 2 AND SEEKS ALTERNATIVES                        10952000
*        EXP1EXT IS ENTERED THROUGH ANCHEXT WITH PO POSITIVE            10953000
*                                                                       10954000
*        AFTER SUCCESSFULLY MATCHING THE EXPRESSION PATTERN, ITS PB     10955000
*        IS SAVED IN THE CP FIELD OF THE EXP2 ENTRY ON STACK 1, THIS IS 10956000
*        SO THAT EXP2EXT CAN RESTORE THE STACK 2 ENTRY AND RESTORE      10957000
*        THE PATTERN BASE SETTING FOR THE EXPRESSION PATTERN IN THE     10958000
*        EVENT THAT THE MATCH BACKS UP INTO A REGION ON STACK 1         10959000
*        LEFT THERE FROM ELEMENTS IN THE EXPRESSION PATTERN             10960000
*                                                                       10961000
*        NOTE THAT THE PATTERN EXP2 IS NEVER ACTUALLY MATCHED -- ONLY   10962000
*        ITS EXTENSION ROUTINE IS USED                                  10963000
         EJECT                                                          10964000
*                                                                       10965000
*        ENTRY POINTS FOR EXPRESSION -- CONTINUED                       10966000
*                                                                       10967000
*        PATTERN MATCH ROUTINE FOR EXP1                                 10968000
*                                                                       10969000
*        PARAM1                   NOT USED                              10970000
*        PARAM2                   EXPRESSION POINTER (VCODE OR ECODE)   10971000
*        EXTEND                   EXP1EXT                               10972000
*                                                                       10973000
*                                                                       10974000
*        "OR" AND "NOOR" CASES MERGE FOR EXP1                           10975000
*                                                                       10976000
         DC    Y(PO$EXP1-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE  10977000
         USING *,RETURN           PATTERN ROUTINE BASE REG              10978000
PN$EXP1  EQU   *                  ENTRY POINT FOR "NOOR" CASE           10979000
PO$EXP1  L     RETURN,PARAM2(PB,PO)         LOAD EXPRESSION POINTER     10980000
         CR    R0,R0              SET CONDITION CODE EQ FOR CALL IN PAT 10981000
         BAL   R1,$EVAL           EVALUATE                              10982000
         USING *,R1               BASE REG SET FROM $EVAL               10983000
         B     FAIL               FAIL IF CODE FAILS                    10984000
*                                                                       10985000
*        RETURN IS MADE WITH DB1 INTACT, SO PO MUST BE RESTORED         10986000
*                                                                       10987000
         USING SPITBOLD,DB1       TELL ASEMBLER OF BASE REGISTER        10988000
         ST    A1,EVALSV          STORE POINTER TO CHECK CODE           10989000
         CLI   EVALSV,PCODE       IS IT A PATTERN?                      10990000
         DROP  DB1                GET RID OF BASE REGISTER              10991000
         BE    PO$EXP1P           SKIP IF IT IS A PATTERN               10992000
         BAL   RETURN,GETSTGS     GET A STRING SPEC                     10993000
         USING *,RETURN           NEW BASE REGISTER                     10994000
         B     PO$EXERR           OFF TO GIVE ERR IF NOT CONVERTABLE    10995000
         L     PO,PSAVPO(,PDR)    RESTORE PATTERN OFFSET                10996000
         LR    NCP,CP             COPY CURSOR POINTER                   10997000
         LTR   A1+1,A1+1          TEST FOR NULL (LENGTH NEGATIVE)       10998000
         BM    PO$EXP1M           SKIP IN CASE OF NULL                  10999000
         BCTR  NCP,0              FUDGE FOR 360 LENGTH                  11000000
         SR    NCP,A1+1           SUBTRACT LENGTH MATCHED               11001000
         BNM   *+12               SKIP IF NOT OFF END OF STRING         11002000
         LM    A1,A1+1,PSAVBPS(PDR)         RESTORE REGISTERS           11003000
         B     LFAIL              AND GIVE LENGTH FAILURE               11004000
         LCR   R1,CP              MINUS NUM CHARS LEFT                  11005000
         AR    R1,FSADR           ADD END OF STRING ADDR = CUR CHAR     11006000
         LA    R0,256             GET INVALUABLE CONSTANT               11007000
         CR    A1+1,R0            ARE WE SHORT OR LONG?                 11008000
         BL    PO$EXP1S           SKIP IF SHORT                         11009000
*                                                                       11010000
*        LOOP TO COMPARE LONG STRINGS                                   11011000
*                                                                       11012000
PO$EXP1L CLC   SCHARS(256,A1),0(R1)         CHECK 256 CHARACTERS        11013000
         BNE   PO$EXP1F           IF NE, FAIL                           11014000
         AR    R1,R0              PUSH UP CHAR ADDR                     11015000
         AR    A1,R0              PUSH UP CHAR ADDR                     11016000
         SR    A1+1,R0            DECREASE COUNT                        11017000
         CR    A1+1,R0            SHORT OR LONG LEFT?                   11018000
         BNL   PO$EXP1L           SKIP IF LONG                          11019000
         EJECT                                                          11020000
*                                                                       11021000
*        COMPARISON OF <256 CHARACTERS                                  11022000
*                                                                       11023000
PO$EXP1S EX    A1+1,PO$EXPC       CHECK THOSE CHARACTERS                11024000
         BE    PO$EXP1M           IF EQUAL, SUCCEED                     11025000
*                                                                       11026000
*        ENTRY FOR FAILURE (MUST RESTORE BPS,PS2)                       11027000
*                                                                       11028000
PO$EXP1F LM    A1,A1+1,PSAVBPS(PDR)         RESTORE THE REGISTERS       11029000
         B     FAIL               AND FAIL                              11030000
*                                                                       11031000
*        REENTRY IN CASE OF NULL RESULT                                 11032000
*                                                                       11033000
PO$EXP1M LM    A1,A1+1,PSAVBPS(PDR)         RESTORE REGISTERS           11034000
         STM   PO,CP,0(PS1)       MAKE STACK1 ENTRIES                   11035000
         AH    PO,THEN(PB,PO)     POINT THROUGH EXP2 PATTERN            11036000
         B     SUCCSP             AND SUCCEED PAST STM                  11037000
*                                                                       11038000
*        COME HERE WHEN DEFERRED EXPRESSION IS A PATTERN                11039000
*                                                                       11040000
         DROP  RETURN             DROP THIS REG (BACK TO USING R1)      11041000
PO$EXP1P LR    R0,A1              SAVE NEW PATTERN BASE                 11042000
         LM    A1,A1+1,PSAVBPS(PDR)         RESTORE THE REGISTERS       11043000
         L     PO,PSAVPO(,PDR)    RESTORE PATTERN OFFSET                11044000
         SR    PS2,BPS            MAKE ROOM ON STACK 2                  11045000
         AH    PO,THEN(PB,PO)    POINT TO EXP2 PATTERN                  11046000
         SH    MINR,MINMATCH(PB,PO)        DECR MINR APPROPRIATELY      11047000
         STM   PB,PO,S2PB+S2OFS(PS2)        MAKE STACK 2 ENT FOR NOTHEN 11048000
         L     PO,NCODEBT         SPECIAL STACK ENTRY NEEDS RIGHT 3     11049000
*                                 BYTES ZERO, WITH SOME POSITIVE VALUE  11050000
         STM   PO,CP,0(PS1)       MAKE PO/CP ENTRY ON STACK 1           11051000
         LR    PB,R0              LOAD NEW PATTERN BASE                 11052000
         LA    PO,PATS            LOAD NEW PATTERN OFFSET               11053000
         B     SUCCSN+8           SUCCEED SKIPPING OVER STM AND AH      11054000
         DROP  R1                 THROUGH WITH THIS REG NOW             11055000
*                                                                       11056000
PO$EXPC  CLC   SCHARS(*-*,A1),0(R1)         COMPARE IN CASE OF NOT PAT  11057000
*                                                                       11058000
*        COME HERE TO ISSUE ERROR MESSAGE                               11059000
*                                                                       11060000
PO$EXERR BAL   RETURN,$EVALERR    DO PROPER THINGS FOR SETEXIT          11061000
         XERR  01,011             EVALUATED RESULT OF DEFERRED          11062000
*                                 EXPRESSION USED IN A PATTERN MATCH    11063000
*                                 IS NOT A STRING OR PATTERN            11064000
         EJECT                                                          11065000
*                                                                       11066000
*        ENTRY POINTS FOR NOTHEN PSEUDO PATTERN                         11067000
*                                                                       11068000
*        NOTHEN IS NOT REALLY A PATTERN, HOWEVER, IT IS ENTERED AS      11069000
*        THOUGH IT WERE, SO IT IS INCLUDED IN THIS SECTION              11070000
*                                                                       11071000
*        THERE ARE TWO CASES POSSIBLE --                                11072000
*                                                                       11073000
*        1)    THE REAL END OF PATTERN, IN WHICH CASE WE GO THROUGH     11074000
*              THE FULL END OF PATTERN LOGIC INCLUDING DOT ASSIGNMENTS  11075000
*                                                                       11076000
*        2)    THE END OF AN EXPRESSION PATTERN (RECURSIVE CALL)        11077000
*              IN WHICH CASE, WE POP UP A LEVEL AND CONTINUE            11078000
*                                                                       11079000
*                                                                       11080000
         USING *,RETURN           STANDARD PATTERN BASE                 11081000
NOTHEN   LR    R1,PB              SAVE PAT BASE OF POSSIBLE EXPR PAT    11082000
         LM    PB,PO,S2PB+S2OFS(PS2)        LOAD LAST PB & PO           11083000
         LTR   PB,PB              TEST FOR ZERO ENTRY SIGNALLING END    11084000
         BZ    ENDPAT             IF FOUND, SKIP TO END OF PATTERN RTN  11085000
         ST    PO,0(,PS1)         MAKE STACK 1 ENTRY TO GET EXP2EXT     11086000
         ST    R1,4(,PS1)         SAVE EXPR PB IN CP FIELD              11087000
         AH    MINR,MINMATCH(PB,PO)         RESTORE MIRN                11088000
         BXH   PS2,BPS,SUCCSN+4   REM STK 2 ENTRY, SUCCEED PAST STM     11089000
*                                                                       11090000
*        COME HERE FOR REAL END OF PATTERN                              11091000
*                                                                       11092000
ENDPAT   L     NCP,STACK1+S1NEWCP(,PDR)     GET ANCHOR MOVEMENT         11093000
         L     PB,PSAVDB1(,PDR)   RELOAD DATA AREA ADDRESS              11094000
         USING SPITBOLD,PB        TELL ASSEMBLER                        11095000
         L     PB,PDRLOC          RESTORE PDR FOR THIS LEVEL            11096000
         DROP  PB                 GET RID OF BASE REGISTER              11097000
         STH   CP,MATCHPE(,PB)    STORE ENDING CURSOR LOCATION          11098000
         STH   NCP,MATCHPB(,PB)   STORE BEGINNING CURSOR LOCATION       11099000
         CLI   DOTSW(PDR),0       WERE ANY DOTS DONE?                   11100000
         BE    PATENDE            END OF PATTERN IF NOT                 11101000
         LR    CP,PS1             COPY END OF STACK 1 ADDRESS           11102000
         LA    PO,3*4             LOAD STACK ENTRY SIZE INCREMENT       11103000
         LA    MINR,STACK1(,PDR)  GET START OF STACK ADDRESS            11104000
         LA    PBASE,PATENDL3-(FAIL-QPATSUBS)         PATENDL3=FAILHERE 11105000
         USING PATENDL3-(FAIL-QPATSUBS),PBASE         TELL ASSEMBLER    11106000
         DROP  RETURN             GET RID OF OLD BASE REGISTER          11107000
*                                                                       11108000
*        FIRST DO SOME INITIAL CALCULATIONS FOR STG SPECIFIERS          11109000
*        THIS CALC LEAVES THE OFFSET OF THE LAST CHARACTER OF THE       11110000
*        SUBJECT STRING AT THE LEFT OF PENDWRD, RIGHT HALF = 0          11111000
*                                                                       11112000
         LH    R2,PSTRING+SOFFSET(,PB)      GET ORIGINAL OFFSET         11113000
         AH    R2,PSTGLEN(,PB)    PLUS ORIGINAL LENGTH                  11114000
         SLL   R2,16              POSITION ON THE LEFT                  11115000
         ST    R2,PENDWRD(,PDR)   AND SAVE ON STACK FOR FUTURE USE      11116000
         SR    CP,PO              POINT TO LAST STACK 1 ENTRY           11117000
         EJECT                                                          11118000
*                                                                       11119000
*        THIS LOOP CYCLES THROUGH STACK1 LOOKING FOR DOT ASSIGNMENTS    11120000
*        TO BE PERFORMED.         ASSIGNMENTS MUST BE DONE IN ORDER     11121000
*                                                                       11122000
PATENDL  CLI   DOTLOC(MINR),DOTFLG          IS THIS A DOT ENTRY?        11123000
         BE    PATENDL4           GO TO PROCESS IT IF SO                11124000
*                                                                       11125000
*        COME HERE TO PUSH STACK POINTER AND CHECK FOR END OF STACK1    11126000
*                                                                       11127000
PATENDL3 BXLE  MINR,PO,PATENDL    LOOP BACK IF NOT AT STACK END         11128000
         B     PATENDE            ELSE END OF PATTERN MATCH             11129000
*                                                                       11130000
*        COME HERE TO DEAL WITH A DOT ENTRY - SEE STACK 1 FORMAT        11131000
*                                                                       11132000
PATENDL4 LM    R1,R2,0(MINR)      LOAD PB AND PO                        11133000
         LA    BPS,0(R1,R2)       GET PATTERN NODE ADDRESS              11134000
         TM    PFLAGS(BPS),PRELOC2          SECOND PARAM RELOCATABLE?   11135000
         BNO   PATENDL0           REGULAR (NON-DEFERRED) DOT IF NOT     11136000
*                                                                       11137000
*        COME HERE TO PROCESS DEFERRED NAME                             11138000
*                                                                       11139000
         L     RETURN,PARAM2(,BPS)          LOAD EXPRESSION POINTER     11140000
         CR    R0,R0              SET CC FOR CALL BY PATTERN MATCH      11141000
         BAL   R1,$EVAL           EVALUATE NAME                         11142000
         B     PATENDL3           SKIP ASSIGN IF NAME FAILS             11143000
         LA    BPS,0(A1,A1+1)     POINT TO NAME FIELD                   11144000
         L     PS2,PSAVPS2(,PDR)  RESTORE PS2 FROM STACK                11145000
         L     PO,PSAVPO(,PDR)    RESTORE PO/DB1 FOR MATCHING           11146000
         B     PATENDL1           AND MERGE TO CALCULATE VALUE          11147000
*                                                                       11148000
*        COME HERE FOR NORMAL NAME (NOT DEFERRED)                       11149000
*                                                                       11150000
PATENDL0 LM    R1,R2,PARAM1(BPS)  LOAD NAME AND OFFSET                  11151000
         LA    BPS,0(R1,R2)       POINT TO NAME FIELD                   11152000
         EJECT                                                          11153000
*                                                                       11154000
*        NOW CALCULATE STRING SPECIFIER                                 11155000
*        SLENGTH = S1BCP-S1ECP-1                                        11156000
*        SOFFSET = SOFFSET(PSTRING)+SLENGTH(PSTRING)+1-S1BCP            11157000
*        PENDWRD = SOFFSET+SLENGTH ON LEFT SIDE OF A WORD               11158000
*        THE +1 COMES FROM A CARRY FROM THE SL                          11159000
*                                                                       11160000
PATENDL1 LH    R2,S1BCP(,MINR)    LOAD STARTING CURSOR                  11161000
         CH    R2,S1ECP(,MINR)    CHECK FOR NULL RESULT                 11162000
         BNE   *+12               SKIP IF NOT NULL                      11163000
         L     R1,NCODEBT         ELSE LOAD NULL SPECIFIER              11164000
         B     PATENDL2           AND SKIP TO DO ASSIGN                 11165000
         AL    R2,PENDWRD(,PDR)   POSITION LAST CHARACTER OFFSETLEFT    11166000
         SL    R2,S1BCP(,MINR)    CALC NEW OFFSET-REAL LENGTH SEE PICS  11167000
         BCTR  R2,0               GET 360 LENGTH AND OFFSET             11168000
         L     R1,PSTRING(,PB)    GET STRING POINTER                    11169000
*                                                                       11170000
*        COME HERE WITH SPECIFIER IN R1,R2  -  VAR BLK PTR IN BPS       11171000
*                                                                       11172000
PATENDL2 BAL   NCP,PATASSGN       DO ASSIGN WITH I/O CHECK              11173000
         B     PATENDL3           LOOP BACK TO CHECK FOR MORE DOTS      11174000
         USING QPATSUBS,PBASE     RESTORE THIS BASE REGISTER            11175000
         EJECT                                                          11176000
*                                                                       11177000
*        ENTRY POINTS FOR "NOOR" PSEUDO PATTERN                         11178000
*                                                                       11179000
*        THIS "PATTERN" IS GIVEN CONTROL WHEN THERE IS NO ALTERNATIVE   11180000
*        TO AN ELEMENT WHICH FAILS TO MATCH                             11181000
*                                                                       11182000
*                                                                       11183000
         USING *,RETURN           USUAL PATTERN BASE                    11184000
NOOR     B     LBACKUP            BACK UP ON STACK                      11185000
         EJECT                                                          11186000
*                                                                       11187000
*        ENTRY POINTS FOR MARK                                          11188000
*                                                                       11189000
*        MARK IS USED BY DOLLAR,DOT AND ARBNO ROUTINES TO SAVE THE      11190000
*        CURRENT CURSOR LOCATION ON STACK 2                             11191000
*                                                                       11192000
*        EXTEND                   MARKEXT                               11193000
*                                                                       11194000
*                                                                       11195000
*        "OR" AND "NOOR" CASES MERGE FOR MARK                           11196000
*                                                                       11197000
         DC    Y(PO$MARK-*)       (DUMMY) OFFSET TO "OR" CASE CODE      11198000
         USING *,RETURN           STANDARD PATTERN BASE                 11199000
PN$MARK  EQU   *                  ENTRY FOR "NOOR" CASE                 11200000
PO$MARK  SR    PS2,BPS            MAKE ROOM ON STACK 2                  11201000
         ST    CP,S2CP+S2OFS(,PS2)          SAVE CURSOR ON STK 2        11202000
         B     SUCCSN             SUCCEED WITH NO CURSOR MOVEMENT       11203000
         EJECT                                                          11204000
*                                                                       11205000
*        ENTRY POINTS FOR DOLLAR                                        11206000
*                                                                       11207000
*        CASE OF DEFERRED NAME                                          11208000
*                                                                       11209000
*        PARAM1                   NOT USED                              11210000
*        PARAM2                   EXPRESSION POINTER                    11211000
*        EXTEND                   DOLEXT                                11212000
*                                                                       11213000
*                                                                       11214000
*        "OR" AND "NOOR" CASES MERGE FOR DEFERRED DOLLAR                11215000
*                                                                       11216000
         DC    Y(PO$DOLD-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE  11217000
         USING *,RETURN           PATTERN BASE REG                      11218000
PN$DOLD  EQU   *                  ENTRY POINT FOR "NOOR" CASE           11219000
PO$DOLD  BAL   NCP,DEFEXPN        EVAL EXPR TO GET NAME, MERGE *+14     11220000
         EJECT                                                          11221000
*                                                                       11222000
*        ENTRY POINTS FOR DOLLAR -- CONTINUED                           11223000
*                                                                       11224000
*        NORMAL CASE (NAME NOT DEFERRED)                                11225000
*                                                                       11226000
*        PARAM1                   VARIABLE NAME BASE                    11227000
*        PARAM2                   VARIABLE NAME OFFSET                  11228000
*        EXTEND                   DOLEXT                                11229000
*                                                                       11230000
*                                                                       11231000
*        "OR" AND "NOOR" CASES MERGE FOR DOLLAR                         11232000
*                                                                       11233000
         DC    Y(PO$DOL-*)        (DUMMY) OFFSET TO CODE FOR "OR" CASE  11234000
         USING *,RETURN           PATTERN BASE REG                      11235000
PN$DOL   EQU   *                  ENTRY POINT FOR "NOOR" CASE           11236000
PO$DOL   L     BPS,PARAM1(PB,PO)  LOAD NAME BASE                        11237000
         A     BPS,PARAM2(PB,PO)  ADD NAME OFFSET TO GET ADDRESS        11238000
*                                                                       11239000
*        MERGE POINT FOR DEFERRED NAME CASE                             11240000
*                                                                       11241000
PO$DOL0  L     NCP,S2CP+S2OFS(,PS2)         LOAD OLD CURSOR             11242000
         STM   PO,NCP,0(PS1)      SAVE ALL REGISTERS ON STACK1          11243000
*                                                                       11244000
*        NOTE PS2 NEEDS AN AR WITH BPS, AS DOES PS1                     11245000
*                                                                       11246000
         L     R1,NCODEBT         LOAD IN CASE OF NULL RESULT           11247000
         CR    NCP,CP             CHECK FOR NULL RESULT                 11248000
         BE    PO$DOL1            OFF TO ASSIGN IF NULL                 11249000
         L     R2,PSAVDB1(,PDR)   RESTORE DATA AREA ADDRESS             11250000
         USING SPITBOLD,R2        TELL ASSEMBLER                        11251000
         L     R2,PDRLOC          RESTORE REAL STACK LOCATION           11252000
         DROP  R2                 GET RID OF BASE REGISTER              11253000
         L     R1,PSTRING(,R2)    LOAD STRING BASE POINTER AND SCODE    11254000
         LA    R0,SCHARS(NCP,R1)  START OF STG ADDR + OLD CURSOR        11255000
         LR    R2,FSADR           COPY END OF STRING ADDRESS            11256000
         SR    R2,R0              CALCULATE SUBSTRING OFFSET            11257000
         SLL   R2,16              POSITION OFFSET                       11258000
         SR    NCP,CP             OLD CURSOR - CURRENT = REAL LENGTH    11259000
         BCTR  NCP,0              -1 = 360 LENGTH                       11260000
         ALR   R2,NCP             COMBINE LENGTH AND OFFSET             11261000
*                                                                       11262000
*        COME HERE TO MAKE ASSIGNMENT                                   11263000
*                                                                       11264000
PO$DOL1  BAL   NCP,PATASSGN       MAKE ASSIGNMENT WITH I/O CHECK        11265000
         AR    PS2,BPS            DELETE STACK2 ENTRY                   11266000
         B     SUCCSN+4           SUCCEED SKIPPING STM                  11267000
         EJECT                                                          11268000
*                                                                       11269000
*        THIS ROUTINE IS CALLED BY @,$ AND ENDPAT(.) FOR ASSIGNMENTS    11270000
*        DURING PATTERN MATCHES. AN I/O CHECK IS MADE AND IF NECESSARY  11271000
*        A RECURSIVE CALL TO THE WRITE ROUTINE IS MADE USING EVAL       11272000
*                                                                       11273000
*        (BPS)                    VARIABLE ADDRESS (NAME+BASE)          11274000
*        BAL   NCP,PATASSGN       CALL FOR ASSIGNMENT                   11275000
*        (BPS)                    RESTORED TO STANDARD VALUE (12)       11276000
*        (R0,RETURN,R1,R2)        DESTROYED                             11277000
*                                                                       11278000
         DROP  RETURN             NO BASE REGISTER HERE                 11279000
PATASSGN STM   R1,R2,VALUE(BPS)   MAKE THE ASSIGNMENT                   11280000
         TM    VFLAGS(BPS),VOUA+VTRC        DO WE HAVE ACTIVE OUTPUT?   11281000
         LR    R0,BPS             SAVE VAR BLOCK ADDRESS                11282000
         LA    BPS,3*4            RESTORE STACK INCREMENT               11283000
         BCR   Z,NCP              RETURN TO CALLER IF NOT               11284000
         L     R1,PSAVDB1(,PDR)   ELSE LOAD DATA BASE REGISTER          11285000
         BALR  R2,0               GET A BASE REGISTER                   11286000
         USING *,R2               TELL ASSEMBLER                        11287000
         CR    R0,PDR             IS IT ABOVE DYNAMIC CORE?             11288000
         BH    PATASSG1           SKIP TO ASSIGN IF SO                  11289000
         DROP  R2                 DROP TEMPORARY BASE                   11290000
         C     R0,DYNAMB-SPITBOLD(,R1)      IS IT BELOW DYNAMIC CORE?   11291000
         BCR   NL,NCP             RETURN IF NOT NATURAL VARIABLE        11292000
*                                                                       11293000
*        HERE WE PERFORM THE ASSIGNMENT                                 11294000
*                                                                       11295000
PATASSG1 L     RETURN,EVALWCON    GET PSEUDO ROUTINE ADDRESS            11296000
         ST    R0,EVALVAR-SPITBOLD(,R1)     SAVE VAR BLK ADDR FOR CODE  11297000
         CR    R0,R0              SET CC FOR PAT MATCH CALL             11298000
         BAL   R1,$EVAL           DO THE WRITE OR TRACE                 11299000
         B     FAIL               FAIL IF EVAL IS UNSUCCESSFUL          11300000
         LM    A1,A1+1,PSAVBPS(PDR)         IGNORE ANY RETURNED VALUE   11301000
         L     PO,PSAVPO(,PDR)    RESTORE PO/DB1                        11302000
         BR    NCP                AND RETURN TO CALLER                  11303000
         EJECT                                                          11304000
*                                                                       11305000
*        THIS ROUTINE IS CALLED BY $ AND @ ROUTINES TO EVALUATE A NAME  11306000
*                                                                       11307000
*        (PB,PO)                  POINTS TO PATTERN NODE                11308000
*        BAL   NCP,DEFEXPN                                              11309000
*        -->   RETURN TO 10(NCP)                                        11310000
*        (BPS)                    RESULTING NAME POINTER                11311000
*        (RETURN)                 RESET TO PROVIDE BASE FOR MERGE       11312000
*        ALL OTHER PAT REGS RESTORED (EXCEPT NCP, CALLING REG)          11313000
*                                                                       11314000
*        NOTE THAT PARAM2 ALWAYS CONTAINS AN ECODE EXPRESSION PTR       11315000
*        SINCE VCODE ARGS WERE TREATED AS SIMPLE VARIABLE REFERENCES    11316000
*        DURING PATTERN CONSTRUCTION (SEE $$ATS1, $$DOTD, $$DOLD)       11317000
*                                                                       11318000
DEFEXPN  L     RETURN,PARAM2(PB,PO)         LOAD EXPRESSION POINTER     11319000
         CR    R0,R0              SET CC FOR PAT MATCH CALL             11320000
         BAL   R1,$EVAL           EVALUATE EXPRESSION                   11321000
         B     FAIL               FAIL IF CODE FOR NAME FAILS           11322000
         L     PO,PSAVPO(,PDR)    RESTORE PO (=DB1)                     11323000
         LA    BPS,0(A1,A1+1)     ADD NAME BASE/OFFSET                  11324000
         L     PS2,PSAVPS2(,PDR)  RESTORE STACK 2 POINTER               11325000
         LA    RETURN,2(,NCP)     RESET BASE REG FOR MERGE BACK         11326000
         B     10(,NCP)           RETURN TO CALLER AT MERGE POINT       11327000
         EJECT                                                          11328000
*                                                                       11329000
*        ENTRY POINTS FOR DOT                                           11330000
*                                                                       11331000
*                                                                       11332000
*        CASE OF DEFERRED NAME                                          11333000
*                                                                       11334000
*        PARAM1                   NOT USED                              11335000
*        PARAM2                   EXPRESSION POINTER                    11336000
*        EXTEND                   DOTEXT                                11337000
*                                                                       11338000
*                                                                       11339000
*                                                                       11340000
*        NORMAL CASE (NAME NOT DEFERRED)                                11341000
*                                                                       11342000
*        PARAM1                   NAME BASE                             11343000
*        PARAM2                   NAME OFFSET                           11344000
*        EXTEND                   DOTEXT                                11345000
*                                                                       11346000
*                                                                       11347000
*        "OR" AND "NOOR" CASES MERGE FOR DOT                            11348000
*                                                                       11349000
         DC    Y(PO$DOT-*)        (DUMMY) OFFSET TO CODE FOR "OR" CASE  11350000
         USING *,RETURN           PATTERN BASE REG                      11351000
PN$DOT   EQU   *                  ENTRY POINTS FOR "NOOR" CASE          11352000
PO$DOTD  EQU   *                  OR ENTRY FOR DEFERRED DOT             11353000
PN$DOTD  EQU   *                  NOOR ENTRY FOR DEFERRED DOT           11354000
PO$DOT   L     NCP,S2OFS(,PS2)    LOAD OLD CURSOR LOCATION              11355000
         AR    PS2,BPS            DELETE STACK 2 ENTRY                  11356000
         MVI   DOTSW(PDR),1       INDICATE A DOT HAS BEEN DONE          11357000
         ST    PO,0(,PS1)         SAVE THIS PATTERN OFFSET              11358000
         ST    PB,S1PB(,PS1)      SAVE THIS PATTERN BASE                11359000
         MVI   DOTLOC(PS1),DOTFLG SET SPECIAL DOT FLAG                  11360000
         ST    CP,8(,PS1)         SAVE ENDING CURSOR                    11361000
         STH   NCP,S1BCP(,PS1)    SAVE BEGINING CURSOR                  11362000
         B     SUCCSN+4           SUCCEED SKIPPING STM                  11363000
         EJECT                                                          11364000
*                                                                       11365000
*        ROUTINE TO EXPAND PATTERN MATCHING STACKS 1 AND 2              11366000
*        EACH CALL TO THIS ROUTINE EXPANDS STACK BY ITS ORIGINAL SIZE   11367000
*        IF GARBAGE COLLECTION IS NEEDED A DUMMY DEFERRED EXPRESSION    11368000
*        IS EXECUTED.                                                   11369000
*        (NCP)                    A(PSTKOV)                             11370000
*        (RETURN)                 EXIT ADDRESS                          11371000
*                                                                       11372000
         USING PSTKOV,NCP         OUR BASE REGISTER                     11373000
PSTKOV   L     R1,PSAVDB1(,PDR)   RECOVER DATA AREA ADDRESS             11374000
         L     R0,FRSAVE-SPITBOLD(,R1)      GET CURRENT FR ADDRESS      11375000
         LA    R1,PSTKENTS*3*4    CALCULATE ROOM TO BE ADDED            11376000
         AR    R0,R1              CALC FINAL CORE POINTER               11377000
         CR    R0,PDR             WILL WE OVERFLOW?                     11378000
         BL    PSTKOV1            SKIP IF NO OVERFLOW                   11379000
         LR    NCP,RETURN         SAVE RETURN ADDRESS                   11380000
         LA    RETURN,EVALGCOL    GET ADDR OF DEFERRED CODE             11381000
         AL    RETURN,ECODEBT     MAKE SURE WE HAVE PROPER TYPE CODE    11382000
         CR    R0,R0              SET CALL FROM PAT MATCH               11383000
         BAL   R1,$EVAL           AND PROCESS THIS EXPRESSION           11384000
         NOP   0                  FAILURE IS IMPOSSIBLE                 11385000
         L     PO,PSAVPO(,PDR)    RESTORE AFTER DB1 USE                 11386000
         LM    A1,A1+1,PSAVBPS(PDR)         RESTORE REGS                11387000
         LR    RETURN,NCP         RESTORE LINKAGE                       11388000
         L     NCP,=A(PSTKOV)     GET OUR BASE REG BACK                 11389000
         BR    NCP                AND RE-ENTER                          11390000
*                                                                       11391000
*        COME HERE WITH ENOUGH CORE FOR STACK MOVE                      11392000
*                                                                       11393000
PSTKOV1  SR    PS1,R1             RELOCATE PS1                          11394000
         SR    PDR,R1             RELOCATE PDR                          11395000
         LR    R1,PS1             COPY NEW PS1 ADDR                     11396000
         LA    R0,PSTKOFS+1(,PDR) GET BOTTOM OF MOVE + FUDGE            11397000
         SR    R1,R0              CALC 360 MOVE LENGTH                  11398000
         LA    R0,256             GET VITAL CONSTANT                    11399000
         LR    R2,PDR             COPY POINTER FOR MOVE                 11400000
*                                                                       11401000
*        NOTE THAT FIRST MOVE WILL ALWAYS BE > 256AS INCREASE SIZE IS   11402000
*        COME HERE TO MOVE 256 CHARACTERS AT A TIME                     11403000
*                                                                       11404000
PSTKOVML MVC   PSTKOFS(256,R2),PSTKOFS+PSTKENTS*3*4(R2)         MOVE    11405000
*                                 A 256 CHARACTER PIECE                 11406000
         AR    R2,R0              PUSH TO AND FROM POINTER              11407000
         SR    R1,R0              DECREMENT LENGTH                      11408000
         CR    R1,R0              IS IT LE 256 YET?                     11409000
         BNL   PSTKOVML           MOVE LONG IF NOT                      11410000
         EX    R1,PSTKOVMV        MOVE REMAINING CHARACTERS             11411000
         BR    RETURN             AND RETURN TO PROPER PLACE            11412000
*                                                                       11413000
PSTKOVMV MVC   PSTKOFS(*-*,R2),PSTKOFS+PSTKENTS*3*4(R2)         MOVE    11414000
*                                 REMAINING CHARACTERS                  11415000
         DROP  NCP                GET RID OF STRANGE BASE REGISTER      11416000
         TITLE 'SPITBOLP -- PATTERN EXIT ROUTINES -- QUICKSCAN MODE'    11417000
*                                                                       11418000
*        IMPORTANT WARNING: IN THE FOLLOWING PAGES, THERE ARE SEVERAL   11419000
*        OCCURENCES OF LR,AR TO SET R1=NCP+MINR. IT LOOKS LIKE THESE    11420000
*        CAN BE REPLACED WITH A FASTER LA INSTRUCTION. THIS IS NOT      11421000
*        THE CASE SINCE SPAN, BREAK ETC. CAN LEAVE THE RESULT NEGATIVE  11422000
*        IN CASES WHERE MINR>0 AND THE LA WILL NOT WORK IN THIS CASE    11423000
*                                                                       11424000
QPATSUBS EQU   *                  START OF QUICKSCAN ROUTINES           11425000
         USING QPATSUBS,PBASE     QUICKSCAN BASE REG SETTING            11426000
*                                                                       11427000
*        SUCC                     SUCCEED (NO ALTERNATIVE)              11428000
*        (PO)                     PATTERN OFFSET                        11429000
*        (CP)                     NEW SETTING OF CP                     11430000
*                                                                       11431000
SUCC     AH    PO,THEN(PB,PO)     POINT OFFSET TO "THEN"                11432000
         LR    R1,CP              COPY CURSOR                           11433000
         AR    R1,MINR            CALCULATE NUMBER OF CHARS LEFT        11434000
         CH    R1,MINMATCH(PB,PO) IS IT ENOUGH?                         11435000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE LOCATION ANYWAY   11436000
         BCR   NL,RETURN          AND OFF TO IT IF WE HAVE ENOUGH CHARS 11437000
         B     LFAIL1             ELSE INDICATE LENGTH FAILURE          11438000
*                                                                       11439000
*        LBACKUP                  BACKUP ON STACK 1 (LENGTH-FAILURE)    11440000
*                                                                       11441000
LBACKUP  SR    PS1,BPS            POP STACK 1                           11442000
         LM    PO,NCP,0(PS1)      LOAD PO,CP,NCP FROM TOP ENTRY         11443000
         LH    R1,EXTEND(PB,PO)   LOAD EXTENSION ROUTINE OFFSET         11444000
         B     QPATSUBS(R1)       OFF TO EXTENSION ROUTINE              11445000
*                                                                       11446000
*        BACKUP                   BACKUP ON STACK 1 (SIGNAL NON-LENGTH) 11447000
*                                                                       11448000
BACKUP   MVI   FAILSW(PDR),X'00'  RESET LENGTH FAIL SWITCH              11449000
         SR    PS1,BPS            POP STACK 1                           11450000
         LM    PO,NCP,0(PS1)      LOAD PO,CP,NCP FOR TOP ENTRY          11451000
         LH    R1,EXTEND(PB,PO)   LOAD EXTEND ROUTINE OFFSET            11452000
         B     QPATSUBS(R1)       OFF TO EXTENSION ROUTINE              11453000
*                                                                       11454000
*        FAIL                     FAIL (WITH AN ALTERNATIVE)            11455000
*        (PO)                     PATTERN OFFSET                        11456000
*        (CP)                     UNCHANGED CURSOR POINTER LOC          11457000
*                                                                       11458000
FAIL     MVI   FAILSW(PDR),X'00'  RESET LENGTH FAIL SWITCH              11459000
         AH    PO,OR(PB,PO)       POINT PATTERN OFFSET TO ALTERNATIVE   11460000
         LR    R1,CP              COPY CURSOR                           11461000
         AR    R1,MINR            ADD TO GET NUMBER OF CHARS LEFT       11462000
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARS?              11463000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11464000
         BCR   NL,RETURN          OFF TO "OR" IF ENOUGH CHARACTERS      11465000
*                                 (ELSE MERGE WITH LFAIL)               11466000
         EJECT                                                          11467000
*                                                                       11468000
*        LFAIL                    FAIL WITH ALTERNATIVE (LENGTH FAIL)   11469000
*        (PO)                     PATTERN OFFSET                        11470000
*        (CP)                     UNCHANGED CURSOR LOCATION             11471000
*                                                                       11472000
LFAIL    LR    R1,CP              COPY CURSOR                           11473000
         AR    R1,MINR            GET NUMBER OF CHARS LEFT              11474000
*                                                                       11475000
*        ENTER HERE WITH (R1) SET TO 1(CP,MINR)                         11476000
*                                                                       11477000
LFAIL1   AH    PO,OR(PB,PO)       POINT PATTERN OFFSET TO ALTERNATIVE   11478000
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARS LEFT?         11479000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE LOCATION          11480000
         BCR   NL,RETURN          OFF TO "OR" CODE IF ENOUGH CHARACTERS 11481000
         B     LFAIL1             LOOP BACK TO TRY NEXT ALTERNATIVE     11482000
*                                                                       11483000
*        SUCCS                    SUCCEED MAKING A STACK 1 ENTRY        11484000
*        (PO)                     PATTERN OFFSET                        11485000
*        (CP)                     UNCHANGED CURSOR POINTER              11486000
*        (NCP)                    UPDATED CURSOR LOCATION               11487000
*                                                                       11488000
SUCCS    STM   PO,CP,0(PS1)       STORE PAT OFFSET, CURSOR LOC ON STACK 11489000
*                                                                       11490000
*        SUCCSP                   ENTRY AFTER MAKING STACK 1 ENTRY      11491000
*                                                                       11492000
SUCCSP   LR    CP,NCP             UPDATE CURSOR LOCATION                11493000
         AH    PO,THEN(PB,PO)     POINT PATTERN OFFSET TO 'THEN'        11494000
         LR    R1,NCP             COPY NEW CURSOR                       11495000
         AR    R1,MINR            GET NUMBER OF CHARS LEFT              11496000
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARS LEFT?         11497000
         BL    SUCCS1             SKIP IF NOT                           11498000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11499000
         BXLE  PS1,BPS,0(RETURN)  OFF TO CODE BUMPING STACK             11500000
         B     PSTAKOV            JUMP TO GIVE STACK OVERFLOW           11501000
*                                                                       11502000
*        COME HERE IF MINMATCH TEST FAILS (INSUFFICIENT CHARACTERS LEFT 11503000
*                                                                       11504000
SUCCS1   BXLE  PS1,BPS,LFAIL1     BUMP STACK, TAKE 'OR' WITH R1 SET     11505000
         LA    RETURN,LFAIL       SET PROPER STACK OVERFLOW EXIT ADDR   11506000
*                                                                       11507000
*        PSTAKOV                  ENTRY TO INCREASE PAT STACK SIZE      11508000
*                                                                       11509000
PSTAKOV  L     NCP,=A(PSTKOV)     GET ROUTINE ADDRESS                   11510000
         BR    NCP                AND OFF TO IT                         11511000
         EJECT                                                          11512000
*                                                                       11513000
*        SUCCER                   SUCCEED AFTER SUCCESSFUL EXTENSION    11514000
*        (PO)                     PATTERN OFFSET                        11515000
*        (CP)                     UPDATED CURSOR LOCATION               11516000
*                                                                       11517000
SUCCER   ST    CP,S1NEWCP(,PS1)   STORE UPDATED CURSOR ON STACK 1       11518000
         AR    PS1,BPS            BUMP STACK ONE PTR (CANNOT OVERFLOW)  11519000
         AH    PO,THEN(PB,PO)     POINT TO "THEN"                       11520000
         LR    R1,CP              COPY CURSOR                           11521000
         AR    R1,MINR            GET NUMBER OF CHARS LEFT              11522000
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARS LEFT?         11523000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11524000
         BCR   NL,RETURN          OFF TO "THEN" IF ENOUGH CHARS         11525000
         B     LFAIL1             ELSE LENGTH FAIL (TAKE ALTERNATIVE)   11526000
*                                                                       11527000
*        SUCCSN                   LIKE SUCCS, BUT WITH NO CP MOVEMENT   11528000
*        (PO)                     PATTERN OFFSET                        11529000
*        (CP)                     UNCHANGED CURSOR POINTER              11530000
*                                                                       11531000
SUCCSN   STM   PO,CP,0(PS1)       MAKE STACK ENTRY                      11532000
         AH    PO,THEN(PB,PO)     POINT TO "THEN"                       11533000
         LR    R1,CP              COPY CURSOR                           11534000
         AR    R1,MINR            GET NUMBER OF CHARACTERS LEFT         11535000
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARACTERS LEFT?    11536000
         BL    SUCCS1             SKIP IF NOT                           11537000
         L     RETURN,CODELOC(PB,PO)        ELSE LOAD CODE POINTER      11538000
         BXLE  PS1,BPS,0(RETURN)  OFF TO CODE BUMPING STACK             11539000
         B     PSTAKOV            STACK OVERFLOW IF WE FALL THROUGH     11540000
         TITLE 'SPITBOLP -- SPECIAL MATCH ROUTINES -- QUICKSCAN MODE'   11541000
*                                                                       11542000
*        IN THIS SECTION ARE MATCH ROUTINES WHICH DIFFER IN FULL        11543000
*        AND QUICKSCAN MODES                                            11544000
*                                                                       11545000
*        ARB MATCH ROUTINE                                              11546000
*                                                                       11547000
MATCHARB LR    NCP,CP             SET FOR INITIAL MATCH OF NULL         11548000
*                                 (MERGE WITH BKX ROUTINE - SAME CODE)  11549000
*                                                                       11550000
*        COMPLETE MATCH FOR BREAKX                                      11551000
*                                                                       11552000
MATCHBKX TS    FAILSW(PDR)        TEST AND RESET FAIL SWITCH            11553000
         BNZ   *+8                SKIP IF NON-ZERO                      11554000
         AL    CP,X80             TURN ON CP SIGN BIT TO SAVE FAILSW    11555000
         STM   PO,NCP,0(PS1)      MAKE STACK ONE ENTRY                  11556000
         B     SUCCSP             AND SUCCEED                           11557000
*                                                                       11558000
*        ARBNO MATCH ROUTINE                                            11559000
*                                                                       11560000
MATCHABN L     NCP,S2CP+S2OFS(,PS2)         CURSOR BEFORE MATCH OF ARG  11561000
         ST    NCP,S1NEWCP(,PS1)  SAVE ON STACK 1 FOR LATER RESTORATION 11562000
         BXH   PS2,BPS,SUCCSN     SUCCEED WITH NO CURSOR MOVEMENT       11563000
*        NOTE -- ABOVE BXH DOES BRANCH -- SEE PRINCIPLES OF OPERATION   11564000
*                                                                       11565000
*        MATCH ROUTINE FOR BAL                                          11566000
*                                                                       11567000
MATCHBAL BAL   RETURN,GBAL        SCAN OUT A BLANKCED STRING            11568000
         TS    FAILSW(PDR)        SET FAIL SWITCH                       11569000
         STM   PO,NCP,0(PS1)      MAKE STACK 1 ENTRY                    11570000
         B     SUCCSP             AND SUCCEED                           11571000
         TITLE 'SPITBOLP -- EXTENSION ROUTINES -- QUICKSCAN MODE'       11572000
*                                                                       11573000
*        CONDITIONS ON ENTRY TO EXTENSION ROUTINE                       11574000
*                                                                       11575000
*        (PO)                     PATTERN OFFSET                        11576000
*        (CP)                     OLD CURSOR POINTER                    11577000
*        (NCP)                    MOST RECENT UPDATED CURSOR VALUE      11578000
*                                                                       11579000
*        ON EXIT FROM AN EXTENSION ROUTINE --                           11580000
*                                                                       11581000
*        ON SUCCESSFUL EXTENSION            SET CP TO UPDATED CURSOR    11582000
*                                           LOC -- BRANCH TO SUCCER     11583000
*                                                                       11584000
*        ON FAILURE TO EXTEND               LEAVE CP,PO SET AS ON ENTRY 11585000
*                                           BRANCH TO FAIL OR LFAIL     11586000
*                                           DEPENDING ON WHETHER FAIL   11587000
*                                           IS A LENGTH FAIL            11588000
*                                                                       11589000
*        ARBEXT                   ARB EXTENSION ROUTINE                 11590000
*                                                                       11591000
ARBEXT   TS    FAILSW(PDR)        TEST AND SET FAIL SWITCH              11592000
         BZ    ARBEX1             SKIP IF IT IS OK TO EXTEND            11593000
         LTR   CP,CP              ELSE SIGN OF CP SHOWS OLD SETTING     11594000
         BP    LFAIL              POSITIVE = SET, SO RETURN             11595000
         LA    CP,0(,CP)          CLEAR OUT THE SIGN BIT                11596000
         B     FAIL               AND FAIL, RESETTING FAILSW TO X'00'   11597000
*                                                                       11598000
*        COME HERE WHEN IT IS OK TO EXTEND                              11599000
*                                                                       11600000
ARBEX1   LR    CP,NCP             LOAD NEW LOCATION                     11601000
         BCT   CP,SUCCER          SUCCEED BUMPING CURSOR                11602000
         B     SUCCER             BRANCH EVEN IF BCT FALLS THROUGH      11603000
*                                                                       11604000
*        BALEXT                   BAL EXTENSION ROUTINE                 11605000
*                                                                       11606000
BALEXT   TS    FAILSW(PDR)        TEST AND SET LENGTH FAIL FLAG         11607000
         BNZ   FAIL               BAL INDICATES NON-LENGTH FAIL HERE    11608000
         BAL   RETURN,GBAL        IF WE HAD A NON-LENGTH FAIL, THEN EXT 11609000
         LR    CP,NCP             LOAD UPDATED CURSOR LOCATION          11610000
         B     SUCCER             AND TAKE EXTENSION ROUTINE SUCCESS    11611000
*                                                                       11612000
*        SUCCEXT                  SUCCEED EXTENSION ROUTINE             11613000
*                                                                       11614000
SUCCEXT  BAL   R2,PTIMTST         TEST FOR OVERTIME                     11615000
         B     SUCCER             AND SIGNAL SUCCESSFUL "EXTENSION"     11616000
*                                                                       11617000
*        FENCEEXT                 FENCE EXTENSION ROUTINE               11618000
*                                                                       11619000
FENCEEXT B     PABORT             FENCE ABORTS WHEN BACKED INTO         11620000
         EJECT                                                          11621000
*                                                                       11622000
*        ANCHEXT                  ANCHOR POINT MOVEMENT ROUTINE         11623000
*                                                                       11624000
ANCHEXT  LTR   PO,PO              TEST HIGH ORDER BYTE OF OFFSET        11625000
         BNZ   EXP1EXT            B IF ANCHORED OR END OF EXPRESSION    11626000
         TS    FAILSW(PDR)        ELSE TEST & SET LENGTH FAIL SWITCH    11627000
         BNZ   PABORT             PATTERN ABORT IF NO NON-LENGTH FAIL   11628000
         LR    CP,NCP             LOAD UPDATED CURSOR LOCATION          11629000
         BCTR  CP,0               BUMP CURSOR ONE CHARACTER             11630000
         ST    CP,S1NEWCP(,PS1)   STORE ANCHOR MOVEMENT                 11631000
         AR    PS1,BPS            BUMP STACK (CANNOT OVERFLOW)          11632000
         LA    PO,PATS            SET OFFSET BACK TO FIRST PATTERN      11633000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11634000
         CH    CP,MINMATCH(PB,PO) CHECK CHARS LEFT (MINR=0 HERE)        11635000
         BCR   NL,RETURN          JUMP TO PATTERN IF CHARS LEFT         11636000
         B     LFAIL              ELSE INDICATE LENGTH FAILURE          11637000
*                                                                       11638000
*        NOTE THAT IF WE RETURN TO ANCHEXT AFTER ALL OF THIS 'OR' CHAIN 11639000
*        LENGTH FAILS FAILSW WILL STILL BE SET, SO WE WILL ABORT        11640000
*                                                                       11641000
*        NOEXT                    USED IN NODES THAT CANNOT EXTEND      11642000
*                                                                       11643000
NOEXT    EQU   LFAIL              TAKE "OR" POINTER                     11644000
*                                                                       11645000
*        DOTEXT                   DOT EXTENSION ROUTINE                 11646000
*                                                                       11647000
DOTEXT   LH    CP,S1ECP(,PS1)     GET CURRENT CURSOR POINTER            11648000
         LH    NCP,S1BCP(,PS1)    GET CURSOR AT START OF DOT PATTERN    11649000
*                                                                       11650000
*        DOLEXT                   DOLLAR EXTENSION ROUTINE              11651000
*                                                                       11652000
DOLEXT   SR    PS2,BPS            GET ROOM ON STACK 2                   11653000
         ST    NCP,S2CP+S2OFS(,PS2)         RESTORE STK2 ENTRY          11654000
         B     LBACKUP            AND BACKUP WITHOUT SIGNALLING LFAIL   11655000
         EJECT                                                          11656000
*                                                                       11657000
*        ENTRY POINTS FOR EXPRESSION (EXP1)                             11658000
*                                                                       11659000
*                                                                       11660000
*        EXP1EXT                  EXTENSION ROUTINE FOR 1ST EXP PATTERN 11661000
*                                                                       11662000
EXP1EXT  BM    PABORT             ABORT IF ANCHORED CALL FROM ANCHEXT   11663000
         LM    PB,PO,S2PB+S2OFS(PS2)        GET PB & PO TO EXP2 PAT     11664000
         AH    MINR,MINMATCH(PB,PO)         RESTORE MINR                11665000
         SH    PO,=Y(LPRM2-PATS)  SET OFFSET TO EXP1 PATTERN            11666000
*                                                                       11667000
*        MARKEXT                  MARK EXTENTION ROUTINE AND END OF EXP 11668000
*                                                                       11669000
MARKEXT  BXH   PS2,BPS,LFAIL      REMOVE STACK 2 ENTRY AND TAKE "OR"    11670000
*                                                                       11671000
*        EXP2EXT                  EXTENSION ROUTINE FOR 2ND EXP PATTERN 11672000
*                                                                       11673000
EXP2EXT  SR    PS2,BPS            MAKE ROOM ON STACK 2                  11674000
         STM   PB,PO,S2PB+S2OFS(PS2)        RESTORE STACK 2 ENTRY       11675000
         SH    MINR,MINMATCH(PB,PO)         RESET MINR FOR LOWER LEVEL  11676000
         LR    PB,CP              LOAD PATTERN BASE FOR * PATTERN       11677000
         B     LBACKUP            AND BACK UP                           11678000
*                                                                       11679000
*        ARBNOEXT                 ARBNO EXTENSION ROUTINE               11680000
*                                                                       11681000
ARBNOEXT LTR   CP,CP              DID WE ALREADY TRY A REMATCH?         11682000
         BM    ARBNEXT1           SKIP IF SO                            11683000
*                                                                       11684000
*        COME HERE AFTER FAILURE IN FOLLOWING PATTERN, REMATCH          11685000
*        THE ARBNO PATTERN UNLESS LAST ITERATION MATCHED NULL           11686000
*                                                                       11687000
         SR    PS2,BPS            RECREATE STACK 2 ENTRY (MARK)         11688000
         ST    CP,S2CP+S2OFS(,PS2)          SAVE NEW STARTING CURSOR    11689000
         CR    CP,NCP             DID LAST ARBNO PATTERN MATCH ANYTHING 11690000
         BE    LBACKUP            IF NOT, BACK INTO ALTERNATIVES        11691000
         MVI   S1OLDCP(PS1),X'80' ELSE SIGNAL NEGATIVE FOR REENTRY      11692000
         S     PO,PARAM1(PB,PO)   POINT BACK TO START OF ARBNO PAT      11693000
         B     SUCCER+4           SUCCEED PAST STM, MAKE STACK 1 ENTRY  11694000
*                                                                       11695000
*        COME HERE SECOND TIME ROUND, RESTORE OLD STARTING CURSOR       11696000
*                                                                       11697000
ARBNEXT1 ST    NCP,S2CP+S2OFS(,PS2)         STORE OLD STARTING CURSOR   11698000
         B     LBACKUP            FORCE ALTERNATIVES                    11699000
         EJECT                                                          11700000
*                                                                       11701000
*        BRKXEXT                  BREAKX EXTEND ROUTINE                 11702000
*                                                                       11703000
BRKXEXT  SR    R0,R0              CLEAR A ZERO                          11704000
         LTR   CP,CP              TEST CP SIGN (OLD FAILSW SETTING)     11705000
         BM    *+6                ZERO IS RIGHT FOR CP MINUS            11706000
         BCTR  R0,0               ELSE GET A FF                         11707000
         LA    CP,0(,CP)          CLEAR OUT FLAG IN CP REGARDLESS       11708000
         TS    FAILSW(PDR)        TEST FAILSW SETTING                   11709000
         STC   R0,FAILSW(PDR)     RESTORE OLD FAILSW SETTING            11710000
         BNZ   LFAIL              NO USE EXTENDING IF ALL LENGTH FAIL   11711000
         L     RETURN,CODELOC(PB,PO)        ELSE RELOAD BASE (CODE LOC) 11712000
         USING PO$BRKX,RETURN     TELL ASSEMBLER                        11713000
         BCT   NCP,PO$BRKX1       OFF TO MERGE POINT EATING BREAK CHAR  11714000
         B     LFAIL              LFAIL IF NO CHARACTERS LEFT           11715000
*                                                                       11716000
*        BRKXDEXT                 BREAKXD EXTEND ROUTNE                 11717000
*                                                                       11718000
BRKXDEXT SR    R0,R0              GET POTENTIAL ZERO FAILSW             11719000
         LTR   CP,CP              TEST OLD FAILSW VALUE                 11720000
         BM    *+6                SKIP IF IT WAS ZERO                   11721000
         BCTR  R0,0               ELSE GET A X'FF'                      11722000
         LA    CP,0(,CP)          CLEAR OUT FLAG IN CP                  11723000
         TS    FAILSW(PDR)        TEST, RESET FAIL SWITCH               11724000
         STC   R0,FAILSW(,PDR)    STORE OLD FAILSW SETTING              11725000
         BNZ   LFAIL              LENGTH FAIL IF ALL AHEAD LFAILED      11726000
         L     RETURN,CODELOC(PB,PO)        RELOAD PAT CODE BASE REG    11727000
         USING PO$BRKXD,RETURN    TELL ASSEMBLER                        11728000
         BCT   NCP,PO$BKXD1       OFF TO MERGE POINT EATING BRK CHAR    11729000
         B     LFAIL              LFAIL IF NO CHARACTERS LEFT           11730000
         DROP  RETURN             GET RID OF BASE REGISTER              11731000
         TITLE 'SPITBOLP -- PATTERN EXIT ROUTINES -- FULLSCAN MODE'     11732000
FPATSUBS EQU   *                  START OF FULLSCAN ROUTINES            11733000
         USING FPATSUBS,PBASE     FULL SCAN BASE REGISTER SETTING       11734000
*                                                                       11735000
*        NOTE -- THE ROUTINES IN THIS SECTION MUST HAVE THE SAME OFFSET 11736000
*        FROM FPATSUBS AS THEIR QUICKSCAN COUNTERPARTS DO FROM QPATSUBS 11737000
*        IN ORDER TO ASSURE THIS THE PORG MACRO IS USED                 11738000
*                                                                       11739000
*NAME    PORG  ,                  POSITIONS THE ROUTINE CORRESPONDING   11740000
*                                 TO NAME CORRECTLY (IT ALSO CHECKS     11741000
*                                 FOR A BACKWARD ORIGIN)                11742000
*                                                                       11743000
*        SUCC                     SUCCEED (NO ALTERNATIVE)              11744000
*        (PO)                     PATTERN OFFSET                        11745000
*        (CP)                     NEW SETTING OF CP                     11746000
*                                                                       11747000
SUCC     PORG  ,                  POSITION                              11748000
         AH    PO,THEN(PB,PO)     POINT TO "THEN"                       11749000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11750000
         BR    RETURN             OFF TO "THEN" CODE                    11751000
*                                                                       11752000
*        LBACKUP                  BACKUP ON STACK 1 (LENGTH FAILURE)    11753000
*                                                                       11754000
LBACKUP  PORG  ,                  POSITION                              11755000
         SR    PS1,BPS            POP STACK 1                           11756000
         LM    PO,NCP,0(PS1)      LOAD PO,CP,NCP FROM TOP ENTRY         11757000
         LH    R1,EXTEND(PB,PO)   LOAD EXTENSION ROUTINE OFFSET         11758000
         B     FPATSUBS(R1)       OFF TO EXTENSION ROUTINE              11759000
*                                                                       11760000
*        BACKUP                   BACKUP ON STACK 1 (SIGNAL NON-LENGTH) 11761000
*                                                                       11762000
BACKUP   PORG  ,                  POSITION                              11763000
         SR    PS1,BPS            POP STACK 1                           11764000
         LM    PO,NCP,0(PS1)      LOAD PO,CP,NCP FROM TOP ENTRY         11765000
         LH    R1,EXTEND(PB,PO)   LOAD EXTENSION ROUTINE OFFSET         11766000
         B     FPATSUBS(R1)       OFF TO EXTENSION ROUTINE              11767000
*                                                                       11768000
*        FAIL                     FAIL WITH ALTERNATIVE                 11769000
*        (PO)                     PATTERN OFFSET                        11770000
*        (CP)                     UNCHANGED CURSOR POINTER LOC          11771000
*                                                                       11772000
FAIL     PORG  ,                  POSITION                              11773000
         AH    PO,OR(PB,PO)       POINT TO ALTERNATIVE                  11774000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11775000
         BR    RETURN             OFF TO CODE FOR "OR"                  11776000
         EJECT                                                          11777000
*                                                                       11778000
*        LFAIL                    FAIL WITH ALTERNATIVE (LENGTH FAIL)   11779000
*                                                                       11780000
LFAIL    PORG  ,                  POSITION                              11781000
         AH    PO,OR(PB,PO)       LOAD POINTER TO ALTERANTIVE           11782000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11783000
         BR    RETURN             OFF TO CODE FOR "OR"                  11784000
*                                                                       11785000
*        SUCCS                    SUCCEED MAKING A STACK 1 ENTRY        11786000
*        (PO)                     PATTERN OFFSET                        11787000
*        (CP)                     UNCHANGED CURSOR POINTER              11788000
*        (NCP)                    UPDATED CURSOR POINTER                11789000
*                                                                       11790000
SUCCS    PORG  ,                  POSITION                              11791000
         STM   PO,CP,0(PS1)       STORE PAT PTR, CURSOR LOC ON STACK1   11792000
*                                                                       11793000
*        SUCCSP                   ENTRY AFTER MAKING STACK ONE ENTRY    11794000
*                                                                       11795000
SUCCSP   PORG  ,                  POSITION (ACTUALLY DOES NOTHING)      11796000
         AH    PO,THEN(PB,PO)     POINT TO "THEN"                       11797000
         LR    CP,NCP             LOAD UPDATED CURSOR LOC               11798000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11799000
         BXLE  PS1,BPS,0(RETURN)  OFF TO "THEN" BUMPING STACK           11800000
         B     FPSTAKOV           STACK OVERFLOW IF FALL THROUGH        11801000
*                                                                       11802000
*        PSTAKOV                  ENTRY TO INCREASE STACK 1 & 2 SIZE    11803000
*                                                                       11804000
PSTAKOV  PORG  ,                  POSITION                              11805000
         L     NCP,=A(PSTKOV)     GET BASE REGISTER FOR ROUTINE         11806000
         BR    NCP                AND OFF TO IT                         11807000
*                                                                       11808000
*        SUCCER                   SUCCEED AFTER SUCCESSFUL EXTENSION    11809000
*        (PO)                     PATTERN OFFSET                        11810000
*        (CP)                     UPDATED CURSOR LOCATION               11811000
*                                                                       11812000
SUCCER   PORG  ,                  POSITION                              11813000
         ST    CP,S1NEWCP(,PS1)   STORE NEW UPDATED CURSOR LOC          11814000
         AH    PO,THEN(PB,PO)     LOAD POINTER TO "THEN"                11815000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE LOCATION          11816000
         BXLE  PS1,BPS,0(RETURN)  OFF TO "THEN" BUMPING STACK           11817000
*                                 (ABOVE BXLE CANNOT FALL THROUGH)      11818000
*                                                                       11819000
*        SUCCSN                   LIKE SUCCS, BUT WITH NO CP MOVEMENT   11820000
*        (PO)                     PATTERN OFFSET                        11821000
*        (CP)                     UNCHANGED CURSOR POINTER              11822000
*                                                                       11823000
SUCCSN   PORG  ,                  POSITION                              11824000
         STM   PO,CP,0(PS1)       MAKE STACK ENTRY                      11825000
         AH    PO,THEN(PB,PO)     LOAD POINTER TO "THEN"                11826000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11827000
         BXLE  PS1,BPS,0(RETURN)  OFF TO CODE BUMPING STACK             11828000
         B     FPSTAKOV           STACK OVERFLOW IF FALL THROUGH        11829000
         TITLE 'SPITBOLP -- SPECIAL MATCH ROUTINES -- FULLSCAN MODE'    11830000
*                                                                       11831000
*        IN THIS SECTION ARE ROUTINES FOR MATCHING WHICH DIFFER IN      11832000
*        FULLSCAN AND QUICKSCAN MODES                                   11833000
*                                                                       11834000
*                                                                       11835000
*        MATCH ROUTINE FOR ARB                                          11836000
*                                                                       11837000
MATCHARB PORG  ,                  POSITION                              11838000
         LR    NCP,CP             SET FOR INITIAL MATCH OF NULL         11839000
*                                 (MERGE WITH CODE FOR BRKX)            11840000
*                                                                       11841000
*        COMPLETE MATCH FOR BREAKX                                      11842000
*                                                                       11843000
MATCHBKX PORG  ,                  POSITION (SHOULD DO NOTHING)          11844000
         STM   PO,NCP,0(PS1)      MAKE STACK 1 ENTRY                    11845000
         B     FSUCCSP            AND SUCCEED                           11846000
*                                                                       11847000
*        ARBNO MATCH ROUTINE                                            11848000
*                                                                       11849000
MATCHABN PORG  ,                  POSITION                              11850000
         BXH   PS2,BPS,FSUCCSN    REMOVE MARK ENTRY AND SUCCEED         11851000
*                                                                       11852000
*        MATCH ROUTINE FOR BAL                                          11853000
*                                                                       11854000
MATCHBAL PORG  ,                  POSITION                              11855000
         BAL   RETURN,GBAL        SCAN OUT A BALANCED STRING            11856000
         STM   PO,NCP,0(PS1)      MAKE PO/CP/NCP STACK 1 ENTRY          11857000
         B     FSUCCSP            AND SUCCEED                           11858000
         TITLE 'SPITBOLP -- EXTENSION ROUTINES -- FULLSCAN MODE'        11859000
*                                                                       11860000
*        CONDITIONS ON ENTRY TO EXTENSION ROUTINE                       11861000
*                                                                       11862000
*        (PO)                     PATTERN OFFSET                        11863000
*        (CP)                     OLD CURSOR POINTER                    11864000
*        (NCP)                    MOST RECENT UPDATED CURSOR VALUE      11865000
*                                                                       11866000
*        ON EXIT FROM AN EXTENSION ROUTINE --                           11867000
*                                                                       11868000
*        ON SUCCESSFUL EXTENSION            SET CP TO UPDATED CURSOR    11869000
*                                           LOC -- BRANCH TO SUCCER     11870000
*                                                                       11871000
*        ON FAILURE TO EXTEND               LEAVE CP,PO SET AS ON ENTRY 11872000
*                                           BRANCH TO FAIL OR LFAIL     11873000
*                                           DEPENDING ON WHETHER FAIL   11874000
*                                           IS A LENGTH FAIL            11875000
*                                                                       11876000
*                                                                       11877000
*        THE FOLLOWING DEFINITIONS MUST BE USED WHEN UNDER CONTROL OF - 11878000
*        USING FPATSUBS,PBASE                                           11879000
*                                                                       11880000
FSUCCER  EQU   SUCCER+FPATSUBS-QPATSUBS     FULLSCAN NAME FOR SUCCER    11881000
FFAIL    EQU   FAIL+FPATSUBS-QPATSUBS       FULLSCAN NAME FOR FAIL      11882000
FLFAIL   EQU   LFAIL+FPATSUBS-QPATSUBS      FULLSCAN NAME FOR LFAIL     11883000
FSUCCSN  EQU   SUCCSN+FPATSUBS-QPATSUBS     FULLSCAN NAME FOR SUCCSN    11884000
FSUCC    EQU   SUCC+FPATSUBS-QPATSUBS       FULLSCAN NAME FOR SUCC      11885000
FSUCCSP  EQU   SUCCSP+FPATSUBS-QPATSUBS     FULLSCAN NAME FOR SUCCSP    11886000
FSUCCS   EQU   SUCCS+FPATSUBS-QPATSUBS      FULLSCAN NAME FOR SUCCS     11887000
FLBACKUP EQU   LBACKUP+FPATSUBS-QPATSUBS    FULLSCAN NAME FOR LBACKUP   11888000
FEXP1EXT EQU   EXP1EXT+FPATSUBS-QPATSUBS    FULLSCAN NAME FOR EXP1EXT   11889000
FPSTAKOV EQU   PSTAKOV+FPATSUBS-QPATSUBS    FULLSCAN NAME FOR PSTAKOV   11890000
*                                                                       11891000
*                                                                       11892000
*        ARBEXT                   ARB EXTENSION ROUTINE                 11893000
*                                                                       11894000
ARBEXT   PORG  ,                  POSITION                              11895000
         LTR   NCP,NCP            TEST NUMBER OF CHARS LEFT             11896000
         BZ    FLFAIL             LENGTH FAIL IF NO CHARS LEFT          11897000
         BAL   R2,PTIMTST         TEST FOR OVERTIME                     11898000
         LR    CP,NCP             COPY CURSOR                           11899000
         BCT   CP,FSUCCER         OFF TO SUCCER BUMPING STACK           11900000
         B     FSUCCER            BRANCH EVEN IF BCT FALLS THROUGH      11901000
*                                                                       11902000
*        BALEXT                   BAL EXTENSION ROUTINE                 11903000
*                                                                       11904000
BALEXT   PORG  ,                  POSITION                              11905000
         BAL   RETURN,GBAL        EXTEND MATCHED PART                   11906000
         LR    CP,NCP             LOAD UPDATED LOCATION                 11907000
         B     FSUCCER            SUCCEED                               11908000
         EJECT                                                          11909000
*                                                                       11910000
*        SUCCEXT                  SUCCEED EXTENSION ROUTINE             11911000
*                                                                       11912000
SUCCEXT  PORG  ,                  POSITION                              11913000
         BAL   R2,PTIMTST         TEST FOR OVERTIME                     11914000
         B     FSUCCER            AND SUCCEED                           11915000
*                                                                       11916000
*        FENCEEXT                 FENCE EXTENSION ROUTINE               11917000
*                                                                       11918000
FENCEEXT PORG  ,                  POSITION                              11919000
         B     PABORT             PATTERN ABORT WHEN BACKED INTO        11920000
*                                                                       11921000
*        ANCHNEXT                 ANCHOR POINT MOVEMENT ROUTINE         11922000
*                                                                       11923000
ANCHEXT  PORG  ,                  POSITION                              11924000
         LTR   PO,PO              TEST MODE (HIGH ORDER BIT OF OFFSET)  11925000
         BNZ   FEXP1EXT           B IF ANCHORED OR END OF EXPRESSION    11926000
         BCTR  NCP,0              MOVE CURSOR ONE CHARACTER             11927000
         ST    NCP,S1NEWCP(,PS1)  STORE ANCHOR MOVEMENT                 11928000
         AR    PS1,BPS            BUMP STACK POINTER (CANNOT OVERFLOW)  11929000
         LA    PO,PATS            INITIALIZE OFFSET TO FIRST PATTERN    11930000
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER           11931000
         LTR   CP,NCP             SET AND TEST CURSOR POSITION          11932000
         BCR   NM,RETURN          OFF TO CODE UNLESS OF END OF STRING   11933000
         B     PABORT             IN WHICH CASE -- ABORT MATCH          11934000
*                                                                       11935000
*        NOEXT                    USED IN NODES THAT CANNOT EXTEND      11936000
*                                                                       11937000
*NOEXT   EQU   LBACKUP            BACK UP ON STACK ONE                  11938000
*                                                                       11939000
*        DOTEXT                   DOT EXTENSION ROUTINE                 11940000
*                                                                       11941000
DOTEXT   PORG  ,                  POSITION                              11942000
         LH    CP,S1ECP(,PS1)     GET CURRENT CURSOR POINTER            11943000
         LH    NCP,S1BCP(,PS1)    GET CURSOR AT START OF DOT PATTERN    11944000
*                                                                       11945000
*        DOLEXT                   DOLLAR EXTENSION ROUTINE              11946000
*                                                                       11947000
DOLEXT   PORG  ,                  POSITION (SHOULD DO NOTHING)          11948000
         SR    PS2,BPS            GET ROOM ON STACK 2                   11949000
         ST    NCP,S2CP+S2OFS(,PS2)         RESTORE STACK 2 ENTRY       11950000
         B     FLBACKUP           AND BACKUP                            11951000
         EJECT                                                          11952000
*                                                                       11953000
*        EXP1EXT                  EXTENSION ROUTINE FOR 1ST EXP PATTERN 11954000
*                                                                       11955000
EXP1EXT  PORG  ,                  POSITION                              11956000
         BM    PABORT             ABORT IF ANCHORED ON CALL FROM ANCHEX 11957000
         LM    PB,PO,S2PB+S2OFS(PS2)        GET PB & PO TO EXP2         11958000
         AH    MINR,MINMATCH(PB,PO)         RESTORE MINR                11959000
         SH    PO,=Y(LPRM2-PATS)  SET OFFSET TO EXP1 PATTERN            11960000
*                                                                       11961000
*        MARKEXT                  MARK EXTENTION ROUTINE AND END OF EXP 11962000
*                                                                       11963000
MARKEXT  PORG  ,                  THIS SHOULD HAVE NO EFFECT            11964000
         BXH   PS2,BPS,FLFAIL     REMOVE STACK 2 ENTRY AND TAKE "OR"    11965000
*                                                                       11966000
*        EXP2EXT                  EXTENSION ROUTINE FOR 2ND EXP PATTERN 11967000
*                                                                       11968000
EXP2EXT  PORG  ,                  POSITION                              11969000
         SR    PS2,BPS            MAKE ROOM ON STACK 2                  11970000
         STM   PB,PO,S2PB+S2OFS(PS2)        RESTORE STACK 2 ENTRY       11971000
         SH    MINR,MINMATCH(PB,PO)         RESET MINR FOR LOWER LEVEL  11972000
         LR    PB,CP              LOAD PATTERN BASE FOR * PATTERN       11973000
         B     FLBACKUP           AND BACKUP                            11974000
*                                                                       11975000
*        ARBNOEXT                 ARBNO EXTENSION ROUTINE               11976000
*                                                                       11977000
ARBNOEXT PORG  ,                  POSITION                              11978000
         BAL   R2,PTIMTST         TEST FOR OVERTIME                     11979000
         SR    PS2,BPS            RECREATE DUMMY STACK 2 ENTRY          11980000
         S     PO,PARAM1(PB,PO)   POINT BACK TO REMATCH                 11981000
         B     FSUCC              AND SUCCED TO REMATCH PATTERN         11982000
*                                                                       11983000
*        BRKXEXT                  BREAKX EXTEND ROUTINE                 11984000
*                                                                       11985000
BRKXEXT  PORG  ,                  POSITION                              11986000
         L     RETURN,CODELOC(PB,PO)        RELOAD CODE LOCATION        11987000
         USING PO$BRKX,RETURN     TELL ASSEMBLER BASE IS LOADED         11988000
         BCT   NCP,PO$BRKX1       JUMP TO MERGE POINT EATING BREAK CHAR 11989000
         B     LFAIL              LFAIL IF NO CHARACTERS LEFT           11990000
*                                                                       11991000
*        BRKXDEXT                 BREAKXD EXTEND ROUTINE                11992000
*                                                                       11993000
BRKXDEXT PORG  ,                  POSITION                              11994000
         L     RETURN,CODELOC(PB,PO)        RELOAD CODE LOCATION        11995000
         USING PO$BRKXD,RETURN    TELL ASSEMBLER                        11996000
         BCT   NCP,PO$BKXD1       JUSMP TO MERGE POINT EATING BREAK CHR 11997000
         B     LFAIL              LFAIL IF NO CHARACTERS LEFT           11998000
         DROP  RETURN                                                   11999000
*                                                                       12000000
         DC    20F'0'             PATCH SPACE FOR SPITBOLP              12001000
         USING SPITBOLD,DB1       DB1 IS DATA BASE REGISTER AGAIN       12002000
         TITLE 'SPITBOLX -- START OF CONTROL SECTION'                   12003000
*                                                                       12004000
*        THIS CONTROL SECTION CONTAINS RUN TIME ROUTINES WHICH ARE NOT  12005000
*        ADDRESSABLE UNDER THE SYS REGISTER IN SPITBOLA                 12006000
*                                                                       12007000
*        EACH ROUTINE IN THIS SECTION MUST ESTABLISH ITS OWN            12008000
*        ADDRESSABILITY -- IN MANY CASES, THE ACTUAL ENTRY POINTS ARE   12009000
*        IN SPITBOLA, WHICH SETS A BASE REGISTER AND BRANCHES TO THE    12010000
*        APPROPRIATE LOCATION IN SPITBOLX                               12011000
*                                                                       12012000
*                                                                       12013000
*        NOTE THAT ALL ROUTINES IN THIS CONTROL SECTION ARE ALWAYS      12014000
*        RESIDENT (UNLIKE THE FUNCTIONS IN SPITBOLF)                    12015000
*                                                                       12016000
         BEGIN X                  START OF SPITBOLX, SPITBLLX CSECT     12017000
         USING SPITBOLA,SYS       THIS BASE REG IS USED THROUGHOUT      12018000
         TITLE 'SPITBOLX -- REGISTER DEFINITIONS'                       12019000
*                                                                       12020000
*        DEFINITIONS OF BRANCH CODES FOR BCR INSTRUCTIONS               12021000
*                                                                       12022000
NO       EQU   14                 CONDITION CODE FOR NOT ONES           12023000
NL       EQU   11                 CONDITION CODE FOR NOT LOW CONDITION  12024000
NZ       EQU   7                  CONDITION CODE FOR NOT ZERO CONDITION 12025000
H        EQU   2                  CONDITION CODE FOR HIGH               12026000
L        EQU   4                  CONDITION CODE FOR LOW                12027000
P        EQU   2                  CONDITION CODE FOR POSITIVE           12028000
NE       EQU   7                  CONDITION CODE FOR THE NE CONDITION   12029000
NH       EQU   13                 CONDITION CODE FOR NOT HIGH           12030000
NP       EQU   13                 CONDITION CODE FOR NOT POSITIVE       12031000
E        EQU   8                  CONDITION CODE FOR EQUAL CONDITION    12032000
M        EQU   4                  CONDITION CODE FOR MINUS BRANCH       12033000
Z        EQU   8                  CONDITION CODE FOR ZERO               12034000
O        EQU   1                  CONDITION CODE FOR ONES               12035000
NM       EQU   11                 CONDITION CODE FOR NOT MINUS          12036000
CZ       EQU   2                  CONDITION CODE FOR CARRY (ZERO RESLT) 12037000
*                                                                       12038000
*        REGISTER DEFINITIONS FOR EXECUTE PACKAGE                       12039000
*                                                                       12040000
*R0      EQU   0                  SCRATCH REGISTER                      12041000
*R1      EQU   1                  SCRATCH REGISTER                      12042000
*R2      EQU   2                  SCRATCH REGISTER                      12043000
FR       EQU   3                  FREE STORAGE POINTER                  12044000
A1       EQU   4                  A1,A1+1 ACCUMULATOR 1                 12045000
A2       EQU   6                  A2,A2+1 ACCUMULATOR 2                 12046000
DB1      EQU   8                  1ST DATA BASE                         12047000
DB2      EQU   9                  2ND DATA BASE                         12048000
DB3      EQU   10                 3RD DATA BASE                         12049000
DB4      EQU   11                 4TH (VARIABLE) DATA BASE              12050000
FRETURN  EQU   12                 FAILURE RETURN REGISTER               12051000
RETURN   EQU   13                 RETURN REGISTER (PRIMARY LINKAGE REG) 12052000
SYS      EQU   14                 SYSTEM BASE REGISTER                  12053000
PDR      EQU   15                 MAIN STACK POINTER                    12054000
*                                                                       12055000
*        THE FOLLOWING DEFINITIONS ARE USED DURING PATTERN MATCHING     12056000
*                                                                       12057000
FSADR    EQU   3                  POINTS ONE PAST STRING BEING MATCHED  12058000
BPS      EQU   4                  CONTAINS THE STACK INCREMENT 12       12059000
PS2      EQU   5                  STACK 2 POINTER (ALSO STACK 1 LIMIT)  12060000
PS1      EQU   6                  STACK 1 POINTER                       12061000
PB       EQU   7                  PATTERN BASE REGISTER                 12062000
PO       EQU   8                  PATTERN OFFSET REGISTER               12063000
CP       EQU   9                  CURSOR (NUMBER OF CHARACTERS LEFT)    12064000
NCP      EQU   10                 UPDATED (NEW) CURSOR LOCATION         12065000
MINR     EQU   11                 MINUS NUM CHARS NEEDED ON HIGHER LEVS 12066000
PBASE    EQU   12                 PATTERN BASE (QPATSUBS OR FPATSUBS)   12067000
         TITLE 'SPITBOLX -- STACK USAGE AND DEFINITIONS'                12068000
*                                                                       12069000
*              STACK USAGE                                              12070000
*                                                                       12071000
*              NOTE THAT IT IS DESIRABLE TO ALLIGN STM FIELDS ON        12072000
*              DOUBLE WORD BOUNDARIES FOR THE LARGER MACHINES     TO    12073000
*              ACCOMPLISH THIS IT IS NECESSARY THAT EACH STACK MOVEMENT 12074000
*              BE A MULTIPLE OF 8 BYTES     INCLUDE A PAD WORD IF NEC.  12075000
*                                                                       12076000
STACKTOP EQU   2048               TOP OF CURRENT STACK LEVEL            12077000
*                                                                       12078000
LASTEM   EQU   STACKTOP           LAST TEMPORARY ON LEVEL ABOVE         12079000
*                                                                       12080000
PDRBPTR  EQU   STACKTOP-4         POINTER TO LAST PDR LOCATION ABOVE US 12081000
*                                                                       12082000
FBLOKLOC EQU   PDRBPTR-4          FUNCTION BLOCK ADDRESS                12083000
*                                 FUNCTION TEMPS ARE ON LEVEL ABOVE     12084000
*                                                                       12085000
RETFLOC  EQU   FBLOKLOC-4         CODE RETURN ADDR FROM THIS FUNCTION   12086000
*                                                                       12087000
FRETFLOC EQU   RETFLOC-4          FAILURE RETURN ADDR (DBL WORD ALLIGN) 12088000
*                                                                       12089000
EVLINK   EQU   FRETFLOC-4         LINKAGE FOR EVAL                      12090000
*                                                                       12091000
MATCHPB  EQU   EVLINK-2           CURSOR POINTER AT START OF MATCH      12092000
*                                                                       12093000
MATCHPE  EQU   MATCHPB-2          CURSOR POINTER AT END OF MATCH        12094000
*                                                                       12095000
PNAME    EQU   MATCHPE-8          NAME BLOCK FOR PAT ASSIGN (DBLWRD)    12096000
*                                                                       12097000
PSTRING  EQU   PNAME-8            ORIGINAL STRING SPEC FOR PAT ASSGN    12098000
*                                 DOUBLE WORD ALLIGN                    12099000
*                                                                       12100000
STACKBOT EQU   PSTRING            BOTTOM OF STANDARD STACK INFORMATION  12101000
*                                                                       12102000
STACKSIZ EQU   STACKTOP-STACKBOT  SIZE OF STANDARD STACK INFORMATION    12103000
*                                                                       12104000
TEM#1    EQU   STACKBOT-8         FIRST TEMPORARY LOCATION (DBLWRD)     12105000
*                                                                       12106000
TEM#2    EQU   TEM#1-8            SECOND TEMPORARY LOCATION             12107000
*                                                                       12108000
TEM#3    EQU   TEM#2-8            THIRD TEMPORARY LOCATION              12109000
*                                                                       12110000
TEM#4    EQU   TEM#3-8            FOURTH TEMPORARY LOCATION             12111000
*                                                                       12112000
*        THE FOLLOWING ARE ALTERNATE NAMES FOR LOCATIONS USED OVER      12113000
*        A CALL TO A PROGRAMER DEFINED TRACE FUNCTION                   12114000
*        EVERYTHING ON THE LEVEL PUSHED BY PDTRC IS USABLE SINCE        12115000
*        THE CALLED FUNCTION WILL PUSH ANOTHER LEVEL                    12116000
*                                                                       12117000
TRLINK   EQU   EVLINK             LINKAGE IS SAVED OVER EVLINK          12118000
*                                                                       12119000
TRVTRC   EQU   MATCHPE            INTEGER VALUE OF &TRACE SAVED IN      12120000
*                                 MATCHPE OVER PROG DEF TRACE CALL      12121000
TRVBLOCK EQU   PSTRING            SAVE VARIABLE BLOCK ADDR IN PSTRING   12122000
*                                 SINCE IT IS NOT RELOCATABLE           12123000
         EJECT                                                          12124000
*                                                                       12125000
*        STACK LOCATIONS USED DURING PATTERN MATCH                      12126000
*        NOTE THAT STACK1 & 2 MAY BE EXPANDED BY MOVING PDR DURING      12127000
*        A MATCH.  THEREFORE ONLY THOSE LOCATIONS AT STACK 1 AND BELOW  12128000
*        CAN BE REFERENCED SYMBOLICALLY WITHOUT PICKING UP PDRLOC       12129000
*                                                                       12130000
RETLOCP  EQU   STACKBOT-4         RETURN LOCATION FROM PATTERN MATCH    12131000
*                                                                       12132000
FRETLOCP EQU   RETLOCP-4          FAILURE RETURN FROM PAT MATCH DBLWORD 12133000
*                                                                       12134000
STACK2   EQU   FRETLOCP-4         TOP OF PATTERN STACK 2                12135000
*                                                                       12136000
S2OFS    EQU   2*3*4              2 ENTRY OFFSET ON STACK 2 FOR OVERFLO 12137000
*                                                                       12138000
PSTKENTS EQU   100                ALLOW 100 STACK 1 & 2 ENTRIES AT      12139000
*                                 START. THIS IS EXPANSION AMOUNT ALSO. 12140000
*                                                                       12141000
STACK1   EQU   STACK2-PSTKENTS*3*4          BOTTOM OF STACK 1           12142000
*                                                                       12143000
ORGPB    EQU   STACK1-4           STARTING PATTERN BASE                 12144000
*                                                                       12145000
PSTGLEN  EQU   ORGPB-2            LENGTH FIELD FROM PSTRING             12146000
*              THIS IS DONE SO LENGTH CAN BE GOTTEN W/O LOAD OF PDRLOC  12147000
*                                                                       12148000
DOTSW    EQU   PSTGLEN-1          SWITCH SET TO ZERO IF NO DOTS DONE    12149000
*                                                                       12150000
FAILSW   EQU   PSTGLEN-2          FAILURE FLAG FOR PATTERN MATCH        12151000
*                                                                       12152000
PENDWRD  EQU   FAILSW             PATEND SAVEAREA - OLD VALS NT NEEDED  12153000
*                                                                       12154000
PSAVDB1  EQU   FAILSW-4           LOCATION TO SAVE DATAAREA ADDR IN MAT 12155000
*                                                                       12156000
PSAVPBAS EQU   PSAVDB1-4          CURRENT SCAN MODE BASE                12157000
*                                                                       12158000
PSAVMINR EQU   PSAVPBAS-4         NEGATIVE CHARS REQUIRED ABOVE US      12159000
*                                                                       12160000
PSAVNCP  EQU   PSAVMINR-4         CURRENT NCP VALUE                     12161000
*                                                                       12162000
PSAVCP   EQU   PSAVNCP-4          CURRENT CURSOR VALUE                  12163000
*                                                                       12164000
PSAVPO   EQU   PSAVCP-4           CURRENT PATTERN OFFSET                12165000
*                                                                       12166000
PSAVPB   EQU   PSAVPO-4           CURRENT PATTERN BASE                  12167000
*                                                                       12168000
PSAVPS1  EQU   PSAVPB-4           CURRENT STACK 1 LOCATION (DBL WORD)   12169000
*                                                                       12170000
PSAVPS2  EQU   PSAVPS1-4          CURRENT STACK 2 LOCATION              12171000
*                                                                       12172000
PSAVBPS  EQU   PSAVPS2-4          STACK INCREMENT (12) (DOUBLE WORD)    12173000
         EJECT                                                          12174000
*                                                                       12175000
PSTKOFS  EQU   PSAVBPS/8*8        RESERVE ROOM AT BOTTOM FOR CHARACTER  12176000
*                                 TABLES  MUST BE >= 256+8 BYTES        12177000
*                                                                       12178000
PATSPACE EQU   STACKTOP-PSTKOFS   ROOM FOR PATTERN STACK BEFORE EXPAND  12179000
*                                                                       12180000
ANCLOC   EQU   STACK1+S1PATOFS    LOCATION OF ANCHOR FLAG (SEE $$PTN2)  12181000
*                                                                       12182000
         TITLE 'SPITBOLX -- GARBAGE COLLECTOR'                          12183000
*                                                                       12184000
*        THE GARBAGE COLLECTOR OPERATES IN FOUR PASSES AS FOLLOWS       12185000
*                                                                       12186000
*        PASS 1                                                         12187000
*        ------                                                         12188000
*                                                                       12189000
*        THIS IS A MARKING PHASE SIMILAR TO THAT USED IN LISP -- WITH   12190000
*        THE ADDITIONAL OPERATION OF BACK-CHAINING ALL REFERENCES.      12191000
*        THE "GARBAGE COLLECTION FIELD" OF EACH BLOCK IN THE DYNAMIC    12192000
*        STORAGE AREA IS USED TO POINT TO A LINKED LIST OF ADDRESSES    12193000
*        WHICH SHOULD POINT TO THE BLOCK AFTER RELOCATION. IF THIS      12194000
*        FIELD IS ZERO AFTER PASS 1 THEN THE BLOCK IS NOT IN USE AND    12195000
*        MAY BE DELETED.                                                12196000
*                                                                       12197000
*        PASS 2                                                         12198000
*        ------                                                         12199000
*                                                                       12200000
*        IN THIS PASS, A POINTER IS MOVED THROUGH THE DYNAMIC STORAGE   12201000
*        AREA, AND ANOTHER POINTER KEEPS TRACK OF WHERE THE BLOCKS      12202000
*        THAT ARE STILL IN USE WILL END UP WHEN THEY ARE FINALLY MOVED  12203000
*        NO ACTUAL MOVING OF BLOCKS TAKES PLACE IN THIS PASS. WHEN WE   12204000
*        COME TO A BLOCK THAT IS IN USE, ALL POINTERS TO THE BLOCK      12205000
*        ARE RELOCATED. THE GARBAGE COLLECTION FIELDS ARE SET TO FORM   12206000
*        A LINKED LIST OF BLOCKS IN USE FOR THE NEXT PASS.              12207000
*                                                                       12208000
*        PASS 3                                                         12209000
*        ------                                                         12210000
*                                                                       12211000
*        PASS 3 IS ONLY USED IF LABELS OR OTHER POINTERS INTO           12212000
*        RELOCATABLE CODE (CODE,EVAL) ARE TO BE RELOCATED. DURING PASS  12213000
*        THREE, ANY SUCH POINTERS ARE RELOCATED USING THE NEW VALUE     12214000
*        IN THE CODNLOC FIELD SET DURING PASS TWO.                      12215000
*                                                                       12216000
*        PASS 4                                                         12217000
*        ------                                                         12218000
*                                                                       12219000
*        IN THE LAST PASS, WE GO DOWN THE CHAIN OF BLOCKS IN USE,       12220000
*        MOVING THEM TO THEIR NEW LOCATIONS AND ZEROING THE GCF.        12221000
         EJECT                                                          12222000
*                                                                       12223000
*        REGISTER DEFINITIONS FOR GCOL                                  12224000
*                                                                       12225000
OLD      EQU   A1                 POINTER TO OLD FREE CORE LOCATION     12226000
NEW      EQU   A2                 POINTER TO NEW FREE CORE LOCATION     12227000
LAST     EQU   A2+1               POINTER TO LAST BLOCK IN USE (PASS2)  12228000
MSK      EQU   A1+1               HOLDS X'00FFFFFF' TO MASK ADDRESSES   12229000
LIM      EQU   FR                 END OF DYNAMIC STORAGE AREA           12230000
GR1      EQU   DB2                PASS 1 PTR TO FIELD TO BE PROCESSED   12231000
MINUS8   EQU   DB3                PASS 1 BXH DECREMENT REGISTER         12232000
GR3      EQU   DB4                PASS 1 BXH END REGISTER, BLK PTR      12233000
GR2      EQU   FRETURN            PASS 1 BAL REGISTER FOR PTRPROC       12234000
BOT      EQU   OLD                BOTTOM OF DYNAMIC STORAGE (PASS 1)    12235000
CLIM     EQU   GR1                PASS 2 SBLOKCOMPRESS CHAR USED        12236000
COLD     EQU   GR2                PASS 2 SBLOK PTS TO USED CHARACTERS   12237000
CNEW     EQU   GR3                PASS 2 SBLOK COMPRESS DESTINATION ADD 12238000
COFF     EQU   MINUS8             PASS 2 DELETED CHARACTERS AHEAD REG   12239000
*                                                                       12240000
*                                                                       12241000
*        ENTRY AND INITIALIZATION FOR PASS 1                            12242000
*                                                                       12243000
*        NOTE THAT IT IS VERY IMPORTANT THAT THE FIRST PTRPROC CALL BE  12244000
*        AFTER THE LABEL GCOLBASE - MAKE SURE THIS OCCURS               12245000
*        REGISTER USAGE/CONTENTS RULES ARE VERY STRICT                  12246000
*        (GR3)                    NON-ZERO MULTIPLE OF FOUR IN PASS1    12247000
*        (R2)                     UPPER 3 BYTES ZERO IN PASS1           12248000
*        CHECK SPECIFIC ROUTINES FOR OTHER RULES                        12249000
*                                                                       12250000
         USING GCOL,R1            BASE REG SET AT ENTRY POINT           12251000
GCOL     STM   0,15,GCOLSV        SAVE REGISTERS                        12252000
         LR    NEW,FR             SET FOR CHECK IN CASE CORE IS EMPTY   12253000
         AP    GCOLCNT,=P'1'      INCREMENT COUNT OF COLLECTIONS        12254000
         LR    RETURN,R1          SWITCH BASE REGS                      12255000
         USING GCOL,RETURN        TELL ASSEMBLER                        12256000
         DROP  R1                 DROP TEMP BASE                        12257000
         L     MSK,=X'00FFFFFF'   LOAD MASK REGISTER                    12258000
         L     BOT,DYNAMB         LOAD START OF FREE CORE               12259000
         LH    MINUS8,=H'-8'      INITIALIZE BXH REGISTER               12260000
         SR    R2,R2              CLEAR R2 FOR PTRPROC USE              12261000
         MVI   ZTBL+X'47',1       SETUP TRT TABL TO SCAN FOR CODE NOP'S 12262000
         MVI   LABRLFLG,0         RESET LABEL RELOCATION FLAG           12263000
         LR    GR3,FR             MAKE SURE GR3 IS DIVISIBLE BY 4       12264000
         STD   ZR,GPCHAIN         CLEAR GPCHAIN, GECHAIN                12265000
*                                                                       12266000
*        THE FOLLOWING CODE IMPLEMENTS THE HEURISTIC APPROACH OF        12267000
*        DOING A SUPER (COMPACTING) GARBAGE COLLECTION AT LEAST         12268000
*        EVERY TEN NORMAL COLLECTIONS SO THAT WE DO NOT MESS AROUND     12269000
*        DOING LOTS OF COLLECTIONS WHICH COULD BE AVOIDED               12270000
*                                                                       12271000
         CLI   GCOLCNT+2,X'9C'    LOW ORDER DIGIT OF COUNT = 9 ?        12272000
         BNE   GCOL1              SKIP IF NOT                           12273000
         OI    GCOLNRG,GCMPRSS    ELSE SET FOR COMPRESSION              12274000
         EJECT                                                          12275000
*                                                                       12276000
*        PASS 1                                                         12277000
*        ------                                                         12278000
*                                                                       12279000
*        COME HERE TO CHECK FOR SPECIAL CASE OF GBGCLF CALL             12280000
*                                                                       12281000
GCOL1    L     PDR,PDRLOC         RESET STACK TO BASE OF THIS LEVEL     12282000
         TM    GCOLNRG,GGBGCLF    CHECK FOR GBGCLF CALL                 12283000
         BNO   PASS1S             SKIP IF NOT GBGCLF CALL               12284000
*                                                                       12285000
*        FOR GBGCLF, BACK OFF RETURN TO RECALL THE FUNCTION             12286000
*                                                                       12287000
         ST    PDR,GCOLSV+4*PDR   SET TO GET PROPER PDR FOR FUNC RETRY  12288000
         LA    GR1,TEM#1+8(,PDR)  INITIALIZE PTR TO NO TEMPS            12289000
         L     R2,RETLOC          LOAD RETURN LOCATION                  12290000
         SH    R2,H12             BACK OFF TWELVE BYTES                 12291000
         CLC   6(2,R2),SRPDRR1    IS THIS SR  PDR,R1 ?                  12292000
         BNE   *+12               SKIP IF NO TEMPS IN USE BEFORE FUNC   12293000
         SH    GR1,4(,R2)         ELSE ADJUST PTR FOR EXTRA TEMPS       12294000
         SH    R2,H6              ADJUST FOR SR, AND LA                 12295000
         TM    6(R2),DB4*16       IS DB4 THE BASE REGISTER?             12296000
         BNO   *+8                SKIP IF NOT                           12297000
         SH    R2,H4              BACK FOR L DB4,BASEADDR               12298000
         ST    R2,GCOLSV+4*RETURN SAVE RETURN LOCATION                  12299000
         EX    0,0(,R2)           EXECUTE INSTRUC TO GET NUMBER OF ARGS 12300000
         SLL   R0,3               *8=ROOM ON STACK                      12301000
         SR    GR1,R0             ADJUST PTR FOR FUNCTION ARG TEMPS     12302000
         SR    R2,R2              RECLEAR R2 FOR PTRPROC CALLS          12303000
*                                                                       12304000
*        COME HERE WITH BOT = LIM TO SET UP BASE REGISTER FOR GCOLCHK   12305000
*                                                                       12306000
GCOLCHK1 LA    RETURN,GCOLBASE    SET UP BASE REGISTER VALUE            12307000
         USING GCOLBASE,RETURN    TELL ASSEMBLER                        12308000
         CR    BOT,LIM            PROTECT AGAINST INITIAL COLLECT CALL  12309000
         BL    PASS1SE            PROCESS TEMPS IF CORE USED            12310000
         B     GCOLCHK            EXIT IF NO CORE USED                  12311000
         USING GCOL,RETURN        PUT BACK OLD BASE REGISTER            12312000
*                                                                       12313000
SRPDRR1  SR    PDR,R1             USED TO CHECK FOR STK ADJ IN FUNC CAL 12314000
         EJECT                                                          12315000
*                                                                       12316000
*        PASS 1 -- CONTINUED                                            12317000
*        -------------------                                            12318000
*                                                                       12319000
*        FIRST UNWIND THE PDR STACK                                     12320000
*                                                                       12321000
*        THIS FIRST SECTION  (WHICH IS SOMEWHAT MESSY) SCANS THE CODE   12322000
*        AT THE POINT OF CALL TO DETERMINE HOW MANY TEMPORARIES ARE IN  12323000
*        USE -- GR1 IS SET TO POINT TO LAST TEMPORARY IN USE            12324000
*                                                                       12325000
PASS1S   CR    BOT,LIM            CHECK FOR CORE EMPTY                  12326000
         BNL   GCOLCHK1           JUMP IF CORE IS EMPTY                 12327000
         L     R1,RETLOC          ELSE LOAD CODE RETURN LOCATION        12328000
         LA    GR1,TEM#1+8(,PDR)  INITIALIZE GR1 TO NO TEMPS IN USE     12329000
         B     PASS1SL            OFF TO TEST FIRST INSTRUCTION         12330000
*                                                                       12331000
*        WE LOOK FORWARD THROUGH THE CODE TO FIND THE NEXT TEMPORARY    12332000
*        REFERENCED.  IF THE REFERENCE IS A LM THEN THE S ADDR IS THAT  12333000
*        OF THE LAST TEMP WE MUST SAVE.  IF THE REFERENCE IS A STM      12334000
*        THE LAST TEMP WE SAVE IS 8 BYTES HIGHER                        12335000
*                                                                       12336000
*        COME HERE TO BUMP PAST FOUR BYTE INSTRUCTION                   12337000
*                                                                       12338000
PASS1RX1 LA    R1,4(,R1)          SKIP PAST FOUR BYTES                  12339000
*                                                                       12340000
*        COME HERE TO TEST NEXT INSTRUCTION (FOR RR OR RX)              12341000
*                                                                       12342000
PASS1SL  TM    0(R1),X'C0'        TEST FOR RR INSTRUCTION               12343000
         BM    PASS1SRX           SKIP IF NOT                           12344000
         CLI   0(R1),X'3E'        IS IT AN AUR?                         12345000
         LA    R1,2(,R1)          ALWAYS SKIP OVER 2 BYTES              12346000
         BNE   PASS1SL            LOOP BACK IF NOT END OF STATEMENT     12347000
         B     PASS1ST            ELSE ALL DONE IF AUR                  12348000
*                                                                       12349000
*        COME HERE IF FOUR BYTE INSTRUCTION                             12350000
*                                                                       12351000
PASS1SRX CLC   0(4,R1),BEVLR1     B $$EVLR AT END OF EXPRESSION?        12352000
         BE    PASS1ST            END OF CODE SCAN IF SO (NO TEMPS)     12353000
         TM    2(R1),PDR*16       ELSE IS IT PDR REFERENCE (PDR=15)     12354000
         BNO   PASS1RX1           SKIP PAST INSTRUCTION IF NOT          12355000
         LH    R0,2(,R1)          GET S ADDRESS                         12356000
         CLI   0(R1),X'98'        IS IT A LM?                           12357000
         BE    *+16               FOUND HIGHEST TEMP IF SO              12358000
         CLI   0(R1),X'90'        ELSE IS IT STM?                       12359000
         BNE   PASS1RX1           SKIP OVER IT IF NOT                   12360000
         AH    R0,H8              POINT TO LAST TEMP USED               12361000
         STH   R0,GBGLA+2         STORE S ADDRESS FOR LA                12362000
         EX    0,GBGLA            LOAD ADDRESS OF LAST TEMP USED        12363000
*                                                                       12364000
*        COME HERE TO SET UP BASE REGISTER FOR REST OF COLLECT          12365000
*                                                                       12366000
PASS1ST  LA    RETURN,GCOLBASE    POINT BASE REGISTER TO NEW LOCATION   12367000
         USING GCOLBASE,RETURN    TELL ASSEMBLER                        12368000
         CNOP  0,4                GCOLBASE MUST BE FULLWORD ALLIGNED    12369000
GCOLBASE EQU   *                  BASE ADDR POINT AFTER INITIALIZATION  12370000
         EJECT                                                          12371000
*                                                                       12372000
*        PASS 1 -- CONTINUED                                            12373000
*        -------------------                                            12374000
*                                                                       12375000
*        COME HERE WHEN CURRENT LEVEL OF STACK IS NOT PATTERN MATCH     12376000
*        (GR1) POINTING TO HIGHEST TEMPORARY LOCATION IN USE            12377000
*                                                                       12378000
         CNOP  0,4                TAKE BOUNDARY ALLIGN OUT OF LOOP      12379000
PASS1SE  LA    LAST,TEM#1(,PDR)   GET LOWEST POSSIBLE TEMPORARY LOC     12380000
         CR    GR1,LAST           DO WE ACTUALLY HAVE TEMPS IN USE?     12381000
         BH    PASS1EM            SKIP IF NOT                           12382000
         LPR   NEW,MINUS8         GET BXLE CONSTANT=+8                  12383000
*                                                                       12384000
*        LOOP TO PROCESS TEMPORARIES IN USE AT THIS LEVEL               12385000
*                                                                       12386000
         CNOP  0,4                ALLIGNMENT FOR BAL                    12387000
         BAL   GR2,PTRPROCV       PROCESS A TEMPORARY                   12388000
         BXLE  GR1,NEW,*-4        LOOP UNTIL ALL PROCESSED              12389000
*                                                                       12390000
*        NOW DEAL WITH PSTRING,PNAME IF IN USE (PNAME NON-ZERO)         12391000
*                                                                       12392000
PASS1EM  CE    ZR,PNAME(,PDR)     TEST TO SEE IF PNAME IN USE           12393000
         BE    PASS1ET            SKIP IF NOT IN USE                    12394000
*                                                                       12395000
*        COME HERE TO PROCESS PSTRING AND PNAME                         12396000
*                                                                       12397000
         CNOP  0,4                ALLIGN NEXT TWO PTRPROC CALLS         12398000
PASS1EP  LA    GR1,PNAME(,PDR)    POINT TO PNAME                        12399000
         BAL   GR2,PTRPROC        PROCESS IT (CANNOT BE NULL)           12400000
         LA    GR1,PSTRING(,PDR)  POINT TO PSTRING                      12401000
         BAL   GR2,PTRPROCV       PROCESS IT                            12402000
*                                                                       12403000
*        ENTER HERE WITH EVERYTHING DEALT WITH EXCEPT FBLOKLOC          12404000
*        THIS LOCATION TELLS US WHAT THE PREVIOUS LEVEL OF THE STACK IS 12405000
*                                                                       12406000
*        1)    FBLOKLOC > 0       PREVIOUS LEVEL WAS FUNCTION CALL      12407000
*                                 (FBLOKLOC POINTS TO FBLOK)            12408000
*                                                                       12409000
*        2)    FBLOKLOC = 0       CURRENT LEVEL IS UNEVALUATED EXPR     12410000
*                                 PREVIOUS LEVEL IS PATTERN MATCH       12411000
*                                 IF CC IN EVLINK IS ZERO               12412000
*                                                                       12413000
*        3)    FBLOKLOC < 0       FLAG FOR BOTTOM OF STACK              12414000
*                                                                       12415000
PASS1ET  L     R0,FBLOKLOC(,PDR)  LOAD TO TEST IT                       12416000
         LTR   R0,R0              TEST IT                               12417000
         BP    PASS1F             SKIP IF FUNCTION                      12418000
         BM    PASS1V             SKIP IF END OF STACK, ELSE MERGE      12419000
         EJECT                                                          12420000
*                                                                       12421000
*        PASS 1 -- CONTINUED                                            12422000
*        -------------------                                            12423000
*                                                                       12424000
*                                                                       12425000
*        IF FBLOKLOC WAS ZERO, THEN THIS LEVEL OF THE STACK             12426000
*        WAS AN EVALUATION OF AN UNEVALUATED EXPRESSION.  IF THE        12427000
*        CONDITION CODE FIELD IN EVLINK IS ZERO, THE LEVEL ABOVE US     12428000
*        IS A PATTERN MATCH.                                            12429000
*                                                                       12430000
         TM    EVLINK(PDR),X'30'  TEST CONDITION CODE                   12431000
         BNZ   PASS1F1            MERGE WITH FUNCTION PROCESSION IF     12432000
*                                 IT IS EVAL FUNCTION CALL              12433000
*                                                                       12434000
*        COME HERE IF LEVEL ABOVE IS A PATTERN MATCH                    12435000
*        NOTE THAT THE LOWEST PDR USED IN MATCH IS CURRENT PDR+PATSPACE 12436000
*                                                                       12437000
         CNOP  0,4                ALLIGN PTRPROC CALLS ON FULLWORD      12438000
         LA    GR1,ORGPB+PATSPACE(,PDR)     POINT TO PATTERN POINTER    12439000
         BAL   GR2,PTRPROC        PROCESS IT                            12440000
         LA    GR1,PSAVPB+PATSPACE(,PDR)    POINT TO CURRENT PB IN REG  12441000
         BAL   GR2,PTRPROC        PROCESS IT                            12442000
         L     LAST,PSAVPS1+PATSPACE(,PDR)  GET TOP OF STACK1 ADDR      12443000
         LA    NEW,3*4            GET BXLE INCREMENT                    12444000
         LA    GR1,STACK1+S1OLDCP+PATSPACE(,PDR)      POINT TO FIRST    12445000
*              (DUMMY) FIELD ON STACK 1 - MAKES SURE THERE IS A FIELD   12446000
         CNOP  0,4                ALLIGN BAL CALL TO PTRPROC            12447000
         BAL   GR2,PTRPROCV       PROCESS IT                            12448000
         BXLE  GR1,NEW,*-4        LOOP UNTIL ALL ENTRIES ARE PROCESSED  12449000
*                                                                       12450000
*        COME HERE TO PROCESS STACK 2 ENTRIES                           12451000
*                                                                       12452000
         L     GR1,PSAVPS2+PATSPACE(,PDR)   GET CURRENT STACK 2 POINTER 12453000
         LA    GR1,S2OFS+S2PB(,GR1)         POINT TO FIRST RELOC FIELD  12454000
         L     PDR,PDRBPTR(,PDR)  POSITION PDR TO PAT MATCH LEVEL       12455000
         LA    LAST,STACK2-2*3*4+S2PB(,PDR) POINT TO END OF STACK 2     12456000
         CNOP  0,4                ALLIGN CALL TO PTRPROC                12457000
         BAL   GR2,PTRPROCV       PROCESS IT                            12458000
         BXLE  GR1,NEW,*-4        LOOP UNTIL STACK PROCESSED            12459000
         LA    GR1,RETLOCP(,PDR)  POINT TO PATTERN RETURN SAVE LOC      12460000
         BAL   GR2,PTRPROCL       PROCESS POSSIBLE RELOCATABLE LABEL    12461000
         LA    GR1,FRETLOCP(,PDR) POINT TO PATTERN FRETURN SAVE LOC     12462000
         BAL   GR2,PTRPROCL       PROCESS POSSIBLE RELOCATABLE LABEL    12463000
*                                                                       12464000
*        COME HERE WITH STACKS PROCESSED TO FINISH UP                   12465000
*                                                                       12466000
         B     PASS1EP            PROCESS PNAME, PSTRING, & NEXT LEVEL  12467000
         EJECT                                                          12468000
*                                                                       12469000
*        PASS 1 -- CONTINED                                             12470000
*        ------------------                                             12471000
*                                                                       12472000
*                                                                       12473000
*        COME HERE WHEN PREVIOUS LEVEL IS A FUNCTION CALL               12474000
*                                                                       12475000
         CNOP  0,4                ALLIGN CALL TO PTRPROC                12476000
PASS1F   LA    GR1,FBLOKLOC(,PDR) POINT TO FUNCTION BLOCK POINTER       12477000
         BAL   GR2,PTRPROC        PROCESS FUNCTION POINTER              12478000
*                                                                       12479000
*        MERGE HERE FOR CASE OF EVAL FUNCTION CALLED ABOVE US           12480000
*                                                                       12481000
PASS1F1  LA    GR1,RETFLOC(,PDR)  POINT TO SAVED VALUE OF (RETURN)      12482000
         BAL   GR2,PTRPROCL       PROCESS POSSIBLE RELOCATABLE CODE LOC 12483000
         LA    GR1,FRETFLOC(,PDR) POINT TO SAVED VALUE OF (FRETURN)     12484000
         BAL   GR2,PTRPROCL       PROCESS POSSIBLE RELOCATABLE CODE LOC 12485000
         LA    GR1,LASTEM(,PDR)   POINT TO LAST TEMPORARY ON LEVEL UP   12486000
         L     PDR,PDRBPTR(,PDR)  RESTORE PDR FOR LEVEL ABOVE           12487000
         B     PASS1SE            AND OFF TO PROCESS TEMPORARIES        12488000
*                                                                       12489000
*        COME HERE WHEN STACK HAS BEEN PROCESSED                        12490000
*        NOW WE MUST PROCESS 8-BYTE CONSTANT BLOCKS IN VARIABLE BLOCKS  12491000
*        THIS IS DONE ONLY DURING CONSTANT EXPRESSION EVALUATION OR IF  12492000
*        THE COMPILER HAS BEEN USED AT EXECUTE TIME (CRELFLG SET)       12493000
*                                                                       12494000
         CNOP  0,4                ALLIGN PTRPROC CALL IN LOOP           12495000
PASS1V   CLI   CRELFLG,0          TEST SPECIAL FLAG                     12496000
         BZ    PASS1VB            SKIP TO PROCESS VAR BLKS IF OFF       12497000
         SR    NEW,NEW            SET OFFSET TO $$BAS1 ENTRY            12498000
*                                                                       12499000
*        LOOP TO PROCESS A 4K VARIABLE BLOCK FOR CONSTANTS              12500000
*        NOTE THAT THE FIRST POINTER PROCESSED IN EACH BLOCK IS THE     12501000
*        CBLKEND WORD, WHICH ASSURES AT LEAST ONE 8 BYTE ENTRY          12502000
*        PROCESSING THIS FIELD WORKS SINCE LEFTMOST BYTE IS ZERO        12503000
*                                                                       12504000
PASS1C   L     LAST,$$BAS1(NEW)   LOAD NEXT BASE TABLE ENTRY            12505000
         LA    LAST,VALUE(,LAST)  POINT TO ACTUAL START OF BLOCK        12506000
         LA    GR1,CBLKEND(,LAST) POINT TO FIRST CONSTANT BLK (DUMMY)   12507000
         L     GR3,CBLKBOT(,LAST) LOAD ADDRESS OF LOWEST CONSTANT BLOCK 12508000
         AR    GR3,MINUS8         BACK UP TO SATISFY BXH ON LAST LOOP   12509000
         CNOP  0,4                MAKE SURE PTRPROC CALL IS ALLIGNED    12510000
         BAL   GR2,PTRPROCV       PROCESS A CONSTANT BLOCK              12511000
         BXH   GR1,MINUS8,*-4     LOOP UNTIL ALL BLOCKS PROCESSED       12512000
         LA    NEW,4(,NEW)        PUSH TO NEXT BASE TABLE ENTRY         12513000
         CH    NEW,CURBASE        HAVE WE EXCEEDED BASE TABLE ENTRIES?  12514000
         BNH   PASS1C             LOOP BACK IF NOT                      12515000
         LTER  SINC,SINC          ARE WE IN CONSTANT EXPRESSIONS?       12516000
         BZ    PASS1SP            NO NEED TO PROC VARBLKS IF SO         12517000
         EJECT                                                          12518000
*                                                                       12519000
*        HERE WE PROCESS VARIABLE BLOCKS FOR THE NORMAL CASE OF A       12520000
*        GARBAGE COLLECTION DURING EXECUTION PROPER                     12521000
*                                                                       12522000
         CNOP  0,4                PUT PTRPROC CALLS ON FULLWORD         12523000
PASS1VB  L     LAST,HASHTBAD      LOAD ADDRESS OF MAIN HASH TABLE       12524000
         LA    NEW,HASHTBNS+1     GET BCT VALUE FOR LOOP                12525000
         B     PASS1VE            AND GO OFF TO LOAD A SLOT VALUE       12526000
*                                                                       12527000
*        COME HERE WHEN A VARIABLE BLOCK IS FOUND TO PROCESS FIELDS     12528000
*                                                                       12529000
PASS1VL  LA    GR1,VALUE(,GR3)    POINT TO VALUE FIELD                  12530000
         BAL   GR2,PTRPROCV       AND PROCESS IT                        12531000
         LA    GR1,VFUNC(,GR3)    POINT TO FUNCTION POINTER             12532000
         BAL   GR2,PTRPROC        PROCESS IT                            12533000
         LA    GR1,VIOPTR(,GR3)   POINT TO IOBLOCK POINTER              12534000
         BAL   GR2,PTRPROC        PROCESS IT                            12535000
         LA    GR1,VNAME(,GR3)    POINT TO NAME FIELD                   12536000
         BAL   GR2,PTRPROC        PROCESS IT (WE KNOW RELOC BIT IS ON)  12537000
         LA    GR1,VLABL(,GR3)    LOAD LABEL POINTER                    12538000
         BAL   GR2,PTRPROCL       PROCESS IT WITH SPECIAL LABEL ROUTINE 12539000
         L     GR3,VLINK(,GR3)    MOVE OUT ON LINK                      12540000
*                                                                       12541000
*        COME HERE TO CHECK FOR ZERO LINK FIELD                         12542000
*                                                                       12543000
PASS1VN  NR    GR3,MSK            CLEAR LEFT BYTE, SET CONDITION CODE   12544000
         BNZ   PASS1VL            PROCESS VARIABLE IF NOT END OF LINK   12545000
*                                                                       12546000
*        COME HERE TO PICK UP NEXT HASH SLOT ENTRY                      12547000
*                                                                       12548000
PASS1VE  L     GR3,VLINK(,LAST)   PICK UP NEXT SLOT VALUE               12549000
         LA    LAST,4(,LAST)      PUSH SLOT POINTER                     12550000
         BCT   NEW,PASS1VN        OFF TO TEST FOR LINK END IF NOT TBLND 12551000
*                                                                       12552000
*        COME HERE WHEN WE HAVE PROCESSED ALL VARIABLE BLOCKS           12553000
*                                                                       12554000
*        NOW DEAL WITH SPECIAL SYSTEM RELOCATABLE FIELDS                12555000
*                                                                       12556000
*                                                                       12557000
         CNOP  2,4                ALLIGN FOLLOWING PTRPROC CALLS        12558000
PASS1SP  LA    GR1,ANYTPTR        POINT TO TABLE POINTER FOR ANY/NOTANY 12559000
         LR    GR3,FR             SET GR3 NONZERO, DIVISIBLE BY 4       12560000
         BAL   GR2,PTRPROCS       PROCESS IT IF TABLE IS IN USE         12561000
         CE    ZR,ANYTPTR         DO WE HAVE A TABLE IN USE?            12562000
         BNZ   *+8                SKIP IF SO                            12563000
         MVI   ANYMASK,0          CLEAR MASK TO GET NEW TABLE NEXT TIME 12564000
         LA    GR1,PCFRSAVE       POINT TO PATTERN CONCAT RELOCATABLE   12565000
         BAL   GR2,PTRPROCS       PROCESS IT IF USED ELSEWHERE TOO      12566000
         CE    ZR,PCFRSAVE        TEST FOR UNUSED ADDRESS FOR PAT ADDR  12567000
         BNZ   *+8                SKIP IF ADDRESS FIELD SAVED           12568000
         STE   ZR,SCNTSAVE        ELSE CLEAR OUT STATEMENT NUMBER TOO   12569000
         EJECT                                                          12570000
*                                                                       12571000
*        NOW RELOCATE SAVED REGISTERS IF REQUESTED                      12572000
*                                                                       12573000
         CNOP  0,4                ALLIGN PTRPROC CALLS TO FULLWORD      12574000
         TM    GCOLNRG,GRELOC1+GRELOC2      TEST FOR RELOC OF REGS      12575000
         BZ    PASS1SP0           SKIP IF NONE                          12576000
         BM    *+12               SKIP IF ONLY ONE                      12577000
         LA    GR1,GCOLSV+4*A2    POINT TO SAVED VALUE OF A2            12578000
         BAL   GR2,PTRPROCV       PROCESS IT AS VALUE                   12579000
         LA    GR1,GCOLSV+4*A1    POINT TO SAVED VALUE OF A1            12580000
         BAL   GR2,PTRPROCV       PROCESS IT AS VALUE                   12581000
*                                                                       12582000
*        COME HERE TO PROCESS POINTERS USED FOR TRACING                 12583000
*                                                                       12584000
PASS1SP0 LA    GR1,FNCLTRC        POINT TO FNCLEVEL CHAIN HEAD          12585000
         BAL   GR2,PTRPROC        PROCESS IT                            12586000
         LA    GR1,STCNTTRC       POINT TO CHAIN HEAD FOR STCOUNT       12587000
         BAL   GR2,PTRPROC        PROCESS IT                            12588000
         LA    GR1,ETYPTRC        POINT TO PTR FOR ERRTYPE TRACE        12589000
         BAL   GR2,PTRPROC        PROCESS IT                            12590000
         LA    GR1,FCTRCCHN       POINT TO CALL TRACE CHAIN HEAD        12591000
         BAL   GR2,PTRPROC        PROCESS IT                            12592000
         LA    GR1,FRTRCCHN       POINT TO RETURN TRACE CHAIN           12593000
         BAL   GR2,PTRPROC        PROCESS IT                            12594000
         LA    GR3,OPTRTABL-4     STOP ADDRESS FOR OPTR TABLE RELOC     12595000
         LA    GR1,NOPTRS*4(,GR3) FIRST (LAST) TABLE ENTRY TO RELOC     12596000
*                                                                       12597000
*        COME HERE TO PROCESS NEXT UNDEFINED OPERATOR TABLE ENTRY       12598000
*                                                                       12599000
PASS1SPA BAL   GR2,PTRPROC        PROCESS IT                            12600000
         LA    GR1,4(,GR1)        CORRECT FOR BXH SUBTRACT OF EIGHT     12601000
         BXH   GR1,MINUS8,PASS1SPA          DECREMENT TBL ENTRY PTR, LP 12602000
         EJECT                                                          12603000
*                                                                       12604000
*        NOW WE MUST PROCESS THE POINTER USED TO OPTIMIZE CONCATENATION 12605000
*        WE ONLY WISH TO HOLD THE STRING IF THERE IS ANOTHER POINTER    12606000
*        TO THE ENTIRE STRING, SINCE THAT IS THE OPTIMIZATION           12607000
*        REQUIREMENT.                                                   12608000
*                                                                       12609000
         LM    NEW,LAST,CONCFRSV+4          LOAD SBLOK PTR,OFFSET & LEN 12610000
         LTR   NEW,NEW            TEST FOR POINTER IN USE               12611000
         BZ    PASS1SPX           SKIP IF NOT USED                      12612000
         STE   ZR,CONCFRSV+4      ZERO POINTER IN CASE WE ABANDON IT    12613000
         CE    ZR,0(,NEW)         IS ANYONE ELSE POINTING TO IT?        12614000
         BE    PASS1SPX           ABANDON STRING IF NO OTHER POINTERS   12615000
         CLI   0(NEW),SBLOK       MAKE SURE THIS IS AN SBLOK            12616000
         BNE   PASS1SPX           ABANDON IT IF PATTERN BLOCK           12617000
         L     GR1,0(,NEW)        LOAD START OF POINTER CHAIN           12618000
*                                                                       12619000
*        THIS LOOP GOES OUT ON CHAIN LOOKING FOR AN IDENTICAL SUBSTRG   12620000
*                                                                       12621000
PASS1SPL C     LAST,4(,GR1)       DO THE SUBSTRINGS MATCH?              12622000
         BE    PASS1SP1           PROCESS POINTER IF MATCH              12623000
         TM    3(GR1),1           CHECK FOR END OF POINTER CHAIN        12624000
         L     GR1,0(,GR1)        MOVE OUT ON POINTER CHAIN             12625000
         BNO   PASS1SPL           AND LOOP BACK IF NOT AT END           12626000
         B     PASS1SPX           ELSE NOT ALL IN USE, SO ABANDON IT    12627000
*                                                                       12628000
*        COME HERE WHEN SBLOK SHOULD BE RETAINED - PROCESS POINTER      12629000
*                                                                       12630000
         CNOP  0,4                ALLIGN PTRPROC CALL TO FULLWORD       12631000
PASS1SP1 ST    NEW,CONCFRSV+4     RESTORE POINTER FOR CONCAT OPTIMIZE   12632000
         LA    GR1,CONCFRSV+4     POINT TO FIELD TO BE RELOCATED        12633000
         BAL   GR2,PTRPROC        PROCESS IT - WE KNOW IT IS RELOCATABL 12634000
         EJECT                                                          12635000
*                                                                       12636000
*        PASS 1 -- CONTINUED                                            12637000
*        -------------------                                            12638000
*                                                                       12639000
*        NOW WE MUST PROCESS MISCELLANEOUS CODE LOCATIONS SINCE THEY    12640000
*        MAY REFER TO RELOCATABLE CHUNKS OF CODE. HOWEVER, WE DO NOT    12641000
*        PERFORM THIS PROCESSING IF WE ARE AT FUNCTION LEVEL ZERO AND   12642000
*        WE WERE CALLED FROM THE ORIGINAL GENERATED CODE. THIS HELPS    12643000
*        TO AVOID HANGING ONTO UNNECCESSARY GARBAGE CODE BLOCKS.        12644000
*                                                                       12645000
PASS1SPX EQU   *                  PASS1 ENTRY - (GR3) IS NON-ZERO       12646000
*                                                                       12647000
*        THE FOLLOWING CODE IS ALSO USED IN PASS 3 WHERE SIMILAR        12648000
*        PROCESSING MUST BE PERFORMED                                   12649000
*                                                                       12650000
PASS13SL CE    ZR,V$FNCLEV        TEST FUNCTION LEVEL                   12651000
         BNZ   PASS1LLL           SKIP TO PROCESS IF &FNCLEVEL#0        12652000
         L     R0,RETLOC          LOAD CURRENT CODE LOCATION            12653000
         NR    R0,MSK             CLEAR POSSIBLE UPPER BYTE             12654000
         CR    R0,BOT             BEFORE DYNAMIC CORE?                  12655000
         BL    PASS13SE           SKIP PROCESSING IF SO                 12656000
         CR    R0,LIM             BEYOND DYNAMIC CORE?                  12657000
         BNL   PASS13SE           SKIP PROCESSING IF PAST DYNAMIC CORE  12658000
*                                                                       12659000
*        HERE WE MUST PROCESS THESE LOCATIONS                           12660000
*        (GR1)                    WILL BE DESTROYED IF LTBLOK ADDRESS   12661000
*                                                                       12662000
         CNOP  0,4                ALIGN PTRPROCL CALL                   12663000
PASS1LLL LA    GR1,SRETSV         POINT TO TABLE SAVE LOCATION          12664000
         BAL   GR2,PTRPROCL       PROCESS IT                            12665000
         LA    GR1,RETURN*4+GCOLSV          POINT TO GCOL RETURN REG    12666000
         BAL   GR2,PTRPROCL       PROCESS IT                            12667000
         LA    GR1,FRETURN*4+GCOLSV         POINT TO SAVED FRETURN ADDR 12668000
         BAL   GR2,PTRPROCL       AND PROCESS IT                        12669000
         LA    LAST,LINKLOCS      POINT TO START OF LOCATIONS           12670000
         LA    GR1,LINKLOCS       POINT TO LOCATIONS, KEEP ALIGNMENT    12671000
         LA    NEW,ENDLINKS       LOAD END OF LIST ADDRESS FOR TESTS    12672000
*                                                                       12673000
*        COME HERE TO PROCESS NEXT ENTRY IN LOCATION TABLE              12674000
*                                                                       12675000
         CNOP  0,4                MAKE SURE WE ARE STILL ON FULLWORD    12676000
PASS1LL  BAL   GR2,PTRPROCL       PROCESS POINTER                       12677000
         LA    LAST,4(,LAST)      POINT TO NEXT LOCATION                12678000
         LR    GR1,LAST           COPY POINTER IN CASE GR1 DESTROYED    12679000
         CR    GR1,NEW            CHECK FOR TABLE END                   12680000
         BL    PASS1LL            BACK IF MORE TO GO                    12681000
*                                                                       12682000
*        HERE WHEN THIS LABEL PROCESSING IS COMPLETE                    12683000
*                                                                       12684000
PASS13SE LTR   GR3,GR3            TEST PASS1/PASS3 FLAG                 12685000
         BNZ   PASS2              OFF TO PASS 2 IF WE ARE ENDING PASS 1 12686000
         B     PASS4              ELSE START PASS 4 IF ENDING PASS 3    12687000
         EJECT                                                          12688000
*                                                                       12689000
*        PTRPROC -- BLOK PROCESSING ROUTINES                            12690000
*        -----------------------------------                            12691000
*                                                                       12692000
*                                                                       12693000
*        PDFBLOKP                 PROGRAM DEFINED DATATYPE FUNCTION     12694000
*                                                                       12695000
         CNOP  0,4                ALLIGN CALL TO PTRPROC                12696000
PDFBLOKP LA    GR1,PDMODL+4(,GR3) POINT TO THE POINTER TO THIS BLOCK    12697000
         BAL   GR2,PTRPROC        USE PTRPROC TO PROCESS IT             12698000
         LA    R2,PDFBLOK         GET BLOCK CODE FOR RESTORE            12699000
         B     PTRPOP             RETURN                                12700000
*                                                                       12701000
*        FFBLOKP                  FIELD FUNCTION                        12702000
*                                                                       12703000
         CNOP  0,4                ALLIGN CALL TO PTRPROC                12704000
FFBLOKP  LA    GR1,PDFPTR(,GR3)   PICK UP PDFBLOK POINTER ADDRESS       12705000
         BAL   GR2,PTRPROC        PROCESS IT                            12706000
         LA    GR1,FFBLNEXT(,GR3) POINT TO NEXT FFBLOK WITH SAME NAME   12707000
         BAL   GR2,PTRPROC        PROCESS IT                            12708000
         LA    R2,FFBLOK          GET BLOCK CODE FOR RESTORE            12709000
         B     PTRPOP             ALL DONE                              12710000
*                                                                       12711000
*        PDBLOKP                  PROGRAM DEFINED DATATYPE              12712000
*                                                                       12713000
         CNOP  2,4                ALLIGN CALL TO PTRPROC ON FULLWORD    12714000
PDBLOKP  IC    R2,NBYTESD(,GR3)   LOAD LENGTH OF BLOCK                  12715000
         LA    GR1,0(R2,GR3)      POINT PAST BLOCK                      12716000
         AR    GR1,MINUS8         POINT TO LAST VALUE FIELD             12717000
         BAL   GR2,PTRPROCV       PROCESS A VALUE FIELD                 12718000
         BXH   GR1,MINUS8,*-4     LOOP UNTIL ALL FIELDS PROCESSED       12719000
         LA    GR1,PDFPTR(,GR3)   POINT TO PDFBLOK POINTER              12720000
         BAL   GR2,PTRPROC        AND PROCESS IT                        12721000
         LA    R2,PDBLOK          RESTORE PROPER BLOCK CODE             12722000
         B     PTRPOP             AND RETURN                            12723000
*                                                                       12724000
*        ABLOKP                   ARRAY                                 12725000
*                                                                       12726000
*        NOTE THAT THE SUBFACS AND ASPEC ARE TREATED AS VALUE FIELDS    12727000
*                                                                       12728000
         CNOP  0,4                ALLIGN CALL TO PTRPROCV ON FULLWORD   12729000
ABLOKP   L     GR1,NBYTESA(,GR3)  LOAD LENGTH OF BLOCK                  12730000
         AR    GR1,GR3            POINT PAST LAST VALUE FIELD           12731000
         AR    GR1,MINUS8         POINT TO LAST VALUE FIELD             12732000
         BAL   GR2,PTRPROCV       PROCESS VALUE FIELD                   12733000
         BXH   GR1,MINUS8,*-4     LOOP UNTIL ALL FIELDS PROCESSED       12734000
         LA    R2,ABLOK           GET BLOCK CODE FOR RESTORE            12735000
         B     PTRPOP             AND RETURN                            12736000
         EJECT                                                          12737000
*                                                                       12738000
*        PTRPROC -- BLOK PROCESSING ROUTINES -- CONTINUED               12739000
*        ------------------------------------------------               12740000
*                                                                       12741000
*                                                                       12742000
*        LTBLOKP                  LABEL TRACE BLOCK                     12743000
*                                                                       12744000
*        ON ENTRY TO LTBLOKP LTLOC HAS ALREADY BEEN PROCESSED           12745000
*                                                                       12746000
         CNOP  0,4                ALLIGN PTRPROC CALL TO FULLWORD       12747000
LTBLOKP  LA    GR1,LTTAG(,GR3)    POINT TO POSSIBLE TRACE TAG           12748000
         BAL   GR2,PTRPROCV       VALUE PROCESS IT                      12749000
         LA    GR1,LTGOTO(,GR3)   POINT TO LABEL LOCATION               12750000
         BAL   GR2,PTRPROCL       LABEL PROCESS IT                      12751000
         LA    R2,LTBLOK          GET BLOCK CODE FOR RESTORE            12752000
         B     PTRPOP             AND RETURN                            12753000
*                                                                       12754000
*        TBBLOKP                  TABLE                                 12755000
*                                                                       12756000
         CNOP  2,4                ALLIGN PTRPROC CALL TO FULLWORD       12757000
TBBLOKP  L     GR1,TBDIVIDE(,GR3) LOAD NO. OF SLOTS * 4                 12758000
         LA    GR1,TBLPTRS-4(GR1,GR3)       POINT TO LAST TABLE ENTRY   12759000
         SR    GR3,MINUS8         TEMPORARILY MOVE UP FOR BXH LIMIT     12760000
         BAL   GR2,PTRPROC        PROCESS HASH POINTER                  12761000
         LA    GR1,4(,GR1)        DO LA TO COUNTER PART OF DECREMENT    12762000
         BXH   GR1,MINUS8,*-8     LOOP UNTIL ALL POINTERS PROCESSED     12763000
         AR    GR3,MINUS8         POINT TO BLOCK AGAIN                  12764000
         LA    R2,TBBLOK          GET BLOCK CODE FOR RESTORE            12765000
         B     PTRPOP             AND RETURN                            12766000
*                                                                       12767000
*        TEBLOKP                  TABLE ELEMENT                         12768000
*                                                                       12769000
         CNOP  0,4                ALIIGN PTRPROC CALL TO FULLWORD       12770000
TEBLOKP  LA    GR1,TEVALUE(,GR3)  POINT TO VALUE                        12771000
         BAL   GR2,PTRPROCV       VALUE PROCESS IT                      12772000
         LA    GR1,TLINK(,GR3)    POINT TO LINK FIELD                   12773000
         BAL   GR2,PTRPROC        PROCESS IT                            12774000
         LA    GR1,TENAME(,GR3)   POINT TO NAME POINTER                 12775000
         BAL   GR2,PTRPROCV       VALUE PROCESS IT                      12776000
         LA    R2,TEBLOK          GET TYPE CODE FOR RESTORE             12777000
         B     PTRPOP             RETURN                                12778000
         EJECT                                                          12779000
*                                                                       12780000
*        PTRPROC -- BLOK PROCESSING ROUTINES -- CONTINUED               12781000
*        ------------------------------------------------               12782000
*                                                                       12783000
*                                                                       12784000
*        IOBLOKP                  IOBLOCK                               12785000
*                                                                       12786000
         CNOP  0,4                ALLIGN PTRPROC CALLS                  12787000
IOBLOKP  LA    GR1,OFORMAT(,GR3)  POINT TO OUTPUT FORMAT                12788000
         BAL   GR2,PTRPROCV       PROCESS IT                            12789000
         LA    GR1,IOTAG(,GR3)    POINT TO TRACE TAG                    12790000
         BAL   GR2,PTRPROCV       VALUE PROCESS IT                      12791000
         LA    R2,IOBLOK          GET BLOCK CODE FOR RESTORE            12792000
         B     PTRPOP             AND RETURN                            12793000
*                                                                       12794000
*        CBLOKP                   CODE BLOCK                            12795000
*                                                                       12796000
         CNOP  0,4                ALLIGN CALLS TO PTRPROC               12797000
CBLOKP   LA    GR1,CODNLOC(,GR3)  POINT TO CODE BLOCK POINTER           12798000
         BAL   GR2,PTRPROC        PROCESS IT                            12799000
         LA    R2,CBLOK           GET BLOCK CODE FOR RESTORE            12800000
         B     PTRPOP             AND RETURN                            12801000
*                                                                       12802000
*        TRBLOK                   TRACE BLOCK                           12803000
*                                                                       12804000
         CNOP  0,4                ALIIGN PTRPROC CALLS TO FULLWORD      12805000
TRBLOKP  LA    GR1,TRTAG(,GR3)    POINT TO TAG                          12806000
         BAL   GR2,PTRPROCV       VALUE PROCESS IT                      12807000
         LA    GR1,TRCLINK(,GR3)  POINT TO POSSIBLE LINK                12808000
         BAL   GR2,PTRPROC        PROCESS IT                            12809000
         LA    R2,TRBLOK          GET BLOCK CODE FOR RESTORE            12810000
         B     PTRPOP             AND RETURN                            12811000
         EJECT                                                          12812000
*                                                                       12813000
*        PBLOKP                   PATTERN                               12814000
*                                                                       12815000
         CNOP  2,4                ALLIGN PTRPROC CALL TO FULLWORD       12816000
PBLOKP   LH    GR1,PTLENG(,GR3)   LOAD LENGTH OF BLOCK                  12817000
         AR    GR1,GR3            POINT PAST BLOCK                      12818000
         ST    GR1,PNOTHEN(,GR3)  SAVE END OF BLOCK ADDR IN RESTORABLE  12819000
*                                 FIELD FOR COMPARES                    12820000
         LA    GR1,PATS(,GR3)     POINT TO FIRST PATTERN ELEMENT        12821000
*                                                                       12822000
*        LOOP THROUGH PATTERN ELEMENTS                                  12823000
*                                                                       12824000
PBLOKP0  TM    PFLAGS(GR1),PRELOC2          IS EITHER PARAM RELOCATABLE 12825000
         BZ    PBLOKP2            SKIP IF NO RELOCATABLE PARAMETERS     12826000
         BM    PBLOKP1            SKIP IF PARAM 1 IS RELOCATABLE        12827000
         CNOP  0,4                ALLIGN PTRPROC CALL TO FULLWORD       12828000
         BAL   GR2,PTRPROCP       CALL SPECIAL PATTERN EXPR PTR ROUTINE 12829000
         LA    GR1,4(,GR1)        BUMP PAST REST OF NODE                12830000
         B     PBLOKP3            AND MERGE WITH END OF BLOK CHECK      12831000
*                                                                       12832000
*        COME HERE WHEN PARAMETER ONE IS RELOCATABLE                    12833000
*                                                                       12834000
         CNOP  0,4                ALLIGN PTRPROC CALL TO FULLWORD       12835000
PBLOKP1  LA    GR1,PARAM1(,GR1)   POINT TO RELOCATABLE PARAMETER        12836000
         BAL   GR2,PTRPROC        PROCESS IT                            12837000
         SH    GR1,=Y(PARAM1)     RESTORE ELEMENT POINTER               12838000
*                                                                       12839000
*        COME HERE TO SKIP PAST NODE                                    12840000
*                                                                       12841000
PBLOKP2  TM    PFLAGS(GR1),PARM1+PARM2      TEST NUMBER OF PARAMS       12842000
         BZ    *+16               SKIP IF NONE                          12843000
         BM    *+8                SKIP IF ONE                           12844000
         LA    GR1,4(,GR1)        BUMP GR1 FOR PARAM2                   12845000
         LA    GR1,4(,GR1)        BUMP GR1 FOR PARAM1                   12846000
         LA    GR1,PARAM1(,GR1)   BUMP GR1 FOR REST OF BLOCK            12847000
*                                                                       12848000
*        COME HERE TO TEST FOR BLOK COMPLETELY PROCESSED                12849000
*                                                                       12850000
PBLOKP3  C     GR1,PNOTHEN(,GR3)  ARE WE AT END OF BLOCK?               12851000
         BL    PBLOKP0            LOOP BACK IF NOT                      12852000
         L     GR1,=A(NOTHEN)     GET VALUE IN DESTROYED WORD           12853000
         ST    GR1,PNOTHEN(,GR3)            AND RESTORE THE WORD        12854000
         LA    R2,PBLOK           GET BLOCK CODE FOR RESTORE            12855000
         B     PTRPOP             ELSE EXIT                             12856000
*                                                                       12857000
*        THIS IS A CHECK TO MAKE SURE THAT PTRPROC CALLS ARE MADE       12858000
*        WITH VALID RETURN ADDRESS (SEE PTRPROC)                        12859000
*        IF THIS TEST FAILS, THE SPACE BETWEEN THE FIRST AND            12860000
*        LAST PTRPROC CALLS MUST BE REDUCED (MOVE PTRPROC ROUTINE)      12861000
*        OR ALLIGN PTRPROC CALLS TO A DOUBLE WORD BOUNDARY              12862000
*                                                                       12863000
         LA    R0,GCOLBASE+4*255-*          ALL CALLS MUST BE SAVEABLE  12864000
*                                           IN ONE BYTE                 12865000
         ORG   *-4                GET RID OF GARBAGE CODE               12866000
         EJECT                                                          12867000
*                                                                       12868000
*        PASS 1                                                         12869000
*        ------                                                         12870000
*                                                                       12871000
*        PTRPROC -- ROUTINE TO PROCESS A RELOCATABLE POINTER            12872000
*                                                                       12873000
*        PTRPROCV -- PROCESSES ONLY IF RELOCBIT IS TURNED ON            12874000
*                                                                       12875000
*        PTRPROCS -- PROCESSES ONLY IF THE BLOCK IS ALREADY IN USE      12876000
*                                                                       12877000
*        THIS ROUTINE IS RECURSIVE AND SAVES THREE ITEMS OVER EACH      12878000
*        CALL, ALTHOUGH NO STACK IS USED. THE FINAL RESULT OF ALL       12879000
*        CALLS TO PTRPROC IS A BACKCHAIN OF REFERENCES TO EACH BLOCK    12880000
*        IN FREE CORE CHAINED FROM THE GARBAGE COLLECTION FIELD.        12881000
*        THE END OF THE CHAIN IS INDICATED BY THE LOW ORDER BIT         12882000
*        (BIT POSITION 31) BEING TURNED ON.                             12883000
*                                                                       12884000
*        THE VALUES SAVED OVER CALLS ARE THE ADDRESS FIELDS (RIGHTMOST  12885000
*        THREE BYTES) OF GR1 AND GR3, AND THE CALLER'S ADDRESS AS       12886000
*        INDICATED BY THE VALUE IN GR1. ALL OF THESE ITEMS MUST BE      12887000
*        MULTIPLES OF FOUR. ADDITIONALLY (GR2-RETURN) MUST NOT          12888000
*        EXCEED 1020 (= 4*255).                                         12889000
*                                                                       12890000
*        ON EXIT, THE RIGHT HAND THREE BYTES OF GR1 & GR3 ARE RESTORED, 12891000
*        WITH THEIR LEFT BYTES SET TO ZERO. GR2 MAY NOT BE RESTORED,    12892000
*        BUT CONTROL IS ALWAYS RETURNED TO THE FULLWORD ADDRESS         12893000
*        INDICATED BY GR2 ON ENTRY. ALSO ON EXIT (AND ENTRY TO A        12894000
*        BLOCK PROCESSING ROUTINE), R2 HAS ITS LEFT THREE BYTES ZERO,   12895000
*        AND HENCE MAY BE USED FREELY FOR IC'S WITHOUT AN SR.           12896000
*        THE LEFT THREE BYTES OF (R2) MUST BE ZERO ON ENTRY TO PTRPROC. 12897000
*                                                                       12898000
*        WHEN A BLOCK IS FOUND THAT NEEDS PROCESSING (BACKCHAIN=0),     12899000
*        THE GR3 VALUE IS SAVED AT THE ADDRESS CONTAINED IN GR1         12900000
*        SINCE THIS IS THE END OF THE CHAIN. THE LOW ORDER BIT IS       12901000
*        SET ON TO IDENTIFY THE END OF THE CHAIN. GR2 IS SAVED BY CAL-  12902000
*        CULATING THE OFFSET FROM (RETURN) AND DIVIDING BY 4, LEAVING   12903000
*        AN EIGHT BIT VALUE. THE BLOCK TYPE CODE IS LOADED AND THE      12904000
*        CODED GR2 VALUE STORED IN ITS PLACE. THE PROPER BLOCK ROUTINE  12905000
*        IS THEN ENTERED.                                               12906000
*                                                                       12907000
*        ON EXIT FROM A BLOCK PROCESSING ROUTINE, (R2) MUST CONTAIN THE 12908000
*        PROPER BLOCK CODE FOR RESTORATION. PTRPOP LOADS THE START      12909000
*        OF THE BACKCHAIN AND FOLLOWS IT DOWN TILL IT FINDS THE END OF  12910000
*        THE CHAIN (BIT 31 TURNED ON). GR3 IS LOADED WITH THE FIELDS    12911000
*        CONTENTS (AFTER TURNING OFF THE FLAG BIT), AND GR1 IS LEFT     12912000
*        POINTING TO THE FIELD (ITS ORIGINAL VALUE ON ENTRY).           12913000
*        THE CODED 8-BIT VALUE OF GR2 IS THEN LOADED AND THE PROPER     12914000
*        BLOCK CODE RESTORED. CONTROL IS RETURNED TO THE CALLER BY      12915000
*        BRANCHING TO RETURN+4*(8-BIT CODE).                            12916000
         EJECT                                                          12917000
*                                                                       12918000
*        PASS 1 -- PTRPROC -- CONTINUED                                 12919000
*        ------------------------------                                 12920000
*                                                                       12921000
*        (R2)                     LEFT THREE BYTES ZERO                 12922000
*        (GR1)                    POINTER TO FIELD TO BE PROCESSED      12923000
*        (GR3)                    INFORMATION TO BE SAVED OVER CALL     12924000
*                                 MUST BE MULTIPLE OF 4 AND NONZERO     12925000
*        BAL   GR2,PTRPROC(V,S)   (THIS CALL MUST BE FULLWORD ALLIGNED) 12926000
*                                                                       12927000
*        PTRPROCV -- ENTRY TO TEST RELOCBIT BEFORE PROCESSING           12928000
*                                                                       12929000
PTRPROCV TM    0(GR1),RELOCBIT    TEST FOR RELOCATABLE DATA CODE        12930000
         BCR   NO,GR2             IMMEDIATE RETURN IF NOT RELOCATABLE   12931000
         L     R1,0(,GR1)         LOAD POINTER TO BE PROCESSED          12932000
         NR    R1,MSK             CLEAR UPPER BYTE                      12933000
         CR    R1,BOT             BELOW DYNAMIC AREA?                   12934000
         BCR   L,GR2              RETURN IF SO (NOT RELOCATABLE)        12935000
         CR    R1,LIM             ABOVE DYNAMIC AREA?                   12936000
         BCR   NL,GR2             RETURN IF SO (NOT RELOCATABLE)        12937000
         CLI   0(GR1),ECODE       IS THIS AN EXPRESSION PTR             12938000
         BNE   PTRPROCM           JUMP IF NOT TO MERGE                  12939000
         B     PTRPROCE           ELSE JUMP TO SPECIAL EXPRESSION RTNE  12940000
*                                                                       12941000
*        NORMAL ENTRY POINT -- PTRPROC                                  12942000
*                                                                       12943000
PTRPROC  L     R1,0(,GR1)         LOAD POINTER TO BE PROCESSED          12944000
         NR    R1,MSK             REMOVE UPPER BYTE                     12945000
         CR    R1,BOT             BELOW DYNAMIC AREA?                   12946000
         BCR   L,GR2              RETURN IF SO                          12947000
         CR    R1,LIM             ABOVE DYNAMIC AREA?                   12948000
         BCR   NL,GR2             RETURN IF SO (NOT RELOCATABLE)        12949000
*                                                                       12950000
*        MERGE HERE FROM PTRPROCV ENTRY                                 12951000
*                                                                       12952000
PTRPROCM IC    R2,DTYPE(,R1)      LOAD BLOCK CODE                       12953000
         L     R0,GCOLPTR(,R1)    LOAD BACKPOINTER CHAIN HEAD           12954000
         ST    GR1,GCOLPTR(,R1)   PUT THIS POINTER ON CHAIN             12955000
         NR    R0,MSK             STRIP BYTE, TEST IF CHAIN EXISTS?     12956000
         BZ    PTRPUSH            JUMP TO MAKE RECURSIVE CALL IF NOT    12957000
*                                                                       12958000
*        COME HERE IF BLOCK HAS ALREADY BEEN PROCESSED                  12959000
*                                                                       12960000
         STC   R2,DTYPE(,R1)      RESTORE BLOCK CODE                    12961000
         IC    R2,0(,GR1)         SAVE LEFT BYTE OF FIELD TO PROCESS    12962000
         ST    R0,0(,GR1)         COMPLETE BACK CHAIN                   12963000
         STC   R2,0(,GR1)         RESTORE LEFT BYTE                     12964000
         BR    GR2                RETURN TO CALLER                      12965000
*                                                                       12966000
*        COME HERE WHEN AN UNPROCESSED BLOCK IS FOUND WHICH DOES NOT    12967000
*        CONTAIN ANY RELOCATABLE POINTERS                               12968000
*                                                                       12969000
PTRPROC1 STC   R2,DTYPE(,R1)      RESTORE BLOCK CODE                    12970000
         MVI   3(GR1),1           TURN ON END OF CHAIN BIT              12971000
         BR    GR2                RETURN TO CALLER                      12972000
         EJECT                                                          12973000
*                                                                       12974000
*        PASS 1 -- PTRPROC -- CONTINUED                                 12975000
*        ------------------------------                                 12976000
*                                                                       12977000
*        COME HERE WHEN AN UNPROCESSED BLOCK IS ENCOUNTERED             12978000
*        (R1) POINTS TO THE BLOCK TO BE PROCESSED                       12979000
*        (R2) CONTAINS THE BLOCK CODE OF THE BLOCK TO BE PROCESSED      12980000
*                                                                       12981000
PTRPUSH  CH    R2,=Y(HNRLBLOK)    DOES THIS BLOCK CONTAIN RELOC PTRS?   12982000
         BNH   PTRPROC1           NO CALL NEEDED IF NOT                 12983000
         LA    GR3,1(,GR3)        ELSE SUPPLY END OF CHAIN BIT          12984000
         IC    R0,0(,GR1)         SAVE LEFT BYTE OF FIELD TO PROCESS    12985000
         ST    GR3,0(,GR1)        SAVE GR3 AT END OF CHAIN, SET END BIT 12986000
         STC   R0,0(,GR1)         RESTORE LEFT BYTE                     12987000
         SR    GR2,RETURN         GET RETURN (GR2) VALUE AS OFFSET      12988000
         SRL   GR2,2              COMPRESS TO 8 BITS BY DIVISION BY 4   12989000
         STC   GR2,DTYPE(,R1)     SAVE 8 BIT CODED GR2 VALUE            12990000
         LR    GR3,R1             COPY BLOCK ADDRESS                    12991000
         B     GTRATB(R2)         GO TO PROPER BLOCK PROCESSING ROUTINE 12992000
*                                                                       12993000
*        JUMP TABLE FOR BLOCK PROCESSING ROUTINES                       12994000
*                                                                       12995000
GTRATB   EQU   *-IOBLOK           SET PROPER STARTING LOCATION          12996000
         B     IOBLOKP            INPUT/OUTPUT BLOCK                    12997000
         B     ABLOKP             ARRAY BLOCK                           12998000
         B     PDBLOKP            PROGRAM DEFINED DATATYPE BLOCK        12999000
         B     FFBLOKP            FIELD FUNCTION BLOCK                  13000000
         B     PDFBLOKP           PROG DEFINED DATATYPE FUNCTION BLOCK  13001000
         B     PBLOKP             PATTERN BLOCK                         13002000
         B     TBBLOKP            TABLE BLOCK                           13003000
         B     TEBLOKP            TABLE ELEMENT BLOCK                   13004000
         B     CBLOKP             CODE BLOCK                            13005000
         B     TRBLOKP            TRACE BLOCK                           13006000
         ORG   GTRATB+LTBLOK      POSITION LAST ENTRY                   13007000
         B     LTBLOKP            LABEL TRACE BLOCK                     13008000
         EJECT                                                          13009000
*                                                                       13010000
*        PASS 1 -- PTRPROC -- CONTINUED                                 13011000
*        ------------------------------                                 13012000
*                                                                       13013000
*        ENTRY TO PROCESS A POINTER THAT NEEDS TO BE RELOCATED ONLY     13014000
*        IF SOME OTHER VALUE FIELD POINTS TO THE BLOCK AS WELL.         13015000
*        IF THE BLOCK IS NOT IN USE, THE POINTER IS SET TO ZERO.        13016000
*                                                                       13017000
PTRPROCS L     R1,0(,GR1)         LOAD BLOCK ADDRESS                    13018000
         CE    ZR,0(,R1)          IS THERE A BACK CHAIN?                13019000
*                                 NOTE: THIS TEST WORKS EVEN IF R1=0    13020000
         BNE   PTRPROC            IF SO, OFF TO RELOCATE THIS POINTER   13021000
         STE   ZR,0(,GR1)         ELSE ZERO POINTER                     13022000
         BR    GR2                AND RETURN                            13023000
*                                                                       13024000
*        RETURN HERE TO POP STACK AFTER PROCESSING A BLOCK              13025000
*        (GR3) POINTS TO THE BLOCK JUST PROCESSED                       13026000
*        (R2) POINTS TO THE BLOCK CODE FOR RESTORATION                  13027000
*                                                                       13028000
PTRPOP   SR    GR2,GR2            CLEAR REGISTER TO RESTORE RETURN ADDR 13029000
         IC    GR2,DTYPE(,GR3)    LOAD 8-BIT CODED VALUE OF SAVED GR2   13030000
         STC   R2,DTYPE(,GR3)     RESTORE BLOCK CODE                    13031000
         SLL   GR2,2              MULTIPLY BY FOUR TO GET OFFSET        13032000
         LR    GR1,GR3            POINT TO HEAD OF BACK CHAIN           13033000
*                                                                       13034000
*        LOOP TO MOVE DOWN TO END OF BACKCHAIN                          13035000
*                                                                       13036000
PTRPOPL  L     GR1,0(,GR1)        MOVE TO NEXT ENTRY ON CHAIN           13037000
         TM    3(GR1),1           END OF CHAIN BIT ON?                  13038000
         BNO   PTRPOPL            LOOP BACK IF NOT END OF CHAIN         13039000
         L     GR3,0(,GR1)        AT END OF CHAIN, RESTORE SAVED GR3    13040000
         NR    GR3,MSK            CLEAR UPPER BYTE OF GR3               13041000
         NR    GR1,MSK            CLEAR UPPER BYTE OF GR1               13042000
         BCT   GR3,0(RETURN,GR2)  RETURN TO CALLER, DELETE EOC FLAG     13043000
         EJECT                                                          13044000
*                                                                       13045000
*        PASS 1 -- CONTINUED                                            13046000
*        -------------------                                            13047000
*                                                                       13048000
*        PTRPROCE -- SPECIAL ROUTINE TO PROCESS AN EXPRESSION POINTER   13049000
*        (ECODE) SUCH VALUES ARE PROCESSED AS LABEL POINTERS AND        13050000
*        CHAINED FROM GECHAIN THROUGH THEIR SECOND WORDS FOR            13051000
*        LATER PROCESSING IN PASS THREE (WHERE THE VALUE IS RELOCATED)  13052000
*                                                                       13053000
PTRPROCE L     R0,GECHAIN         LOAD CURRENT HEAD OF CHAIN            13054000
         ST    GR1,GECHAIN        STORE NEW CHAIN HEAD POINTER          13055000
         ST    R0,4(,GR1)         LINK TO CHAIN, MERGE PTRPROCL         13056000
*                                                                       13057000
*        PTRPROCL -- PROCESS POSSIBLE RELOCATABLE LABEL FIELD           13058000
*        THIS ROUTINE IS ALSO USED IN PASS 3                            13059000
*                                                                       13060000
*        (GR1)                    POINTS TO FIELD TO BE PROCESSED       13061000
*        (GR3)                    NON-ZERO -- PASS 1, ZERO -- PASS 3    13062000
*        (LAST),(NEW)             MUST NOT BE CHANGED BY THIS CALL      13063000
*        CNOP  0,4                IF PASS1 CALL                         13064000
*        BAL   GR2,PTRPROCL                                             13065000
*        (GR1)                    MODIFIED IF LTBLOK POINTER FOUND      13066000
*                                                                       13067000
PTRPROCL L     R1,0(,GR1)         LOAD POINTER                          13068000
         NR    R1,MSK             STRIP UPPER BYTE                      13069000
         CR    R1,BOT             BELOW DYNAMIC MEMORY?                 13070000
         BCR   L,GR2              RETURN IF SO , NOT RELOCATABLE        13071000
         CR    R1,LIM             ABOVE DYNAMIC MEMORY?                 13072000
         BCR   NL,GR2             RETURN IF SO, NOT RELOCATABLE         13073000
         MVI   LABRLFLG,1         ELSE SET SPECIAL LABEL FLAG           13074000
         CLI   0(R1),LTBLOK       ARE WE POINTING TO AN LTBLOK?         13075000
         BNE   PTRPRCL0           SKIP IF NOT TO PROCESS LABEL          13076000
*                                                                       13077000
*        HERE WE KNOW FIELD BEING PROCESSED CONTAINS AN LTBLOK PTR      13078000
*        OUR ACTION IS DETERMINED BY SETTING OF PASS1/3 SWITCH (GR3)    13079000
*                                                                       13080000
         LTR   GR3,GR3            TEST PASS SWITCH                      13081000
         BZ    PTRPRC3L           SKIP IF PASS3                         13082000
*                                                                       13083000
*        COME HERE FOR PASS1 PROCESSING OF LTBLOK POINTER               13084000
*        WE MODIFY (GR1) TO POINT TO LTLOC FIELD IN LTBLOK, THEN        13085000
*        PASS CONTROL TO PTRPROCM WHICH PROCESSES REMAINDER OF LTBLOK   13086000
*        IF THE LTBLOK HAS ALREADY BEEN PROCESSED, WE ARE DONE          13087000
*                                                                       13088000
         CE    ZR,GCOLPTR(,R1)    HAS THIS BLOCK BEEN PROCESSED?        13089000
         LA    GR1,LTLOC(,R1)     POINT TO LTLOC IN CASE IT HASN'T      13090000
         BZ    PTRPROCM           MERGE WITH PTRPROC IF NOT YET DONE    13091000
         BR    GR2                ELSE RETURN TO CALLER                 13092000
*                                                                       13093000
*        COME HERE IN PASS3 TO SET NEW LTBLOK ADDRESS IN POINTER        13094000
*        AND PROCESS LTGOTO FIELD                                       13095000
*                                                                       13096000
PTRPRC3L MVC   1(3,GR1),LTLOC+1(R1)         MOVE IN NEW LTBLOK ADDRESS  13097000
         LA    GR1,LTGOTO(,R1)    POINT TO LABEL FIELD IN LTBLOK        13098000
         B     PTRPROCL           AND LOOP BACK TO PROCESS IT           13099000
         EJECT                                                          13100000
*                                                                       13101000
*        PASS1 -- PTRPROCL -- CONTINUED                                 13102000
*        ------------------------------                                 13103000
*                                                                       13104000
*        HERE WE SEARCH AHEAD IN THE CODE FOR THE NEXT NOP INSTRUCTION  13105000
*        WHOSE SECOND HALFWORD CONTAINS AN OFFSET BACK TO THE           13106000
*        START OF THE CODE BLOCK SO THAT WE CAN PROCESS THE CODE BLOCK  13107000
*                                                                       13108000
*                                                                       13109000
*        SEVERAL CALLERS MERGE AT THIS POINT WITH GR1,GR2,GR3 SET AS    13110000
*        ABOVE, AND ALSO (R1) POINTING TO THE RELOCATABLE CODE          13111000
*                                                                       13112000
PTRPRCL0 BCTR  R1,0               ON ENTRY, BACKOFF R1                  13113000
PTRPRCL1 TRT   1(256,R1),ZTBL     SCAN AHEAD FOR X'47' (NOP OPCODE)     13114000
         BNZ   PTRPRCL2           SKIP IF X'47' FOUND                   13115000
         LA    R1,256(,R1)        ELSE PUSH POINTER                     13116000
         B     PTRPRCL1           LOOP BACK TO KEEP SCANNING            13117000
*                                                                       13118000
*        COME HERE WHEN WE FIND AN X'47', IS IT A NOP INSTRUCTION?      13119000
*                                                                       13120000
PTRPRCL2 CLI   1(R1),X'00'        TEST FOR ZERO MASK FIELD              13121000
         BNE   PTRPRCL1           KEEP SCANNING IF NOT A NOP            13122000
*                                                                       13123000
*        COME HERE WITH (R1) POINTING TO THE NOP INSTRUCTION            13124000
*                                                                       13125000
         LH    R0,2(,R1)          LOAD HALFWORD OFFSET TO START OF BLK  13126000
         N     R0,=X'0000FFFF'    REMOVE POSSIBLE SIGN BITS             13127000
         AR    R0,R0              CONVERT HALFWORDS TO BYTES            13128000
         SR    R1,R0              POINT BACK TO START OF BLOCK          13129000
         LTR   GR3,GR3            TEST CASES                            13130000
         BZ    PTRPRC33           SKIP IF CALL IS IN PASS 3             13131000
*                                                                       13132000
*        HERE IF IN PASS 1                                              13133000
*                                                                       13134000
         CE    ZR,0(,R1)          CODE BLOCK ALREADY PROCESSED?         13135000
         BCR   NZ,GR2             RETURN TO CALLER IF SO                13136000
*                                                                       13137000
*        IF BLOCK HAS NOT BEEN PROCESSED, SET BACK PTR TO CODNLOC FIELD 13138000
*                                                                       13139000
         LA    R0,CODNLOC(,R1)    POINT TO CODNLOC FIELD                13140000
         ST    R0,GCOLPTR(,R1)    STORE AS HEAD OF BACK CHAIN           13141000
         MVI   DTYPE(R1),CBLOK    RESTORE BLOCK CODE                    13142000
         MVI   CODNLOC+3(R1),1    SET END OF CHAIN BIT                  13143000
         BR    GR2                RETURN TO CALLER                      13144000
*                                                                       13145000
*        HERE IF IN PASS 3                                              13146000
*                                                                       13147000
PTRPRC33 L     R0,CODNLOC(,R1)    LOAD NEW LOCATION                     13148000
         LA    R1,0(,R1)          STRIP POSSIBLE UPPER BYTE             13149000
         SR    R0,R1              CALCULATE RELOCATION FACTOR           13150000
         A     R0,0(,GR1)         RELOCATE LABEL POINTER                13151000
         ST    R0,0(,GR1)         STORE RELOCATED VALUE                 13152000
         BR    GR2                RETURN TO CALLER                      13153000
         EJECT                                                          13154000
*                                                                       13155000
*        PASS 1 -- PTRPROC -- CONTINUED                                 13156000
*        ------------------------------                                 13157000
*                                                                       13158000
*                                                                       13159000
*        PTRPROCP -- SPECIAL ROUTINE FOR RELOCATABLE EXPRESSION PTR     13160000
*        IN PATTERN NODE (PARAM2). SUCH A POINTER IS PROCESSED AS A     13161000
*        LABEL AND ALSO THE ENTRIES ARE CHAINED FROM GPCHAIN THROUGH    13162000
*        THE PARAM1 FIELD WHICH IS ALWAYS AVAILABLE IN THIS CASE.       13163000
*                                                                       13164000
PTRPROCP L     R1,PARAM2(,GR1)    POINT TO CODE LOCATION                13165000
         NR    R1,MSK             CLEAR UPPER BYTE                      13166000
         CR    R1,BOT             BELOW DYNAMIC MEMORY?                 13167000
         BL    PTRPRCP1           SKIP IF SO (NOT RELOCATABLE)          13168000
         CR    R1,LIM             ABOVE DYNAMIC MEMORY?                 13169000
         BNL   PTRPRCP1           SKIP IF SO (NOT RELOCATABLE)          13170000
*                                                                       13171000
*        HERE WE HAVE A RELOCATABLE EXPRESSION POINTER                  13172000
*                                                                       13173000
         L     R0,GPCHAIN         LOAD CURRENT HEAD OF CHAIN            13174000
         ST    GR1,GPCHAIN        STORE NEW HEAD OF CHAIN               13175000
         ST    R0,PARAM1(,GR1)    LINK THIS BLOCK TO REST OF CHAIN      13176000
         LA    GR1,PARAM2(,GR1)   POINT TO PARAM2                       13177000
         B     PTRPRCL0           MERGE INTO PTRPROCL                   13178000
*                                                                       13179000
*        HERE IF POINTER IS NOT RELOCATABLE                             13180000
*                                                                       13181000
PTRPRCP1 LA    GR1,PARAM2+4(,GR1) POINT PAST THIS NODE                  13182000
         B     PBLOKP3            MERGE BACK INTO PBLOK ROUTINE         13183000
         EJECT                                                          13184000
*                                                                       13185000
*        PASS 2                                                         13186000
*        ------                                                         13187000
*                                                                       13188000
PASS2    LA    LAST,PASS3S        INITIALIZE CHAIN OF BLOCKS IN USE     13189000
         STE   ZR,PASS3S          ZERO IN CASE NOTHING ANYWHERE         13190000
         L     OLD,DYNAMB         LOAD START OF DYNAMIC STORAGE         13191000
         LR    NEW,OLD            INITIALIZE POINTER TO NEW BLOCKS      13192000
         MVI   0(FR),SBLOK+1      END OF FREE CORE MUST NOT BE SBLOK    13193000
*                                                                       13194000
*        LOOP THROUGH ALL BLOCKS IN STORAGE                             13195000
*                                                                       13196000
PASS2L   SR    R2,R2              CLEAR FOR IC AND GETLENGTH CALL       13197000
         IC    R2,DTYPE(,OLD)     GET BLOCK TYPE                        13198000
         EX    0,BLOKLEN(R2)      LOAD BLOCK LENGTH INTO R2             13199000
         L     R1,GCOLPTR(,OLD)   LOAD GARBAGE COLLECT FIELD            13200000
         NR    R1,MSK             REMOVE BLOCK CODE                     13201000
         BNZ   PASS2LU            SKIP IF THE BLOCK IS IN USE           13202000
         CLI   DTYPE(OLD),CBLOK   IS BLOCK BEING FREED CODE?            13203000
         BNE   PASS2C             SKIP IF NOT                           13204000
*                                                                       13205000
*        HERE WE ARE FREEING A CODE BLOCK, RETURN THE 32 BYTE BLOCKS    13206000
*        OF CONSTANTS IT USED TO THE FREELIST (SEE FIND8 FOR DETAILS)   13207000
*                                                                       13208000
         L     R1,CODECCHN(,OLD)  LOAD POINTER TO HEAD OF LIST          13209000
         LTR   GR2,R1             ANY BLOCKS REFERENCED? (+ MOVE PTR)   13210000
         BZ    PASS2C             SKIP IF NOT                           13211000
*                                                                       13212000
*        IF THERE ARE BLOCKS, POINT (GR2) TO LAST BLOCK ON CHAIN        13213000
*                                                                       13214000
         BAL   GR1,*+8            SET LOOP ADDR & JUMP INTO LOOP        13215000
         L     GR2,0(,GR2)        POINT TO NEXT BLOCK                   13216000
         STE   ZR,8(,GR2)         CLEAR CONSTANTS IN BLOCK              13217000
         STE   ZR,16(,GR2)        . . . .                               13218000
         STE   ZR,24(,GR2)        . . . .                               13219000
         CE    ZR,0(,GR2)         END OF CHAIN?                         13220000
         BCR   NZ,GR1             LOOP BACK IF NOT                      13221000
*                                                                       13222000
*        NOW LINK THE CHAIN OF BLOCKS INTO THE FREELIST                 13223000
*                                                                       13224000
         L     R0,CONSCHAN        CURRENT CHAIN POINTER                 13225000
         ST    R0,0(,GR2)         LINK TO END OF NEW CHAIN              13226000
         ST    R1,CONSCHAN        SET NEW HEAD TO POINT TO THIS CHAIN   13227000
         B     PASS2C             SKIP (BLOCK IS NOT IN USE)            13228000
*                                                                       13229000
*        HERE FOR BLOCK WHICH IS IN USE                                 13230000
*                                                                       13231000
PASS2LU  IC    R0,DTYPE(,LAST)    SAVE BLOCK CODE IN LAST BLOCK         13232000
         ST    OLD,GCOLPTR(,LAST) SAVE POINTER TO NEXT BLOCK IN USE     13233000
         STC   R0,DTYPE(,LAST)    RESTORE BLOCK TPE IN LAST BLOCK       13234000
         LR    LAST,OLD           UPDATE CHAIN ADDRESS OF BLOCKS IN USE 13235000
         LR    R0,R2              COPY LENGTH IN CASE NOT SBLOK         13236000
         EJECT                                                          13237000
*                                                                       13238000
*        AT THIS POINT WE TEST FOR THE FOLLOWING SPECIAL CASE --        13239000
*                                                                       13240000
*        DUE TO THE WAY IN WHICH SUB-STRINGS ARE CREATED -- IT IS       13241000
*        POSSIBLE TO HAVE SBLOKS IN STORAGE WHICH ARE ONLY PARTLY IN    13242000
*        USE.  DEALING WITH THIS SITUATION FULLY REQUIRES A SLOW        13243000
*        PROCEDURE AND IS THEREFORE DONE ONLY WHEN NECESSARY (ON        13244000
*        COLLECT CALLS AND WHEN A GBGCL CALL DOES NOT CREATE ENOUGH     13245000
*        SPACE)                                                         13246000
*                                                                       13247000
*                                                                       13248000
*        WHEN THE FLAG GCMPRSS IS SET ON IN GCOLNRG THE FOLLOWING       13249000
*        PROCEDURE IS USED.                                             13250000
*                                                                       13251000
*        SBLOKS FOUR WORDS OR SHORTER ARE LEFT AS THEY ARE              13252000
*        FOR LONGER SBLOKS (EXCEPT THOSE WITH ONLY ONE BACKPOINTER)     13253000
*        A NEW CHAIN IS CONSTRUCTED WHICH IS SORTED BY OFFSET           13254000
*        AFTER FORMING THE CHAIN A PASS IS MADE DOWN IT TO MOVE USED    13255000
*        PORTIONS OF THE STRING TOWARD THE FRONT OF THE BLOCK,          13256000
*        RELOCATING OLD OFFSET FIELDS AS NECESSARY. USED CHARACTERS     13257000
*        ARE DETERMINED AS FOLLOWS -                                    13258000
*        INITIALIZE COLD TO THE OFFSET OF THE LOWEST USED PIECE         13259000
*        AND CLIM TO COLD+SLENGTH+1, I.E. THE EQUIVALENT OFFSET ADDRESS 13260000
*        JUST PAST THE LAST USED CHARACTER.  COFF IS SET TO THE NUMBER  13261000
*        OF CHARACTERS OF GARBAGE AHEAD OF COLD.  CNEW POINTS TO THE    13262000
*        NEXT POSITION TO MOVE CHARACTERS, AND HENCE IS INITIALIZED     13263000
*        TO OLD.  (COFF = COLD+OLD-CNEW)                                13264000
*        MOVE DOWN THE CHAIN EXAMINING OFFSETS.  IF CLIM EQUALS OR      13265000
*        EXCEEDS THE OFFSET THEN THE SUBSTRING IS INCLUDED IN OR        13266000
*        ADJACENT TO THE CURRENT STRING OF CHARACTERS BEING ACCUMULATED 13267000
*        FOR A MOVE.  IF CLIM IS LESS THAN THE NEXT OFFSET THEN THERE   13268000
*        IS A GAP TO BE ELIMINATED.  THE ACCUMULATED STRING             13269000
*        OF GOOD CHARACTERS IS MOVED FORWARD FROM (COLD+OLD) TO (NEW)   13270000
*        ITS REAL LENGTH IS (CLIM-COLD) (NOTE THAT MVC LOOP USES REAL   13271000
*        LENGTH AND HENCE MOVES AN EXTRA CHARACTER, CAUSING NO HARM)    13272000
*        THEN CNEW IS UPDATED PAST MOVED CHARACTER, AND COLD, ETC.      13273000
*        ARE SET UP AS AT INITIALIZATION USING THE CURRENT POINTER      13274000
*        AS THE CHAIN HEAD.                                             13275000
*        WHEN CLIM >= OFFSET, A CHECK IS MADE OF CLIM VS OFFSET+LENGTH  13276000
*        IF CLIM IS NOT GREATER, THEN NEW CHARACTERS ARE BEING ADDED    13277000
*        BY THIS POINTER, SO CLIM IS SET TO OFFSET+LENGTH(360)+1        13278000
*        CHAIN END IS MARKED BY THE RIGHTMOST BIT BEING ON, WITH THE    13279000
*        NEXT LEFT BIT BEING USED TO SIGNAL END WHEN LOOP IS USED       13280000
*        FOR THE FINAL CHARACTER MOVE(AND IS TURNED OFF AFTER USE)      13281000
*                                                                       13282000
*        AN ADDITIONAL OPTIMIZATION INVOLVES THE COMBINING OF ADJACENT  13283000
*        SBLOK'S IN FREE CORE IF THE COMBINED LENGTH IS LESS THAN 32K   13284000
*        THIS IS DONE BY CHECKING THE NEXT BLOCK TO SEE IF IT IS AN     13285000
*        SBLOK.  IF SO, ADD ITS POINTERS (IF ANY) TO THE HEAD OF THE    13286000
*        CHAIN OF THE ORIGINAL SBLOK TO SPEED SORTING.  THE POINTERS    13287000
*        FROM THE ATTACHED SBLOK MUST HAVE THEIR OFFSET INCREASED BY    13288000
*        THE LENGTH OF THE SBLOK PRECEEDING IT                          13289000
*                                                                       13290000
         EJECT                                                          13291000
         TM    GCOLNRG,GCMPRSS    IS THIS A DESPERATE COLLECT?          13292000
         BNO   PASS2RL            SKIP THIS ROUTINE IF NOT              13293000
         CLI   DTYPE(OLD),SBLOK   IS THIS AN SBLOK?                     13294000
         BNE   PASS2RL            NOTHING SPECIAL IF NOT                13295000
*                                                                       13296000
*        THIS LOOP ATTACHES SUBSEQUENT SBLOKS TO THE FIRST SBLOK        13297000
*                                                                       13298000
PASS2SBS LA    GR1,0(R2,OLD)      GET ADDRESS OF BLOCK PAST THIS SBLOK  13299000
         CLI   0(GR1),SBLOK       IS NEXT ITEM AN SBLOK?                13300000
         BNE   PASS2SBT           ALL DONE WITH SBLOK COMBINE IF NOT    13301000
         LR    GR2,R2             COPY LENGTH OF OLD SBLOK              13302000
         SLL   GR2,16             POSITION IN OFFSET FIELD              13303000
         AH    R2,STLENGTH(,GR1)  GET LENGTH OF POTENTIAL NEW SBLOK     13304000
         CH    R2,=X'7FFF'        CHECK AGAINST MAXIMUM POSSIBLE        13305000
         BH    PASS2SBT           ALL DONE WITH COMBINE IF GE 32K       13306000
         STH   R2,STLENGTH(,OLD)  STORE LENGTH OF NEW SBLOK             13307000
         CE    ZR,GCOLPTR(,GR1)   IS ANYTHING CHAINED TO NEW SBLOK?     13308000
         BE    PASS2SBS           NO POINTER PROCESSING IF NOT          13309000
         LR    GR3,GR1            COPY ADDRESS OF NEW SBLOK PART        13310000
*                                                                       13311000
*        THIS LOOP MOVES OUT ON CHAIN ATTACHED TO NEW SBLOK PART        13312000
*        UPDATING THE OFFSET FIELD BY LENGTH OF OLD SBLOK               13313000
*                                                                       13314000
PASS2SBL L     GR3,0(,GR3)        MOVE OUT ON CHAIN                     13315000
         L     R0,4(,GR3)         LOAD OFFSET/LENGTH WORD               13316000
         AR    R0,GR2             INCREMENT OFFSET PORTION              13317000
         ST    R0,4(,GR3)         STORE UPDATED OFFSET/LENGTH           13318000
         TM    3(GR3),1           IS THIS END OF CHAIN?                 13319000
         BZ    PASS2SBL           LOOP BACK IF NOT END OF CHAIN         13320000
*                                                                       13321000
*        NOW LINK POINTERS FROM COMBINED BLOCK TO ORIGINAL CHAIN        13322000
*                                                                       13323000
         ST    R1,0(,GR3)         ADD OLD CHAIN AT END OF NEW CHAIN     13324000
         MVI   0(GR3),SCODE       MAKE SURE IT HAS AN SCODE             13325000
         L     R1,GCOLPTR(,GR1)   LOAD NEW HEAD OF CHAIN ADDRESS        13326000
         ST    R1,GCOLPTR(,OLD)   SAVE A COPY OF IT IN SBLOK            13327000
         B     PASS2SBS           LOOP BACK TO FIND MORE SBLOKS         13328000
*                                                                       13329000
*        COME HERE WHEN SBLOK COMBINATION IS COMPLETE                   13330000
*        REGISTERS R0 AND R2 MUST BE RESET TO SBLOK LENGTH              13331000
*                                                                       13332000
PASS2SBT LH    R2,STLENGTH(,OLD)  RESTORE R2 = SBLOK SIZE               13333000
         LR    R0,R2              AND COPY IT INTO R0                   13334000
         CH    R2,=H'16'          IS IT LONGER THAN 16 CHARACTERS?      13335000
         BNH   PASS2RL            NOT WORTH THE TROUBLE IF NOT          13336000
         TM    3(R1),1            LOOK FOR END OF CHAIN FLAG            13337000
         BO    PASS2SB4           CHAIN ALREADY BUILT IF ONE MEMBERED   13338000
         MVI   DTYPE(OLD),SCODE   FIX UP BLOCK SO NO IC, STC NEEDED     13339000
         SR    R2,R2              INITIALIZE COUNT OF NEW CHAIN MEMBERS 13340000
         L     GR1,0(,R1)         POINT TO 2ND CHAIN MEMBER             13341000
         MVI   3(R1),1            SET OFFICIAL CHAIN END IN NEW CHAIN   13342000
         EJECT                                                          13343000
*                                                                       13344000
*        COME HERE TO MOVE OUT ON ORIGINAL CHAIN                        13345000
*                                                                       13346000
PASS2SB1 LH    R0,SOFFSET(,GR1)   LOAD OFFSET OF ELEMENT NEEDING PLACE  13347000
         LR    GR2,OLD            GET FIRST BLK ADDR, SORTED CHAIN      13348000
         L     GR3,GCOLPTR(,GR2)  GET POINTER TO FIRST BLK W/OFFSET     13349000
         LA    R1,1(,R2)          COPY COUNT+1 OF CHAIN ITEMS           13350000
         LR    R2,R1              SAVE AS NEW COUNT                     13351000
*                                                                       13352000
*        LOOP TO FIND PLACE ON SORTED CHAIN FOR NEW ELEMENT             13353000
*                                                                       13354000
PASS2SB2 CH    R0,SOFFSET(,GR3)   COMPARE OFFSETS                       13355000
         BNH   PASS2SB3           FOUND PLACE IF NEW <= OLD             13356000
         LR    GR2,GR3            UPDATE 1 BACK POINTER                 13357000
         L     GR3,0(,GR2)        MOVE OUT ON CHAIN                     13358000
         BCT   R1,PASS2SB2        LOOP UNLESS END OF SORTED CHAIN       13359000
*                                                                       13360000
*        COME HERE TO INSERT ELEMENT INTO SORTED CHAIN                  13361000
*                                                                       13362000
PASS2SB3 ST    GR1,0(,GR2)        LINK INTO CHAIN BEFORE CMPRD OFFSET   13363000
         LR    GR2,GR1            SAVE ADDRESS OF NEW POINTER           13364000
         TM    3(GR1),1           TEST FOR END OF CHAIN                 13365000
         L     GR1,0(,GR1)        MOVE OUT ON UNSORTED CHAIN            13366000
         ST    GR3,0(,GR2)        COMPLETE LINK IN OF NEW POINTER       13367000
         BNO   PASS2SB1           GET NEXT POINTER IF NOT END OF CHAIN  13368000
         MVI   DTYPE(OLD),SBLOK   FIX UP BLOCK CODE                     13369000
         EJECT                                                          13370000
*                                                                       13371000
*        COME HERE WITH SORTED CHAIN SET UP                             13372000
*                                                                       13373000
PASS2SB4 LA    R0,256             GET VITAL CONSTANT                    13374000
         L     R2,GCOLPTR(,OLD)   GET ADDRESS OF FIRST CHAIN MEMBER     13375000
         LR    CNEW,OLD           FIRST MOVED CHARS TO START OF BLOCK   13376000
         SR    CLIM,CLIM          MAKE SURE CLIM VALUE UPDATED          13377000
         LH    R1,SOFFSET(,R2)    POINT TO FIRST SAVED CHARACTERS       13378000
         B     PASS2SBE           AND MAKE ENTRY TO FIX POINTERS        13379000
*                                                                       13380000
*        COME HERE TO MOVE OUT ON CHAIN AND EXAMINE NEW OFFSET          13381000
*                                                                       13382000
PASS2SBA L     R2,0(,R2)          GET ADDRESS OF NEXT POINTER           13383000
         LH    R1,SOFFSET(,R2)    LOAD OFFSET FOR THIS POINTER          13384000
         CR    CLIM,R1            IS FIELD ALREADY INCLUDED?            13385000
         BNL   PASS2SBF           OFF TO RELOCATE OFFSET IF SO          13386000
*                                                                       13387000
*        COME HERE TO MOVE A GROUP OF USED CHARACTERS FORWARD IN BLOCK  13388000
*                                                                       13389000
PASS2SBB LTR   COFF,COFF          NO MOVE NEEDED IF OFFSETDIF=0         13390000
         BZ    PASS2SBD+4         JUST UPDATE CNEW IF CHARS IN POSITION 13391000
         SR    CLIM,COLD          GET REAL LENGTH OF CHARACTERS TO MOVE 13392000
         AR    COLD,OLD           GET ACTUAL FROM ADDRESS               13393000
         CR    CLIM,R0            CAN WE DO IT IN ONE MOVE?             13394000
         BL    PASS2SBD           SKIP IF POSSIBLE                      13395000
*                                                                       13396000
*        LOOP TO MOVE DOWN 256 CHARACTERS AT A TIME                     13397000
*                                                                       13398000
PASS2SBC MVC   SCHARS(256,CNEW),SCHARS(COLD)          MOVE BLOCK OF CHA 13399000
         AR    CNEW,R0            PUSH 'TO' POINTER                     13400000
         AR    COLD,R0            PUSH 'FROM' POINTER                   13401000
         SR    CLIM,R0            DECREMENT LENGTH LEFT                 13402000
         CR    CLIM,R0            SMALL ENOUGH FOR ONE MVC?             13403000
         BNL   PASS2SBC           LOOP BACK IF NOT                      13404000
*                                                                       13405000
*        COME HERE TO MOVE LAST (<=256) CHUNK OF CHARACTERS             13406000
*                                                                       13407000
PASS2SBD EX    CLIM,PASS2SBM      DO VARIABLE LENGTH MVC                13408000
         AR    CNEW,CLIM          BUMP NEW CHAR ADDR PAST LAST CHAR     13409000
*                                                                       13410000
*        COME HERE TO SET UP POINTERS FOR NEXT BLOCK IN USE             13411000
*                                                                       13412000
PASS2SBE LR    COLD,R1            SET OFFSET OF USED CHARACTERS         13413000
         LA    COFF,0(COLD,OLD)   GET ADDRESS OF USED CHARACTERS        13414000
         SR    COFF,CNEW          GET OFFSET TO NEW LOCATION            13415000
         EJECT                                                          13416000
*                                                                       13417000
*        COME HERE TO RELOCATE OFFSET FIELD AND MAKE SURE ALL           13418000
*        USED CHARACTERS ARE COVERED BY CLIM                            13419000
*                                                                       13420000
PASS2SBF SR    R1,COFF            SUBTRACT NO. OF DELETED CHARACTERS    13421000
         STH   R1,SOFFSET(,R2)    STORE AS NEW OFFSET                   13422000
         AR    R1,COFF            RESTORE CURRENT OFFSET                13423000
         AH    R1,SLENGTH(,R2)    ADD IN 360 LENGTH OF PTR              13424000
         CR    CLIM,R1            CLIM MUST BE > SINCE 360 LEN USED     13425000
         BH    *+8                SKIP IF ALL CHARS ARE INCLUDED        13426000
         LA    CLIM,1(,R1)        ELSE GET PROPER CLIM                  13427000
         TM    3(R2),1            IS THIS END OF CHAIN?                 13428000
         BNO   PASS2SBA           LOOP BACK IF NOT                      13429000
         XI    3(R2),2            SET OR UNSET SPECIAL END FLAG         13430000
         LH    R1,SOFFSET(,R2)    SAVE LAST OFFSET OVER MVC CALL        13431000
         TM    3(R2),2            IS FLAG SET TO DO LAST MVC?           13432000
         BO    PASS2SBB           SKIP IF SO, R1 SET FOR NO RELOCATION  13433000
         STH   COLD,SOFFSET(,R2)  RESTORE CORRECT OFFSET SAVED BEFORE   13434000
         LA    R0,SCHARS+BOUND(,CNEW)       GET ADDRSS PAST NEW SBLOK   13435000
         N     R0,FULLWRD         PUT AT FULLWORD ADDRESS               13436000
         SR    R0,OLD             GET LENGTH OF NEW SBLOK               13437000
         LH    R2,STLENGTH(,OLD)  RESTORE OLD BLOCK LENGTH              13438000
         STH   R0,STLENGTH(,OLD)  STORE NEW BLOCK LENGTH                13439000
         L     R1,GCOLPTR(,OLD)   RESTORE INITIAL POINTER TO REFERENCES 13440000
*                                                                       13441000
*        LOOP TO RELOCATE POINTERS POINTING TO THIS BLOCK               13442000
*                                                                       13443000
PASS2RL  TM    3(R1),1            TEST FOR END OF CHAIN                 13444000
         L     GR1,0(,R1)         LOAD NEXT LINK ENTRY                  13445000
         IC    GR2,0(,R1)         SAVE UPPER BYTE                       13446000
         ST    NEW,0(,R1)         STORE NEW POINTER VALUE               13447000
         STC   GR2,0(,R1)         RESTORE UPPER BYTE                    13448000
         LR    R1,GR1             UPDATE POINTER TO NEXT LINK           13449000
         BNO   PASS2RL            BACK TO RELOC NXT FLD IF NOT CHN END  13450000
         AR    NEW,R0             UPDATE 'NEW' POINTER                  13451000
*                                                                       13452000
*        REENTER HERE FOR BLOCK NOT IN USE                              13453000
*                                                                       13454000
PASS2C   AR    OLD,R2             UPDATE CURRENT POINTER                13455000
         CR    OLD,LIM            ALL DONE?                             13456000
         BL    PASS2L             LOOP BACK IF NOT                      13457000
         IC    R2,DTYPE(,LAST)    ELSE SAVE BLOK CODE ON LAST BLOCK     13458000
         STE   ZR,GCOLPTR(,LAST)  SET ZERO FOR END OF CHAIN             13459000
         STC   R2,DTYPE(,LAST)    RESTORE BLOK CODE                     13460000
         B     PASS3              SKIP TO PASS 3                        13461000
PASS2SBM MVC   SCHARS(*-*,CNEW),SCHARS(COLD)                            13462000
         EJECT                                                          13463000
*                                                                       13464000
*        PASS 3                                                         13465000
*        ------                                                         13466000
*                                                                       13467000
*        RELOCATE RELOCATABLE CODE POINTERS IF ANY                      13468000
*                                                                       13469000
*        AT THIS STAGE, PASS 2 HAS PROCESSED ANY CODE BLOCKS FOUND      13470000
*        TO BE IN USE DURING PASS 1. THUS THE CODNLOC FIELD OF EACH     13471000
*        CODE BLOCK CORRECTLY INDICATES ITS NEW LOCATION AND PROVIDES   13472000
*        THE NECCESSARY INFORMATION FOR RELOCATION. THE ACTUAL          13473000
*        RELOCATION IS PERFORMED IN THE PTRPROCL ROUTINE WITH GR3=0     13474000
*                                                                       13475000
*        INITIALIZE TO PROCESS ECODE VALUES ON GECHAIN                  13476000
*                                                                       13477000
PASS3    L     LAST,GECHAIN       LOAD PTR TO FIRST ECODE ON CHAIN      13478000
         L     BOT,DYNAMB         RELOAD START OF MEMORY ADDRESS        13479000
         SR    GR3,GR3            INDICATE PASS3 FOR PTRPROCL           13480000
         B     PASS3B             MERGE INTO LOOP                       13481000
*                                                                       13482000
*        LOOP THROUGH ENTRIES ON GECHAIN                                13483000
*                                                                       13484000
PASS3L1  L     R1,0(,GR1)         LOAD EXPRESSION POINTER               13485000
         L     LAST,4(,GR1)       LOAD LINK POINTER TO NEXT ECODE       13486000
         BAL   GR2,PTRPRCL0       PROCESS EXPR PTR (MUST BE RELOC HERE) 13487000
*                                                                       13488000
*        HERE TO MOVE OUT ON CHAIN (MERGE HERE FIRST TIME)              13489000
*                                                                       13490000
PASS3B   LTR   GR1,LAST           MOVE OUT AND TEST FOR END OF CHAIN    13491000
         BNZ   PASS3L1            LOOP BACK IF MORE TO GO               13492000
*                                                                       13493000
*        INITIALIZE PROCESSING OF PATTERN EXPR PTRS ON CPCHAIN          13494000
*                                                                       13495000
         L     LAST,GPCHAIN       LOAD HEAD OF CHAIN                    13496000
         B     PASS3C             JUMP INTO LOOP                        13497000
*                                                                       13498000
*        LOOP THROUGH ENTRIES ON GPCHAIN                                13499000
*                                                                       13500000
PASS3L2  L     R1,PARAM2(,GR1)    LOAD EXPR POINTER FOR PTRPROCL        13501000
         L     LAST,PARAM1(,GR1)  LOAD FORWARD LINK POINTER             13502000
         LA    GR1,PARAM2(,GR1)   POINT TO FIELD TO RELOCATE            13503000
         BAL   GR2,PTRPRCL0       MERGE INTO PTRPROCL                   13504000
*                                                                       13505000
*        HERE TO MOVE OUT ON CHAIN, MERGE HERE FIRST TIME THROUGH       13506000
*                                                                       13507000
PASS3C   LTR   GR1,LAST           MOVE OUT ON CHAIN AND TEST FOR END    13508000
         BNZ   PASS3L2            LOOP BACK IF MORE TO GO               13509000
*                                                                       13510000
*        THE REMAINING SECTION NEED ONLY BE DONE IF THE SPECIAL         13511000
*        LABEL RELOCATE FLAG HAS BEEN SET (SEE PTRPROCL)                13512000
*                                                                       13513000
         CLI   LABRLFLG,0         ANY LABEL PTRS TO RELOCATE?           13514000
         BZ    PASS4              ALL DONE WITH PASS 3 IF NOT           13515000
         L     LAST,HASHTBAD      POINT TO VARIABLE BLOCK HASH TABLE    13516000
         EJECT                                                          13517000
*                                                                       13518000
*        PASS 3 -- CONTINUED                                            13519000
*        -------------------                                            13520000
*                                                                       13521000
*        LOOP THROUGH SLOTS IN HASH TABLE                               13522000
*                                                                       13523000
PASS3L   L     NEW,VLINK(,LAST)   POINT TO FIRST VAR BLOCK ON CHAIN     13524000
*                                                                       13525000
*        LOOP THROUGH VARIABLE BLOCKS ON ONE CHAIN                      13526000
*                                                                       13527000
PASS3LL  NR    NEW,MSK            STRIP UPPER BYTE AND TEST             13528000
         BZ    PASS3E             SKIP IF END OF THIS CHAIN             13529000
         LA    GR1,VLABL(,NEW)    ELSE POINT TO LABEL FIELD             13530000
         BAL   GR2,PTRPROCL       PROCESS IT                            13531000
         L     NEW,VLINK(,NEW)    MOVE OUT ON CHAIN                     13532000
         B     PASS3LL            LOOP BACK                             13533000
*                                                                       13534000
*        HERE TO MOVE TO NEXT HASH SLOT                                 13535000
*                                                                       13536000
PASS3E   LA    LAST,4(,LAST)      POINT TO NEXT SLOT                    13537000
         C     LAST,HASHTBEN      MORE SLOTS TO GO?                     13538000
         BL    PASS3L             LOOP BACK IF SO                       13539000
*                                                                       13540000
*        NOW PROCESS CODE POINTERS ON MAIN STACK (PDR)                  13541000
*                                                                       13542000
         L     PDR,PDRLOC         RESET STACK POINTER TO TOP LEVEL      13543000
*                                                                       13544000
*        LOOP THROUGH LEVELS OF STACK, SEE PASS 1 FOR EXPLANATION       13545000
*        OF THE INTERPRETAION OF THE FBLOKLOK AND EVLINK FIELDS         13546000
*                                                                       13547000
PASS3SL  L     R0,FBLOKLOC(,PDR)  LOAD FUNCTION BLOCK POINTER           13548000
         LTR   R0,R0              TEST IT                               13549000
         BP    PASS3F             SKIP IF FUNCTION ON THIS LEVEL        13550000
         BM    PASS13SL           AT STACK END, PROCESS SPECIAL LOCS    13551000
         TM    EVLINK(PDR),X'30'  IF UNEVAL EXPR, TEST CONDITION CODE   13552000
         BNZ   PASS3F             SKIP IF EVAL FUNCTION CALL            13553000
*                                                                       13554000
*        HERE WE HAVE A PATTERN MATCH ON THE PREVIOUS LEVEL             13555000
*                                                                       13556000
         L     PDR,PDRBPTR(,PDR)  POP PDR TO PATTERN LEVEL              13557000
         LA    GR1,RETLOCP(,PDR)  POINT TO RETURN SAVE LOC              13558000
         BAL   GR2,PTRPROCL       PROCESS IT                            13559000
         LA    GR1,FRETLOCP(,PDR) POINT TO FRETURN SAVE LOC             13560000
         BAL   GR2,PTRPROCL       PROCESS IT                            13561000
         B     PASS3SL            LOOP BACK FOR NEXT STACK LEVEL        13562000
*                                                                       13563000
*        HERE WE HAVE A FUNCTION CALL                                   13564000
*                                                                       13565000
PASS3F   LA    GR1,RETFLOC(,PDR)  POINT TO SAVED VALUE OF (RETURN)      13566000
         BAL   GR2,PTRPROCL       PROCESS IT                            13567000
         LA    GR1,FRETFLOC(,PDR) POINT TO SAVED VALUE OF (FRETURN)     13568000
         BAL   GR2,PTRPROCL       PROCESS IT                            13569000
         L     PDR,PDRBPTR(,PDR)  POINT TO PREVIOUS STACK LEVEL         13570000
         B     PASS3SL            LOOP BACK FOR NEXT LEVEL              13571000
         EJECT                                                          13572000
*                                                                       13573000
*        PASS 4                                                         13574000
*        ------                                                         13575000
*                                                                       13576000
*        THIS IS THE PASS WHERE WE ACTUALLY MOVE THE BLOCKS             13577000
*                                                                       13578000
PASS4    L     NEW,DYNAMB         LOAD START OF DYNAMIC CORE            13579000
         L     OLD,PASS3S         INITIALIZE POINTER TO BLOCKS IN USE   13580000
         LA    GR2,256            GET CRANK CONSTANT                    13581000
         B     PASS4M3            JUMP INTO LOOP                        13582000
*                                                                       13583000
*        LOOP THROUGH RELOCATING BLOCKS                                 13584000
*                                                                       13585000
PASS4L   SR    R2,R2              CLEAR FOR IC, GETLENG CALL            13586000
         IC    R2,DTYPE(,OLD)     LOAD BLOCK TYPE                       13587000
         L     GR1,GCOLPTR(,OLD)  LOAD POINTER TO NEXT BLOCK            13588000
         STE   ZR,GCOLPTR(,OLD)   CLEAR OUT GBGCOL FIELD                13589000
         STC   R2,DTYPE(,OLD)     RESTORE BLOCK CODE                    13590000
         EX    0,BLOKLEN(R2)      GET LENGTH OF BLOCK IN R2             13591000
         CR    R2,GR2             TEST FOR SHORT (<=256 CHARACTERS)     13592000
         BL    PASS4M2            SKIP IF SHORT                         13593000
*                                                                       13594000
*        LOOP TO MOVE LONG BLOCK IN 256-BYTE CHUNKS                     13595000
*                                                                       13596000
PASS4LM  MVC   0(256,NEW),0(OLD)  MOVE 256-BYTE CHUNK                   13597000
         AR    NEW,GR2            ADVANCE NEW BLOCK POINTER             13598000
         AR    OLD,GR2            ADVANCE OLD BLOCK POINTER             13599000
         SR    R2,GR2             DECREASE COUNT OF CHARACTERS LEFT     13600000
         CR    R2,GR2             TEST FOR LONG (>256 CHARACTERS LEFT)  13601000
         BNL   PASS4LM            LOOP BACK IF YES                      13602000
*                                                                       13603000
*        REENTER HERE FOR SHORT BLOCK <= 256 CHARS                      13604000
*                                                                       13605000
PASS4M2  EX    R2,PASS4MM         MOVE REMAINING CHARACTERS             13606000
         AR    NEW,R2             UPDATE NEW BLOCK POINTER              13607000
         LR    OLD,GR1            UPDATE OLD BLOCK IN USE POINTER       13608000
*                                                                       13609000
*        ENTER HERE FOR FIRST BLOCK                                     13610000
*                                                                       13611000
PASS4M3  NR    OLD,MSK            STRIP UPPER BYTE OF POINTER           13612000
         BNZ   PASS4L             LOOP BACK UNLESS ZERO (END OF CHAIN)  13613000
         C     LIM,CONCFRSV       CHECK CONCAT SAVEAREA PTR FOR HERE    13614000
         STE   ZR,CONCFRSV        ZERO IN CASE OF NE                    13615000
         BNE   *+8                SKIP IF NOT EQUAL                     13616000
         ST    NEW,CONCFRSV       ELSE UPDATE IT                        13617000
         C     LIM,PCFRSAVE       CHECK FOR COLLECT FROM PAT BUILDER    13618000
         BNE   *+8                SKIP IF NOT IN MIDDLE OF PAT BUILD    13619000
         ST    NEW,PCFRSAVE       ELSE STORE NEW FREE CORE ADDRESS      13620000
         L     OLD,GCOLSV+4*FR    LOAD OLD FR VALUE                     13621000
         ST    NEW,GCOLSV+4*FR    STORE NEW FR POINTER                  13622000
         CLI   CLLCTFL,X'FF'      CHECK FOR COLLECT CALL                13623000
         BE    GCOLEXIT           SKIP SPACE CHECK IF SO, JUMP TO EXIT  13624000
         CR    NEW,OLD            SEE IF WE MADE SOME ROOM              13625000
         BNL   PASS4ERR           OUT OF CORE IF NO CHANGE              13626000
         EJECT                                                          13627000
*                                                                       13628000
*                                                                       13629000
*        MERGE HERE FOR CASE OF CORE EMPTY ON ORIGINAL CALL             13630000
*                                                                       13631000
GCOLCHK  C     NEW,GCOLSV+4*PDR   IS OUR NEW CORE < PDR?                13632000
         BNL   PASS4ERR           OUT OF CORE IF NOT LOW                13633000
*                                                                       13634000
*        EXIT POINT                                                     13635000
*                                                                       13636000
GCOLEXIT LM    0,15,GCOLSV        RESTORE ALL REGISTERS                 13637000
         MVI   ZTBL+X'47',0       RESET ZTBL TO ZEROS                   13638000
         BR    RETURN             AND RETURN TO CALLER                  13639000
*                                                                       13640000
PASS4MM  MVC   0(*-*,NEW),0(OLD)  MOVE REMAINING CHARS OF BLOCK         13641000
*                                                                       13642000
*        COME HERE IF GARBAGE COLLECT DID NOT WORK (MEMORY OVERFLOW)    13643000
*                                                                       13644000
PASS4ERR LM    0,15,GCOLSV        RESTORE REGS IN CASE OF SETEXIT       13645000
         MVI   ZTBL+X'47',0       RESET ZTBL TO ZEROS                   13646000
         XI    GCOLNRG,GCMPRSS    FLIP SETTING OF SPCL GBGCL BIT        13647000
         TM    GCOLNRG,GCMPRSS    TEST CURRENT SETTING                  13648000
         BCR   O,R1               COLLECT AGAIN IF NOW SET TO COMPRESS  13649000
         XERR  06,001             OVERFLOW IN MAIN DYNAMIC STORAGE AREA 13650000
*                                                                       13651000
*        NOTE THAT AT THE CURRENT TIME, RECOVERY FROM THIS ERROR        13652000
*        IS NOT ALWAYS RELIABLE SINCE SOME ROUTINES BUILD ON FR BEFORE  13653000
*        CHECKING. IF THIS HAPPENS IN A LOOP, PDR DESTRUCTION OCCURS    13654000
         TITLE 'SPITBOLX -- INPUT-OUTPUT ROUTINES'                      13655000
*                                                                       13656000
*        WRITE OUTPUTS ITS ARGUMENT OR DATATYPE NAME IF NOT A STRING    13657000
*                                                                       13658000
         USING *,A2+1             BASE REGISTER                         13659000
WRITE    ST    RETURN,WRETLOC     SAVE RETURN LOCATION                  13660000
         TM    VFLAGS(A2),VTRC    CHECK FOR VALUE TRACE                 13661000
         BNO   WRITE0             SKIP IF NO TRACE                      13662000
*                                                                       13663000
*        COME HERE IF WE HAVE A VALUE TRACE TO PERFORM                  13664000
*                                                                       13665000
         ST    DB4,PSTRING+4(,PDR)          SAVE BASE OVER TRACE CALL   13666000
         L     DB4,=A(DTERTNS)    GET TRACE ROUTINE BASE REGISTER       13667000
         B     VALTRACE-DTERTNS(,DB4)       CALL VALUE TRACE ROUTINE    13668000
*                                                                       13669000
*        COME HERE FOR ORDINARY WRITE CASE                              13670000
*                                                                       13671000
WRITE0   CE    ZR,V$OUTPUT        HAS OUTPUT BEEN TURNED OFF?           13672000
         BE    WRITEX             B IF OFF                              13673000
         BAL   RETURN,GETSTGS     CONVERT TO STRING                     13674000
         BAL   RETURN,$$DTTP      GET DATATYPE NAME IF NOT CONVERTIBLE  13675000
         BALR  RETURN,0           ESTABLISH A NEW BASE REG              13676000
         USING *,RETURN           TELL ASSEMBLER                        13677000
         DROP  A2+1               DROP OLD BASE, IT GETS CLOBBERED      13678000
         L     R1,VIOPTR(,A2)     LOAD POINTER TO FILE INFORMATION      13679000
         L     R0,OFILE(,R1)      LOAD INTERFACE FILE POINTER           13680000
         L     A2,OFORMAT(,R1)    GET FORMAT ADDRESS                    13681000
         AH    A2,OFORMAT+SOFFSET(,R1)      ADD IN OFFSET               13682000
         LA    A2,SCHARS(,A2)     POINT TO FIRST CHARACTER              13683000
         LH    A2+1,OFORMAT+SLENGTH(,R1)    GET 360 LENGTH OF FORMAT    13684000
         LA    A2+1,1(,A2+1)      GET REAL LENGTH OF FORMAT             13685000
         CLI   OFORMAT(R1),NCODE  CHECK FOR NULL CASE                   13686000
         BNE   *+6                SKIP IF NOT                           13687000
         SR    A2+1,A2+1          IF NULL, SET LENGTH OF FORMAT = 0     13688000
         LA    A1,SCHARS(,A1)     POINT TO FIRST CHARACTER OF STRING    13689000
         LA    A1+1,1(,A1+1)      GET REAL LENGTH OF STRING             13690000
         C     R0,PRINTDCB        SET CC FOR PRINTER/PUNCH IN CASE ERR  13691000
         L     R2,VOUTPUTS        LOAD ADDRESS OF OUTPUT ROUTINE        13692000
         BALR  R1,R2              CALL ROUTINE                          13693000
         B     SYSERROR           JUMP TO SIGNAL ERROR ON ERROR RETURN  13694000
         LTR   R0,R0              CHECK FOR TOO MANY RECORDS WRITTEN    13695000
         BNZ   WRITEX             JUMP TO EXIT IF OK                    13696000
         SPM   R1                 ELSE RECALL CC FROM PRINT/PUNCH CHECK 13697000
         BNE   *+8                SKIP IF PUNCH CASE, ELSE PRINT CASE   13698000
         XERR  11,001             PAGE LIMIT EXCEEDED                   13699000
         XERR  11,002             CARD LIMIT EXCEEDED                   13700000
*                                                                       13701000
*        MERGE HERE TO EXIT                                             13702000
*                                                                       13703000
WRITEX   L     RETURN,WRETLOC     RESTORE RETURN REGISTER               13704000
         BR    RETURN             AND RETURN TO CODE                    13705000
*                                                                       13706000
VOUTPUTS DC    V(SYSWRITE)        ADDRESS OF OUTPUT ROUTINE             13707000
         DROP  RETURN             DROP BASE REG                         13708000
         EJECT                                                          13709000
*                                                                       13710000
*        PROCESSING ON READ CALL                                        13711000
*                                                                       13712000
*        THIS ROUTINE CHECKS FOR AN INPUT ASSOCIATION AND PERFORMS      13713000
*        ANY NECCESSARY INPUT OPERATION                                 13714000
*                                                                       13715000
         USING *,A2+1             OUR BASE REG                          13716000
READ     LR    A2,A1              GET VARIABLE BLOCK PTR IN CORRECT REG 13717000
         CE    ZR,V$INPUT         HAS INPUT BEEN TURNED OFF?            13718000
         BE    READ4A             GET RESULT IF OFF                     13719000
         TM    VFLAGS(A2),VINP+VINA         IS VAR INPUT ASSOCIATED?    13720000
         BNO   READ4A             GET RESULT IF NOT                     13721000
*                                                                       13722000
*        COME HERE WHEN WE KNOW VARIABLE IS READ ASSOCIATED             13723000
*                                                                       13724000
         L     A1,VIOPTR(,A2)     GET POINTER TO IOBLOK                 13725000
         L     R0,IFILE(,A1)      GET INTERFACE FILE POINTER            13726000
         L     R2,VSYSMAXL        GET ADDR OF INTERFACE ROUTINE TO GIVE 13727000
*                                 MAXIMUM POSSIBLE RECORD LENGTH        13728000
         BALR  R1,R2              AND CALL IT                           13729000
         B     SYSERROR           GIVE ERROR MESSAGE IF COME HERE       13730000
         LR    R2,R0              COPY MAXIMUM RECORD LENGTH            13731000
*                                                                       13732000
*        COME HERE TO CHECK FOR COLLECT NEEDED                          13733000
*                                                                       13734000
READ0A   LA    R1,SCHARS+BOUND(R2,FR)       GET FINAL FREE CORE ADDR    13735000
         CR    R1,PDR             WILL WE OVERFLOW?                     13736000
         BL    READ0              SKIP IF NOT                           13737000
*                                                                       13738000
*        COME HERE IF A GARBAGE COLLECTION IS REQUIRED. A SPECIAL       13739000
*        SITUATION ARISES WHEN READSAVE HAS SAVED THE VALUE OF A2,A2+1  13740000
*        IF THE READ CALL WAS PRECEDED BY LR A2,A1 LR A2+1,A1+1, THEN   13741000
*        IT MUST BE RELOCATED, OTHERWISE IT IS GARBAGE AND MUST NOT BE. 13742000
*                                                                       13743000
         ST    RETURN,RETLOC      SAVE RETURN ADDRESS                   13744000
         CLI   READFLG,1          READSAVE SAVED VALUE OF A2,A2+1?      13745000
         BNE   READGG             IF NOT, READSAVE IS OK                13746000
         SH    RETURN,H8          ELSE POINT BACK TO POSSIBLE LR INS    13747000
         CLC   0(4,RETURN),READCI DO WE HAVE LR A2,A1 LR A2+1,A1+1?     13748000
         BE    READGG             IF SO, READSAVE IS VALID              13749000
         STE   ZR,READSAVE        ELSE READSAVE IS GARBAGE, CLEAR IT    13750000
*                                                                       13751000
*        HERE CALL THE GARBAGE COLLECTOR                                13752000
*                                                                       13753000
READGG   BAL   RETURN,GBGCL0      COLLECT                               13754000
         L     RETURN,RETLOC      RESTORE RETURN ADDRESS                13755000
         L     A1,VIOPTR(,A2)     RELOAD POINTER TO IOBLOK              13756000
         B     READ0A             AND BACK TO CHECK FOR SPACE           13757000
         EJECT                                                          13758000
*                                                                       13759000
*        COME HERE WITH ENOUGH ROOM FOR MAX LENGTH RECORD               13760000
*                                                                       13761000
READ0    L     R0,IFILE(,A1)      GET INTERFACE FILE POINTER            13762000
         LA    A1,SCHARS(,FR)     POINT TO BUFFER ADDRESS               13763000
         L     R2,VREAD           GET ADDRESS OF INTERFACE READ ROUTINE 13764000
         BALR  R1,R2              AND CALL IT                           13765000
         B     SYSERROR           THIS IS THE ERROR RETURN              13766000
*                                                                       13767000
*        RE-ENTER HERE IF RECORD OK                                     13768000
*                                                                       13769000
         LTR   A1+1,R0            COPY AND TEST RECORD LENGTH           13770000
         BCR   M,FRETURN          FAIL IF NEGATIVE (END OF FILE)        13771000
         BZ    READNUL            JUMP IF ZERO (NULL RECORD READ)       13772000
         L     R2,VIOPTR(,A2)     GET ADDRESS OF IOBLOK                 13773000
         L     R2,IFORMAT+4(,R2)  LOAD INTEGER RECORD LENGTH            13774000
         LTR   R2,R2              WAS A LENGTH SPECIFIED?               13775000
         BZ    *+12               SKIP IF NOT                           13776000
         CR    A1+1,R2            ELSE WAS SIZE OF RECORD READ GREATER? 13777000
         BNH   *+6                SKIP IF INPUTED RECORD MEETS SPECS    13778000
         LR    A1+1,R2            ELSE USE FORMAT LENGTH                13779000
         BCTR  A1+1,0             ADJUST TO 360 LENGTH                  13780000
         CE    ZR,V$TRIM          HAS TRIM BEEN TURNED OFF?             13781000
         BE    READ1              SKIP TRIM IF IT HAS                   13782000
         LA    R1,0(A1,A1+1)      POINT TO LAST CHARACTER               13783000
         LA    A1+1,1(,A1+1)      GET REAL LENGTH                       13784000
         BALR  R2,0               SET LOOP REGISTER                     13785000
*                                                                       13786000
*        LOOP TO REMOVE TRAILING BLANKS                                 13787000
*                                                                       13788000
         CLI   0(R1),C' '         IS IT A BLANK?                        13789000
         BNE   READTD             TRIM DONE IF NOT                      13790000
         BCTR  R1,0               BACK UP 1 CHARACTER                   13791000
         BCTR  A1+1,R2            CHECK LENGTH REMAINING, LOOP IF DONE 13792000
*                                                                       13793000
*        COME HERE IF RETURNED RESULT IS NULL                           13794000
*                                                                       13795000
READNUL  MVI   VALUE(A2),NCODE    SET RESULT=NULL                       13796000
         B     READ4A             OFF TO GET VALUE IN REGISTER          13797000
         EJECT                                                          13798000
*                                                                       13799000
*        COME HERE TO FIX LENGTH AFTER TRIM                             13800000
*                                                                       13801000
READTD   BCTR  A1+1,0             GET 360 LENGTH                        13802000
*                                                                       13803000
*        COME HERE IF NO TRIM TO BE DONE (MERGE AFTER TRIM)             13804000
*                                                                       13805000
READ1    C     A1+1,V$MAXLN       IS THIS GT &MAXLNGTH?                 13806000
         BL    *+8                360 LENGTH MUST BE LESS THAN MAXLEN   13807000
         XERR  11,003             INPUT RECORD LONGER THAN &MAXLNGTH    13808000
         STE   ZR,0(,FR)          SET SBLOK=GCOLPTR=0                   13809000
         LA    R2,SCHARS+BOUND+1(,A1+1)     PUSH OVER PROPER BOUNDARY   13810000
         N     R2,FULLWRD         PUT ON PROPER BOUNDARY                13811000
         STH   R2,STLENGTH(,FR)   STORE LENGTH IN BLOCK                 13812000
         ST    FR,VALUE(,A2)      SAVE POINTER TO THIS BLOCK            13813000
         MVI   VALUE(A2),SCODE    SET RESULT=STRING                     13814000
         ST    A1+1,VALUE+4(,A2)  STORE OFFSET(=0) AND 360 LENGTH       13815000
         AR    FR,R2              PUSH FREE CORE POINTER PAST BLOCK     13816000
*                                                                       13817000
*        COMMON EXIT ROUTINE TO LOAD VALUE                              13818000
*                                                                       13819000
READ4A   CLI   READFLG,1          RETURN VALUE IN A1?                   13820000
         BNE   READ5              B IF SHOULD RETURN IN A2              13821000
         LM    A1,A1+1,VALUE(A2)  GET VALUE IN A1,A1+1                  13822000
         LM    A2,A2+1,READSAVE   RESTORE A2 VALUE IN CASE OF DOIO CALL 13823000
         BR    RETURN             AND RETURN TO CALLER                  13824000
*                                                                       13825000
*        ENTER HERE IF RESULTS ARE NEEDED IN A2,A2+1                    13826000
*                                                                       13827000
READ5    LM    A2,A2+1,VALUE(A2)  GET VALUE TO RETURN                   13828000
         LM    A1,A1+1,READSAVE   RESTORE A1 VALUE                      13829000
         BR    RETURN             AND RETURN TO CALLER                  13830000
*                                                                       13831000
READMV   MVC   SCHARS(*-*,FR),SCHARS(A1)    MOVE IN CHARS               13832000
VREAD    DC    V(SYSREAD)         ROUTINE TO READ A RECORD              13833000
VSYSMAXL DC    V(SYSMAXL)         INTERFACE ROUTINE TO RETURN MAX RL    13834000
*                                                                       13835000
*        INSTRUCTIONS USED IN READSAVE GARBAGE COLLECT TEST             13836000
*                                                                       13837000
READCI   LR    A2,A1              LR INSTRUCS INDICATING READSAVE OK    13838000
         LR    A2+1,A1+1          .                                     13839000
         DROP  A2+1               DROP READ BASE REGISTER               13840000
         TITLE 'SPITBOLX -- ROUTINE FOR DATATYPE FUNCTION'              13841000
*                                                                       13842000
*        CONDITIONS ON ENTRY                                            13843000
*                                                                       13844000
*        (A1,A1+1)                ARGUMENT                              13845000
*        (R2)                     BASE REG                              13846000
*                                                                       13847000
         USING DATATPP,R2         SET BASE REG FOR ASSEMBLER            13848000
DATATPP  ST    A1,DATATSV         STORE ARGUMENT TO TEST TYPE           13849000
         CLI   DATATSV,DCODE      TEST FOR PROGRAM DEFINED DATATYPE     13850000
         BNE   DATATPS            SKIP IF NOT PROG DEFINED DATATYPE     13851000
*                                                                       13852000
*        CASE OF PROGRAM DEFINED DATATYPE                               13853000
*                                                                       13854000
         L     A1,PDFPTR(,A1)     PICK UP POINTER TO PDFBLOK            13855000
         L     A1,PDFNPTR(,A1)    PICK UP POINTER TO DATATYPE NAME      13856000
         LM    A1,A1+1,VNAME(A1)  PICK UP NAME                          13857000
         BR    RETURN             RETURN TO CALLER                      13858000
*                                                                       13859000
*        COME HERE FOR ALL OTHER CASES                                  13860000
*                                                                       13861000
DATATPS  LA    A1,4               SET INCREMENT FOR BXLE                13862000
         LA    A1+1,DATATBLE      SET FOR END TEST                      13863000
         LA    R1,DATATBL         POINT TO TABLE OF ENTRIES             13864000
*                                                                       13865000
*        SEARCH THROUGH FOR MATCH ON DATA TYPES                         13866000
*                                                                       13867000
DATAPL   CLC   DATATSV(1),0(R1)   IS THIS THE RIGHT TYPE?               13868000
         BE    *+8                SKIP IF SO                            13869000
         BXLE  R1,A1,DATAPL       LOOP BACK                             13870000
*                                                                       13871000
*        WE FALL THROUGH ABOVE BXLE ONLY IF DATATYPE IS EXTERNAL        13872000
*                                                                       13873000
DATAPL1  L     A1,DATATPBS        LOAD BASE ADDRESS OF STRING           13874000
         AH    A1,2(,R1)          ADD OFFSET                            13875000
         SR    A1+1,A1+1          CLEAR LENGTH FIELD AND SET OFFSET=0   13876000
         IC    A1+1,1(,R1)        LOAD LENGTH                           13877000
         BR    RETURN             RETURN TO CALLER                      13878000
         EJECT                                                          13879000
*                                                                       13880000
*        TABLE OF DATATYPE NAMES                                        13881000
*                                                                       13882000
DTP      EQU   *                  ADDRESS OF START OF TABLE             13883000
DTPS     DC    C'STRING'          SCODE,NCODE                           13884000
DTPI     DC    C'INTEGER'         ICODE                                 13885000
DTPR     DC    C'REAL'            RCODE                                 13886000
DTPP     DC    C'PATTERN'         PCODE                                 13887000
DTPA     DC    C'ARRAY'           ACODE                                 13888000
DTPM     DC    C'NAME'            MCODE                                 13889000
DTPT     DC    C'TABLE'           TCODE                                 13890000
DTPE     DC    C'EXPRESSION'      ECODE,VCODE                           13891000
DTPW     DC    C'DREAL'           WCODE                                 13892000
DTPC     DC    C'CODE'            CCODE                                 13893000
DTPX     DC    C'EXTERNAL'        EXTERNAL CODE                         13894000
*                                                                       13895000
         CNOP  0,4                ALLIGN                                13896000
DATATPBS DC    AL1(SCODE)         BASE POINTER (STRING CODE)            13897000
         DC    AL3(DTP-SCHARS)    OFFSETTED BASE ADDRESS OF NAMES       13898000
*                                                                       13899000
*        TABLE TO SEARCH FOR RIGHT NAME                                 13900000
*                                                                       13901000
*                                                                       13902000
DATATBL  EQU   *                  START OF TABLE                        13903000
         DC    AL1(SCODE,5,0,DTPS-DTP)      STRING                      13904000
         DC    AL1(ICODE,6,0,DTPI-DTP)      INTEGER                     13905000
         DC    AL1(ACODE,4,0,DTPA-DTP)      ARRAY                       13906000
         DC    AL1(RCODE,3,0,DTPR-DTP)      REAL                        13907000
         DC    AL1(TCODE,4,0,DTPT-DTP)      TABLE                       13908000
         DC    AL1(NCODE,5,0,DTPS-DTP)      STRING                      13909000
         DC    AL1(MCODE,3,0,DTPM-DTP)      NAME                        13910000
         DC    AL1(PCODE,6,0,DTPP-DTP)      PATTERN                     13911000
         DC    AL1(ECODE,9,0,DTPE-DTP)      EXPRESSION                  13912000
         DC    AL1(VCODE,9,0,DTPE-DTP)      EXPRESSION                  13913000
         DC    AL1(WCODE,4,0,DTPW-DTP)      DREAL                       13914000
         DC    AL1(CCODE,3,0,DTPC-DTP)      CODE                        13915000
         DC    AL1(0,7,0,DTPX-DTP)          EXTERNAL                    13916000
DATATBLE EQU   *-8                LAST ENTRY (EXCLUDING EXTERNAL)       13917000
         DROP  R2                 DROP DATATP BASE REG                  13918000
         TITLE 'SPITBOLX -- KEYWORD ACCESS ROUTINES'                    13919000
*                                                                       13920000
*        KEYWORD FETCH ROUTINE ENTERED FROM $$KGET IN SPITBOLA          13921000
*                                                                       13922000
         USING KGETC,R2           BASE REGISTER SET BY $$GET            13923000
KGETC    ST    RETURN,RETLOC      SAVE IN CASE OF ERRORS                13924000
         LA    A1,0(,A1)          CLEAR UPPER BYTE                      13925000
         CR    A1,FR              IS THIS BLOCK ABOVE FREE CORE?        13926000
         BH    KGETC1             NATURAL VARIABLE IF SO, SKIP          13927000
         C     A1,DYNAMB          IS IT BELOW FREE CORE?                13928000
         BL    KGETC1             SKIP IF LOW(NATURAL VARIABLE)         13929000
         XERR  05,001             AN ATTEMPT WAS MADE TO ACCESS THE     13930000
*                                 KEYWORD ATTRIBUTE OF A NON-NATURAL    13931000
*                                 VARIABLE                              13932000
*                                                                       13933000
*        COME HERE IF THE KEYWORD BLOCK IS IN THE ADDRESSABLE REGION    13934000
*                                                                       13935000
KGETC1   SR    R1,R1              CLEAR FOR IC                          13936000
         IC    R1,VKEY(,A1)       LOAD KEYWORD VALUE                    13937000
*                                                                       13938000
*        DUMP FUNCTION ENTERS HERE                                      13939000
*        CH ARE DONE TO MAKE DUMP MERGE EASY                            13940000
*                                                                       13941000
KGETC2   CH    R1,=Y(KREGGET)     IS THIS KEYWORD SIMPLY ACCESSABLE?    13942000
         BL    KGTRYP             CHECK FOR PATTERN GET IF NOT          13943000
         SR    A1,A1              INDICATE INTEGER RESULT               13944000
         L     A1+1,V$ABEND-K$ABEND(R1)    LOAD KEYWORD VALUE           13945000
         BR    RETURN             AND RETURN TO CALLER                  13946000
*                                                                       13947000
*        COME HERE TO CHECK FOR SPECIAL GET OR PATTERN KEYWORDS         13948000
*                                                                       13949000
KGTRYP   CH    R1,=Y(KPATGET)     TEST FOR PATTERN KEYWORD              13950000
         BL    KSPECGTB(R1)       ELSE SPECIAL GET, OFF TO PROPER CODE  13951000
         L     A1,KGPATTB(R1)     LOAD PATTERN VALUE                    13952000
         BR    RETURN             AND RETURN TO CALLER                  13953000
         EJECT                                                          13954000
*                                                                       13955000
*        KEYWORD NUMBERS MUST BE IN THE FOLLOWING SPECIAL ORDER         13956000
*        THOSE WHICH ARE PROTECTED AND HAVE SPECIAL GET ROUTINES        13957000
*        &ALPHABET                                                      13958000
*        THOSE WHICH ARE PROTECTED AND ARE PATTERNS                     13959000
*        THOSE WHICH ARE PROTECTED AND HAVE GET=LOAD                    13960000
*        THOSE WHOSE PUT=STORE AND GET=LOAD                             13961000
*        THOSE WHICH HAVE SPECIAL PUT ROUTINES AND GET=LOAD             13962000
*        &ERRTYPE                                                       13963000
*        IN ADDITION INITIALIZATION DIFFICULTIES SHOULD BE CONSIDERED   13964000
*        AND THE LARGEST VALUE MUST BE LESS THAN X'80' FOR PLUS VFUNC   13965000
*                                                                       13966000
*        NOTE THAT THE ENTRIES FOR &FNCLEVEL, &TRACE, &FTRACE MUST      13967000
*        CONTIGUOUS, SEE CODING AT FUNCTION ENTRY AND EXIT.             13968000
*                                                                       13969000
K$UNDEFI EQU   0                  KEYWORD VALUE FOR UNDEFINED KEYWORD   13970000
K$LASTNO EQU   K$UNDEFI+4         KEYWORD VALUE FOR &LASTNO             13971000
K$RTNTYP EQU   K$LASTNO+4         KEYWORD VALUE FOR &RTNTYPE            13972000
K$STCOUN EQU   K$RTNTYP+4         KEYWORD VALUE FOR &STCOUNT            13973000
K$STNO   EQU   K$STCOUN+4         KEYWORD VALUE FOR &STNO               13974000
K$ALPHAB EQU   K$STNO+4           KEYWORD VALUE FOR &ALPHABET           13975000
K$ABORT  EQU   K$ALPHAB+4         KEYWORD VALUE FOR &ABORT              13976000
K$ARB    EQU   K$ABORT+4          KEYWORD VALUE FOR &ARB                13977000
K$BAL    EQU   K$ARB+4            KEYWORD VALUE FOR &BAL                13978000
K$FAIL   EQU   K$BAL+4            KEYWORD VALUE FOR &FAIL               13979000
K$FENCE  EQU   K$FAIL+4           KEYWORD VALUE FOR &FENCE              13980000
K$REM    EQU   K$FENCE+4          KEYWORD VALUE FOR &REM                13981000
K$SUCCEE EQU   K$REM+4            KEYWORD VALUE FOR &SUCCEED            13982000
K$FNCLEV EQU   K$SUCCEE+4         KEYWORD VALUE FOR &FNCLEVEL           13983000
K$TRACE  EQU   K$FNCLEV+4         KEYWORD VALUE FOR &TRACE              13984000
K$FTRACE EQU   K$TRACE+4          KEYWORD VALUE FOR &FTRACE             13985000
K$ABEND  EQU   K$FTRACE+4         KEYWORD VALUE FOR &ABEND              13986000
K$CODE   EQU   K$ABEND+4          KEYWORD VALUE FOR &CODE               13987000
K$DUMP   EQU   K$CODE+4           KEYWORD VALUE FOR &DUMP               13988000
K$ERRLIM EQU   K$DUMP+4           KEYWORD VALUE FOR &ERRLIMIT           13989000
K$INPUT  EQU   K$ERRLIM+4         JEYWORD VALUE FOR &INPUT              13990000
K$OUTPUT EQU   K$INPUT+4          KEYWORD VALUE FOR &OUTPUT             13991000
K$TRIM   EQU   K$OUTPUT+4         KEYWORD VALUE FOR &TRIM               13992000
K$MAXLNG EQU   K$TRIM+4           KEYWORD VALUE FOR &MAXLNGTH           13993000
K$STLIMI EQU   K$MAXLNG+4         KEYWORD VALUE FOR &STLIMIT            13994000
K$ANCHOR EQU   K$STLIMI+4         KEYWORD VALUE FOR &ANCHOR             13995000
K$FULLSC EQU   K$ANCHOR+4         KEYWORD VALUE FOR &FULLSCAN           13996000
K$ERRTYP EQU   K$FULLSC+4         KEYWORD VALUE FOR &ERRTYPE            13997000
*                                                                       13998000
KPATGET  EQU   K$ALPHAB+4         LOWEST KEYWORD NUMBER FOR PATTERNS    13999000
*                                                                       14000000
KPROPUT  EQU   K$FNCLEV           HIGHEST PROTECTED KEYWORD             14001000
*                                                                       14002000
KREGGET  EQU   K$SUCCEE+4         LOWEST KEYWORD FOR REGULAR LOAD       14003000
*                                                                       14004000
KSPCPUT  EQU   K$MAXLNG           KEYWORD NUMBER OF LOWEST SPECIAL PUT  14005000
         EJECT                                                          14006000
*                                                                       14007000
*        COME HERE FOR KEYWORDS REQUIRING SPECIAL GETS                  14008000
*        ALSO COME HERE IF VARIABLE DOES NOT HAVE A KEYWORD ATTRIBUTE   14009000
*        NOTE THAT SPECIAL GETS COULD BE PUT IN TABLE WITH KEY NUMBERS  14010000
*        BEING ROUTINE OFFSET, NO NECESSARILY MULTIPLE OF FOUR!         14011000
*                                                                       14012000
KSPECGTB EQU   *-0                KEYWORD NUMBERS START AT ZERO HERE    14013000
*        ENTRY FOR UNDEFINED KEYWORD (VKEY=0)                           14014000
         XERR  05,002             REFERENCE TO UNDEFINED KEYWORD        14015000
*        ENTRY FOR &LASTNO                                              14016000
         B     KGETLSTN           OFF TO CODE FOR &LASTNO               14017000
*        ENTRY FOR &RTNTYPE                                             14018000
         B     KGETRTNT           OFF TO CODE FOR &RTNTYPE              14019000
*        ENTRY FOR &STCOUNT                                             14020000
         B     KGETSTCN           OFF TO CODE FOR &STCOUNT              14021000
*        ENTRY FOR &STNO                                                14022000
         B     KGETSTNO           OFF TO SPECIAL CODE FOR &STNO         14023000
*        ENTRY FOR &ALPHABET  -  MUST BE LAST TABLE ENTRY               14024000
         LM    A1,A1+1,ALPHPTR    LOAD SPECIFIER FOR &ALPHABET          14025000
         BR    RETURN             THIS EXIT TO CALLER IS FOR &ALPHABET  14026000
*                                                                       14027000
*        TABLE OF PATTERN SPECIFIERS NAMES COME FROM PATTERN MACRO      14028000
*                                                                       14029000
         CNOP  0,4                ALLIGN FOLLING VALUES TO FULLWORD     14030000
KGPATTB  EQU   *-K$ABORT          FIRST ENTRY IS ABORT                  14031000
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN                 14032000
         DC    AL3(ABORTPAT)      ADDRESS OF ABORT PATTERN              14033000
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN                 14034000
         DC    AL3(ARBPAT)        ADDRESS OF ARB PATTERN                14035000
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN                 14036000
         DC    AL3(BALPAT)        ADDRESS OF BAL PATTERN                14037000
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN                 14038000
         DC    AL3(FAILPAT)       ADDRESS OF FAIL PATTERN               14039000
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN                 14040000
         DC    AL3(FENCEPAT)      ADDRESS OF FENCE PATTERN              14041000
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN                 14042000
         DC    AL3(REMPAT)        ADDRESS OF REM PATTERN                14043000
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN                 14044000
         DC    AL3(SUCCPAT)       ADDRESS OF SUCCEED PATTERN            14045000
*                                                                       14046000
*        SPECIFIER FOR &ALPHABET                                        14047000
*                                                                       14048000
ALPHPTR  DC    AL1(SCODE)         TYPE CODE FOR STRING                  14049000
         DC    AL3(ALPHBET-SCHARS)          ADDRSS WITH OFFSET FOR ALPH 14050000
         DC    AL2(0,256-1)       SOFFSET=0,SELNGTH=255                 14051000
         EJECT                                                          14052000
*                                                                       14053000
*        ABORT PATTERN                                                  14054000
*                                                                       14055000
         PATTERN   NAME=ABORT,MIN=0                                     14056000
*                                                                       14057000
*        ARB PATTERN                                                    14058000
*                                                                       14059000
         PATTERN   NAME=ARB,EXTEND=YES,MIN=0                            14060000
*                                                                       14061000
*        BAL PATTERN                                                    14062000
*                                                                       14063000
         PATTERN   NAME=BAL,EXTEND=YES,MIN=1                            14064000
*                                                                       14065000
*        FAIL PATTERN                                                   14066000
*                                                                       14067000
         PATTERN   NAME=FAIL,MIN=0                                      14068000
*                                                                       14069000
*        FENCE PATTERN                                                  14070000
*                                                                       14071000
         PATTERN   NAME=FENCE,EXTEND=YES,MIN=0                          14072000
*                                                                       14073000
*        REM PATTERN                                                    14074000
*                                                                       14075000
         PATTERN   NAME=REM,MIN=0                                       14076000
*                                                                       14077000
*        SUCCEED PATTERN                                                14078000
*                                                                       14079000
         PATTERN   NAME=SUCC,EXTEND=YES,MIN=0                           14080000
*                                                                       14081000
*        MARK PATTERN (USED BY $ . ARBNO)                               14082000
*                                                                       14083000
         PATTERN   NAME=MARK,MIN=0,EXTEND=YES                           14084000
*                                                                       14085000
*        DEFINITIONS OF NAMES USED IN INITV TABLE                       14086000
*                                                                       14087000
P$ABORT  EQU   ABORTPAT           ABORT                                 14088000
P$ARB    EQU   ARBPAT             ARB                                   14089000
P$BAL    EQU   BALPAT             BAL                                   14090000
P$FAIL   EQU   FAILPAT            FAIL                                  14091000
P$FENCE  EQU   FENCEPAT           FENCE                                 14092000
P$REM    EQU   REMPAT             REM                                   14093000
P$SUCCEE EQU   SUCCPAT            SUCCEED                               14094000
         EJECT                                                          14095000
*                                                                       14096000
*        LOAD VALUE OF &STNO                                            14097000
*                                                                       14098000
KGETSTNO LR    R1,DB4             SAVE DB4 ENTRY VALUE                  14099000
         L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE REG          14100000
         USING DTERTNS,DB4        TELL ASSEMBLER                        14101000
         BAL   A2,CALCSTNO        CALL STMNT NUMBER ROUTINE             14102000
         LR    DB4,R1             RESTORE DB4 ENTRY VALUE               14103000
         DROP  DB4                END OF THIS BASE REG                  14104000
         BR    RETURN             RETURN TO CALLER                      14105000
*                                                                       14106000
*        LOAD VALUE OF &STCOUNT                                         14107000
*                                                                       14108000
KGETSTCN LER   FA,SCNT            LOAD COUNT VALUE                      14109000
         SU    FA,STSTART         SUBTRACT STARTING VALUE               14110000
         STE   FA,KGETSV          STORE IN WORK AREA                    14111000
         MVI   KGETSV,0           CLEAR EXPONENT                        14112000
         L     A1+1,KGETSV        LOAD AS INTEGER                       14113000
         A     A1+1,V$STCNT       ADD IN NO. OF STMTS ALREADY COUNTED   14114000
         SR    A1,A1              INDICATE INTEGER RESULT               14115000
         BR    RETURN             RETURN TO CALLER                      14116000
*                                                                       14117000
*        LOAD VALUE OF &LASTNO                                          14118000
*                                                                       14119000
KGETLSTN MVC   RETLOC(4),$$LAST   SET LOC OF LAST STMNT                 14120000
         LR    R1,DB4             SAVE DB4 ENTRY VALUE                  14121000
         L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE REG          14122000
         USING DTERTNS,DB4        TELL ASSEMBLER                        14123000
         BAL   A2,CALCSTNO        CALL STMNT NUMBER ROUTINE             14124000
         LR    DB4,R1             RESTORE DB4 ENTRY VALUE               14125000
         DROP  DB4                DROP SPECIAL BASE REG                 14126000
         BR    RETURN             RETURN TO CALLER                      14127000
*                                                                       14128000
*        LOAD VALUE OF &RTNTYPE                                         14129000
*                                                                       14130000
KGETRTNT IC    R1,V$RETYPE        PICK UP VALUE OF SWITCH               14131000
         L     A1,INITVPTR        LOAD POINTER TO INITV NAMES           14132000
         L     A1+1,RTYPTAB(R1)   LOAD OFFSET AND LENGTH OF NAME        14133000
         BR    RETURN             AND RETURN TO CALLER                  14134000
*                                                                       14135000
*        TABLE OF OFFSETS AND LENGTHS FOR RETURN TYPE NAMES             14136000
*                                                                       14137000
         CNOP  0,4                ALLIGN TO FULLWORD                    14138000
RTYPTAB  DC    Y(E$RETURN-INITVR1)          OFFSET TO RETURN ENTRY      14139000
         DC    Y(6-1)             360 LENGTH OF 'RETURN'                14140000
         DC    Y(E$FRETUR-INITVR1)          OFFSET TO FRETURN ENTRY     14141000
         DC    Y(7-1)             360 LENGTH OF 'FRETURN'               14142000
         DC    Y(E$NRETUR-INITVR1)          OFFSET TO NRETURN ENTRY     14143000
         DC    Y(7-1)             360 LENGTH OF 'NRETURN)               14144000
         DROP  R2                 GET RID OF BASE REGISTER              14145000
         EJECT                                                          14146000
*                                                                       14147000
*        KEYWORD STORE ROUTINE ENTERED FROM $$KPUT IN ADDRESSABLE AREA  14148000
*                                                                       14149000
         USING KPUTC,DB3          BASE REGISTER SET BY $$KPUT           14150000
KPUTC    ST    RETURN,RETLOC      STORE IN CASE OF ERROR                14151000
         LA    R1,0(,A1)          COPY VBLOK PTR, STRIP UPPER BYTE      14152000
         LR    A1,A2              COPY VALUE TO ASSIGN TO (A1,A1+1)     14153000
         LR    A1+1,A2+1          .                                     14154000
         LR    A2,R1              COPY VBLOK POINTER                    14155000
         CR    A2,FR              IS BLOCK ABOVE FREE CORE?             14156000
         BH    KPUTC1             SKIP IF NATURAL VARIABLE              14157000
         C     A2,DYNAMB          NTURAL VAR ONLY IF BELOW FREE CORE    14158000
         BL    KPUTC1             SKIP IF NATURAL VARIABLE              14159000
         XERR  05,003             AN ATTEMPT WAS MADE TO CHANGE THE     14160000
*                                 VALUE OF A KEYWORD ASSOCIATED WITH    14161000
*                                 A NON-NATURAL VARIABLE                14162000
*                                                                       14163000
*        COME HERE IF VARIABLE IS NATURAL                               14164000
*                                                                       14165000
KPUTC1   SR    A2+1,A2+1          CLEAR FOR IC                          14166000
         IC    A2+1,VKEY(,A2)     LOAD KEYWORD NUMBER                   14167000
         CLI   VKEY(A2),KPROPUT   IS THE KEYWORD PROTECTED?             14168000
         BH    KPUTC2             BRANCH TO PUT IF NOT PROTECTED        14169000
         LTR   A2+1,A2+1          IS IT NON-EXISTANT KEYWORD?           14170000
         BNZ   *+8                SKIP IF DEFINED & PROTECTED           14171000
         XERR  05,004             ATTEMPT TO CHANGE THE VALUE OF AN     14172000
*                                 UNDEFINED KEYWORD                     14173000
         XERR  05,005             ATTEMPT TO CHANGE THE VALUE OF A      14174000
*                                 PROTECTED KEYWORD                     14175000
*                                                                       14176000
*        COME HERE IF THE KEYWORD EXISTS AND IS NOT PROTECTED           14177000
*                                                                       14178000
KPUTC2   BAL   RETURN,GETINT      CONVERT NEW VALUE TO INTEGER          14179000
         XERR  01,012             VALUE TO BE STORED IN A KEYWORD       14180000
*                                 CAN NOT BE CONVERTED TO INTEGER       14181000
         L     RETURN,RETLOC      RESTORE CALLERS ADDRESS               14182000
         LR    R2,DB3             COPY BASE REGISTER ADDRESS            14183000
         DROP  DB3                GET RID OF OLD BASE REGISTER          14184000
         USING KPUTC,R2           TELL ASSEMBLER OF NEW BASE REGISTER   14185000
         L     DB3,$$BAS3         RESTORE DATA BASE REGISTER            14186000
         CLI   VKEY(A2),KSPCPUT   DO WE USE A SPECIAL PUT FOR KEYWORD?  14187000
         BNL   KSPCPTB(A2+1)      BRANCH TO PROPER ROUTINE IF SPECIAL   14188000
         ST    A1+1,V$ABEND-K$ABEND(A2+1)   STORE KEYWORD VALUE         14189000
         BR    RETURN             AND RETURN TO CALLER                  14190000
*                                                                       14191000
*        STORE VALUE OF &ANCHOR                                         14192000
*                                                                       14193000
KPUTANCH ST    A1+1,V$ANCHOR      SAVE VALUE OF &ANCHOR                 14194000
         LTR   A1+1,A1+1          IS IT ZERO FOR UNANCHORED?            14195000
         BZ    *+8                SKIP IF SO                            14196000
         LA    A1+1,X'80'         GET BIT SETTING FOR ANCHORED          14197000
         STC   A1+1,ANCHMODE      STORE AS SIGN BIT IN FLAG WORD        14198000
         BR    RETURN             RETURN TO CALLER                      14199000
         EJECT                                                          14200000
*                                                                       14201000
*        STORE VALUE OF &FULLSCAN                                       14202000
*                                                                       14203000
KPUTSCAN ST    A1+1,V$SCAN        STORE VALUE OF &FULLSCAN              14204000
         L     R1,=A(QPATSUBS)    TENTATIVELY SET QUICKSCAN VALUE       14205000
         LTR   A1+1,A1+1          TEST NEW VALUE                        14206000
         BZ    *+8                SKIP IF VALUE IS QUICKSCAN            14207000
         L     R1,=A(FPATSUBS)    ELSE GET BASE FOR FULLSCAN            14208000
         ST    R1,SCANMODE        SAVE FOR PAT MATCH USE                14209000
         BR    RETURN             AND RETURN TO CALLER                  14210000
*                                                                       14211000
*        STORE VALUE OF &MAXLNGTH                                       14212000
*                                                                       14213000
KPUTMAXL CH    A1+1,=Y(32758)     CHECK AGAINST LARGEST SPITBOL VALUE   14214000
         BNH   *+8                SKIP TO DO STORE IF NOT INVALID SIZE  14215000
         XERR  11,004             ATTEMPT TO SET VALUE OF &MAXLNGTH     14216000
*                                 GREATER THAN ALLOWED BY SYSTEM        14217000
         ST    A1+1,V$MAXLN       SAVE NEW VALUE 3F &MAXLENGTH          14218000
         BR    RETURN             AND RETURN TO CALLER                  14219000
*                                                                       14220000
*        STORE VALUE OF &STLIMIT                                        14221000
*                                                                       14222000
KPUTSTLM LER   FA,SCNT            COPY CURRENT STATEMENT COUNT          14223000
         SU    FA,STSTART         CALCULATE NO. OF STATEMENTS EXECUTED  14224000
         STE   FA,SCNTSAVE        STORE FOR LOAD INTO GENERAL REGISTER  14225000
         L     R1,SCNTSAVE        LOAD INTO GENERAL REGISTER            14226000
         LA    R1,0(,R1)          CLEAR OUT X'7F' EXPONENT              14227000
         STE   ZR,SCNTSAVE        PREVENT INVALID PAT CONCAT OPT        14228000
         A     R1,V$STCNT         ADD IN STMTS ALREADY COUNTED          14229000
         SR    A1+1,R1            COMPUTE NO. STMTS LEFT TO EXECUTE     14230000
         BNM   *+8                SKIP ERROR MESSAGE IF HAVE'T OVERFLOW 14231000
         XERR  11,005             &STLIMIT SET TO A VALUE LESS THAN THE 14232000
*                                 NUMBER OF STATEMENTS ALREADY EXECUTED 14233000
         ST    R1,V$STCNT         STORE COUNT OF STMTS ALREADY EXECUTED 14234000
         AR    R1,A1+1            GET NEW STLIMIT VALUE                 14235000
         ST    R1,V$STLIM         STORE FOR EASY REFERENCE              14236000
         LER   SCNT,SINC          LOAD MINIMUM SCNT VALUE IN CASE       14237000
*                                 REMAINING STLIMIT VALUE GE 2**24      14238000
         C     A1+1,=X'00FFFFFF'  CAN THIS BE SET IN ONE ASSIGNMENT?    14239000
         BNL   KPTSTLM1           SKIP IF CON'T DO IN ONE SETUP         14240000
         LE    SCNT,SPINMX        LOAD MAXIMUM SCNT VALUE               14241000
         ST    A1+1,STSTART       STORE SETTING IN TEMPORARY            14242000
         MVI   STSTART,X'7F'      ADD EXPONENT                          14243000
         SU    SCNT,STSTART       CALCULATE NEW SCNT VALUE              14244000
*                                                                       14245000
*        COME HERE WITH SCNT SET TO PROPER VALUE                        14246000
*                                                                       14247000
KPTSTLM1 STE   SCNT,STSTART       STORE NEW STARTING VALUE              14248000
         BR    RETURN             AND RETURN TO CALLER                  14249000
         EJECT                                                          14250000
*                                                                       14251000
*        TABLE OF POINTERS FOR SPECIAL PUT KEYWORDS                     14252000
*        NOTE THAT PUT KEYWORDS MUST NOT DESTROY OLD VALUES             14253000
*        BEFORE ISSUING ERROR MESSAGES, IN CASE OF A SETEXIT            14254000
*                                                                       14255000
KSPCPTB  EQU   *-KSPCPUT          SET UP FOR PROPER TABLE ENTRY         14256000
         B     KPUTMAXL           OFF TO CODE FOR &MAXLNGTH             14257000
         B     KPUTSTLM           OFF TO CODE FOR &STLIMIT              14258000
         B     KPUTANCH           OFF TO CODE FOR & ANCHOR              14259000
         B     KPUTSCAN           OFF TO CODE FOR &FULLSCAN             14260000
*                                                                       14261000
*        THIS IS THE LAST TABLE ENTRY - ERRTYPE                         14262000
*                                                                       14263000
KPUTETYP ST    A1+1,V$ERRTYP      SAVE USER ERROR CODE                  14264000
         LTR   A1+1,A1+1          IS VALUE SET ZERO?                    14265000
         BCR   E,RETURN           RETURN IF SO (DO NOT TRAP)            14266000
         L     DB4,=A(DTERTNS)    LOAD ERROR ROUTINES BASE REGISTER     14267000
         USING DTERTNS,DB4        TELL ASSEMBLER                        14268000
         B     EXERRCM            OFF TO MERGE WITH ERROR CIRCUIT       14269000
         DROP  DB4                GET RID OF BASE REGISTER              14270000
         TITLE 'SPITBOLX -- EXTERNAL FUNCTION CALL ROUTINE'             14271000
*                                                                       14272000
*        THIS ROUTINE IS CALLED FROM AN EFBLOK TO CALL AN               14273000
*        EXTERNALLY LOADED FUNCTION                                     14274000
*                                                                       14275000
*        THE ACTUAL ENTRY POINT $$LOAD IS IN SPITBOLA                   14276000
*                                                                       14277000
         USING LOADC,DB3          BASE REGISTER SET IN SPITBOLA         14278000
LOADC    LH    DB2,EFNARGS(,DB4)  LOAD NUMBER OF ARGUMENTS              14279000
         CR    R0,DB2             DO WE HAVE THE RIGHT NUMBER?          14280000
         BL    $$WNAG             FILL IN WITH NULLS IF NOT             14281000
         STM   FRETURN,RETURN,FRETLOC       SAVE RETURN ADDRESSES       14282000
         LR    FRETURN,DB2        SAVE NUMBER OF ARGS                   14283000
         BCTR  DB2,0              NO. OF ARGS - 1                       14284000
         SLL   DB2,2              *4                                    14285000
         LCR   A2+1,DB2           GET -((NO. OF ARGS - 1)*4))           14286000
         LA    DB2,LOADARGS(DB2,PDR)        GET ADDR OF LAST CALL PARAM 14287000
         AR    A2+1,A2+1          GET MULTIPLE OF 8 STACK REF           14288000
         LA    A2,LOADPRMS(,PDR)  POINT TO LOCATION TO BUILD DATA       14289000
         LA    A2+1,TEM#1(A2+1,PDR)         POINT TO LAST ARG ON STACK  14290000
         AL    A2,X80             SET SIGN BIT ON FOR LAST ARG IN LIST  14291000
*                                                                       14292000
*        LOOP TO SAVE ARG ADDRESSES AND POINTERS                        14293000
*                                                                       14294000
LOADCL   ST    A2,0(,DB2)         STORE ARG POINTER TO DATA             14295000
         LM    A1,A1+1,0(A2+1)    GET PARAMETER                         14296000
         SR    R1,R1              CLEAR FOR IC                          14297000
         IC    R1,EFTARGS-1(DB4,FRETURN)    GET TYPE OF CONVERT NEC.    14298000
         B     LOADCL(R1)         AND CONVERT IT                        14299000
*                                                                       14300000
LDSVAREA EQU   48                 PDR OFFSET FOR CALL SAVEAREA          14301000
LOADARGS EQU   LDSVAREA+9*8       PDR OFFSET OF PARAMETER LIST          14302000
LOADPRMS EQU   LOADARGS+64*4      START OF ACTUAL DATA ARGUMENTS        14303000
*                                                                       14304000
*        CONVERT ARGUMENT TO REAL                                       14305000
*                                                                       14306000
LOADRL   BAL   RETURN,GETREAL     CONVERT ARG TO REAL                   14307000
         XERR  01,013             REAL ARGUMENT FOR LOADED FUNCTION IS  14308000
*                                 NOT A REAL                            14309000
         LR    A1,A1+1            MOVE REAL NUMBER TO PROPER REGISTER   14310000
         B     LOADCNC            JUMP TO COMMON LOOP EXIT POINT        14311000
*                                                                       14312000
*        CONVERT ARGUMENT TO INTEGER                                    14313000
*                                                                       14314000
LOADIN   BAL   RETURN,GETINT      CONVERT ARG TO INTEGER                14315000
         XERR  01,014             INTEGER ARGUMENT TO LOADED FUNCTION   14316000
*                                 IS NOT AN INTEGER                     14317000
         LR    A1,A1+1            MOVE INTEGER TO PROPER REG            14318000
         B     LOADCNC            JUMP TO COMMON EXIT POINT             14319000
         EJECT                                                          14320000
*                                                                       14321000
*        CONVERT ARGUMENT TO STRING                                     14322000
*                                                                       14323000
LOADST   BAL   RETURN,GETSTG      CONVERT ARGUMENT TO STRING            14324000
         XERR  01,015             STRING ARGUMENT TO LOADED FUNCTION    14325000
*                                 IS NOT A STRING                       14326000
         ST    A1+1,LOADF1        STORE OFFSET/LENGTH                   14327000
         AH    A1,LOADF1-4+SOFFSET          ADD OFFSET                  14328000
         LH    A1+1,LOADF1-4+SLENGTH        LOAD LENGTH                 14329000
         LA    A1+1,1(,A1+1)      GET REAL LENGTH FROM 360 LENGTH       14330000
         LA    A1,SCHARS(,A1)     GET RID OF SCHARS OFFSET              14331000
         CLI   GETSV,NCODE        IS ARGUMENT NULL?                     14332000
         BNE   *+8                SKIP IF NOT                           14333000
         SR    A1,A1              ELSE CLEAR TO ZEROS                   14334000
         SR    A1+1,A1+1          ....                                  14335000
         CR    FR,PDR             HAVE WE OVERFLOWED CORE?              14336000
         BL    LOADCNC            JUMP TO COMMON POINT IF NOT           14337000
         LM    FRETURN,RETURN,FRETLOC       RESTORE CALLING REGISTERS   14338000
         STE   ZR,FRETLOC         SET LOCATION UNUSED                   14339000
         B     GBGCLF             GARBAGE COLLECT AND START OVER        14340000
*                                                                       14341000
*        CONVERT ARGUMENT TO DREAL                                      14342000
*                                                                       14343000
LOADDR   BAL   RETURN,GETDREAL    CONVERT ARG TO DREAL                  14344000
         XERR  01,016             DREAL ARGUMENT TO LOADED FUNCTION IS  14345000
*                                 NOT A DREAL                           14346000
         SLDL  A1,8               POSITION PROPERLY FOR SYSTEM          14347000
*                                                                       14348000
*        COMMON EXIT (ALSO COME HERE IF NO CONVERT)                     14349000
*                                                                       14350000
LOADCNC  STM   A1,A1+1,0(A2)      STORE PREPARED ARGUMENT IN PLACE      14351000
         LA    A2+1,8(,A2+1)      POINT TO NEXT ARGUMENT LOCATION       14352000
         LA    A2,8(,A2)          POINT TO NEXT DATA LOCATION           14353000
         SH    DB2,H4             POINT TO NEXT PARAM ADDR FIELD        14354000
         BCT   FRETURN,LOADCL     BACK UP 1 CONVERT BYTE AND LOOP       14355000
*                                                                       14356000
*        ALL ARGUMENTS ARE STORED -- NOW SET UP CALL PARAMETERS         14357000
*                                                                       14358000
         STE   0,LOADF1           SAVE FLOATING REG 0                   14359000
         LR    DB2,SYS            SAVE SYSTEM BASE REGISTER             14360000
         DROP  SYS                CANNOT USE SYS FROM NOW ON            14361000
         USING SPITBOLA,DB2       USE DB2 INSTEAD AS BASE REG           14362000
         SR    A1,A1              RESET FAIL RETURN SWITCH              14363000
         LA    1,LOADARGS(,PDR)   POINT TO PARAMETER ADDRESS LIST       14364000
         LA    13,LDSVAREA(,PDR)  USE PDR STACK FOR SAVEAREA            14365000
         L     15,EFCODE(,DB4)    POINT TO ENTRY POINT                  14366000
         BALR  14,15              MAKE OUR CALL                         14367000
         EJECT                                                          14368000
*                                                                       14369000
*        COME HERE ON RETURN FROM THE EXTERNAL FUNCTION                 14370000
*                                                                       14371000
         B     *+6                SKIP IF SUCCESS RETURN                14372000
         LR    A1,14              SET FAIL RETURN IF RETURN TO 4(,14)   14373000
         LR    SYS,DB2            RESTORE STANDARD SYSTEM BASE REG      14374000
         USING SPITBOLA,SYS       TELL ASSEMBLER                        14375000
         DROP  DB2                DROP OUT TEMPORARY BASE               14376000
         LE    SINC,=X'7F000001'  RESTORE STATEMENT COUNT INCREMENT     14377000
         STD   0,LOADF0           SAVE POSSIBLE REAL RESULT             14378000
         LE    0,LOADF1           RESTORE FLOATING REG 0                14379000
         SDR   ZR,ZR              RE-ZERO OUR ZERO REG                  14380000
         L     PDR,PDRLOC         RESTORE PDR STACK POINTER             14381000
         LM    FRETURN,RETURN,FRETLOC       RESTORE RETURN ADDRESSES    14382000
         STE   ZR,FRETLOC         INDICATE LOC NO LONGER IN USE         14383000
*                                                                       14384000
*        NOW DEAL WITH RETURNED VALUE                                   14385000
*                                                                       14386000
LOADRTNS SR    R2,R2              CLEAR FOR IC                          14387000
         IC    R2,EFTRSL(,DB4)    LOAD TYPE CNVRT BYTE FOR RETURNED VAL 14388000
         LR    DB4,DB3            SWITCH BASE REGISTERS                 14389000
         USING LOADC,DB4          TELL ASSEMBLER                        14390000
         DROP  DB3                ...                                   14391000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGS                14392000
         LTR   A1,A1              TEST FAIL RETURN SWITCH               14393000
         BCR   NZ,FRETURN         FAIL IF FAIL SWITCH IS SET            14394000
         B     LOADRTNS(R2)       ELSE JUMP TO PROPER EXIT ROUTINE      14395000
*                                                                       14396000
*        COME HERE IF RETURNED RESULT IS AN INTEGER                     14397000
*                                                                       14398000
LOADRIN  LR    A1+1,R0            ACQUIRE INTEGER VALUE                 14399000
         SR    A1,A1              INDICATE INTEGER                      14400000
         BR    RETURN             RETURN TO CALLER                      14401000
*                                                                       14402000
*        COME HERE IF RETURNED RESULT IS A REAL                         14403000
*                                                                       14404000
LOADRRL  L     A1+1,LOADF0        LOAD RETURNED REAL VALUE              14405000
         L     A1,RCODEBT         INDICATE REAL TYPE                    14406000
         BR    RETURN             RETURN TO CALLER                      14407000
*                                                                       14408000
*        COME HERE IF RETURNED RESULT IS DREAL                          14409000
*                                                                       14410000
LOADRDR  LM    A1,A1+1,LOADF0     LOAD RETURNED RESULT                  14411000
         SRDL  A1,8               SHIFT TO GET ROOM FOR TYPE CODE       14412000
         AL    A1,WCODEBT         ADD IN TYPE CODE                      14413000
         BR    RETURN             AND RETURN TO CALLER                  14414000
*                                                                       14415000
*        COME HERE IF RETURNED RESULT IS A STRING                       14416000
*                                                                       14417000
LOADRST  LR    R1,R0              COPY POINTER TO ADDRESS/LENGTH BLOCK  14418000
         LM    R0,R1,0(R1)        LOAD ADDRESS LENGTH OF STRING         14419000
         BCTR  R1,0               GET 360 LENGTH OF RETURNED STRING     14420000
         LTR   A1+1,R1            MOVE AND TEST LENGTH                  14421000
         BM    LOADRNL            SKIP IF RETURNED RESULT IS NULL       14422000
         LR    R2,R0              COPY POINTER TO STRING                14423000
         EJECT                                                          14424000
*                                                                       14425000
*        COME HERE TO CHECK FOR POSSIBLE COLLECT                        14426000
*                                                                       14427000
LOADRSTA LA    A2,SCHARS+BOUND+1(A1+1,FR)   POINT PAST NEW SBLOK        14428000
         N     A2,FULLWRD         ALIGN TO FULLWORD (= NEW FR VALUE)    14429000
         CR    A2,PDR             WILL THERE BE ROOM?                   14430000
         BL    LOADRST0           SKIP IF NO COLLECT NEEDED             14431000
         BAL   RETURN,GBGCL0      ELSE GARBAGE COLLECT                  14432000
         L     RETURN,RETLOC      RESTORE RETURN ADDRESS                14433000
         B     LOADRSTA           AND BACK TO CHECK FOR COLLECT NEEDED  14434000
*                                                                       14435000
*        COME HERE WITH ENOUGH ROOM FOR SBLOK IN FREE CORE              14436000
*                                                                       14437000
LOADRST0 LA    R0,256             GET VITAL CONSTANT                    14438000
         LR    A1,FR              COPY POINTER TO START OF BLOCK        14439000
         CR    R1,R0              MORE THAN 256 CHARACTERS TO MOVE?     14440000
         BL    LOADRST2           SKIP IF NOT                           14441000
*                                                                       14442000
*        LOOP TO MOVE 256 CHARACTERS AT A TIME                          14443000
*                                                                       14444000
LOADRST1 MVC   SCHARS(256,FR),0(R2)         MOVE 256 CHARACTERS         14445000
         AR    R2,R0              BUMP SOURCE POINTER                   14446000
         AR    FR,R0              BUMP DESTINATION POINTER              14447000
         SR    R1,R0              DECREMENT COUNT OF CHARS LEFT         14448000
         CR    R1,R0              STILL MORE THAN 256 CHARS TO GO?      14449000
         BNL   LOADRST1           LOOP BACK IF SO                       14450000
*                                                                       14451000
*        COME HERE TO MOVE LAST OR ONLY CHUNK OF 256 CHARS OR LESS      14452000
*                                                                       14453000
LOADRST2 EX    R1,LOADRMV         MOVE REMAINING CHARACTERS             14454000
         SR    A2,A1              CALCULATE LENGTH OF SBLOK             14455000
         STH   A2,STLENGTH(,A1)   STORE SBLOK LENGTH                    14456000
         STE   ZR,0(,A1)          SET DTYPE=SBLOK=0 , GCOLPTR=0         14457000
         AL    A1,SCODEBT         SUPPLY STRING TYPE BYTE               14458000
         LA    FR,0(A1,A2)        BUMP FR PAST BLOCK                    14459000
         BR    RETURN             RETURN TO CALLER                      14460000
*                                                                       14461000
*        COME HERE TO RETURN A NULL RESULT                              14462000
*                                                                       14463000
LOADRNL  L     A1,NCODEBT         LOAD NULL DATA CODE                   14464000
         BR    RETURN             RETURN TO CALLER                      14465000
*                                                                       14466000
*        COME HERE WHEN NO TYPE CONVERSION IS REQUIRED                  14467000
*                                                                       14468000
LOADRNC  LR    R2,R0              COPY POINTER TO RESULT                14469000
         LM    A1,A1+1,0(R2)      AND LOAD RESULT INTO A1,A1+1          14470000
         BR    RETURN             RETURN TO CALLER                      14471000
         DROP  DB4                DROP BASE REGISTER                    14472000
*                                                                       14473000
LOADRMV  MVC   SCHARS(*-*,FR),0(R2)         MOVE CHARS TO SBLOK         14474000
         TITLE 'SPITBOLX -- INDIRECT ADDRESSING ROUTINE'                14475000
*                                                                       14476000
*        ENTER FROM ADDRESSABLE AREA WITH DOLLFLG SET                   14477000
*                                                                       14478000
         USING DOLLC,R2           BASE REGISTER SET AT ENTRY POINT      14479000
DOLLC    ST    RETURN,RETLOC      SAVE RETURN LOCATION FOR ERRORS       14480000
*                                                                       14481000
*        ENTER HERE WHEN RETLOC HAS BEEN INITIALIZED ALREADY (GETNAME)  14482000
*                                                                       14483000
DOLLC1   ST    A1,DOLLWORK        STORE ARGUMENT TO CHECK TYPE CODE     14484000
*                                 NOTE: DOLLSAV IS A LINKAGE LOCATION   14485000
*                                 AND CANNOT BE USED FOR A NON-LABEL    14486000
         CLI   DOLLWORK,MCODE     IS IT A NAME?                         14487000
         BE    DOLLCM             SPECIAL ROUTINE IF NAME               14488000
         CLI   DOLLWORK,NCODE     IS ARGUMENT NULL?                     14489000
         BE    DOLLNULL           OFF TO GIVE PROPER ERROR IF SO        14490000
         ST    RETURN,DOLLSAV     SAVE LINK BACK TO CALLER              14491000
         DROP  R2                 GETSTG WILL DESTROY OUR BASE REGISTER 14492000
         BAL   RETURN,GETSTG      CONVERT OUR ARGUMENT TO STRING        14493000
         USING *,RETURN           TEMPORARY BASE REGISTER FOR ERROR     14494000
         B     DOLLCERR           OFF TO CHECK CALLER ON ERROR          14495000
         DROP  RETURN             GET RID OF BASE REGISTER              14496000
         L     R2,=A(VARLOC)      LOAD ADDRESS OF COMMON HASH ROUTINE   14497000
         BALR  R1,R2              AND CALL IT                           14498000
         SR    A1+1,A1+1          OFFSET = 0 FOR NATURAL VARIABLE       14499000
         L     RETURN,DOLLSAV     RESTORE CALLER'S ADDRESS              14500000
         AL    A1,MCODEBT         SUPPLY MCODE IN CASE CALL BY NAME     14501000
*                                                                       14502000
*        COME HERE WITH NATURAL VARIABLE POINTER TO EXIT                14503000
*                                                                       14504000
DOLLCX   TM    DOLLFLG,$GETNM+$BYNAM        TEST TYPE OF CALL           14505000
         BCR   M,RETURN           RETURN IF ORDINARY CALL BY NAME       14506000
         BO    4(,RETURN)         GETNAME RETURN MUST SKIP OVER ERROR   14507000
*                                                                       14508000
*        COME HERE IF CALL WAS BY VALUE                                 14509000
*                                                                       14510000
         TM    VFLAGS(A1),VINA    IS THIS BLOCK INPUT ASSOCIATED?       14511000
         BO    $$READ             USE READ CIRCUITRY IF SO              14512000
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE FROM BLOCK                 14513000
         BR    RETURN             AND RETURN TO CALLER                  14514000
*                                                                       14515000
*        COME HERE ON NON-STRING ERROR TO CHECK FOR GETNAME CALL        14516000
*                                                                       14517000
DOLLCERR L     RETURN,DOLLSAV     RESTORE RETURN IN CASE OF GETNAME     14518000
         TM    DOLLFLG,$GETNM     WAS THIS A GETNAME CALL?              14519000
         BCR   O,RETURN           GIVE GETNAME ERROR IF GETNAME CALL    14520000
         XERR  01,017             OPERAND OF UNARY $ IS NOT A STRING OR 14521000
*                                 A NAME                                14522000
         EJECT                                                          14523000
*                                                                       14524000
*        COME HERE IF ARGUMENT=NAME                                     14525000
*                                                                       14526000
         USING DOLLC,R2           BASE REGISTER IS STILL GOOD HERE      14527000
DOLLCM   LA    R1,0(,A1)          COPY PTR WITH LEFT BYTE STRIPPED      14528000
         CR    R1,FR              ARE WE BELOW FREE CORE END?           14529000
         BNL   DOLLCX             EXIT WITH STD VARIABLE IF ABOVE CORE  14530000
         C     R1,DYNAMB          ARE WE ABOVE BOTTOM OF FREE CORE?     14531000
         BL    DOLLCX             NOT VARIABLE IF NOT                   14532000
*                                                                       14533000
*        COME HERE IF NAME WAS OF SOMETHING IN FREE CORE                14534000
*                                                                       14535000
         TM    DOLLFLG,$BYNAM     WERE WE CALLED BY NAME?               14536000
         BCR   O,RETURN           DONE IF SO (=ERROR RETURN FOR GTNM)   14537000
         AR    A1,A1+1            ADD OFFSET TO NAME                    14538000
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE FROM BLOCK                 14539000
         BR    RETURN             AND RETURN TO CALLER                  14540000
*                                                                       14541000
*        COME HERE WITH NULL ARGUMENT TO GIVE PROPER ERROR RETURN       14542000
*                                                                       14543000
DOLLNULL TM    DOLLFLG,$GETNM     WERE WE CALLED BY GETNAME?            14544000
         BCR   O,RETURN           RETURN TO GETNAME ERROR IF SO         14545000
         XERR  13,011             OPERAND OF UNARY $ IS NULL            14546000
         DROP  R2                 DROP BASE REGISTER                    14547000
         TITLE 'SPITBOLX -- PATTERN CONCATENATION AND ALTERNATION'      14548000
*                                                                       14549000
*        THIS ROUTINE HANDLES BOTH THE CONCATENATION AND ALTERNATION    14550000
*        OF PATTERNS -- THESE MERGE SINCE MUCH OF THE CODE IS COMMON    14551000
*        FIRST WE CHECK FOR POSSIBLE OPTIMIZATION -- IF LEFT ARGUMENT   14552000
*        CAN BE DESTROYED AND IT IS AT TOP OF CORE, WE DON'T NEED TO    14553000
*        COPY IT.  ALSO THIS IS THE CASE IF ONLY THE RIGHT ARG IS       14554000
*        ABOVE THE LEFT ARGUMENT IN CORE                                14555000
*        THE LEFT ARGUMENT CAN BE DESTROYED IF IT WAS CREATED DURING    14556000
*        THIS STATEMENT.  THIS IS TRUE IF SCNT=SCNTSAVE                 14557000
*                                                                       14558000
*        CONDITIONS ON ENTRY                                            14559000
*                                                                       14560000
*        (A1)                     POINTS TO LEFT PATTERN                14561000
*        (A2)                     POINTS TO RIGHT PATTERN               14562000
*        PRETLOC                  RETURN LOCATION                       14563000
*        RETURN                   BASE REGISTER                         14564000
*        PATFLAG                  X'00' - ALTERNATION , X'FF' - CONCAT  14565000
*                                                                       14566000
         USING *,RETURN           BASE REGISTER PRESET BY $$CNCT        14567000
PATSUB   CE    SCNT,SCNTSAVE      DID WE CREATE A PATTERN OR CONCAT     14568000
*                                 IN THIS STATEMENT ALREADY?            14569000
         BNE   PATSUB1A           NO OPTIMIZATION IF NOT                14570000
         LA    R2,0(,A1)          CLEAR LEFT BYTE FOR TEST              14571000
         C     R2,PCFRSAVE        LEFT ARG MUST BE FROM THIS STATEMENT  14572000
         BL    PATSUB2            NO OPTIMIZATION IF IT WAS NOT         14573000
         AH    R2,PTLENG(,A1)     POINT PAST PATTERN                    14574000
         CR    R2,FR              IS LEFT ARG AT TOP OF CORE?           14575000
         BNE   PATSUB0            IF NOT, CHECK FOR RIGHT ARG ABOVE     14576000
*                                                                       14577000
*        COME HERE WHEN LEFT ARGUMENT IS AT TOP OF CORE AND IT CAN BE   14578000
*        DESTROYED.  THIS SAVES A COPY AND DELAYS GARBAGE COLLECTION    14579000
*                                                                       14580000
         LH    R1,PTLENG(,A2)     GET LENGTH OF RIGHT ARGUMENT          14581000
         AR    R1,FR              POINT PAST WHERE FR WILL BE (16 BYTES 14582000
*                                 EXTRA ARE INCLUDED IN THIS TEST)      14583000
         CR    R1,PDR             WILL WE OVERFLOW CORE?                14584000
         BNH   PATSUB1            DO MOVE IF NOT                        14585000
         B     GBGCL2             CALL GARBAGE COLLECTOR, SAVING TWO    14586000
*                                 ARGUMENTS, RE-ENTER AT PATSUB         14587000
*                                                                       14588000
*        COME HERE TO CHECK TO SEE IF ONLY RIGHT ARG IS ABOVE LEFT ARG  14589000
*                                                                       14590000
PATSUB0  LA    R1,0(,A2)          GET ADDRESS OF RIGHT ARG FOR TEST     14591000
         CR    R2,R1              DOES LEFT ARG TOUCH RIGHT ARG?        14592000
         BNE   PATSUB2            NO OPT IF NOT                         14593000
         AH    R1,PTLENG(,A2)     POINT PAST RIGHT ARG                  14594000
         CR    R1,FR              IS RIGHT ARG AT TOP OF CORE?          14595000
         BNE   PATSUB2            NO OPT IF NOT                         14596000
         EJECT                                                          14597000
*                                                                       14598000
*        COME HERE TO MOVE RIGHT ARG JUST ABOVE LEFT ARG                14599000
*                                                                       14600000
PATSUB1  LA    R0,256             GET VITAL CONSTANT                    14601000
         LH    A1+1,PTLENG(,A2)   GET LENGTH OF PAT 2                   14602000
         AH    A1+1,PATSADJ+2     GET 360 LENGTH OF COPIED PART         14603000
         LH    R1,PTLENG(,A1)     GET REAL LENGTH OF LEFT ARG           14604000
         LA    R1,1(R1,A1+1)      PLUS REAL LENGTH OF RIGHT ARG         14605000
         CH    R1,=X'7FFF'        CHECK FOR EXCEEDING 32K               14606000
         BH    PSIZERR            GIVE ERROR MESSAGE IF TOO LARGE       14607000
         STH   R1,PTLENG(,A1)     IF OK, STORE IN BLOCK                 14608000
         LR    A2+1,R2            COPY 'TO' POINTER                     14609000
         CR    A1+1,R0            CAN WE DO IT IN 1 MOVE?               14610000
         BL    PCLMOVE            B IF POSSIBLE                         14611000
*                                                                       14612000
*        LOOP TO MOVE PATTERN IN 256 BYTE CHUNKS                        14613000
*                                                                       14614000
PCBMOVE  MVC   0(256,A2+1),PATS(A2)         MOVE A BIG PIECE            14615000
         AR    A2+1,R0            UPDATE 'TO' ADDRESS                   14616000
         AR    A2,R0              UPDATE 'FROM' ADDRESS                 14617000
         SR    A1+1,R0            BACK OFF LENGTH                       14618000
         CR    A1+1,R0            DO WE NEED A BIG MOVE?                14619000
         BNL   PCBMOVE            B IF YES                              14620000
*                                                                       14621000
*        COME HERE TO MOVE <= 256 BYTES                                 14622000
*                                                                       14623000
PCLMOVE  EX    A1+1,PCMOVE        MOVE REMAINING CHARACTERS             14624000
         LA    FR,1(A1+1,A2+1)    POINT TO NEW FREE CORE                14625000
         B     PATSUB3            MERGE WITH NON-OPTIMUM CASE           14626000
*                                                                       14627000
PCMOVE   MVC   0(*-*,A2+1),PATS(A2)         MOVE IN VARIABLE NUM CHARS  14628000
*                                                                       14629000
*        COME HERE WHEN CREATING FIRST PATTERN IN A STATEMENT           14630000
*                                                                       14631000
PATSUB1A STE   SCNT,SCNTSAVE      SAVE STATEMENT COUNT FOR FUTURE CHECK 14632000
         ST    FR,PCFRSAVE        SAVE START OF PATS FOR THIS STMNT     14633000
*                                                                       14634000
*        COME HERE IF NO OPTIMIZATION IS POSSIBLE                       14635000
*                                                                       14636000
PATSUB2  LH    A1+1,PTLENG(,A1)   SAVE LENGTH OF LEFT PATTERN           14637000
         STH   A1+1,PATCNLN       SAVE IN TEMPORARY LOCATION            14638000
*                                                                       14639000
*        NOW WE FUDGE UP TWO STRING POINTERS TO USE THE STRING CON-     14640000
*        CATENATION ROUTINE TO JOIN THE PATTERNS TOGETHER               14641000
*                                                                       14642000
         SH    A1+1,=Y(SCHARS+1)  FUDGE LEFT PATTERN LENGTH             14643000
         LH    A2+1,PTLENG(,A2)   LOAD RIGHT PATTERN LENGTH             14644000
         A     A2+1,PATSADJ       ADD FUDGE                             14645000
         BAL   RETURN,SCONC       CONCATENATE AS STRINGS                14646000
         EJECT                                                          14647000
*                                                                       14648000
*        OPTIMIZED AND NON-OPTIMIZED CASES MERGE HERE WITH              14649000
*        (RETURN) SET AS A BASE REGISTER POINTING HERE                  14650000
*                                                                       14651000
PATSUB2A MVI   DTYPE(A1),PBLOK    RESET TYPE TO PATTERN BLOCK           14652000
*                                                                       14653000
*        NOW GET PTR TO RIGHT PATTERN AND END OF NEW BLOCK              14654000
*                                                                       14655000
         LA    R2,0(,A1)          POINT TO NEW BLOCK (STRIP UPPER BYTE) 14656000
         AH    R2,PATCNLN         POINT R2 TO IMAGE OF RIGHT ARG        14657000
*                                                                       14658000
*        OPTIMIZED CASE MERGES HERE WITH REGISTERS SET                  14659000
*                                                                       14660000
PATSUB3  LA    A2+1,4             CONSTANT TO BUMP PATTERN POINTERS     14661000
*                                                                       14662000
*        THE FOLLOWING LOOP CYCLES THROUGH THE PATTERNS IN THE RIGHT    14663000
*        ARGUMENT ADJUSTING ALL NOTHEN AND NOOR POINTERS TO POINT BACK  14664000
*        TO THE NEW PNOTHEN AND PNOOR FIELDS -- THIS IS DONE FOR BOTH   14665000
*        ALTERNATION AND CONCATENATION                                  14666000
*                                                                       14667000
         LR    A2,R2              INITIALIZE POINTER TO FIRST PATTERN   14668000
         BALR  RETURN,0           SET NEW BASE REGISTER                 14669000
         USING *,RETURN           TELL ASSEMBLER                        14670000
PATC0    TM    THEN(A2),X'80'     TEST FOR NEGATIVE THEN PTR (NOTHEN)   14671000
         BNO   *+14               SKIP IF NOT NOTHEN                    14672000
         LA    R0,PNOTHEN(,A1)    ELSE POINT TO NEW PNOTHEN FIELD       14673000
         SR    R0,A2              CALCULATE OFFSET FROM PAT PTR         14674000
         STH   R0,THEN(,A2)       STORE AS NEW NOTHEN POINTER           14675000
         TM    OR(A2),X'80'       TEST FOR NEGATIVE OR POINTER (NOOR)   14676000
         BNO   *+14               SKIP IF NOT NOOR                      14677000
         LA    R0,PNOOR(,A1)      ELSE POINT TO NEW PNOOR FIELD         14678000
         SR    R0,A2              CALCULATE OFFSET FROM PAT PTR         14679000
         STH   R0,OR(,A2)         STORE AS NEW NOOR POINTER             14680000
         TM    PFLAGS(A2),PARM1+PARM2       TEST NUMBER OF PARAMETERS   14681000
         BZ    *+12               SKIP IF NO PARAMETERS                 14682000
         BM    *+6                SKIP IF ONE PARAMETER                 14683000
         AR    A2,A2+1            ADJUST POINTER FOR PARAM2             14684000
         AR    A2,A2+1            ADJUST POINTER FOR PARAM1             14685000
         LA    A2,12(,A2)         ADJUST POINTER FOR OTHER FIELDS       14686000
         CR    A2,FR              HAVE WE REACHED THE END OF THE PAT?   14687000
         BCR   L,RETURN           LOOP BACK IF NOT                      14688000
         EJECT                                                          14689000
*                                                                       14690000
*        NOW TEST ALTERNATION/CONCATENATION CASES                       14691000
*                                                                       14692000
         CLI   PATFLAG,X'00'      TEST CASES                            14693000
         BNE   PATSUBC            SKIP ON CONCATENATION CASE            14694000
*                                                                       14695000
*        FOR ALTERNATION -- GO THROUGH FIRST OR CHAIN IN LEFT PATTERN   14696000
*        UNTIL WE FIND THE NOOR POINTER -- CHANGE IT TO POINT TO THE    14697000
*        RIGHT PATTERN -- ALSO CHANGE CODELOC TO POINT TO THE "OR" CASE 14698000
*        USING THE OFFSET (SEE PATSUBS)                                 14699000
*                                                                       14700000
         LA    R1,PATS(,A1)       POINT TO FIRST LEFT ARG PAT NODE      14701000
ALT0     LH    R0,OR(,R1)         LOAD 'OR' POINTER                     14702000
         AR    R1,R0              POINT TO NEXT MEMBER ON OR CHAIN      14703000
         LTR   R0,R0              WAS THIS THE NEGATIVE 'OR' (NOOR)?    14704000
         BP    ALT0               LOOP BACK IF NOT (WAS STD 'OR')       14705000
         SR    R1,R0              ELSE FIX UP R1 TO POINT TO LAST NODE  14706000
*                                                                       14707000
*        COME HERE FOR ALTERNATION WHEN BLOCK WITH "NOOR" IS FOUND      14708000
*                                                                       14709000
PATSUBA  SR    R2,R1              GET OFFSET TO RIGHT ARG               14710000
         IC    R0,PFLAGS(,R1)     SAVE THE FLAG BYTE                    14711000
         STH   R2,OR(,R1)         STORE AS NEW "OR" POINTER             14712000
         L     R2,CODELOC(,R1)    LOAD POINTER TO "NOOR" CASE CODE      14713000
         BCTR  R2,0               MINUS ONE                             14714000
         BCTR  R2,0               MINUS TWO POINTS TO CODE OFFSET       14715000
         AH    R2,0(,R2)          ADD OFFSET TO POINT TO "OR" CASE CODE 14716000
         ST    R2,CODELOC(,R1)    STORE AS NEW CODE POINTER             14717000
         STC   R0,PFLAGS(,R1)     RESTORE THE FLAG BYTE                 14718000
         B     PATSUBX            JUMP TO EXIT                          14719000
*                                                                       14720000
*        CONCATENATION CASE -- THE NEXT STEP IS TO CYCLE DOWN THE MAIN  14721000
*        "OR" CHAIN IN THE RIGHT PATTERN TO FIND THE MINIMUM NUMBER OF  14722000
*        CHARACTERS REQUIRED FOR ITS MATCH                              14723000
*                                                                       14724000
PATSUBC  LR    A2,R2              GET POINTER TO FIRST RIGHT ARG PAT    14725000
         LH    R0,MINMATCH(,A2)             INITIALIZE R0 = MIN MATCH   14726000
*                                                                       14727000
*        LOOP TO CYCLE THROUGH COMPARING MINMATCH WITH SMALLEST SO FAR  14728000
*                                                                       14729000
PATSUBC1 LH    R1,OR(,A2)         LOAD NEXT 'OR' OFFSET                 14730000
         LTR   R1,R1              TEST FOR NEGATIVE 'OR' POINTER (NOOR) 14731000
         BM    PATSUBC2           SKIP IF NO MORE TO GO (NOOR)          14732000
         AR    A2,R1              ELSE POINT TO ALTERNATIVE             14733000
         CH    R0,MINMATCH(,A2)   TEST MINMATCH WITH SMALLEST SO FAR    14734000
         BL    PATSUBC1           LOOP BACK IF NOT SMALLEST SO FAR      14735000
         LH    R0,MINMATCH(,A2)   IF SMALLEST SO FAR, ACQUIRE MINMATCH  14736000
         B     PATSUBC1           AND LOOP BACK                         14737000
         EJECT                                                          14738000
*                                                                       14739000
*        CONTINUING THE CONCATENATION CASE, WE NOW HAVE THE MINIMUM     14740000
*        NUMBER OF CHARACTERS REQUIRED TO MATCH THE RIGHT HAND PATTERN  14741000
*        THIS QUANTITY MUST BE ADDED TO ALL MINMATCH FIELDS IN THE      14742000
*        LEFT HAND PATTERN -- ALSO IN THE LOOP THROUGH THE LEFT ARG     14743000
*        PATTERNS, ALL "NOTHEN" POINTERS ARE CHANGED TO POINT TO THE    14744000
*        RIGHT ARGUMENT PATTERN                                         14745000
*                                                                       14746000
PATSUBC2 LA    A2,PATS(,A1)       INITIALIZE POINTER TO LEFT ARG PTRS   14747000
*                                                                       14748000
*        REENTRY POINT TO LOOP THROUGH LEFT ARG PATTERNS                14749000
*                                                                       14750000
PATSUBC3 TM    THEN(A2),X'80'     TEST FOR NEGATIVE THEN PTR (NOTHEN)   14751000
         BNO   *+12               SKIP IF NOT NOTHEN                    14752000
         LR    R1,R2              ELSE COPY POINTER TO RIGHT ARG PATS   14753000
         SR    R1,A2              CALCULATE OFFSET                      14754000
         STH   R1,THEN(,A2)       STORE AS "THEN" POINTER               14755000
         LH    R1,MINMATCH(,A2)   LOAD OLD MINMATCH FIELD               14756000
         AR    R1,R0              ADD MINMATCH REQUIRED FOR RIGHT ARG   14757000
         STH   R1,MINMATCH(,A2)   STORE ALTERED MINMATCH FIELD          14758000
         TM    PFLAGS(A2),PARM1+PARM2       TEST NUMBER OF PARAMETERS   14759000
         BZ    *+12               SKIP IF NONE                          14760000
         BM    *+6                SKIP IF ONLY ONE                      14761000
         AR    A2,A2+1            BUMP POINTER FOR PARAM2               14762000
         AR    A2,A2+1            BUMP POINTER FOR PARAM1               14763000
         LA    A2,12(,A2)         BUMP POINTER FOR OTHER FIELDS         14764000
         CR    A2,R2              TEST FOR ALL DONE                     14765000
         BL    PATSUBC3           LOOP BACK IF NOT                      14766000
*                                                                       14767000
*        COMMON EXIT POINT FOR ALTERNATION AND CONCATENATION            14768000
*                                                                       14769000
PATSUBX  LA    A1,0(,A1)          CLEAR UPPER BYTE FROM NEW BLOCK PTR   14770000
         AL    A1,PCODEBT         SUPPLY TYPE CODE (PCODE)              14771000
         MVI   0(A1),PBLOK        MARK BLOCK IN STORAGE AS PATTERN      14772000
         L     RETURN,PRETLOC     LOAD RETURN LOCATION                  14773000
         BR    RETURN             RETURN                                14774000
         DROP  RETURN             DROP BASE REG                         14775000
*                                                                       14776000
*        THE FOLLOWING IS USED TO ADJUST THE STRING OFFSET AND STRING   14777000
*        LENGTH FIELDS OF A PATTERN VALUE SO THAT ONLY THE ACTUAL       14778000
*        NODE DATA IS USED. NOTE THAT THE EXTRA -1 IN THE OFFSET ADJUST 14779000
*        ALLOWS FOR THE OVERFLOW ON ADDING THE NEGATIVE LENGTH ADJUST   14780000
*                                                                       14781000
         CNOP  0,4                ALLIGN                                14782000
PATSADJ  DC    Y(PATS-SCHARS-1)   SET OFFSET TO POINT TO NODES          14783000
         DC    Y(0-PATS-1)        ADJUST LENGTH ACCORDINGLY             14784000
         TITLE 'SPITBOLX -- RETURN POINTS FOR USER DEFINED FUNCTIONS'   14785000
*                                                                       14786000
*        FRETURN                  FAILURE RETURN                        14787000
*                                                                       14788000
L$FRETUR MVI   V$RETYPE,4         SET FAILURE RETURN VALUE              14789000
         BALR  R1,0               GET BASE REGISTER                     14790000
         USING *,R1               TELL ASSEMBLER                        14791000
         B     RSTORE             JUMP TO COMMON RESTORE ROUTINE        14792000
*                                                                       14793000
*        NRETURN                  RETURN BY NAME                        14794000
*                                                                       14795000
L$NRETUR MVI   V$RETYPE,8         SET RETURN BY NAME VALUE              14796000
         BALR  R1,0               SET UP A BASE REGISTER                14797000
         USING *,R1               TELL ASSEMBLER                        14798000
         B     RSTORE             JUMP TO COMMON RESTORE ROUTINE        14799000
*                                                                       14800000
*        RETURN                   NORMAL RETURN BY VALUE                14801000
*                                                                       14802000
L$RETURN MVI   V$RETYPE,0         SET SUCCESS RETURN VALUE              14803000
*                                                                       14804000
*        COME HERE TO RESTORE ARGUMENTS                                 14805000
*                                                                       14806000
RSTORE   BALR  DB3,0              SET BASE REGISTER FOR RSTORE          14807000
         USING *,DB3              TELL ASSEMBLER                        14808000
         DROP  R1                 DROP ENTRY BASE REGISTER              14809000
         ST    RETURN,$$LAST      SAVE IN CASE OF &LASTNO               14810000
*                                                                       14811000
*        LOOP TO STRIP EXPRESSION LEVELS FROM STACK (SETEXIT CASES)     14812000
*                                                                       14813000
RESTOREL CE    ZR,FBLOKLOC(,PDR)  OK FBLOK POINTER ON STACK?            14814000
         BL    RESTOREC           JUMP IF OK TO CONTINUE                14815000
         L     PDR,PDRBPTR(,PDR)  ELSE POP STACK                        14816000
         BZ    RESTOREL           LOOP BACK IF EXPRESSION LEVEL         14817000
*                                                                       14818000
*        ELSE WE ARE AT THE BOTTOM OF THE STACK, NOTE THAT PDR GETS     14819000
*        RELOADED FROM PDRLOC UNDOING THE GARBAGE LOAD FROM PDRBPTR     14820000
*                                                                       14821000
         XERR  08,001,S           RETURN FROM LEVEL ZERO                14822000
*                                                                       14823000
*        COME HERE WITH PROPER STACK LEVEL FOR RETURN                   14824000
*                                                                       14825000
RESTOREC LM    A1+1,A2+1,V$FNCLEV LOAD FNCLEV,TRACE,FTRACE              14826000
         BCTR  A1+1,0             DECREMENT &FNCLEV                     14827000
         ALR   A2,A2+1            TEST &TRACE AND &FTRACE FOR ZERO      14828000
         BNZ   RESTORET           SKIP TO TRY TRACE IF BOTH NOT ZERO    14829000
         ST    A1+1,V$FNCLEV      ELSE STORE UPDATED &FNCLEVEL          14830000
         EJECT                                                          14831000
*                                                                       14832000
*        RE-ENTRY FROM FUNCTION TRACE REGISTERS AS ON ENTRY             14833000
*                                                                       14834000
FTRACERE L     R0,PDRBPTR(,PDR)   LOAD CORRECT PDR LOC IN CASE OF ERRS  14835000
         ST    R0,PDRLOC          STORE IN CURRENT PDR LOCATION         14836000
         L     DB4,FBLOKLOC(,PDR) GET ADDRESS OF FBLOK                  14837000
         L     RETURN,FNAME(,DB4) GET VARIABLE BLOCK ADDRESS FOR NAME   14838000
         LR    FRETURN,PDR        SAVE CURRENT STACK LOCATION           14839000
         LM    A1,A1+1,VALUE(RETURN)        LOAD RETURNED VALUE         14840000
         LA    PDR,LASTEM-TEM#1(,PDR)       POINT TO TEMPS LEVEL ABOVE  14841000
         LH    R2,FNARGS(,DB4)    GET NUMBER OF ARGUMENTS               14842000
         AH    R2,FNLOCS(,DB4)    ADD NUMBER OF LOCALS                  14843000
         BZ    NAMREST            SKIP IF NO ARGS OR LOCALS TO RESTORE  14844000
         SLL   R2,2               MULTIPLY BY FOUR                      14845000
         AR    R2,DB4             POINT PAST LAST ARG BLOCK ADDRESS     14846000
         LR    R1,DB4             SET LIMIT FOR REVERSE ORDER RESTORE   14847000
         L     R0,=F'-4'          LOAD MINUS FOUR AS BXH INCREMENT      14848000
*                                                                       14849000
*        LOOP TO RESTORE ARGS AND LOCALS IN REVERSE ORDER               14850000
*                                                                       14851000
RESTLOOP L     DB4,FARGS-4(,R2)   LOAD POINTER TO BLOCK                 14852000
         LA    PDR,8(,PDR)        POP STACK TO SAVED VALUE              14853000
         LM    A2,A2+1,TEM#1(PDR) LOAD SAVED VALUE                      14854000
         STM   A2,A2+1,VALUE(DB4) RESTORE VALUE                         14855000
         BXH   R2,R0,RESTLOOP     LOOP BACK UNTIL ALL DONE              14856000
*                                                                       14857000
*        NOW RESTORE THE FUNCTION NAME VALUE                            14858000
*                                                                       14859000
NAMREST  LM    A2,A2+1,LASTEM(FRETURN)      LOAD SAVED VALUE            14860000
         STM   A2,A2+1,VALUE(RETURN)        RESTORE VALUE               14861000
         LM    FRETURN,RETURN,FRETFLOC(FRETURN)       GET RETN ADDRS    14862000
         LM    DB2,DB3,$$BAS2     RELOAD DBS (DB2 IN CASE OF TRACE)     14863000
         DROP  DB3                DROP RESTORED BASE REGISTER           14864000
         EJECT                                                          14865000
*                                                                       14866000
*        NOW TEST TYPE OF RETURN                                        14867000
*                                                                       14868000
         CLI   V$RETYPE,4         CHECK TYPE OF RETURN                  14869000
         L     PDR,PDRLOC         RESET STACK POINTER                   14870000
         BCR   L,RETURN           RETURN FOR SUCCESS CASE               14871000
         BCR   E,FRETURN          FAIL ON FRETURN CASE                  14872000
*                                                                       14873000
*        FALL THROUGH HERE IF RETURN BY NAME (NRETURN)                  14874000
*                                                                       14875000
         CLC   0(4,RETURN),BFRVN  TEST FOR B $$FRVN (CALL BY NAME)      14876000
         BNE   $$DL1V             IF BY VALUE, USE $ BY VALUE ROUTINE   14877000
         LA    RETURN,4(,RETURN)  ELSE FUDGE RETURN PAST ERROR CALL     14878000
         B     $$DL1N             AND RETURN VIA $ BY NAME              14879000
*                                                                       14880000
*        COME HERE TO ATTEMPT TO GIVE TRACE FOR FUNCTION RETURN         14881000
*                                                                       14882000
RESTORET L     DB4,=A(DTERTNS)    LOAD TRACE BASE REGISTER              14883000
         USING DTERTNS,DB4        TELL ASSEMBLER                        14884000
         SLR   A2,A2+1            FIX &TRACE AND TEST ITS VALUE         14885000
         BZ    RFTRC              OFF TO DO FTRACE IF &TRACE = ZERO     14886000
         B     RTRC               ELSE TRY TO DO STANDARD TRACE         14887000
         DROP  DB4                GET RID OF THIS BASE REGISTER         14888000
         TITLE 'SPITBOLX -- PATTERN CONSTRUCTION ROUTINE FOR LEN, ETC.' 14889000
*                                                                       14890000
*        PATSET -- COMMON ROUTINE USED BY LEN,POS,RPOS,TAB,RTAB         14891000
*                                                                       14892000
*        (A1,A1+1)                ARGUMENT                              14893000
*        BAL   A2,PATSET                                                14894000
*        DC    YL2(CODELOC-PATSUBS)         MINMATCH=ARG                14895000
*              OR                                                       14896000
*        DC    YL2(CODELOC-PATSUBS+X'8000') MINMATCH=0                  14897000
*        ->  ERROR EXIT FOR ARGUMENT NOT CONVERTIBLE TO INTEGER         14898000
*        ->  ERROR EXIT FOR INTEGER NEGATIVE                            14899000
*                                                                       14900000
*        NOTE ACTUAL ENTRY POINT IS IN ADDRESSABLE REGION               14901000
*                                                                       14902000
         USING *,A2+1             BASE REG SET AT ENTRY POINT           14903000
PATSETC  ST    A1,PATSETSV        SAVE FUNCTION ARG FOR TEST            14904000
         TM    PATSETSV,EXPRBIT   TEST FOR EXPRESSION                   14905000
         BNO   PATSETI            SKIP IF NOT EXPRESSION                14906000
         LH    A2,0(,A2)          LOAD PATSET PARAMETER                 14907000
         MVI   PATSETSV,QF+PARM1+PARM2+PRELOC2        MPBLOK FIRST BYTE 14908000
         MVI   PATSETSV+1,LPRM2   2ND BYTE FOR MPBLOK                   14909000
         SH    A2,=H'14'          BACK OFF CODELOC TO CORRECT LOCATION  14910000
         LR    A1+1,A1            POSITION TO SET EXPR AS PARAM2        14911000
         SR    R2,R2              SET MINMATCH = 0                      14912000
         B     PATSET2            SKIP TO COMMON EXIT                   14913000
*                                                                       14914000
*        ENTRY FOR INTEGER ARGUMENT (NOT EXPRESSION)                    14915000
*                                                                       14916000
PATSETI  ST    RETURN,RETLOC      SAVE RETURN LOCATION                  14917000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    14918000
         B     2(,A2)             ERROR EXIT IF UNCONVERTIBLE           14919000
         LTR   A1,A1+1            MOVE INTEGER TO PARAM 1 AND TEST      14920000
         BM    6(,A2)             ERROR EXIT IF NEGATIVE                14921000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               14922000
         SR    R2,R2              PREPARE MINMATCH = 0                  14923000
         MVI   PATSETSV,QF+PARM1  1ST BYTE FOR MPBLOK                   14924000
         MVI   PATSETSV+1,LPRM1   2ND BYTE FOR MPBLOK                   14925000
         LH    A2,0(,A2)          LOAD PATSET PARAMETER                 14926000
         LTR   A2,A2              TEST FOR MINMATCH = ARG BIT           14927000
         BM    PATSET2            SKIP TO COMMON EXIT ROUTINE IF MINUS  14928000
         LR    R2,A1              ELSE SET MINMATCH = ARG               14929000
*                                                                       14930000
*        COMMON EXIT POINT                                              14931000
*                                                                       14932000
PATSET2  N     A2,=X'00007FFF'    REMOVE MINMATCH = ARG BIT             14933000
         STH   A2,PATSETSV+2      STORE CODELOC FOR MPBLOK              14934000
         LA    R1,PATSETSV        POINT TO MPBLOK ARGUMENTS             14935000
         B     MPBLOKX            MAKE BLOCK AND RETURN TO CODE         14936000
         DROP  A2+1               DROP PATSET BASE REG                  14937000
         TITLE 'SPITBOLX -- PATTERN REPLACEMENT ROUTINE'                14938000
*                                                                       14939000
*        THIS IS A CONTINUATION OF THE ROUTINE AT $$PATA                14940000
*                                                                       14941000
         USING *,DB2              BASE REGISTER SET BY $$PATA           14942000
PATAC    ST    RETURN,RETLOC      SAVE RETURN LOCATION                  14943000
         BAL   RETURN,GETSTG      CONVERT TO STRING                     14944000
         XERR  01,018             REPLACING RIGHT HAND SIDE IN PATTERN  14945000
*                                 REPLACEMENT IS NOT A STRING           14946000
         STM   A1,A1+1,PART2      STORE PART 2                          14947000
*                                                                       14948000
*        NOW GET PART 1                                                 14949000
*                                                                       14950000
*              SLENGTH=SLENGTH(PSTRING)-MATCHPB                         14951000
*              SOFFSET=SOFFSET(PSTRING)                                 14952000
*                                                                       14953000
         LM    A1,A1+1,PSTRING(PDR)         LOAD PSTRING SPECIFIER      14954000
         SH    A1+1,MATCHPB(,PDR) ADJUST LENGTH -- NOTE MAY GO NEGATIVE 14955000
         ST    A1+1,PART1+4       STORE OFFSET & LENGTH OF PART 1       14956000
*                                                                       14957000
*        NOW GET PART 3                                                 14958000
*                                                                       14959000
*              SLENGTH=MATCHPE-1                                        14960000
*        SOFFSET=SOFFSET(PSTRING)+SLENGTH(PSTRING)+1-SLENGTH(PART3)     14961000
*                                                                       14962000
         LH    R1,MATCHPE(,PDR)   PREPARE TO CALCULATE LENGTH           14963000
         SH    R1,H1              CALCULATE LENGTH                      14964000
         BM    PART3N             SKIP IF NEGATIVE (PART 3 NULL)        14965000
         LR    A2,A1              ELSE COPY BASE ADDRESS                14966000
         LH    A2+1,PSTRING+SOFFSET(,PDR)   GET SOFFSET(PSTRING)        14967000
         AH    A2+1,SLENGTH+PSTRING(,PDR)   ADD IN SLENGTH(PSTRING)     14968000
         SR    A2+1,R1            SUBTRACT SLENGTH(PART3)               14969000
         SLL   A2+1,16            SHIFT TO SOFFSET FIELD                14970000
         OR    A2+1,R1            STICK IN LENGTH                       14971000
         CLI   PART2,NCODE        IS SECOND PART NULL?                  14972000
         BNE   PATA2              SKIP IF NON-NULL                      14973000
         EJECT                                                          14974000
*                                                                       14975000
*        AT THIS POINT, WE HAVE FOUND THAT PART 2 IS NULL               14976000
*                                                                       14977000
         TM    PART1+SLENGTH,X'80'          CHECK PART 1 LENGTH         14978000
         BNO   PATA1              POSITIVE LENGTH = NON-NULL, SKIP      14979000
*                                                                       14980000
*        HERE, WE HAVE FOUND THAT PARTS 1,2 ARE NULL, SO ASSIGN PART 3  14981000
*                                                                       14982000
         LR    A1,A2              MOVE PART 3                           14983000
         LR    A1+1,A2+1               TO ACCUMULATOR 1                 14984000
         B     PATASN             AND SKIP TO ASSIGNMENT                14985000
*                                                                       14986000
*        COME HERE WITH PARTS 2,3 NON-NULL                              14987000
*                                                                       14988000
PATA2    TM    PART1+SLENGTH,X'80'          TEST LENGTH OF PART 1       14989000
         BNO   PATA3              SKIP IF POSITIVE (NON-NULL)           14990000
*                                                                       14991000
*        COME HERE WITH PART 1 NULL, PARTS 2,3 NON-NULL                 14992000
*                                                                       14993000
         LM    A1,A1+1,PART2      POSITION PART 2 AND MERGE             14994000
*                                                                       14995000
*        COME HERE WITH PART 2 NULL, PARTS 1,3 NON-NULL                 14996000
*                                                                       14997000
PATA1    BAL   RETURN,SCONC       CONCATENATE THE TWO NON-NULL PARTS    14998000
         B     PATASN             AND JUMP TO ASSIGN                    14999000
*                                                                       15000000
*        COME HERE WITH PART 3 NULL                                     15001000
*                                                                       15002000
PART3N   TM    PART1+SLENGTH,X'80'          CHECK PART 1                15003000
         BO    PATA4              SKIP IF PART 1 NULL                   15004000
         CLI   PART2,NCODE        IS SECOND PART NULL?                  15005000
         BE    PATASN             SKIP IF SO TO ASSIGN                  15006000
*                                                                       15007000
*        HERE WE HAVE PARTS 1,2 NON-NULL -- PART 3 NULL                 15008000
*                                                                       15009000
         LM    A2,A2+1,PART2      LOAD SECOND PART                      15010000
         BAL   RETURN,SCONC       CONCATENATE                           15011000
         B     PATASN             JUMP TO ASSIGN                        15012000
*                                                                       15013000
*        COME HERE WITH ONLY PART 2 NON-NULL                            15014000
*                                                                       15015000
PATA4    LM    A1,A1+1,PART2      LOAD PART 2                           15016000
         B     PATASN             SKIP TO ASSIGN                        15017000
         EJECT                                                          15018000
*                                                                       15019000
*        COME HERE WITH ALL PARTS NON-NULL                              15020000
*                                                                       15021000
*        FIRST CONCATENATE PARTS 1,2                                    15022000
*                                                                       15023000
PATA3    STM   A2,A2+1,PART1      SAVE PART 3 FOR MOMENT                15024000
         LM    A2,A2+1,PART2      LOAD PART 2 FOR CONCATENATION         15025000
         BAL   RETURN,SCONC       CONCATENATE PARTS 1,2                 15026000
         LM    A2,A2+1,PART1      RELOAD PART 3                         15027000
         BAL   RETURN,SCONC       CONCATENATE ON PART 3                 15028000
*                                                                       15029000
*        COME HERE TO ASSIGN VALUE                                      15030000
*                                                                       15031000
PATASN   LM    A2,A2+1,PNAME(PDR) LOAD NAME AND OFFSET                  15032000
         STE   ZR,PNAME(,PDR)     SET TO ZERO TO INDICATE NOT NEEDED    15033000
         AR    A2,A2+1            ADD OFFSET TO NAME BASE               15034000
         L     DB2,$$BAS2         RELOAD DB2                            15035000
         DROP  DB2                DROP BASE REGISTER                    15036000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               15037000
         B     WRIT               DO ASSIGN WITH I/O CHECK              15038000
         TITLE 'SPITBOLX -- PATTERN ENTRY POINT ROUTINE'                15039000
*                                                                       15040000
*        THIS IS A CONTINUATION OF THE PROCESSING AT $$PTN2,$$PTV2      15041000
*                                                                       15042000
         USING PTV2C,DB2          BASE REGISTER SET BY $$PTV2           15043000
PTV2C    STM   FRETURN,RETURN,FRETLOCP(PDR) SAVE REGS                   15044000
         ST    RETURN,RETLOC      THIS IS FOR TRACE ETC...              15045000
         CR    FR,PDR             CHECK FOR MEMORY OVERFLOW WITH ERRLIM 15046000
         BNL   PATMAT3B           FORCE COLLECT IF MEMORY OVERFLOW      15047000
*                                                                       15048000
*        RE-ENTER HERE IN CASE GETPAT CALL IS DONE                      15049000
*                                                                       15050000
PATMATG  STM   A1,A1+1,PSTRING(PDR)         SAVE PSTRING (SUBJECT STG)  15051000
         ST    A2,ORGPB(,PDR)               SAVE PATTERN POINTER        15052000
         CLI   PSTRING(PDR),SCODE IS SUBJECT A STRING?                  15053000
         BE    PATMAT3            SKIP IF YES                           15054000
         BAL   RETURN,GETSTG      CONVERT SUBJECT TO STRING             15055000
         XERR  01,019             PATTERN MATCH SUBJECT IS NOT A STRING 15056000
         CLI   PSTRING(PDR),NCODE IS SUBJECT NULL?                      15057000
         BNE   *+8                SKIP IF NOT                           15058000
         LM    A1,A1+1,NULLSTR    ELSE GET NULL BLOCK                   15059000
         STM   A1,A1+1,PSTRING(PDR)         SAVE IT IN PSTRING          15060000
*                                                                       15061000
*        COME HERE WITH PSTRING ALL SET UP (AS A STRING)                15062000
*                                                                       15063000
PATMAT3  ST    FR,FRSAVE          SAVE FREE CORE POINTER                15064000
         CLI   ORGPB(PDR),PCODE   IS PATTERN A PATTERN?                 15065000
         BE    PATMAT4            SKIP IF IT IS                         15066000
         LR    A1,A2              ELSE MOVE "PATTERN"                   15067000
         LR    A1+1,A2+1               TO ACCUMULATOR 1                 15068000
         BAL   RETURN,GETSTGS     CONVERT "PATTERN" TO A STRING         15069000
         B     PATMAT3A           SKIP IF UNCONVERTIBLE                 15070000
         LA    R0,256             GET THAT CONSTANT FOR LONG STRINGS    15071000
         CR    A1+1,R0            IS PATTERN A LONG STRING              15072000
         BL    PATMATS            IF NOT, OFF TO SPECIAL STRING CIRCUIT 15073000
         LR    A1,A2              COPY ORIGNIAL SPECIFIER TO ALLOW      15074000
         LR    A1+1,A2+1          FOR RELOCATION IF COLLECT DONE        15075000
*                                                                       15076000
*        WE COME HERE IN CASE THE PATTERN IS AN EXPRESSION OR A LONG    15077000
*        STRING (THE LATTER CASE IS ABSURD AND NOT WORTH OPTIMIZING)    15078000
*        IN THESE CASES -- WE CONVERT TO PATTERN AND MERGE              15079000
*                                                                       15080000
PATMAT3A BAL   RETURN,GETPAT      CONVERT TO PATTERN                    15081000
         XERR  01,020             THE PATTERN IN A PATTERN MATCH IS NOT 15082000
*                                 A STRING OR A PATTERN                 15083000
         LR    A2,A1              COPY PATTERN POINTER TO CORRECT REG   15084000
         LM    A1,A1+1,PSTRING(PDR)         RESTORE PSTRING FOR COLLCT  15085000
         CR    FR,PDR             DO WE NEED A COLLECT?                 15086000
         BL    PATMATG            RE-ENTER IF NOT                       15087000
*                                                                       15088000
*        COME HERE IF COLLECT NECESSARY                                 15089000
*                                                                       15090000
PATMAT3B BAL   RETURN,GBGCL2      DO A COLLECT                          15091000
         B     PATMATG            AND THEN RE-ENTER                     15092000
         EJECT                                                          15093000
*                                                                       15094000
*        IN THE CASE WHERE THE PATTERN IS A STRING, IT WOULD BE         15095000
*        INNEFICIENT TO USE THE FULL PATTERN MATCH LOGIC -- SO THIS     15096000
*        CASE IS HANDELED SEPARATELY                                    15097000
*                                                                       15098000
*        REGISTER USAGE                                                 15099000
*                                                                       15100000
*        (R0)                     CONSTANT 256                          15101000
*        (R1)                     SUBJECT STRING SCAN POINTER           15102000
*        (A1)                     POINTS TO PATTERN STRING              15103000
*        (A1+1)                   360 LENGTH OF PATTERN STRING          15104000
*        (A2+1)                   MAX NUMBER OF ANCHOR MOVES REMAINING  15105000
*        (DB4)                    ANCHOR MOVEMENT                       15106000
*                                                                       15107000
PATMATS  SR    DB4,DB4            CLEAR ANCHOR MOVEMENT                 15108000
         L     R1,PSTRING(,PDR)             PICK UP SUBJECT STRING BASE 15109000
         AH    R1,PSTRING+SOFFSET(,PDR)     AND OFFSET                  15110000
         LA    R1,SCHARS(,R1)     ADJUST TO POINT TO FIRST CHARACTER    15111000
         LH    A2+1,PSTRING+SLENGTH(,PDR)   LOAD 360 LENGTH OF SUBJECT  15112000
         SR    A2+1,A1+1          SUBJ LENG - PAT LENG = ANCHOR MOVES   15113000
         BM    PABORTMM           PATTERN ABORTS IF SUBJECT TOO SHORT   15114000
         LTR   A1+1,A1+1          TEST FOR NULL PATTERN                 15115000
         BM    PATMTAN            ALWAYS MATCH ON A NULL PATTERN        15116000
         TM    ANCHMODE,X'80'     TEST ANCHOR MODE                      15117000
         BO    PATMTA             SKIP ON ANCHORED CASE                 15118000
*                                                                       15119000
*        COME HERE IN UNANCHORED MODE -- WE USE ZTBL IN SPITBOLR        15120000
*        (PLUGGED WITH THE FIRST PATTERN CHARACTER) TO SEARCH THROUGH   15121000
*        THE STRING, DOING A COMPARE WHEREVER THE TRT STOPS             15122000
*                                                                       15123000
         SR    RETURN,RETURN      CLEAR FOR IC INSTRUCTION              15124000
         IC    RETURN,SCHARS(,A1)           LOAD FIRST PATTERN CHAR     15125000
         LA    RETURN,ZTBL(RETURN)          POINT TO LOCATION TO PLUG   15126000
*                                                                       15127000
*        THIS IS THE LOOP TO SEARCH FOR THE NEXT TRT STOPPING PLACE     15128000
*                                                                       15129000
PATMATLP LR    DB3,R1             SAVE PRESENT SCAN LOCATION            15130000
         CR    A2+1,R0            DO WE HAVE 256 CHARS LEFT OR LESS     15131000
         BL    PATMATS1           SKIP IF SO                            15132000
         MVI   0(RETURN),1        PLUG SCAN TABLE                       15133000
         TRT   0(256,R1),ZTBL     ELSE CHECK 256 CHARACTERS             15134000
         MVI   0(RETURN),0        UNPLUG SCAN TABLE                     15135000
         BNZ   PATMTF             JUMP IF WE FIND SOMETHING             15136000
         AR    R1,R0              ELSE CRANK SUBJECT STRING POINTER     15137000
         AR    DB4,R0             CRANK ANCHOR MOVEMENT                 15138000
         SR    A2+1,R0            DECREMENT NUMBER OF MOVES LEFT        15139000
         B     PATMATLP           AND LOOP BACK                         15140000
         EJECT                                                          15141000
*                                                                       15142000
*        PATTERN MATCH AGAINST STRING -- CONTINUED                      15143000
*                                                                       15144000
*                                                                       15145000
*        COME HERE TO TEST 256 CHARACTERS OR LESS                       15146000
*                                                                       15147000
PATMATS1 MVI   0(RETURN),1        PLUG SCAN TABLE                       15148000
         EX    A2+1,PATTRT        TEST REMAINING CHARSACTERS            15149000
         MVI   0(RETURN),0        UNPLUG SCAN TABLE                     15150000
         BZ    PABORTMM           ABORT IF NOTHING FOUND                15151000
*                                                                       15152000
*        COME HERE WHEN THE TRT STOPS ON THE RIGHT CHARACTER            15153000
*                                                                       15154000
PATMTF   SR    DB3,R1             GET MINUS NUMBER OF CHARACTERS SKIPPD 15155000
         AR    A2+1,DB3           DECREMENT NUMBER OF MOVES LEFT        15156000
         SR    DB4,DB3            INCREMENT ANCHOR MOVEMENT             15157000
         EX    A1+1,PATCMP        TEST FULL STRING AGAINST PATTERN      15158000
         BE    PATMTAN            JUMP IF WE HAVE FOUND A MATCH         15159000
         LA    R2,1               GET INCREMENT/DECREMENT IN REGISTER   15160000
         AR    DB4,R2             BUMP ANCHOR FOR CHARACTER TESTED      15161000
         AR    R1,R2              BUMP SCAN POINTER                     15162000
         SR    A2+1,R2            DECREMENT NUMBER OF MOVES LEFT        15163000
         BNM   PATMATLP           LOOP BACK IF MORE MOVES TO GO         15164000
         B     PABORTMM           ABORT IF NO MATCH FOUND               15165000
*                                                                       15166000
*        COME HERE FOR TEST IN ANCHORED MODE                            15167000
*                                                                       15168000
PATMTA   EX    A1+1,PATCMP        COMPARE CHARACTERS                    15169000
         BNE   PABORTMM           ABORT IF NO MATCH                     15170000
*                                                                       15171000
*        COME HERE ON SUCCESSFUL MATCH (ANOCHORED AND UNANCHORED)       15172000
*                                                                       15173000
PATMTAN  LH    A2,PSTRING+SLENGTH(,PDR)     LOAD 360 LENGTH OF SUBJECT  15174000
         LA    A2,1(,A2)          GET REAL LENGTH                       15175000
         SR    A2,DB4             DECREMENT BY ANCHOR MOVEMENT          15176000
         STH   A2,MATCHPB(,PDR)   STORE INITIAL CURSOR POSITION         15177000
         SR    A2,A1+1            ADJUST FOR CHARACTERS MATCHED         15178000
         BCTR  A2,0               PLUS ONE MORE FOR 360 FUDGED LENGTH   15179000
         STH   A2,MATCHPE(,PDR)   STORE FINAL CURSOR POSITION           15180000
         B     PATENDEM           AND JUMP TO END OF PATTERN EXIT       15181000
*                                                                       15182000
PATCMP   CLC   0(*-*,R1),SCHARS(A1)         MATCH SUBJECT & PATTERN     15183000
PATTRT   TRT   0(*-*,R1),ZTBL                                           15184000
         DROP  DB2                GET RID OF BASE REGISTER              15185000
         EJECT                                                          15186000
*                                                                       15187000
*        COME HERE WITH PSTRING AND ORGPB CORRECTLY SET UP              15188000
*        FOR FULL PATTERN MATCH LOGIC                                   15189000
*                                                                       15190000
PATMAT4  SR    MINR,MINR          CLEAR CHAR NEEDED ABOVE REG           15191000
         L     PBASE,SCANMODE     GET PROPER BASE FOR MODE              15192000
         ST    DB1,PSAVDB1(,PDR)  SAVE DATA AREA ADDRESS ON STACK       15193000
         L     PO,ANCHMODE        GET ANCH OR UNANCH, CLOBBER DB1       15194000
         DROP  DB1                NO LONGER A BASE REGISTER             15195000
         LH    CP,PSTRING+SLENGTH(,PDR)     LOAD STRING LENGTH          15196000
         LA    CP,1(,CP)          +1 = INITIAL CURSOR (CHARS TO MATCH)  15197000
         ST    CP,FAILSW(,PDR)    CLEAR DOTSW AND STORE PSTGLEN         15198000
*                                 = REAL SUBJECT STRING LENGTH AT STKBT 15199000
         TS    FAILSW(PDR)        SET LENGTH FAIL SWITCH                15200000
         L     FSADR,PSTRING(,PDR)          LOAD BASE ADDRESS OF STRING 15201000
         LA    FSADR,SCHARS(FSADR,CP)       POINT TO END OF STRING + 1  15202000
         AH    FSADR,PSTRING+SOFFSET(,PDR)  ADD IN CHAR OFFSET          15203000
         LR    PB,A2              GET PATTERN POINTER                   15204000
         LA    PS1,STACK1+12(,PDR)          GET STACK1 ADDR             15205000
         LA    PS2,STACK2-S2OFS-3*4(,PDR)   GET STACK2 ADDRESS          15206000
         LA    BPS,12             GET STACK INCREMENT                   15207000
         LR    NCP,CP             COPY CHAR ADDR FOR FIRST STACK ENTRY  15208000
         STM   PO,NCP,STACK1(PDR) MAKE FIRST ENTRY                      15209000
         LA    PO,PATS            GET PATTERN BASE                      15210000
         STE   ZR,S2OFS+S2PB(,PS2)          MAKE TOP OF STACK ENTRY     15211000
         USING QPATSUBS,PBASE     GET QUICK BASE REG                    15212000
         B     SUCC+4             OFF TO PAT MATCH                      15213000
         DROP  PBASE              DROP PATTERN REG                      15214000
*                                                                       15215000
*        NULLSTR -- DUMMY NULL STRING WITH SLENGTH = -1                 15216000
*                                                                       15217000
         CNOP  0,4                ALLIGN                                15218000
NULLSTR  DC    AL1(SCODE)         STRING CODE                           15219000
         DC    AL3(*)             BASE ADDRESS MUST BE ADDRESSABLE      15220000
         DC    Y(0)               SOFFSET = 0                           15221000
         DC    H'-1'              SLENGTH = -1                          15222000
         USING SPITBOLD,DB1       BASE REGISTER OK AGAIN                15223000
         TITLE 'SPITBOLX -- PATTERN CONSTRUCTION FOR ANY/NOTANY'        15224000
*                                                                       15225000
*        NTNANY                   COMMON ROUTINE FOR ANY/NOTANY         15226000
*                                                                       15227000
*        DB2 SHOWS WHICH CASE WE HAVE --                                15228000
*                                                                       15229000
*        DB2 = 0                  NOTANY                                15230000
*        DB2 = NTNANYA-NTNANYN    ANY                                   15231000
*                                                                       15232000
         USING NTNANY,DB3         BASE REGISTER SET AT ENTRY POINT      15233000
NTNANY   LA    R0,1(,A1+1)        LOAD REAL LENGTH TO (R0)              15234000
         SR    R1,R1              CLEAR FOR FOLLOWING IC                15235000
         IC    R1,ANYMASK         PICK UP CURRENT MASK                  15236000
         SRA   R1,1               MOVE TO NEXT BIT POSITION             15237000
         BNZ   NTNANY1            SKIP UNLESS WE RAN OUT OF BITS        15238000
*                                                                       15239000
*        COME HERE TO GET A NEW TBLOK, WE JUST USED OLD ONE UP          15240000
*                                                                       15241000
         STE   ZR,GCOLPTR(,FR)    SET GCOLPTR = 0                       15242000
         MVI   DTYPE(FR),TBLOK    SET BLOK CODE                         15243000
         STE   ZR,CTCHARS(,FR)    ZERO FIRST TABLE WORD                 15244000
         STE   ZR,CTCHARS+4(,FR)  CLEAR SECOND TABLE WORD               15245000
         MVC   CTCHARS+8(248,FR),CTCHARS(FR)          DO OPT MVC        15246000
         ST    FR,ANYTPTR         SAVE NEW TBLOK POINTER                15247000
         LA    FR,CTCHARS+256(,FR)          BUMP FR                     15248000
         LA    R1,X'80'           SET LEFT MOST BIT POSITION TO START   15249000
*                                                                       15250000
*        COME HERE WITH TABLE ALL SET UP TO GO                          15251000
*                                                                       15252000
NTNANY1  STC   R1,ANYMASK         STORE NEW BIT MASK                    15253000
         LR    A2,A1              SAVE STRING POINTER                   15254000
         LM    A1,A1+1,ANYPARAM   LOAD PARAMETER VALUES (ANYTPTR/TM ..) 15255000
         EJECT                                                          15256000
*                                                                       15257000
*        NTNANY (COMMON ROUTINE FOR ANY/NOTANY) -- CONTINUED            15258000
*                                                                       15259000
*        LOOP TO TURN SELECTED BITS ON                                  15260000
*                                                                       15261000
ANYLOOP  SR    A2+1,A2+1          CLEAR FOR IC                          15262000
         IC    A2+1,SCHARS(A2)    LOAD CHARACTER                        15263000
         AR    A2+1,A1            ADD TBLOK POINTER                     15264000
         EX    R1,SETBIT          TURN ON MASK BIT IN SELECTED CHAR     15265000
         LA    A2,1(,A2)          STEP TO NEXT CHARACTER                15266000
         BCT   R0,ANYLOOP         BACK TILL COUNT EXHAUSTED             15267000
*                                                                       15268000
*        TBLOK ALL SET UP, TEST CASES                                   15269000
*                                                                       15270000
         LA    R2,1               SET MINMATCH VALUE                    15271000
         B     NTNANYN(DB2)       JUMP TO PROPER EXIT POINT             15272000
         DROP  DB3                GET RID OF THIS BASE REGISTER         15273000
*                                                                       15274000
*        EXIT POINT FOR NOTANY CASE                                     15275000
*                                                                       15276000
NTNANYN  BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT      15277000
         DC    YL1(QF+PARM1+PARM2+PRELOC1,LPRM2)      TWO PARMS, 1 REL  15278000
         DC    YL2(PN$NANY-PATSUBS)         CODELOC OFFSET              15279000
*                                                                       15280000
*        EXIT POINT FOR ANY CASE                                        15281000
*                                                                       15282000
NTNANYA  BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT      15283000
         DC    YL1(QF+PARM1+PARM2+PRELOC1,LPRM2)      TWO PARAMS, 1 REL 15284000
         DC    YL2(PN$ANY-PATSUBS)          CODELOC OFFSET              15285000
*                                                                       15286000
SETBIT   OI    CTCHARS(A2+1),*-*  TURN SELECTED BIT ON                  15287000
         TITLE 'SPITBOLX -- PATTERN CONSTRUCTION FOR SPAN'              15288000
*                                                                       15289000
*        THIS ROUTINE IS PASSED CONTROL FROM SPITBOLA TO CONSTRUCT      15290000
*        THE PATTERN FOR A SPAN WHOSE ARGUMENT IS A STRING              15291000
*                                                                       15292000
*        (DB3)                    BASE REGISTER                         15293000
*        (A1)                     ADDRESS OF STRING                     15294000
*        (A1+1)                   360 LENGTH OF STRING                  15295000
*                                                                       15296000
         USING SPANPP,DB3         BASE REGISTER SET BY CALLER           15297000
SPANPP   LA    R2,1               SET MINMATCH PARAMETER = 1            15298000
         LTR   A1+1,A1+1          TEST 360 LENGTH                       15299000
         BZ    SPANPP1            SKIP ON ONE CHARACTER CASE            15300000
*                                                                       15301000
*        HERE WE MUST BUILD A NEW TBLOK FOR A MULIPLE CHARACTER CASE    15302000
*                                                                       15303000
         STE   ZR,GCOLPTR(,FR)    CLEAR OUT GCOL POINTER                15304000
         MVI   DTYPE(FR),TBLOK    SET PROPER BLOCK CODE                 15305000
         MVI   CTCHARS(FR),X'FF'  SET RUN CHARACTER                     15306000
         MVC   CTCHARS+1(255,FR),CTCHARS(FR)          PROPAGATE         15307000
         LA    R1,1(,A1+1)        GET REAL NUMBER OF CHARS              15308000
         SR    DB2,DB2            CLEAR FOR IC                          15309000
         SR    R0,R0              CLEAR TO GET A ZERO TO STORE          15310000
*                                                                       15311000
*        LOOP TO PLUG SELECTED CHARS AS ZEROS                           15312000
*                                                                       15313000
SPANPPL  IC    DB2,SCHARS-1(A1,R1)          PICK UP CHARACTER           15314000
         STC   R0,CTCHARS(FR,DB2) PLUG TABLE                            15315000
         BCT   R1,SPANPPL         LOOP TILL ALL PLUGGED                 15316000
*                                                                       15317000
*        NOW CHECK FOR SPECIAL CASE OF SAME TABLE AS SCANTB3            15318000
*        I.E. SPAN('0123456789'), IF SO, USE IT                         15319000
*                                                                       15320000
         CH    A1+1,=H'9'         IS 360 COUNT OF CHARS 9?              15321000
         BNE   SPANPPX            IF NOT, SKIP FOR NORMAL EXIT          15322000
         L     A1,=A(SCANTB3-CTCHARS)       ELSE LOAD SCANTB3 IN CASE   15323000
         OC    CTCHARS+C'0'(10,FR),CTCHARS+C'0'(FR)   ALL ZEROS?        15324000
         BZ    SPANPPS            IF SO, SKIP TO USE SCANTB3            15325000
         EJECT                                                          15326000
*                                                                       15327000
*        HERE FOR A NORMAL EXIT                                         15328000
*                                                                       15329000
SPANPPX  LR    A1,FR              COPY ADDRESS OF TBLOK TO PARAM REG    15330000
         LA    FR,CTCHARS+256(,FR)          PUSH FREE PTR PAST BLOCK    15331000
         BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT      15332000
         DC    AL1(PARM1+PRELOC1+QF,LPRM1)  ONE PARAM, RELOCATABLE      15333000
         DC    AL2(PN$SPAN-PATSUBS)         MATCH OFFSET                15334000
*                                                                       15335000
*        HERE FOR THE ONE CHARACTER CASE. HERE WE CALCULATE             15336000
*        AN APPROPRIATE ADDRESS IN THE MASTER SPAN TABLE                15337000
*                                                                       15338000
SPANPP1  SR    R1,R1              CLEAR FOR IC                          15339000
         IC    R1,SCHARS(,A1)     LOAD CHARACTER VALUE                  15340000
         L     A1,=A(SPANTBL)     POINT TO MASTER SPAN TABLE REF POINT  15341000
         SR    A1,R1              CALCULATE PROPER STARTING ADDR        15342000
*                                                                       15343000
*        MERGE HERE TO EXIT FOR SCANTB3 CASE (A1 = TABLE ADDRESS)       15344000
*                                                                       15345000
SPANPPS  BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT      15346000
         DC    AL1(PARM1+QF+PSPANFLG,LPRM1) ONE PARAM, SPECIAL FLAG     15347000
         DC    AL2(PN$SPAN-PATSUBS)         MATCH OFFSET                15348000
*                                                                       15349000
         DROP  DB3                DROP BASE REG                         15350000
         TITLE 'SPITBOLX -- PATTERN CONSTRUCTION FOR BREAK,BREAKX'      15351000
*                                                                       15352000
*        THIS ROUTINE IS PASSED CONTROL FROM SPITBOLA TO CONSTRUCT      15353000
*        PATTERNS FOR BREAK, BREAKX CALLS WITH STRING ARGUMENTS         15354000
*                                                                       15355000
*        (DB3)                    BASE REG (+ FOR BREAK, - FOR BREAKX)  15356000
*        (A1)                     ADDRESS OF STRING (-SCHARS)           15357000
*        (A1+1)                   360 LENGTH OF STRING                  15358000
*                                                                       15359000
         USING BREAKPP,DB3        BASE REG SET BY CALLER                15360000
BREAKPP  LTR   A1+1,A1+1          TEST LENGTH                           15361000
         BZ    BREAKPP1           SKIP ON ONE CHARACTER CASE            15362000
*                                                                       15363000
*        HERE WE MUST BUILD A NEW TBLOK FOR A MULTIPLE CHARACTER CASE   15364000
*                                                                       15365000
         STE   ZR,GCOLPTR(,FR)    CLEAR GCOL POINTER                    15366000
         MVI   DTYPE(FR),TBLOK    SET PROPER BLOCK CODE                 15367000
         MVC   CTCHARS(256,FR),ZTBL         CLEAR TABLE TO ZEROS        15368000
         LA    R1,1(,A1+1)        GET REAL NUMBER OF CHARS              15369000
         SR    DB2,DB2            CLEAR FOR IC                          15370000
         LA    R0,X'FF'           GET STOP CHAR TO PLUG                 15371000
*                                                                       15372000
*        LOOP TO PLUG SELECTED CHARS AS NON-ZERO                        15373000
*                                                                       15374000
BREAKPPL IC    DB2,SCHARS-1(A1,R1)          PICK UP CHARACTER           15375000
         STC   R0,CTCHARS(FR,DB2) PLUG TABLE                            15376000
         BCT   R1,BREAKPPL        LOOP TILL ALL PLUGGED                 15377000
*                                                                       15378000
*        TABLE IS NOW ALL SET UP                                        15379000
*                                                                       15380000
         LR    A1,FR              COPY ADDRESS OF NEW BLOCK             15381000
         LA    FR,CTCHARS+256(,FR)          PUSH FREE PTR PAST BLOCK    15382000
         B     BREAKPPX           JUMP TO EXIT                          15383000
         EJECT                                                          15384000
*                                                                       15385000
*        HERE FOR CASE OF ONE CHARACTER ARGUMENT. IN THIS               15386000
*        CASE WE CALCULATE AN APPROPRIATE STARTING ADDRESS IN THE       15387000
*        MASTER BREAK TABLE                                             15388000
*                                                                       15389000
BREAKPP1 SR    R1,R1              CLEAR FOR IC                          15390000
         IC    R1,SCHARS(,A1)     LOAD CHARACTER VALUE                  15391000
         LA    A1,BREAKTBL        POINT TO MASTER BREAK TABLE           15392000
         SR    A1,R1              CALCULATE PROPER STARTING ADDRESS     15393000
*                                                                       15394000
*        COMMON EXIT POINT (A1 POINTS TO TABLE)                         15395000
*                                                                       15396000
BREAKPPX SR    R2,R2              SET MINMATCH = 0                      15397000
         LTR   DB3,DB3            TEST CASES                            15398000
         BM    BRKXEX             JUMP ON BREAKX CASE                   15399000
*                                                                       15400000
*        EXIT POINT FOR BREAK                                           15401000
*                                                                       15402000
         BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK, EXIT         15403000
         DC    AL1(PARM1+PRELOC1+QF,LPRM1)  ONE PARAM, RELOCATABLE      15404000
         DC    AL2(PN$BREAK-PATSUBS)        MATCH OFFSET                15405000
*                                                                       15406000
*        EXIT POINT FOR BREAKX                                          15407000
*                                                                       15408000
BRKXEX   BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT      15409000
         DC    AL1(PARM1+PRELOC1+QF,LPRM1)  ONE PARAM, RELOCATABLE      15410000
         DC    AL2(PN$BRKX-PATSUBS+X'8000')                             15411000
         DC    AL2(BRKXEXT-QPATSUBS)                                    15412000
*                                                                       15413000
         DROP  DB3                GET RID OF BASE REGISTER              15414000
         TITLE 'SPITBOLX -- GETPAT -- CONVERT TO PATTERN'               15415000
*                                                                       15416000
*        THE ENTRY POINT FOR THIS ROUTINE (GETPAT) AND THE              15417000
*        DESCRIPTION OF THE CALLING SEQUENCE CAN BE FOUND IN SPITBOLA   15418000
*                                                                       15419000
         USING GETPATC,DB2        OUR BASE REGISTER                     15420000
GETPATC  ST    A1,GETPSV          SAVE ARGUMENT FOR CODE TESTS          15421000
         CLI   GETPSV,PCODE       IS IT A PATTERN ALREADY?              15422000
         BE    GETPATXT           IF SO, JUMP TO EXIT                   15423000
         TM    GETPSV,EXPRBIT     TEST FOR EXPRESSION                   15424000
         BO    GETPATE            SKIP IF EXPRESSION                    15425000
         CLI   GETPSV,NCODE       TEST FOR NULL                         15426000
         BNE   GETPATS            SKIP IF NON-NULL ARGUMENT             15427000
*                                                                       15428000
*        CASE OF NULL -- CONVERTED TO NULL PATTERN                      15429000
*                                                                       15430000
         L     A1,NULLPTR         LOAD POINTER TO NULL PATTERN          15431000
         B     GETPATXT           JUMP TO EXIT                          15432000
*                                                                       15433000
*        HERE ARGUMENT IS EITHER CONVERTIBLE TO STRING OR ILLEGAL       15434000
*                                                                       15435000
GETPATS  ST    RETURN,GETPSV      SAVE LINK REG                         15436000
         BAL   RETURN,GETSTG      CONVERT TO STRING                     15437000
         B     GETPATX            JUMP IF UNCONVERTIBLE TO GIVE ERROR   15438000
         L     RETURN,GETPSV      RELOAD RETURN REG                     15439000
         LA    R2,1(,A1+1)        GET LENGTH OF STRING + SOME GARBAGE   15440000
         N     R2,=X'00007FFF'    ISOLATE LENGTH FOR MINMATCH           15441000
         CH    R2,H256            TEST FOR 256 CHARACTERS OR LESS       15442000
         BH    GETPATS2           SKIP IF LONGER                        15443000
         EJECT                                                          15444000
*                                                                       15445000
*        GETPAT -- CONTINUED                                            15446000
*                                                                       15447000
*                                                                       15448000
*        CASE OF STRING OF 256 CHARACTERS OR LESS                       15449000
*                                                                       15450000
         BAL   R1,MPBLOK          MAKE PATTERN BLOCK                    15451000
         DC    YL1(QF+PARM1+PARM2+PRELOC1,LPRM2) 2 PARAMS, 1 RELOC      15452000
         DC    YL2(PN$STRS-PATSUBS)         CODE LOCATION               15453000
         B     GETPATXT           JUMP TO EXIT                          15454000
*                                                                       15455000
*        CASE OF STRING LONGER THAN 256 CHARACTERS                      15456000
*                                                                       15457000
GETPATS2 BAL   R1,MPBLOK          MAKE PATTERN BLOCK                    15458000
         DC    YL1(QF+PARM1+PARM2+PRELOC1,LPRM2) 2 PARAMS, 1 RELOC      15459000
         DC    YL2(PN$STRL-PATSUBS)         CODE LOCATION               15460000
*                                                                       15461000
*        COMMON SUCCESS EXIT POINT                                      15462000
*                                                                       15463000
GETPATXT LM    DB2,DB3,GETPATSV   RESTORE REGS                          15464000
         B     4(,RETURN)         RETURN TO CALLER                      15465000
*                                                                       15466000
*        HERE FOR ERROR RETURN                                          15467000
*                                                                       15468000
GETPATX  L     RETURN,GETPSV      RELOAD RETURN LOCATION                15469000
         LM    DB2,DB3,GETPATSV   RELOAD REGISTERS                      15470000
         BR    RETURN             GIVE ERROR RETURN                     15471000
*                                                                       15472000
*        NULL PATTERN                                                   15473000
*                                                                       15474000
         CNOP  0,4                ALLIGN TO FULLWORD                    15475000
         PATTERN   NAME=NULL,MIN=0                                      15476000
         EJECT                                                          15477000
*                                                                       15478000
*        GETPAT -- CONTINUED                                            15479000
*                                                                       15480000
*                                                                       15481000
*        COME HERE FOR CASE OF EXPRESSION                               15482000
*                                                                       15483000
*                                                                       15484000
*        FOR AN EXPRESSION, WE BUILD A TWO NODE PATTERN -- EXP1 HAS     15485000
*        ONE PARAMETER POINTING TO THE CODE OR VARIABLE AND IS LINKED   15486000
*        THROUGH ITS THEN FIELD TO AN EXP2 NODE -- SEE PATTERN ENTRY    15487000
*        POINTS FOR EXP1 AND EXP1,EXP2 EXTENSION ROUTINES               15488000
*                                                                       15489000
GETPATE  LR    A1+1,A1            POSITION EXPR PTR TO STORE IN PARAM2  15490000
         LA    R2,1               SET MINMATCH = 1                      15491000
         BAL   R1,MPBLOK          MAKE EXP1 BLOCK WITH ROOM FOR EXP2    15492000
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2+LPRM0-PATS) 1 PRM + XTR 15493000
         DC    AL2(PN$EXP1-PATSUBS+X'8000') CODE LOC + EXTEND FLAG      15494000
         DC    AL2(NOEXT-QPATSUBS)          EXTEND OFFSET               15495000
         LA    R0,LPRM2-PATS      GET OFFSET FROM EXP1 TO EXP2          15496000
         STH   R0,THEN+PATS(,A1)  MAKE THEN OFFSET OF EXP1 --> EXP2     15497000
         MVC   LPRM2(12,A1),GETPEXP2        MOVE IN SECOND NODE (EXP2)  15498000
         B     GETPATXT           EXIT VIA COMMON POINT                 15499000
*                                                                       15500000
*        MODEL FOR EXP2 NODE IN PATTERN CONSTRUCTED ABOVE               15501000
*                                                                       15502000
         CNOP  0,4                ALLIGN                                15503000
GETPEXP2 DC    AL1(0)             PFLAGS = 0 (NO PARAMETERS)            15504000
         DC    AL3(SPITBOLP)      CODE LOC (SEE BELOW)                  15505000
         DC    AL2(0)             MINMATCH = 0                          15506000
         DC    AL2(EXP2EXT-QPATSUBS)        EXTEND OFFSET               15507000
         DC    AL2(PNOTHEN-LPRM2)           "NOTHEN OFFSET"             15508000
         DC    AL2(PNOOR-LPRM2)             "NOOR" OFFSET               15509000
         DROP  DB2                GET RID OF THIS BASE REGISTER         15510000
*                                                                       15511000
*        NOTE THAT THE CODELOC IN EXP2 IS NEVER USED (ONLY THE          15512000
*        EXTENSION ROUTINE IS USED). HOWEVER, IT IS IMPORTANT TO HAVE A 15513000
*        REASONABLE VALUE SO THAT THE OBJECT MODULE RESTART ROUTINE     15514000
*        DOES NOT CLOBBER THE FLAGS BYTE WHEN IT RELOCATES THE NODE     15515000
         TITLE 'SPITBOLX -- MPBLOK -- MAKE PATTERN BLOCK'               15516000
*                                                                       15517000
*        THIS ROUTINE IS CONTINUED FROM THE ENTRY POINT IN THE          15518000
*        ADDRESSABLE AREA (AT MPBLOK AND MPBLOKX) SEE THESE ENTRY       15519000
*        POINTS FOR A DESCRIPTION OF THE ARGUMENTS ETC..                15520000
*                                                                       15521000
         USING MPBLOKC,DB3        BASE REG SET AT ENTRY POINT           15522000
MPBLOKC  MVC   0(LPRM0,FR),MODPAT MOVE DUMMY FOR ALL BUT PARAMS         15523000
         STM   A1,A1+1,PARAM1+PATS(FR)      STORE PARAMS (IF ANY)       15524000
         CE    SCNT,SCNTSAVE      ALREADY BUILT A PATTERN THIS STMNT?   15525000
         BE    *+12               ALREADY SET UP IF SO                  15526000
         STE   SCNT,SCNTSAVE      ELSE SAVE THIS STATEMENT NUMBER       15527000
         ST    FR,PCFRSAVE        AND SAVE FIRST PATTERN ADDRESS        15528000
         LR    A1,FR              SAVE ADDRESS OF NEW PBLOK             15529000
         AL    A1,PCODEBT         SUPPLY PATTERN CODE BYTE              15530000
         SR    A1+1,A1+1          CLEAR FOR IC                          15531000
         IC    A1+1,1(,R1)        PICK UP GIVEN LENGTH                  15532000
         STC   A1+1,PTLENG+1(,FR) STORE IN NEW BLOCK                    15533000
         LH    R0,2(,R1)          PICK UP CODE POINTER                  15534000
         N     R0,=X'00007FFF'    REMOVE POSSIBLE EXTEND FLAG BIT       15535000
         A     R0,=A(PATSUBS)     ADD BASE LOCATION                     15536000
         ST    R0,CODELOC+PATS(,FR)         STORE CODE POINTER          15537000
         MVC   PFLAGS+PATS(1,FR),0(R1)      MOVE PFLAGS INTO PLACE      15538000
         LA    R0,NOEXT-QPATSUBS  SET DEFAULT NOEXT EXTEND ADDRESS      15539000
         TM    2(R1),X'80'        CHECK FOR EXTEND ROUTINE GIVEN        15540000
         BNO   *+12               WE HAVE CORRECT PTR IF NON SUPPLIED   15541000
         LH    R0,4(,R1)          PICK UP SUPPLIED EXTEND OFFSET        15542000
         LA    R1,2(,R1)          FUDGE RETURN FOR TWO EXTRA BYTES      15543000
         STH   R0,EXTEND+PATS(,FR)          STORE EXTEND ROUTINE OFFSET 15544000
         STH   R2,MINMATCH+PATS(,FR)        STORE MINMATCH VALUE        15545000
         AR    FR,A1+1            BUMP FREE POINTER                     15546000
*                                                                       15547000
*        COME HERE TO EXIT -- BLOCK CONSTRUCTION COMPLETE               15548000
*                                                                       15549000
PBLOKL   CLI   PBLOKSW,0          TEST CALL CASES                       15550000
         L     DB3,$$BAS3         RESTORE CLOBBERED BASE REG            15551000
         DROP  DB3                GET RID OF BASE REGISTER              15552000
         BNZ   4(,R1)             RETURN TO CALLER FOR MPBLOK CALL      15553000
         CR    FR,PDR             ELSE CHECK FOR GARBAGE COLLECT        15554000
         BCR   L,RETURN           RETURN TO CODE IF OK                  15555000
         B     GBGCL1S            ELSE DO A GARBAGE COLLECT FIRST       15556000
*                                                                       15557000
*        MODEL PATTERN BLOCK                                            15558000
*                                                                       15559000
MODPAT   DC    AL1(PBLOK)         BLOK CODE FOR PATTERN BLOCK           15560000
         DC    AL3(0)             GARBAGE COLLECT FIELD                 15561000
         DC    Y(*-*)             PTLENG (GETS FILLED IN)               15562000
         DC    Y(ANCHEXT-QPATSUBS)          OFFSET FOR NO EXTENSION     15563000
         DC    AL4(NOTHEN)        CODELOC FOR "NOTHEN"                  15564000
         DC    AL1(QF)            SET NOTHEN MINMATCH NEGATIVE          15565000
         DC    AL3(NOOR)          CODELOC FOR "NOOR"                    15566000
         DC    2AL4(0)            FIELDS WHICH GET FILLED IN            15567000
         DC    AL2(PNOTHEN-PATS,PNOOR-PATS) NOTHEN & NOOR NEGATIVE OFS  15568000
         TITLE 'SPITBOLX -- ARRAY REFERENCE ROUTINES'                   15569000
*                                                                       15570000
*        ROUTINE TO HANDLE REFERENCE TO A SINGLY SUBSCRIPTED ARRAY      15571000
*        (MIGHT ALSO BE A REFERENCE TO A TABLE)                         15572000
*                                                                       15573000
*        CONDITIONS ON ENTRY                                            15574000
*                                                                       15575000
*        R2                       PRESET BASE REGISTER                  15576000
*        A1,A1+1                  SUBSCRIPT                             15577000
*        A2,A2+1                  ARRAY POINTER                         15578000
*        NAMEFL                   0 -- BY NAME  ,  X'FF' -- BY VALUE    15579000
*                                                                       15580000
         USING *,R2               BASE REGISTER                         15581000
SUBSC1   ST    A2,SUBSCSV         STORE ARRAY POINTER TO TEST CODE      15582000
         CLI   SUBSCSV,ACODE      TEST FOR CASE OF ARRAY                15583000
         BE    SUBSC1N            SKIP IF IT IS AN ARRAY                15584000
         ST    RETURN,RETLOC      ELSE STORE RETURN LOCATION            15585000
         CLI   SUBSCSV,TCODE      TEST FOR TABLE                        15586000
         BE    TBLOOK             JUMP TO PROCESS A TABLE REFERENCE     15587000
         XERR  03,001             ARRAY REFERENCE WITH ONE SUBSCRIPT    15588000
*                                 REFERENCES AN OBJECT WHICH IS         15589000
*                                 NEITHER AN ARRAY NOR A TABLE          15590000
SUBSC1N  CLI   NSUBS(A2),1        TEST FOR ONE SUBSCRIPT                15591000
         BNE   SUBSERR3           ERROR IF NOT SINGLE SUBSCRIPTED       15592000
         LTR   A1,A1              IF OK, TEST SUBSCRIPT FOR INTEGER     15593000
         BZ    SUBSC1A            SKIP IF IT IS AN INTEGER              15594000
         ST    RETURN,RETLOC      SAVE RETURN LOCATION                  15595000
         BAL   RETURN,GETINT      GET AN INTEGER VALUE                  15596000
         XERR  01,021             SUBSCRIPT IN REFERENCE TO ONE         15597000
*                                 DIMENSIONAL ARRAY IS NOT AN INTEGER   15598000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               15599000
         L     R2,SUBSC1AD        RELOAD BASE REGISTER FOR THIS ROUTINE 15600000
*                                                                       15601000
*        MERGE HERE IF SUBSCRIPT WAS ALREADY AN INTEGER                 15602000
*                                                                       15603000
SUBSC1A  SH    A1+1,SUBLBD(,A2)   SUBTRACT LOW BOUND (GET ZERO ORIGIN)  15604000
         LH    R0,SUBDIM(,A2)     LOAD DIMENSION                        15605000
         CLR   A1+1,R0            CHECK FOR SUBSCRIPT IN RANGE          15606000
         BCR   NL,FRETURN         FAIL IF OUT OF RANGE                  15607000
         SLL   A1+1,3             SUBSCRIPT * 8 TO REFERENCE DATA       15608000
         CLI   NAMEFL,0           TEST BY VALUE OR BY NAME              15609000
         BE    SUBSC1NM           SKIP IF BY NAME                       15610000
*                                                                       15611000
*        HERE TO RETURN BY VALUE                                        15612000
*                                                                       15613000
         L     A1,AVALS(A2,A1+1)  LOAD FIRST WORD OF VALUE              15614000
         L     A1+1,AVALS+4(A2,A1+1)        LOAD SECOND WORD OF VALUE   15615000
         BR    RETURN             RETURN TO CALLER                      15616000
*                                                                       15617000
*        HERE TO RETURN BY NAME                                         15618000
*                                                                       15619000
SUBSC1NM LA    A1+1,AVALS-VALUE(,A1+1)      SET PROPER OFFSET           15620000
         LA    A1,0(,A2)          COPY ARRAY PTR, STRIP UPPER BYTE      15621000
         AL    A1,MCODEBT         SUPPLY PROPER NAME CODE               15622000
         BR    RETURN             RETURN TO CALLER                      15623000
         DROP  R2                 DROP BASE REG                         15624000
         EJECT                                                          15625000
*                                                                       15626000
*        ROUTINE TO HANDLE MULTIPLY SUBSCRIPTED REFERENCE TO ARRAY      15627000
*                                                                       15628000
*                                                                       15629000
*        CONDITIONS ON ENTRY                                            15630000
*                                                                       15631000
*        STACK (TEM#1,TEM#2..)    SUBSCRIPT VALUES                      15632000
*        A1,A1+1                  ARRAY POINTER                         15633000
*        R0                       NUMBER OF SUBSCRIPTS                  15634000
*        A2                       PRESET BASE REGISTER                  15635000
*        NAMEFL                   0 -- BY NAME  ,  X'FF' -- BY VALUE    15636000
*                                                                       15637000
         USING *,A2               BASE REGISTER                         15638000
SUBSCM   ST    A1,SUBSCSV         STORE ARRAY POINTER TO TEST CODE      15639000
         CLI   SUBSCSV,ACODE      IS IT AN ARRAY?                       15640000
         BNE   SUBSERR2           GIVE ERROR IF NOT ARRAY               15641000
         SR    R1,R1              CLEAR R1 FOR IC                       15642000
         IC    R1,NSUBS(A1)       LOAD NUMBER OF DIMENSIONS             15643000
         SR    R1,R0              COMPARE WITH NUM SUBS (CLEARING R1)   15644000
         BNZ   SUBSERR3           GIVE ERROR IF WRONG NUMBER OF SUBS    15645000
         LA    A2+1,TEM#1(PDR)    INITIALIZE POINTER TO SUBSCRIPTS      15646000
         LR    R2,A1              INITIALIZE POINTER TO BOUNDS          15647000
*                                                                       15648000
*        REGISTER USAGE IN THIS LOOP                                    15649000
*                                                                       15650000
*        A2+1                     SUBSCRIPT POINTER                     15651000
*        A2                       BASE REGISTER                         15652000
*        R0                       SUBSCRIPT COUNTER (COUNTS DOWN)       15653000
*        R1                       ACCUMULATING INDEX (RESULT)           15654000
*        R2                       POINTER TO SUBSCRIPT BOUNDS           15655000
*                                                                       15656000
SUBSCML  LM    A1,A1+1,0(A2+1)    PICK UP NEXT SUBSCRIPT                15657000
         LTR   A1,A1              IS IT AN INTEGER                      15658000
         BZ    SUBSCM2            SKIP IF IT IS                         15659000
         ST    RETURN,RETLOC      SAVE RETURN LOCATION                  15660000
         STM   R0,R2,SUBSCSV+4    SAVE LOOP REGISTERS                   15661000
         BAL   RETURN,GETINT      GET AN INTEGER                        15662000
         XERR  01,022             SUBSCRIPT IN REFERENCE TO MULTI-      15663000
*                                 DIMENSIONAL ARRAY IS NOT AN INTEGER   15664000
         LM    R0,R2,SUBSCSV+4    RESTORE LOOP REGISTERS                15665000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               15666000
         EJECT                                                          15667000
*                                                                       15668000
*        REENTER HERE IF INTEGER                                        15669000
*                                                                       15670000
SUBSCM2  SH    A1+1,SUBLBD(R2)    SUBTRACT LOW BOUND                    15671000
         BM    FAILR              FAIL ON OUT OF RANGE IF MINUS         15672000
         CH    A1+1,SUBDIM(R2)    CHECK AGAINST HIGH BOUND              15673000
         BNL   FAILR              FAIL IF OUT OF RANGE                  15674000
         M     A1,SUBFAC(R2)      IF IN RANGE -- MULTIPLY BY FACTOR     15675000
         AR    R1,A1+1            ADD INTO RESULT                       15676000
         SH    A2+1,H8            MOVE POINTER TO NEXT SUBSCRIPT        15677000
         LA    R2,8(R2)           MOVE TO NEXT SET OF BOUNDS            15678000
         BCT   R0,SUBSCML         JUMP BACK FOR NEXT SUBSCR IF MORE     15679000
*                                                                       15680000
*        COME HERE AT END OF LOOP                                       15681000
*                                                                       15682000
         L     PDR,PDRLOC         RESET STACK POINTER                   15683000
         MVI   SUBSCSV,MCODE      SET NAME CODE IN ARRAY PTR            15684000
         L     A1,SUBSCSV         LOAD ARRAY PTR WITH MCODE             15685000
         SR    R2,A1              ARRAY BOUNDS PTR AT END - ARRAY START 15686000
         LA    A1+1,AVALS-8-VALUE(R1,R2)    CALCULATE OFFSET            15687000
         TS    NAMEFL             TEST FOR BY NAME OR VALUE             15688000
         BCR   Z,RETURN           ALL DONE IF BY NAME                   15689000
         AR    A1,A1+1            ELSE ADD IN OFFSET                    15690000
         LM    A1,A1+1,VALUE(A1)  PICK UP VALUE                         15691000
         BR    RETURN             AND RETURN                            15692000
         DROP  A2                 DONT NEED THIS BASE REG ANY MORE      15693000
*                                                                       15694000
SUBSERR2 XERR  03,002,S           MULTI-DIMENSIONAL ARRAY REFERENCE     15695000
*                                 REFERS TO AN OBJECT WHICH IS NOT AN   15696000
*                                 ARRAY                                 15697000
*                                                                       15698000
SUBSERR3 XERR  03,003,S           WRONG NUMBER OF SUBSCRIPTS IN AN      15699000
*                                 ARRAY REFERENCE                       15700000
         TITLE 'SPITBOLX -- TABLE REFERENCE ROUTINE'                    15701000
*                                                                       15702000
*        THIS ROUTINE IS ENTERED FROM SUBSC1 FOR A TABLE REFERENCE      15703000
*        IT IS ALSO USED BY THE CONVERT FUNCTION (CONVERT TO TABLE)     15704000
*        NOTE THAT CONVERT EXPECTS DB1-DB3 TO BE INTACT ON RETURN       15705000
*                                                                       15706000
*        CONDITIONS ON ENTRY --                                         15707000
*                                                                       15708000
*        (R2)                     BASE REG (POINTS TO SUBSC1)           15709000
*        (A1,A1+1)                SUBSCRIPT                             15710000
*        (A2)                     TABLE POINTER                         15711000
*        NAMEFL                   0 -- BY NAME , X'FF' -- BY VALUE      15712000
*                                                                       15713000
*        ON RETURN, THE REQUIRED NAME OR VALUE IS IN (A1,A1+1)          15714000
*                                                                       15715000
*        TABLES ARE MAINTAINED AS HASH TABLES USING A CENTRAL STRUCTURE 15716000
*        (TBLOK) WHICH CONTAINS N POINTERS TO CHAINS OF INDIVIDUAL      15717000
*        ELEMENTS (TEBLOK'S). THE NUMBER N IS SPECIFIED IN THE          15718000
*        CALL TO THE TABLE FUNCTION. THIS ROUTINE PERFORMS A HASH TO    15719000
*        DETERMINE THE CHAIN TO BE SEARCHED AND THEN SEARCHES DOWN      15720000
*        THE CHAIN LOOKING FOR A MATCH. THERE ARE FOUR POSSIBLE         15721000
*        RESULTS AS FOLLOWS --                                          15722000
*                                                                       15723000
*        BLOCK FOUND, CALL BY VALUE         LOAD VALUE FROM TEBLOK      15724000
*        BLOCK FOUND, CALL BY NAME          RETURN ADDRESS OF TEBLOK    15725000
*        BLOCK NOT FOUND, CALL BY VALUE     RETURN NULL                 15726000
*        BLOCK NOT FOUND, CALL BY NAME      BUILD TEBLOK & RETURN ADDR  15727000
*                                                                       15728000
*        IN THE LATTER CASE, THE NEW TEBLOK IS LINKED INTO THE          15729000
*        APPROPRIATE CHAIN AT THE HEAD OF THE CHAIN                     15730000
*                                                                       15731000
*        THE HASH FUNCTION VARIES WITH DATATYPE AS DESCRIBED BELOW      15732000
*                                                                       15733000
         USING SUBSC1,R2          BASE REG FOR THIS ROUTINE             15734000
TBLOOK   STM   A1,A1+1,SUBSCSV    SAVE "SUBSCRIPT"                      15735000
         STM   FRETURN,RETURN,SRETFSV       SAVE FRETURN, RETURN POINT  15736000
         CLI   SUBSCSV,SCODE      STRING CASE?                          15737000
         BE    TBLOOKS            SKIP IF STRING                        15738000
         LTR   A1,A1              FURTHER CHECK ON TYPE CODE            15739000
         BNP   TBLOOK2            SKIP IF INEGER, REAL OR DREAL         15740000
         CLI   SUBSCSV,NCODE      NULL?                                 15741000
         BE    TBLOOKNL           SKIP IF NULL                          15742000
         CLI   SUBSCSV,MCODE      NAME?                                 15743000
         BE    TBLOOK2            SKIP TO TEST BOTH WORDS IF NAME       15744000
         EJECT                                                          15745000
*                                                                       15746000
*        HERE FOR ALL DATATYPES EXCEPT NUMERIC, STRING, NAME, NULL      15747000
*        IN THESE CASES, USE THE TYPE CODE FOR THE HASH                 15748000
*                                                                       15749000
         LR    R1,A1              COPY FIRST WORD                       15750000
         SRL   R1,32-8            POSITION TYPE CODE FOR HASH           15751000
         BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH        15752000
*                                                                       15753000
*        RETURN HERE TO CHECK FOR MATCH WITH A NODE (SEE TBHASH)        15754000
*        IN THIS CASE, ALL WE NEED TO CHECK IS THE FIRST WORD           15755000
*                                                                       15756000
         C     A1,TENAME(,R1)     DOES THIS MATCH?                      15757000
         BNE   TBLOOKN            SKIP IF NO                            15758000
         B     TBLOOKY            SKIP IF YES                           15759000
*                                                                       15760000
*        COME HERE FOR INTEGER, REAL, DREAL, NAME                       15761000
*        IN THESE CASES THE HASH USES THE SECOND WORD OF THE VALUE      15762000
*                                                                       15763000
TBLOOK2  LR    R1,A1+1            USE SECOND WORD AS HASH ARG           15764000
         BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH        15765000
*                                                                       15766000
*        RETURN HERE TO CHECK FOR MATCH, HERE WE CHECK FOR BOTH WORDS   15767000
*                                                                       15768000
         C     A1+1,TENAME+4(,R1) CHECK SECOND WORDS                    15769000
         BNE   TBLOOKN            SKIP IF NO MATCH                      15770000
         C     A1,TENAME(,R1)     ELSE CHECK FIRST WORD                 15771000
         BE    TBLOOKY            SKIP IF BOTH WORDS MATCH              15772000
         B     TBLOOKN            ELSE NO MATCH                         15773000
*                                                                       15774000
*        HERE FOR NULL SUBSCRIPT                                        15775000
*                                                                       15776000
TBLOOKNL SR    R1,R1              USE ZERO FOR HASH                     15777000
         BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH        15778000
*                                                                       15779000
*        HERE TO CHECK FOR THE NULL ENTRY WE WANT                       15780000
*                                                                       15781000
         CLI   TENAME(R1),NCODE   IS NAME OF THIS NODE NULL?            15782000
         BNE   TBLOOKN            SKIP IF NOT                           15783000
         BE    TBLOOKY            SKIP IF YES (FOUND)                   15784000
*                                                                       15785000
*        HERE FOR STRING CASE, USE THE FOLLOWING FOR THE HASH --        15786000
*                                                                       15787000
*        LENGTH > 4    (360 LENGTH) XOR (1ST 4 CHRS) XOR (LAST 4 CHRS)  15788000
*        LENGTH = 4    (FOUR CHARS)                                     15789000
*        LENGTH < 4    (WHOLE STRING PADDED ON RIGHT WITH X'00')        15790000
*                                                                       15791000
TBLOOKS  AH    A1,SUBSCSV+SOFFSET           POINT TO STRING             15792000
         LH    A1+1,SUBSCSV+SLENGTH         LOAD STRING LENGTH          15793000
         CH    A1+1,H3            CHECK LENGTH                          15794000
         BH    TBLOOKSL           SKIP IF LONGER THAN 4 CHARACTERS      15795000
         EJECT                                                          15796000
*                                                                       15797000
*        HERE WE HAVE A STRING SHORTER THAN 5 CHARACTERS                15798000
*                                                                       15799000
         STE   ZR,TBLSV           CLEAR AREA TO X'00'                   15800000
         EX    A1+1,TBLOOKSM      MOVE WHAT CHARS WE HAVE               15801000
         L     R1,TBLSV           LOAD CHARS AS HASH                    15802000
         B     TBLOOKS1           SKIP TO MERGE                         15803000
*                                                                       15804000
*        HERE FOR STRINGS LONGER THAN FOUR CHARACTERS                   15805000
*                                                                       15806000
TBLOOKSL MVC   TBLSV(4),SCHARS(A1)          GET FIRST 4 CHARS           15807000
         LR    R1,A1+1            COPY 360 LENGTH                       15808000
         X     R1,TBLSV           EXCLUSIVE OR WITH FIRST 4 CHARS       15809000
         LA    A2+1,0(A1,A1+1)    POINT TO END OF STRING                15810000
         MVC   TBLSV(4),SCHARS+1-4(A2+1)    MOVE LAST FOUR CHARS        15811000
         X     R1,TBLSV           EXCLUSIVE OR LAST FOUR CHARS          15812000
         CH    A1+1,H256          CHECK FOR SHORT/LONG STRING           15813000
         BNL   TBLOOKS2           SKIP IF LONG STRING                   15814000
*                                                                       15815000
*        HERE FOR SHORT STRINGS                                         15816000
*                                                                       15817000
TBLOOKS1 BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH        15818000
*                                                                       15819000
*        RETURN HERE TO CHECK FOR MATCH WITH PARTICULAR BLOCK ON CHAIN  15820000
*                                                                       15821000
         CH    A1+1,TENAME+SLENGTH(,R1)     LENGTHS MATCH?              15822000
         BNE   TBLOOKN            NO MATCH IF UNEQUAL LENGTHS           15823000
         CLI   TENAME(R1),SCODE   ELSE IS IT REALLY A STRING?           15824000
         BNE   TBLOOKN            NO MATCH IF NOT                       15825000
         L     A2+1,TENAME(,R1)   ELSE LOAD STRING BASE POINTER         15826000
         AH    A2+1,TENAME+SOFFSET(,R1)     ADD OFFSET                  15827000
         EX    A1+1,TBLOOKCS      ARE STRINGS IDENTICAL?                15828000
         BNE   TBLOOKN            SKIP IF NOT                           15829000
         BE    TBLOOKY            SKIP IF YES                           15830000
*                                                                       15831000
*        HERE FOR STRINGS LONGER THAN 255 CHARACTERS                    15832000
*                                                                       15833000
TBLOOKS2 ST    A2,TBLSV           SAVE TABLE POINTER                    15834000
         BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH        15835000
*                                                                       15836000
*        HERE TO COMPARE FOR LONG STRING MATCH. TO HECK WITH SPEED      15837000
*        IN THIS HIGHLY UNUSUAL CASE, USE IDENT FOR THE COMPARISON      15838000
*                                                                       15839000
         LM    A1,A1+1,TENAME(R1) LOAD NAME                             15840000
         LM    A2,A2+1,SUBSCSV    LOAD SUBSCRIPT                        15841000
         BAL   RETURN,$$IDNT      USE IDENT FOR THE COMPARISON          15842000
         L     A2,TBLSV           RESTORE TABLE POINTER                 15843000
         BNE   TBLOOKN            BRANCH IF NO MATCH                    15844000
         B     TBLOOKY            BRANCH IF MATCH                       15845000
*                                                                       15846000
TBLOOKSM MVC   TBLSV(*-*),SCHARS(A1)        MOVE UP TO 4 CHRS FOR HASH  15847000
TBLOOKCS CLC   SCHARS(*-*,A1),SCHARS(A2+1)  CHECK FOR MATCHING NAMES    15848000
         EJECT                                                          15849000
*                                                                       15850000
*        COMMON HASH ROUTINE USED FOR ALL DATATYPES                     15851000
*                                                                       15852000
*        TBHASH IS CALLED FOR PARTICULAR CASES BY --                    15853000
*                                                                       15854000
*        (R1)                     ARGUMENT FOR HASH                     15855000
*        (R2)                     BASE REG FOR ROUTINE                  15856000
*        (A2)                     POINTER TO TABLE                      15857000
*        BAL   FRETURN,TBHASH                                           15858000
*                                                                       15859000
*        ON RETURN, THE FOLLOWING ARE THE CONDITIONS                    15860000
*                                                                       15861000
*        (R0)                     OFFSET TO PROPER HASH SLOT IN TABLE   15862000
*        (R1)                     POINTER TO FIRST TEBLOK ON CHAIN      15863000
*        (A1,A1+1,A2,A2+1)        UNCHANGED                             15864000
*        (FRETURN)                STILL POINTS PAST CALL                15865000
*                                                                       15866000
*        THE CALL TO TBHASH IS IMMEDIATELY FOLLOWED BY A ROUTINE THAT   15867000
*        CHECKS TO SEE IF THE TEBLOK POINTED TO BY (R1) IS THE ONE      15868000
*        WHICH MATCHES THE ARGUMENT SUBSCRIPT. IF IT IS, CONTROL IS     15869000
*        PASSED TO TBLOOKY, ELSE CONTROL IS PASSED TO TBLOOKN.          15870000
*                                                                       15871000
*        THE HASH IS CALCULATED AS THE N RESIDUE OF THE HASH ARGUMENT   15872000
*        WHERE N IS THE NUMBER OF HEADERS IN THE TABLE                  15873000
*                                                                       15874000
TBHASH   SR    R0,R0              CLEAR FOR DIVIDE                      15875000
         SLL   R1,2               HASH ARGUMENT *4 TO INDEX BY WORDS    15876000
         D     R0,TBDIVIDE(,A2)   DIVIDE TO CALCULATE HASH FUNCTION     15877000
         LR    R1,R0              COPY OFFSET                           15878000
         L     R1,TBLPTRS(R1,A2)  LOAD POINTER TO FIRST TEBLOK          15879000
         LTR   R1,R1              IS THERE A BLOCK                      15880000
         BCR   NZ,FRETURN         IF SO, RETURN TO COMPARISON ROUTINE   15881000
         B     TBLOOKB            ELSE OFF TO HANDLE NON-EXISTANT VALUE 15882000
*                                                                       15883000
*                                                                       15884000
*        HERE IF THERE IS NO MATCHING NODE ON THE HASH CHAIN            15885000
*                                                                       15886000
TBLOOKN  L     R1,TLINK(,R1)      LINK TO NEXT NODE ON CHAIN            15887000
         LTR   R1,R1              IS THERE ONE?                         15888000
         BCR   NZ,FRETURN         RETURN TO CHECK IT IF SO              15889000
         EJECT                                                          15890000
*                                                                       15891000
*        HERE IF THIS ENTRY DOES NOT ALREADY EXIST IN THE TABLE         15892000
*        IF THE CALL WAS BY VALUE, WE RETURN NULL                       15893000
*        IF THE CALL WAS BY NAME, WE CREATE A NEW TEBLOK                15894000
*                                                                       15895000
TBLOOKB  LM    FRETURN,RETURN,SRETFSV       RELOAD RETURN REGS          15896000
         L     A1,NCODEBT         LOAD NULL IN CASE BY VALUE            15897000
         CLI   NAMEFL,0           BY VALUE OR NAME?                     15898000
         BCR   NE,RETURN          RETURN IF BY VALUE (RETURN NULL)      15899000
         LM    A1,A1+1,SUBSCSV    LOAD SUBSCRIPT (IN CASE OF COLLECT)   15900000
*                                                                       15901000
*        HERE TO BUILD A NEW TEBLOK                                     15902000
*                                                                       15903000
TBLOOKB0 LA    R1,TESIZE(,FR)     SEE WHERE FREE CORE WILL END UP       15904000
         CR    R1,PDR             WILL THERE BE ROOM                    15905000
         BL    TBLOOKB1           SKIP IF THERE IS ROOM                 15906000
         BAL   RETURN,GBGCL2      COLLECT SAVING TABLE POINTER          15907000
         L     RETURN,SRETSV      RESTORE RETURN ADDRESS                15908000
         B     TBLOOKB0           BACK TO CHECK SPACE AGAIN             15909000
*                                                                       15910000
*        HERE AFTER CHECKING FOR SUFFICIENT SPACE                       15911000
*                                                                       15912000
TBLOOKB1 AR    A2,R0              POINT TO PROPER HASH CHAIN SLOT       15913000
         L     R0,TBLPTRS(,A2)    LOAD OLD HEAD OF CHAIN POINTER        15914000
         ST    FR,TBLPTRS(,A2)    SET NEW BLOCK AS HEAD OF CHAIN        15915000
         ST    R0,TLINK(,FR)      LINK THIS BLOCK TO REST OF CHAIN      15916000
         STE   ZR,GCOLPTR(,FR)    CLEAR GCOL FIELD                      15917000
         MVI   DTYPE(FR),TEBLOK   SET BLOCK CODE                        15918000
         MVI   TEVALUE(FR),NCODE  SET VALUE = NULL                      15919000
         STM   A1,A1+1,TENAME(FR) STORE SUBSCRIPT IN NAME FIELD         15920000
         LR    A1,FR              COPY ADDRESS OF TEBLOK                15921000
         AL    A1,MCODEBT         SUPPLY STANDARD NAME CODE             15922000
         SR    A1+1,A1+1          SET ZERO (TEVALUE-VALUE) OFFSET       15923000
         LR    FR,R1              BUMP FREE REG PAST BLOCK              15924000
         BR    RETURN             RETURN TO CALLER                      15925000
*                                                                       15926000
*        HERE IF A MATCHING BLOCK IS FOUND                              15927000
*                                                                       15928000
TBLOOKY  LM    FRETURN,RETURN,SRETFSV       RELOAD RETURN REGS          15929000
         CLI   NAMEFL,0           CHECK FOR NAME OR VALUE               15930000
         BE    TBLOOKYN           SKIP IF BY NAME                       15931000
         LM    A1,A1+1,TEVALUE(R1)          IF BY VALUE, LOAD VALUE     15932000
         BR    RETURN             AND RETURN                            15933000
*                                                                       15934000
*        HERE FOR FOUND MATCHING BLOCK, CALLED BY NAME                  15935000
*                                                                       15936000
TBLOOKYN LR    A1,R1              COPY BLOCK POINTER                    15937000
         AL    A1,MCODEBT         SUPPLY NAME CODE                      15938000
         SR    A1+1,A1+1          CLEAR OFFSET                          15939000
         BR    RETURN             RETURN TO CALLER                      15940000
*                                                                       15941000
         DROP  R2                 DROP TABLE BASE REG                   15942000
         TITLE 'SPITBOLX -- MISCELLANEOUS ERROR EXITS'                  15943000
*                                                                       15944000
$$NOGO   XERR  08,002,S           TRANSFER TO UNDEFINED LABEL           15945000
*                                                                       15946000
DREALO   XERR  10,001             OVERFLOW IN + - / OR * OF TWO DREALS  15947000
*                                                                       15948000
REALO    XERR  10,002,S           OVERFLOW IN + - / OR * OF TWO REALS   15949000
*                                                                       15950000
REALDZ   XERR  10,003,S           REAL DIVISION BY ZERO                 15951000
*                                                                       15952000
DREALDZ  XERR  10,004             DREAL DIVISION BY ZERO                15953000
*                                                                       15954000
EXPWRO   XERR  10,005             OVERFLOW IN REAL ** INTEGER OR        15955000
*                                 DREAL ** INTEGER                      15956000
*                                                                       15957000
DVDIZ    XERR  10,006,S           INTEGER DIVISION BY ZERO              15958000
*                                                                       15959000
*        THIS IS A PSEUDO FFBLOK WHICH GIVES AN ERROR MESSAGE           15960000
*                                                                       15961000
         USING FLCERR-FCODE,DB4   POINTER TO FFBLOK IS DB4              15962000
FLCERR   NOP   0                  DO NOTHING ON NORMAL ENTRY            15963000
         B     *+4                BRANCH TO RETAIN CONTROL ON EXECUTE   15964000
         XERR  01,023,S           A FIELD FUNCTION WAS APPLIED TO AN    15965000
*                                 INCORRECT PROGRAM DEFINED DATATYPE    15966000
*                                                                       15967000
*        THE FOLLOWING ENTRY POINTS ARE USED FOR EXECUTION ERRORS       15968000
*        9.001 - 9.012 (UNDEFINED FUNCTION AND OPERATOR CALLS)          15969000
*                                                                       15970000
XER09012 BCTR  DB2,0              9.012     UNDEFINED OPTR UNARY EXCLAM 15971000
XER09011 BCTR  DB2,0              9.011     UNDEFINED OPTR BINARY %     15972000
XER09010 BCTR  DB2,0              9.010     UNDEFINED OPTR UNARY %      15973000
XER09009 BCTR  DB2,0              9.009     UNDEFINED OPTR BINARY ?     15974000
XER09008 BCTR  DB2,0              9.008     UNDEFINED OPTR BINARY #     15975000
XER09007 BCTR  DB2,0              9.007     UNDEFINED OPTR UNARY #      15976000
XER09006 BCTR  DB2,0              9.006     UNDEFINED OPTR UNARY |      15977000
XER09005 BCTR  DB2,0              9.005     UNDEFINED OPTR BINARY @     15978000
XER09004 BCTR  DB2,0              9.004     UNDEFINED OPTR BINARY      15979000
XER09003 BCTR  DB2,0              9.003     UNDEFINED OPTR BINARY &     15980000
XER09002 BCTR  DB2,0              9.002     UNDEFINED OPTR UNARY /      15981000
XER09001 BCTR  DB2,0              9.001     UNDEFINED FUNCTION CALL     15982000
*                                                                       15983000
*        COME HERE WITH (DB2) DECREMENTED BY AN AMOUNT CORRESPONDING    15984000
*        TO THE CORRECT MINOR CODE FOR THE ERROR MESSAGE                15985000
*                                                                       15986000
         ST    RETURN,RETLOC      SAVE RETURN POINT                     15987000
         LCR   DB2,DB2            GET CODE - (DB2)                      15988000
         A     DB2,$$BAS2         CALCULATE MINOR CODE                  15989000
         STC   DB2,SYSERCOD+3     STORE MINOR CODE                      15990000
         MVI   SYSERCOD+2,9       SET PROPER MAJOR CODE                 15991000
         B     SYSERCOD           ISSUE ERROR (NOTE ERROR RESTORES DB2) 15992000
*                                                                       15993000
$$NOFN   EQU   XER09001           ALTERNATE NAME FOR UNDEF FUNCTION     15994000
         TITLE 'SPITBOLX -- DUMP,TRACE,EOJ ROUTINES'                    15995000
*                                                                       15996000
*        ALL THESE ROUTINES ARE UNDER CONTROL OF THE FOLLOWING USING    15997000
*                                                                       15998000
         USING DTERTNS,DB4        BASE REG FOR DUMP/TRACE/EOJ ROUTINES  15999000
DTERTNS  EQU   *                  START OF DUMP/TRACE/EOJ ROUTINES      16000000
*                                                                       16001000
*        LINETERM -- DUMP OUT BUFFER FOR TRACE OR DUMP -- CALLED ON A2  16002000
*        LINETERM ALWAYS ENDS BY REINITIALIZING WITH LINEINIT           16003000
*                                                                       16004000
LINE$    EQU   DB4                REG FOR BALR CALL TO LINETERM         16005000
LINETERM STM   A1,A2+1,DTESAVE    SAVE REGISTERS NEEDED FOR WRITE       16006000
         LR    A1,FR              POINT TO OUTPUT BUFFER                16007000
         SR    DB3,A1             GET LINE LENGTH                       16008000
         LR    A1+1,DB3           COPY LENGTH IN CASE ALL FITS ON LINE  16009000
         SH    DB3,=Y(TBUFSIZE)   GET LENGTH OF CHARS BEYOND BUFFER     16010000
         BNP   *+8                SKIP IF NO OVERFLOW                   16011000
         LA    A1+1,TBUFSIZE      ELSE PRINT OUT FULL BUFFER            16012000
         SR    A2+1,A2+1          SET UNFORMATED OUTPUT                 16013000
         L     R0,PRINTDCB        GET INTERFACE POINTER                 16014000
         L     R2,=V(SYSWRITE)    LOAD INTERFACE ROUTNE ADDRESS         16015000
         BALR  R1,R2              CALL ROUTINE                          16016000
         NOP   0                  IGNORE ERROR RETURN                   16017000
         LM    A1,A2+1,DTESAVE    RESTORE WRITE REGISTERS               16018000
         LTR   DB3,DB3            CHECK FOR OVERFLOW ON LAST RECORD     16019000
         BM    LINEINIT           SET UP FOR NEXT LINE IF NO OVERFLOW   16020000
         EX    DB3,LINEMOVE       MOVE THE OVERFLOW INTO THE BUFFER     16021000
         MVI   0(FR),C' '         SET CONTROL CHARACTER                 16022000
         LA    DB3,1(DB3,FR)      POINT TO NEXT EMPTY LOCATION          16023000
         BR    A2                 AND RETURN TO CALLER                  16024000
*                                                                       16025000
*        LINEINIT -- INITIALIZE TRACE OR DUMP OUTPUT -- CALLED ON A2    16026000
*        LEAVES DB3 POINTING TO FIRST AVAILABLE LOC IN BUFFER           16027000
*                                                                       16028000
LINEINIT MVI   0(FR),C' '         SET FOR BLANK LINE (NO SKIP)          16029000
         LA    DB3,1(,FR)         POINT PAST CONTROL CHARACTER          16030000
         BR    A2                 AND RETURN TO CALLER                  16031000
*                                                                       16032000
LINEMOVE MVC   1(*-*,FR),TBUFSIZE(FR)       MOVE BACK OVERFLOW RECORD   16033000
TBUFSIZE EQU   121                SIZE OF TRACE BUFFER INCL. CONT CHAR  16034000
         EJECT                                                          16035000
*                                                                       16036000
*        ROUTINE TO INITIALIZE TRACE OUTPUT                             16037000
*                                                                       16038000
*        BAL   A2,FTRCINIT                                              16039000
*                                                                       16040000
*        INITIALIZES THE TRACE BUFFER AND PLACES  ****NN*** ON THE      16041000
*        LINE WHERE NN IS THE STATEMENT NUMBER FROM RETLOC OR ALTLOC    16042000
*                                                                       16043000
FTRCINIT LR    A2+1,A2            SAVE LINKAGE                          16044000
         BAL   A2,LINEINIT        INITIALIZE PRINT LINE                 16045000
         MVC   0(10,DB3),TRCINIT  MOVE IN *** AND EDIT PATTERN          16046000
         BAL   A2,CALCSTNO        CALCULATE STATEMENT NUMBER            16047000
         CVD   A1+1,STOPSV        CONVERT TO DECIMAL                    16048000
         ED    0(6,DB3),STOPSV+5  EDIT WITH LEADING *                   16049000
         LA    DB3,10(,DB3)       BUMP PAST ****NN*** AND BLANK         16050000
         BR    A2+1               RETURN TO CALLER                      16051000
*                                                                       16052000
*        EDIT PATTERN FOR TRACINIT                                      16053000
*                                                                       16054000
TRCINIT  DC    C'*'               FILL CHARACTER                        16055000
         DC    X'2020202020'      EDIT PATTERN                          16056000
         DC    C'*** '            TRAILING ASTERISKS                    16057000
*                                                                       16058000
DMPRBBEB DC    C'>'               C'> = ' FOR ARRAY TABLE               16059000
DMPBEB   DC    C' = '             BLANK EQUALS BLANK FOR ASSIGNS        16060000
*                                                                       16061000
*        COME HERE JUST BEFORE TERMINATING A LINE TO WHICH EXTRA        16062000
*        CHARACTERS HAVE BEEN ADDED UNOFFICIALLY.  FIRST ENTRY ALSO     16063000
*        SKIPS OVER ONE CHARACTER ADDITION                              16064000
*        BAL   A2,DMPCHK          CALL OF THIS ROUTINE                  16065000
*        EXIT IS TO USER, POSSIBLY BY WAY OF LINETERM                   16066000
*                                                                       16067000
DMPCHK1  LA    DB3,1(,DB3)        BUMP OVER ONE CHARACTER ADDITION      16068000
*                                                                       16069000
*        COME HERE TO CHECK FOR OVERFLOW                                16070000
*                                                                       16071000
DMPCHK   LA    R2,TBUFSIZE(,FR)   POINT PAST LAST ALLOWED CHARACTER     16072000
         CR    DB3,R2             CHECK CURRENT POSITION                16073000
         BCR   NH,A2              EXIT TO CALLER IF NO OVERFLOW         16074000
         BR    LINE$              ELSE TERMINATE LINE FIRST             16075000
         EJECT                                                          16076000
*                                                                       16077000
*        THIS ROUTINE IS ENTERED FROM WRITE IN SPITBOLX UPON NEED       16078000
*        FOR A VALUE TRACE TO BE PERFORMED.  REGISTERS ON ENTRY -       16079000
*        (A2)                     ADDRESS OF VARIABLE BLOCK             16080000
*        NOTE THAT A PROGRAMER DEFINED TRACE FUNCTION IS IN USE IF      16081000
*        A VIOPTR POINTS TO AN IOBLOK AND IOFUNC IS NON-ZERO            16082000
*        ON EXIT WRETLOC MUST BE RESTORED, AS MUST DB4 AND A2,A2+1      16083000
*        EXIT POINT DEPENDS UPON WHETHER A WRITE IS ALSO REQUESTED      16084000
*                                                                       16085000
VALTRACE LR    DB2,A2             POINT TO VAR BLOCK WITH SAFE REGISTER 16086000
         L     A2,V$TRACE         PICK UP &TRACE FOR PDTRC CALL         16087000
         SH    A2,H1              DECREMENT AND TEST VALUE OF &TRACE    16088000
         BM    VALTEXIT           SKIP TRACE IF &TRACE IS TURNED OFF    16089000
         CE    ZR,VIOPTR(,DB2)    DO WE POINT TO AN IOBLOK?             16090000
         BE    VALTSTD            SKIP IF NO IOBLOK (NO TRACE INFO)     16091000
         L     R1,VIOPTR(,DB2)    ELSE LOAD ADDRESS OF IOBLOK           16092000
         CE    ZR,IOFUNC(,R1)     IS THERE A PROG DEFINED TRACE FUNC    16093000
         BE    VALTSTD            SKIP IF NO FUNC DEFINED               16094000
*                                                                       16095000
*        COME HERE WITH R1 SET UP TO CALL PDTRC ROUTINE                 16096000
*                                                                       16097000
         BAL   A2+1,PDTRCL        MAKE ENTRY FOR (R1) SETUP CASE        16098000
         NOP   0                  IMPOSSIBLE RETURN                     16099000
         ST    RETURN,WRETLOC     RESTORE WRETLOC FOR WRITE             16100000
         B     VALTEXIT           AND EXIT FROM TRACE                   16101000
*                                                                       16102000
*        COME HERE TO PRINT STD TRACE LINE WITH NAME = VALUE            16103000
*        NOTE THAT DUMPNVAL IS NOT USED SINCE IT REQUIRES FRETURN SAVE  16104000
*                                                                       16105000
VALTSTD  ST    A2,V$TRACE         SAVE UPDATED VALUE OF &TRACE          16106000
         BAL   A2,FTRCINIT        INITIALIZE LINE, SKIP &TRACE DECR     16107000
         LM    A1,A1+1,VNAME(DB2) LOAD STRING NAME FOR VARIABLE         16108000
         BAL   RETURN,LINESTR     ADD IT TO TRACE LINE                  16109000
         LM    A1,A1+1,VALUE(DB2) LOAD VALUE ASSIGNED                   16110000
         BAL   A2,LINEQVAL        PUT VALUE ON LINE AFTER C' = '        16111000
         BALR  A2,LINE$           AND PRINT THE LINE                    16112000
*                                                                       16113000
*        COME HERE TO RETURN TO WRITE ROUTINE                           16114000
*                                                                       16115000
VALTEXIT LR    A2,DB2             RESTORE VARIABLE BLOCK ADDRESS REG    16116000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           16117000
         L     DB4,PSTRING+4(,PDR)          RESTORE DATA BASE ADDRESS   16118000
         L     A2+1,=A(WRITE)     LOAD BASE ADDRESS                     16119000
         USING WRITE,A2+1         TELL ASSEMBLER                        16120000
         TM    VFLAGS(A2),VOUA    IS A WRITE REQUESTED?                 16121000
         BZ    WRITEX             OFF TO EXIT IF NOT                    16122000
         LM    A1,A1+1,VALUE(A2)  ELSE RESTORE OUTPUT VALUE REGSITERS   16123000
         B     WRITE0             AND OFF TO GIVE OUTPUT REQUESTED      16124000
         DROP  A2+1               GET RID OF BASE REGISTER              16125000
         EJECT                                                          16126000
*                                                                       16127000
*        LINEQVAL -- PRINT C' = ' FOLLOWED BY VALUE IN A1,A1+1 AT DB3   16128000
*                                                                       16129000
LINEQVAL MVC   0(3,DB3),DMPBEB    MOVE IN C' = '                        16130000
         LA    DB3,3(,DB3)        PUSH BUFFER POINTER PAST IT AND MERGE 16131000
*                                                                       16132000
*        LINEVAL -- PRINT THE VALUE IN A1,A1+1 AT CURRENT DB3 LOC       16133000
*                                                                       16134000
LINEVAL  STM   A1,A2,LINESV       STORE ARGUMENT AND LINKAGE            16135000
         CLI   LINESV,NCODE       IS VALUE NULL                         16136000
         BCR   E,A2               PRINT NOTHING IF NULL                 16137000
         CLI   LINESV,SCODE       IS IT STRING?                         16138000
         BNE   *+12               SKIP IF NOT                           16139000
         MVI   0(DB3),C''''       MOVE IN INITIALI QUOTE IF STRING      16140000
         LA    DB3,1(,DB3)        ADJUST DB3 FOR QUOTE                  16141000
         CLI   LINESV,MCODE       NAME?                                 16142000
         BNE   LINEVAL1           SKIP IF NOT                           16143000
*                                                                       16144000
*        FOR NAMES REFERRING TO A SIMPLE VARIABLE, PRINT .NAME          16145000
*                                                                       16146000
         BAL   RETURN,GETSTGS     TRY TO CONVERT TO STRING              16147000
         B     LINEVAL1           NOT SIMPLE VAR IF NOT CONVERTIBLE     16148000
         MVI   0(DB3),C'.'        ELSE SET PERIOD ON TRACE LINE         16149000
         LA    DB3,1(,DB3)        BUMP PAST PERIOD AND MERGE            16150000
*                                                                       16151000
*        MERGE HERE TO CONVERT TO STRING OR GET DATATYPE                16152000
*                                                                       16153000
LINEVAL1 BAL   RETURN,GETSTGS     GET STRING FOR PRINTING               16154000
         BAL   RETURN,$$DTTP      GET DATATYPE IF UNCONVERTIBLE         16155000
         BAL   RETURN,LINESTR     GO PRINT STRING OUT                   16156000
         LM    A1,A2,LINESV       RESTORE ARGUMENTS                     16157000
         CLI   LINESV,SCODE       WAS IT A STRING?                      16158000
         BNE   LINEVAL2           IF NOT, GO CHECK FOR ID PRINT         16159000
         MVI   0(DB3),C''''       ELSE MOVE TERMINAL QUOTE FOR STG      16160000
         B     DMPCHK1            BUMP PAST QUOTE, CHECK FOR OVERFLOW   16161000
*                                                                       16162000
*        COME HERE TO CHECK FOR CALL FROM DUMP REQUIRING ID NUMBER      16163000
*                                                                       16164000
LINEVAL2 CLI   LINESV,DCODE       IS IT PROG DEFINED DATATYPE?          16165000
         BE    LINEPDID           OFF TO DUMP ITS ID IF SO              16166000
         CLI   LINESV,TCODE       IS THIS A TABLE?                      16167000
         BE    LINEVALT           OFF TO PRINT INFO IF TABLE            16168000
         CLI   LINESV,ACODE       IS THIS AN ARRAY?                     16169000
         BCR   NE,A2              RETURN TO CALLER IF NOT               16170000
*                                                                       16171000
*        COME HERE IF OBJECT IS AN ARRAY TO GET SPECIFIER               16172000
*                                                                       16173000
         LM    A1,A1+1,ASPEC(A1)  LOAD PROTOTYPE                        16174000
         B     LINEVAL3           AND MERGE WITH TABLE                  16175000
         EJECT                                                          16176000
*                                                                       16177000
*        COME HERE FOR TABLE VALUE                                      16178000
*                                                                       16179000
LINEVALT L     A1+1,TBDIVIDE(,A1) LOAD NUMBER OF SLOTS * 4              16180000
         SRL   A1+1,2             /4 EQUALS NUMBER OF SLOTS             16181000
         SR    A1,A1              INDICATE INTEGER TYPE CODE            16182000
*                                                                       16183000
*        TABLE AND ARRAY MERGE HERE WITH PROTOTYPES IN A1,A1+1          16184000
*                                                                       16185000
LINEVAL3 MVI   0(DB3),C'('        MOVE IN LEFT PARENTHESIS              16186000
         LA    DB3,1(,DB3)        AND BUMP PAST IT                      16187000
         MVC   LINEIDSV(12),LINESV          SAVE ORIGINAL CALL INFO     16188000
         BAL   A2,LINEVAL         PUT VALUE ON LINE                     16189000
         LM    A1,A2,LINEIDSV     RECOVER CALL REGISTERS                16190000
         MVC   0(3,DB3),DMPRPB#   MOVE IN C') #'                        16191000
*                                                                       16192000
*        PROGRAMER DEFINED DATATYPE MERGES HERE                         16193000
*                                                                       16194000
LINEVAL4 LH    A1+1,2(,A1)        PICK UP POSSIBLE ID NUMBER            16195000
         LTR   A1+1,A1+1          TEST FOR ID NUMBER                    16196000
         BZ    DMPCHK1            BUMP PAST ) AND CHK FOR OVERFLOW IF   16197000
*                                 NO ID PRESENT                         16198000
         LA    DB3,3(,DB3)        ELSE BUMP PAST # FOR ID               16199000
         SR    A1,A1              INDICATE INTEGER RESULT               16200000
         B     LINEVAL            OFF TO PRINT NUMBER AND RETURN        16201000
*                                                                       16202000
*        COME HERE FOR PROGRAMER DEFINED DATATYPE                       16203000
*                                                                       16204000
*        THE DUMP FUNCTION MERGES HERE WITH (A1) POINTING TO THE BLOCK  16205000
*                                                                       16206000
LINEPDID MVC   0(2,DB3),DMPB#     MOVE C' #' ONTO LINE                  16207000
         BCT   DB3,LINEVAL4       BACK UP DB3 FOR MERGE AND MERGE       16208000
*                                                                       16209000
DMPRPB#  DC    C')'               RIGHT PAREN FOR TABLE AND ARRAY       16210000
DMPB#    DC    C' #'              ' #' FOR ID NUMBER PRINTING           16211000
         EJECT                                                          16212000
*                                                                       16213000
*        LINESTR -- PRINT STRING VALUE IN A1,A1+1 AT DB3 POINTER        16214000
*        CALLED ON RETURN                                               16215000
*                                                                       16216000
LINESTR  LR    R1,A1+1            COPY OFFSET/LENGTH                    16217000
         SRL   R1,16              ISOLATE OFFSET                        16218000
         AR    A1,R1              ADD OFFSET TO BASE                    16219000
         N     A1+1,=X'00007FFF'  ISOLATE SLENGTH                       16220000
*                                                                       16221000
*        LOOP GONE THROUGH MORE THAN ONCE IF WE DO NOT FIT ON ONE LINE  16222000
*                                                                       16223000
LINESTRL LA    R2,TBUFSIZE-1(,FR) END OF BUFFER-1 FOR 360 LENGTH CHECK  16224000
         SR    R2,DB3             CALCULATE NUMBER OF COLS LEFT ON LINE 16225000
         BM    LINESPRT           IF OVERFLOW, GO PRINT LINE            16226000
         CR    R2,A1+1            WILL STRING FIT ON THIS LINE          16227000
         BNL   LINESFIT           SKIP IF IT WILL                       16228000
         EX    R2,LINESMV         ELSE MOVE IN WHATEVER WILL FIT        16229000
         LA    R2,1(,R2)          ADJUST FOR 360 LENGTH                 16230000
         AR    A1,R2              PUSH STRING POINTER                   16231000
         SR    A1+1,R2            DECREMENT COUNT                       16232000
         LA    DB3,TBUFSIZE(,FR)  INDICATE FULL BUFFER                  16233000
*                                                                       16234000
*        COME HERE TO PRINT A LINE                                      16235000
*                                                                       16236000
LINESPRT BALR  A2,LINE$           TERMINATE LINE                        16237000
         B     LINESTRL           AND LOOP BACK                         16238000
*                                                                       16239000
*        COME HERE WHEN WE CAN FIT ON THIS LINE                         16240000
*                                                                       16241000
LINESFIT EX    A1+1,LINESMV       MOVE REST OF (OR ALL OF) STRING       16242000
         LA    DB3,1(DB3,A1+1)    BUMP PAST PART MOVED                  16243000
         BR    RETURN             RETURN TO CALLER                      16244000
*                                                                       16245000
LINESMV  MVC   0(*-*,DB3),SCHARS(A1)        MOVE CHARS TO BUFFER        16246000
         EJECT                                                          16247000
*                                                                       16248000
*        TRACLABL -- ROUTINE TO PRINT TRACE OF TRANSFER TO LABEL        16249000
*                                                                       16250000
*        WHEN A TRACED LABEL IS TRANSFERED TO, THE TRANSFER IS MADE     16251000
*        TO A BLOCK IN FREE CORE.  THIS BLOCK CALLS LABTRAC, SETTING    16252000
*        DB2 TO AN ADDRESS WITHIN THE FREE CORE BLOCK                   16253000
*        THE FREE CORE BLOCK CONTAINS THE REAL LABEL ADDRESS AND        16254000
*        THE ADDRESS OF THE VARIABLE BLOCK                              16255000
*        NOTE THAT LABELS ARE ALSO TRACED ON FUNCTION CALL              16256000
*                                                                       16257000
LABTRACC L     A2,V$TRACE         LOAD VALUE OF &TRACE                  16258000
         SH    A2,H1              DECREMENT AND TEST VALUE              16259000
         BM    LABTRACX           EXIT IF &TRACE NOT ON                 16260000
         CE    ZR,LTFUNC-LTOFFSET(,DB2)     DO WE HAVE PDT FUNCTION?    16261000
         BNE   LABTFUNC           OFF TO HANDLE IT IF PRESENT           16262000
         ST    A2,V$TRACE         STORE UPDATED &TRACE VALUE            16263000
         ST    RETURN,RETLOC      STORE FOR USE BY CALCSTNO             16264000
         BAL   A2,FTRCINIT        INITIALIZE TRACE OUTPUT               16265000
         MVC   0(12,DB3),TRCLBMSG MOVE IN LABEL TRACE MESSAGE           16266000
         LA    DB3,12(,DB3)       BUMP PAST MESSAGE                     16267000
         L     R1,LTBLOCK-LTOFFSET(,DB2)    LOAD VAR BLOCK ADDRESS      16268000
         LM    A1,A1+1,VNAME(R1)  LOAD VARIABLE BLOCK NAME              16269000
         BAL   RETURN,LINESTR     PUT NAME ON OUTPUT LINE               16270000
         BALR  A2,LINE$           PRINT LINE                            16271000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               16272000
*                                                                       16273000
*        COME HERE AT END OF TRACE OR IF &TRACE LE ZERO                 16274000
*                                                                       16275000
LABTRACX L     R1,LTGOTO-LTOFFSET(,DB2)     LOAD TRANSFER ADDRESS       16276000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           16277000
         BR    R1                 AND OFF TO STATEMENT                  16278000
*                                                                       16279000
*        COME HERE IF WE HAVE A PROG TRACE FUNC TO INVOKE               16280000
*                                                                       16281000
LABTFUNC LA    R1,LTTAG-TRTAG-LTOFFSET(,DB2)          GET ADDR OF PSEUD 16282000
*                                 TRBLOK FOR PDTRC CALL                 16283000
         BAL   A2+1,PDTRCL        CALL THE FUNCTION                     16284000
         NOP   0                  IMPOSSIBLE TO RETURN HERE             16285000
         L     R1,VLABL(,DB2)     LOAD ADDRESS OF LTBLOK OR CODE        16286000
         L     DB2,$$BAS2         RESTORE DB2                           16287000
         CLI   0(R1),LTBLOK       DID SOMEONE GET RID OF LTBLOK?        16288000
         BCR   NE,R1              OFF TO CODE IF THEY STOPTRED          16289000
         L     R1,LTGOTO(,R1)     ELSE LOAD CODE ADDR FROM LTBLOK       16290000
         BR    R1                 AND OFF TO IT                         16291000
*                                                                       16292000
TRCLBMSG DC    C'TRANSFER TO '    MESSAGE LINE FOR LABEL TRACE          16293000
         EJECT                                                          16294000
*                                                                       16295000
*        COME HERE IF THIS IS FAILURE CASE, NOGOTO, -FAIL SET           16296000
*                                                                       16297000
*        IN THIS SITUATION, THE GENERATED CODE SETS FRETURN TO DB1 TO   16298000
*        REDUCE THE LENGTH OF THE GENERATED CODE. THIS IS DONE ON THE   16299000
*        BASIS THAT A FAILURE IS UNLIKELY IN SUCH A STATEMENT. THIS     16300000
*        SECTION IS USED IF SUCH A FAILURE DOES OCCUR. THE FAILURE      16301000
*        BRANCH POINT IS THE FOLLOWING STATEMENT WHICH IS LOCATED BY    16302000
*        SCANNING TO THE NEXT AUR STATEMENT. NOTE THAT THIS PROCEDURE   16303000
*        IS USUALLY FAIRLY FAST SINCE THE CODE LOCATION POINTS          16304000
*        NEAR THE END OF THE STATEMENT IN MOST SIMPLE INSTANCES.        16305000
*        NOTE ALSO THAT IN THE CASE WHERE NO FAILURE OCCURS, THE        16306000
*        EXECUTION TIME IS REDUCED SINCE THE BALR, LA SEQUENCE          16307000
*        IS REPLACED BY A SINGLE LR INSTRUCTION.                        16308000
*                                                                       16309000
READFAIL LA    R1,0(,RETURN)      COPY CALL ADDRESS                     16310000
         SH    R1,H2              BACK OFF TWO BYTES FOR LOOP           16311000
         BALR  R2,0               SET START OF LOOP ADDRESS             16312000
         CLI   2(R1),X'3E'        AUR INSTRUCTION?                      16313000
         LA    R1,2(,R1)          BUMP POINTER ANYWAY                   16314000
         BCR   NE,R2              LOOP BACK IF NOT AUR                  16315000
         BR    R1                 ELSE JUMP TO CODE (AT AUR INSTRUC)    16316000
         EJECT                                                          16317000
*                                                                       16318000
*        COME HERE TO DO A GARBAGE COLLECTION BEFORE TRACING            16319000
*                                                                       16320000
FNCTGBG  BAL   RETURN,GBGCL0      CALL GARBAGE COLLECTOR                16321000
         L     RETURN,RETFLOC(,PDR)         RESTORE RETURN VALUE        16322000
*                                                                       16323000
*        COME HERE TO TEST FOR COLLECT NEEDED BEFORE TRACING            16324000
*                                                                       16325000
FNCTRC   CR    FR,PDR             DO WE NEED A COLLECT?                 16326000
         BNL   FNCTGBG            OFF TO COLLECT IF SO                  16327000
         SLR   A2,A2+1            FIX UP VALUE OF &TRACE AND TEST       16328000
         BZ    CFTRC              OFF TO TRY FTRACE IF &TRACE=0         16329000
*                                                                       16330000
*        COME HERE IF VALUE OF &TRACE NE ZERO                           16331000
*                                                                       16332000
CTRC     TM    FFLAGS(DB3),VFTC   CHECK FOR POSSIBLE TRACE IN FBLOK     16333000
         BZ    CFTRC              OFF TO CHECK FOR FTRACE IF NO TRACE   16334000
         SH    A2,H1              DECREMENT AND TEST &TRACE             16335000
         BM    CFTRC              OFF TO TRY FTRACE IF NEGATIVE         16336000
         BAL   R1,FTRCNAME        SEARCE FOR NAME USED FOR CALL         16337000
         TM    VFLAGS(DB2),VFTC   IS THIS SPECIFIC FUNC TRACED?         16338000
         BZ    CFTRC              OFF TO TRY FTRACE IF NOT              16339000
         ST    A2,V$TRACE         STORE UPDATED &TRACE VALUE            16340000
         LA    R1,FCTRCCHN-TRCLINK          POINT TO START OF TRC CHAIN 16341000
         BAL   A2+1,PDTRC1        AND OFF TO SEARCH FOR PROG TRACE      16342000
         B     CFTRC1             DO OUR TRACE IF NO TRACE FUNC         16343000
         L     A2+1,V$FTRACE      LOAD &FTRACE IN (A2+1) FOR MERGE      16344000
         L     DB3,FBLOKLOC(,PDR) RESTORE BLOK ADDRESS                  16345000
*                                                                       16346000
*        COME HERE TO TEST FOR MASTER FUNCTION TRACE (&FTRACE GT 0)     16347000
*                                                                       16348000
CFTRC    SH    A2+1,H1            DECREMENT AND TEST &FTRACE            16349000
         BM    CFLVTRC            OFF TO CHECK FOR FNCLEV TRC IF LE 0   16350000
         ST    A2+1,V$FTRACE      STORE UPDATED VALUE OF &FTRACE        16351000
         BAL   R1,FTRCNAME        FIND NAME USED IN CALL                16352000
*                                                                       16353000
*        AT THIS POINT (DB2) POINTS TO CALLING NAME                     16354000
*                                                                       16355000
CFTRC1   ST    RETURN,RETLOC      STORE RETURN FOR CALCSTNO USE         16356000
         BAL   A2,FTRCINIT        SET UP TRACE LINE INFO                16357000
         MVC   0(24,DB3),FTCCMSG  MOVE IN MESSAGE                       16358000
         L     R0,V$FNCLEV        LOAD FUNCTION LEVEL                   16359000
         CVD   R0,STOPSV          CONVERT TO DECIMAL                    16360000
         ED    16(4,DB3),STOPSV+6 EDIT IN FUNCTION LEVEL                16361000
         LA    DB3,24(,DB3)       BUMP BUFFER POINTER                   16362000
         LM    A1,A1+1,VNAME(DB2) LOAD NAME OF CALLER                   16363000
         BAL   RETURN,LINESTR     PLACE IT ON TRACE LINE                16364000
         MVI   0(DB3),C'('        MOVE IN LEFT PARENTHESIS              16365000
         LA    DB3,1(,DB3)        BUMP PAST IT                          16366000
         L     DB2,FBLOKLOC(,PDR) LOAD FUNCTION BLOCK ADDRESS           16367000
         LH    FRETURN,FNARGS(,DB2)         LOAD NUMBER OF ARGUMENTS    16368000
         LTR   FRETURN,FRETURN    CHECK FOR NO ARGUMENT CASE            16369000
         BZ    CFTRC2             SKIP IF NO ARGUMENTS                  16370000
         EJECT                                                          16371000
*                                                                       16372000
*        LOOP TO DUMP OUT ARGUMENT VALUES                               16373000
*                                                                       16374000
FTRACELP L     A1,FARGS(,DB2)     LOAD ADDRESS OF NEXT ARG NAME         16375000
         LM    A1,A1+1,VALUE(A1)  LOAD ARGUMENT VALUE                   16376000
         BAL   A2,LINEVAL         PRINT VALUE                           16377000
         MVI   0(DB3),C','        MOVE IN COMMA AFTER ARGUMENT          16378000
         LA    DB3,1(,DB3)        BUMP BUFFER POINTER                   16379000
         LA    DB2,4(,DB2)        BUMP ARGUMENT NAME POINTER            16380000
         BCT   FRETURN,FTRACELP   LOOP BACK IF ARGUMENTS LEFT TO DUMP   16381000
         BCTR  DB3,0              DELETE LAST COMMA BY ADJUSTING PTR    16382000
*                                                                       16383000
*        COME HERE AFTER FINISHING ARGUMENTS                            16384000
*                                                                       16385000
CFTRC2   MVI   0(DB3),C')'        PUT ON FINAL RIGHT PAREN              16386000
         BAL   A2,DMPCHK1         BUMP OVER ) AND CHECK FOR OVERFLOW    16387000
         BALR  A2,LINE$           TERMINATE LINE (PRINT IT)             16388000
         LM    FRETURN,RETURN,FRETFLOC(PDR) RESTORE RETURN AND FRETURN  16389000
*                                                                       16390000
*        AT THIS TIME WE MUST CHECK FOR &FNCLEVEL TRACE                 16391000
*                                                                       16392000
CFLVTRC  L     R1,V$FNCLEV        LOAD VALUE OF &FNCLEVEL               16393000
         LA    R1,1(,R1)          INCREMENT IT                          16394000
         ST    R1,V$FNCLEV        STORE UPDATED VALUE                   16395000
         L     R1,FNCLTRC         LOAD POINTER TO TRACE INFORMATION     16396000
         BAL   DB2,KEYTRACE       OFF TO USE KEYWORD TRACING ROUTINE    16397000
         DC    Y(E$FNCLEV-INITVR1,8-1)      OFFSET, LENGTH FOR FNCLEVEL 16398000
         L     A1+1,V$FNCLEV      INSTRUCTION TO ACCESS VALUE           16399000
         L     DB4,FBLOKLOC(,PDR) RESTORE FBLOK ADDRESS                 16400000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           16401000
         B     FTRACECE           AND MERGE WITH FINAL CALL CODE        16402000
         EJECT                                                          16403000
*                                                                       16404000
*        THIS ROUTINE IS CALLED TO DO FUNCTION RETURN TRACING           16405000
*        AS NECESSARY, DETERMINED BY THE SETTINGS OF &TRACE AND &FTRACE 16406000
*                                                                       16407000
RTRC     L     DB3,FBLOKLOC(,PDR) LOAD FUNCTION BLOCK ADDRESS           16408000
         TM    FFLAGS(DB3),VFTR   IS THERE AN INDIVIDUAL TRACE?         16409000
         BZ    RFTRC              CHECK FOR GLOBAL TRACE IF NOT SPECIAL 16410000
         SH    A2,H1              DECRECMENT &TRACE AND CHECK FOR ON    16411000
         BM    RFTRC              IF &TRACE IS OFF, CHECK &FTRACE       16412000
         BAL   R1,FTRCNAME        GET FUNCTION NAME USED IN CALL        16413000
         TM    VFLAGS(DB2),VFTR   SEE IF IT IS TRACED                   16414000
         BZ    RFTRC              SKIP SPECIAL TRACE IF NOT             16415000
         ST    A2,V$TRACE         STORE UPDATED VALUE OF &TRACE         16416000
         LA    R1,FRTRCCHN-TRCLINK          POINT TO POTENTIAL CHAIN    16417000
*                                 OF PD TRACE FUNCTIONS                 16418000
         SR    FRETURN,FRETURN    MAKE SURE THIS IS NOT RELOCATED       16419000
         IC    FRETURN,V$RETYPE   SAVE VALUE OF &RETYPE                 16420000
         BAL   A2+1,PDTRC1        OFF TO CHECK FOR & DO PDTP            16421000
         B     RFTRC1             IF NO PROG DEF TRACE PROC, DO REG TRC 16422000
*                                 NOTE THAT &LASTNO=LAST STMT OF PDTP   16423000
         STC   FRETURN,V$RETYPE   RESTORE RETURN TYPE (? IS THIS OK?)   16424000
         L     A2+1,V$FTRACE      LOAD VALUE OF &FTRACE FOR MERGE       16425000
         L     DB3,FBLOKLOC(,PDR) RESTORE BLOK ADDRESS                  16426000
*                                                                       16427000
*        COME HERE TO TEST FOR GLOBAL FUNCTION TRACING - CONTROLLED     16428000
*        BY THE SETTING OF &FTRACE                                      16429000
*                                                                       16430000
RFTRC    SH    A2+1,H1            DECREMENT AND TEST &FTRACE SETTING    16431000
         BM    RTRCFNCL           SKIP TRACE IF LE ZERO                 16432000
         ST    A2+1,V$FTRACE      STORE UPDATED VALUE OF &FTRACE        16433000
         BAL   R1,FTRCNAME        GET NAME USED FOR FUNCTION CALL       16434000
*                                                                       16435000
*        COME HERE WITH DB2 POINTING TO NAME USED IN CALL               16436000
*        TO DO A SYSTEM TRACE - ALSO COME HERE IF NO 4TH ARG TO TRACE   16437000
*                                                                       16438000
RFTRC1   ST    RETURN,RETLOC      SAVE FOR STATEMENT NUMBER CALC        16439000
         BAL   A2,FTRCINIT        SET UP TRACE LINE FOR FUNCTION        16440000
         MVC   0(24,DB3),FTRCMSG  MOVE IN POTENTIAL TRACE MSG           16441000
         L     R0,V$FNCLEV        LOAD 'FROM' FUNCTION LEVEL            16442000
         BCTR  R0,0               CALCULATE 'TO' FUNCTION LEVEL         16443000
         CVD   R0,STOPSV          GET IN PACKED DECIMAL                 16444000
         ED    16(4,DB3),STOPSV+6 PUT ON LINE IN READABLE FORM          16445000
         CLI   V$RETYPE,4         TEST TYPE OF RETURN                   16446000
         BL    FTRACER1           SKIP IF TYPE = 'RETURN'               16447000
         MVC   1(6,DB3),FTRCMSG   SHIFT 'RETURN' ONE POSITION RIGHT     16448000
         MVI   0(DB3),C'F'        PROVISIONALLY INDICATE FRETURN        16449000
         BE    FTRACER1           DONE IF IT WAS FRETURN CASE           16450000
         MVI   0(DB3),C'N'        ELSE THIS WAS A NRETURN               16451000
         EJECT                                                          16452000
*                                                                       16453000
*        COME HERE WITH RETURN TYPE SET UP IN MESSAGE                   16454000
*                                                                       16455000
FTRACER1 LA    DB3,24(,DB3)       BUMP PAST MEESAGE                     16456000
         LM    A1,A1+1,VNAME(DB2) LOAD FUNCTION NAME                    16457000
         BAL   RETURN,LINESTR     ADD IT TO TRACE LINE                  16458000
         CLI   V$RETYPE,4         CHECK FOR FAILURE RETURN              16459000
         BE    FTRACER2           MESSAGE COMPLETE IF FAILURE           16460000
         L     R1,FBLOKLOC(,PDR)  LOAD FUNCTION BLOCK ADDRESS           16461000
         L     R1,FNAME(,R1)      LOAD ADDRESS OF VARIABLE THAT         16462000
*                                 CONTAINS THE RETURNED VALUE           16463000
         LM    A1,A1+1,VALUE(R1)  LOAD THE RETUNED VALUE                16464000
         BAL   A2,LINEQVAL        PRINT RETURNED VALUE AFTER C' = '     16465000
*                                                                       16466000
*        COME HERE TO PRINT THE LINE OF TRACE OUTPUT                    16467000
*                                                                       16468000
FTRACER2 BALR  A2,LINE$           TERMINATE THE LINE                    16469000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               16470000
*                                                                       16471000
*        COME HERE TO CHECK FOR AND GIVE &FNCLEVEL TRACE                16472000
*                                                                       16473000
RTRCFNCL L     R1,V$FNCLEV        LOAD &FNCLEVEL TO CHANGE VALUE        16474000
         BCTR  R1,0               DECREMENT IT                          16475000
         ST    R1,V$FNCLEV        AND STORE UPDATED VALUE               16476000
         L     R1,FNCLTRC         LOAD TRACE INFORMATION FOR FNCLEVEL   16477000
         BAL   DB2,KEYTRACE       CALL STANDARD KEYWORD TRACE ROUTINE   16478000
         DC    Y(E$FNCLEV-INITVR1,8-1)      OFFSET,LENGTH FOR FNCLEVEL  16479000
         L     A1+1,V$FNCLEV      INSTRUCTION TO ACCESS & VALUE         16480000
*                                                                       16481000
*        COME HERE TO EXIT FROM RETURN TRACING PROCEDURE                16482000
*                                                                       16483000
RFTRCX   L     DB3,=A(RSTORE+2)   SET UP OLD BASE REGISTER              16484000
         L     DB2,$$BAS2         RESTORE DB2                           16485000
         USING RSTORE+2,DB3       TELL ASSEMBLER                        16486000
         B     FTRACERE           AND MERGE PAST FNCLEV STORE           16487000
         DROP  DB3                                                      16488000
*                                                                       16489000
*        THIS ROUTINE SHOULD GIVE THE NAME ACTUALLY USED IN THE CALL    16490000
*        HOWEVER BECAUSE OF PROBLEMS WITH APPLY CALLS IT GIVES FNAME    16491000
*                                                                       16492000
FTRCNAME L     DB2,FNAME(,DB3)    LOAD NAME OF FUNCTION                 16493000
         BR    R1                 AND RETURN TO CALLER                  16494000
*                                                                       16495000
FTRCMSG  DC    C'RETURN  TO LEVEL '         START OF MESSAGE            16496000
         DC    X'202120'          EDIT PATTERN FOR LEVEL                16497000
         DC    C' OF '            REST OF MESSAGE                       16498000
*                                                                       16499000
FTCCMSG  DC    C'CALL  FROM LEVEL '         START OF MESSAGE            16500000
         DC    X'202120'          EDIT PATTERN FOR LEVEL                16501000
         DC    C' OF '            REST OF MESSAGE                       16502000
         EJECT                                                          16503000
*                                                                       16504000
*        THIS ROUTINE IS CALLED TO TRACE CERTAIN KEYWORDS               16505000
*        INITIALLY A CHECK IS MADE TO DETERMINE IS TRACE NECESSARY      16506000
*                                                                       16507000
*        CONDITIONS ON ENTRY                                            16508000
*        (R1)                     CONTAINS ADDRESS OF TRBLOK IF 4 ARGS  16509000
*                                 NEGATIVE - NO FUNCTION ADDRESS GIVEN  16510000
*                                 ZERO - UNTRACED KEYWORD               16511000
*        BAL   DB2,KEYTRACE       STANDARD KEYTRACE CALL                16512000
*        DC    Y(NAME OFFSET,360 LENGTH)                                16513000
*        (INSTRUCTION TO BE EXECUTED TO LOAD KEYWORD VALUE)             16514000
*                                                                       16515000
KEYTRACE L     A2,V$TRACE         PICK UP VALUE OF &TRACE TO TEST/DEC   16516000
         SH    A2,H1              TEST AND DECREMENT SWITCH VALUE       16517000
         BM    8(,DB2)            SKIP ALL TRACES IF NOT SET            16518000
         LTR   R1,R1              CHECK FOR SPECIFIC TRACE ON KEYWORD   16519000
         BZ    8(,DB2)            EXIT IF NOT TRACED                    16520000
         LA    A2+1,4(,DB2)       SET UP EXIT ADDRESS FOR POTENTIAL     16521000
*                                 PROG DEF TRACE PROCEDURE              16522000
         BP    PDTRCL             INVOKE PROCEDURE IF REQUESTED         16523000
         ST    A2,V$TRACE         ELSE SAVE UPDATED &TRACE VALUE        16524000
         ST    RETURN,RETLOC      SAVE RETURN ADDR, MAY BE USED FOR STN 16525000
         BAL   A2,FTRCINIT        INITIALIZE TRACE                      16526000
         MVI   0(DB3),C'&&'       SET UP INITIAL & ON TRACE LINE        16527000
         LA    DB3,1(,DB3)        AND BUMP PAST IT                      16528000
         L     A1,INITVPTR        LOAD POINTER FOR INITV NAMES          16529000
         AH    A1,0(,DB2)         ADD IN KEYWORD NAME OFFSET            16530000
         LH    A1+1,2(,DB2)       LOAD LENGTH OF KEYWORD NAME           16531000
         BAL   RETURN,LINESTR     ADD KEYWORD NAME TO TRACE LINE        16532000
         MVC   0(3,DB3),DMPBEB    ADD C' = '                            16533000
         LA    DB3,3(,DB3)        SKIP OVER IT                          16534000
         EX    0,4(,DB2)          LOAD KEYWORD VALUE IN A1+1            16535000
         SR    A1,A1              INDICATE INTEGER VALUE                16536000
         BAL   A2,LINEVAL         PUT VALUE ON TRACE LINE               16537000
         BALR  A2,LINE$           AND OUTPUT THE LINE                   16538000
         L     RETURN,RETLOC      RESTORE RETURN VALUE                  16539000
         B     8(,DB2)            AND RETURN TO CALLER                  16540000
         EJECT                                                          16541000
*                                                                       16542000
*        THE FOLLOWING SUBROUTINE IS USED TO CHECK FOR AND PERFORM      16543000
*        A PROGRAM DEFINED TRACE FUNCTION --                            16544000
*                                                                       16545000
*        (R1)                     POINTS TO HEAD OF CHAIN OF TRBLOK'S   16546000
*        (DB2)                    PTR TO VARIABLE BLOCK (WITH MCODE)    16547000
*        BAL   A2+1,PDTRC1                                              16548000
*        -->   RETURN HERE IF THERE IS NO BLOCK ON THE CHAIN            16549000
*        -->   RETURN HERE AFTER FINDING BLOCK AND PERFORMING TRACE     16550000
*                                                                       16551000
PDTRC1   L     R1,TRCLINK(,R1)    MOVE OUT ON LINK OF BLOCKS            16552000
         LTR   R1,R1              TEST FOR END OF CHAIN                 16553000
         BCR   Z,A2+1             'NO TRACE' RETURN IF NAME NOT ON LIST 16554000
         C     DB2,TRVBLK(,R1)    DOES THIS TRC BLOCK REFER TO OUR VAR? 16555000
         BNE   PDTRC1             LOOP BACK TO TEST MORE IF NOT         16556000
*                                                                       16557000
*        CALL THIS POINT WITH (R1) POINTING TO LOCATED TRBLOK           16558000
*                                                                       16559000
PDTRCL   SH    PDR,=Y(STACKSIZ)   BUMP STACK FOR STANDARD STUFF         16560000
         L     R0,PDRLOC          LOAD PREVIOUD LEVEL                   16561000
         ST    R0,PDRBPTR(,PDR)   SET BACK POINTER ON STACK             16562000
         ST    PDR,PDRLOC         SET CURRENT LEVEL                     16563000
         ST    A2+1,TRLINK(,PDR)  SAVE OUR LINKAGE                      16564000
         ST    A2,TRVTRC(,PDR)    SAVE VALUE OF &TRACE                  16565000
         STE   ZR,V$TRACE         TURN OFF &TRACE TO AVOID INF LOOP     16566000
         STM   FRETURN,RETURN,FRETFLOC(PDR) SAVE RETURN POINTERS        16567000
         LM    A1,A2+1,TRTAG(R1)  LOAD TAG,NAME & FUNC ADDRESS          16568000
         ST    A2,TRVBLOCK(,PDR)  SAVE ON STACK FOR RESTORE AFTER CALL  16569000
         L     A2+1,VFUNC(,A2+1)  LOAD FUNCTION ADDRESS FROM VAR BLOCK  16570000
         ST    A2+1,FBLOKLOC(,PDR)          PUT FUNC ADDR ON STACK      16571000
         STE   ZR,PNAME(,PDR)     INDICATE PNAME NOT IN USE FOR COLLECT 16572000
         SR    A2+1,A2+1          CLEAR OUT POSSIBL NAME OFFSET         16573000
         STM   A1,A2+1,TEM#2(PDR) STORE NAME/TAG AS ARGUMENTS           16574000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           16575000
         LA    FRETURN,PDTRET     SAVE US FROM FRETURN                  16576000
*                                                                       16577000
*        NOTE THAT THE FOLLOWING CODE MUST BE STANDARD FUNC CALL CODE   16578000
*                                                                       16579000
         LA    R0,2               WE HAVE TWO ARGUMENTS                 16580000
         L     DB4,FBLOKLOC(,PDR) LOAD FUNCTION ADDRESS                 16581000
         BAL   RETURN,FCODE(,DB4) CALL THE FUNCTION                     16582000
PDTRET   EQU   *                  BOTH SUCCESS AND FAILURE RETURN HERE  16583000
         L     DB4,=A(DTERTNS)    RESTORE OUR BASE REGISTER             16584000
         L     R0,TRVTRC(,PDR)    LOAD UPDATED &TRACE VALUE FROM STK    16585000
         ST    R0,V$TRACE         AND STORE IN PROPER PLACE             16586000
         L     A2+1,TRLINK(,PDR)  RESTORE CALLER'S ADDRESS              16587000
         L     DB2,TRVBLOCK(,PDR) RETURN VARIABLE BLOCK ADDR IN DB2     16588000
         LM    FRETURN,RETURN,FRETFLOC(PDR) RESTORE CODE ADDRESSES      16589000
         LA    PDR,STACKSIZ(,PDR) RESTORE PROPER PDR LOCATION           16590000
         ST    PDR,PDRLOC         RESET CURRENT LOCATION                16591000
         B     4(,A2+1)           AND GIVE SUCCESS RETURN               16592000
         AUR   SCNT,SINC          DUMMY FOR CALCSTNO                    16593000
         B     CALCPDTF           BRANCH TO PROPER ROUTINE              16594000
         EJECT                                                          16595000
*                                                                       16596000
*        CALCSTNO -- CALCULATE STATEMENT NUMBER                         16597000
*                                                                       16598000
*        ALTLOC OR RETLOC         CODE LOCATION                         16599000
*        BAL   A2,CALCSTNO                                              16600000
*        (A1,A1+1)                INTEGER VALUE OF STATEMENT NUMBER     16601000
*        NOTE -- THIS ROUTINE MUST NOT USE R1                           16602000
*                                                                       16603000
*        EVERY FEW STATEMENTS, THE GENERATED CODE CONTAINS A NOP        16604000
*        INSTRUCTION WHOSE THIRD AND FOURTH BYTES CONTAIN THE CURRENT   16605000
*        STATEMENT NUMBER. NORMALLY, THIS NOP INSTRUCTION IMMEDIATELY   16606000
*        FOLLOWS THE AUR AT THE START OF THE STATEMENT. THE EXCEPTION   16607000
*        TO THIS RULE OCCURS IN CODE GENERATED AT EXECUTION TIME WHERE  16608000
*        ANOTHER NOP INSTRUCTION (CONTAINING AN OFFSET TO THE START     16609000
*        OF THE CODE BLOCK) PRECEDES THE STATEMENT NUMBER NOP.          16610000
*        IN CERTAIN CASES (E.G. TRACE FUNCTION CALLS), THE CODE ADDR IS 16611000
*        WRONG. IN THESE CASES, THE CALL POINT IS FOLLOWED BY A DUMMY   16612000
*        AUR FOLLOWED BY A BRANCH TO A SPECIAL ROUTINE WHICH LOCATES    16613000
*        THE REAL CODE LOCATION AND MERGES BACK.                        16614000
*                                                                       16615000
*        ANOTHER SPECIAL CASE ARISES FROM EXECUTION OF EXPRESSION       16616000
*        CODE. THIS IS RECOGNIZED BY THE TERMINATING B $$EVLR INSTRUC   16617000
*                                                                       16618000
CALCSTNO LR    R0,PDR             SAVE ENTRY VALUE OF PDR               16619000
         L     A1,ALTLOC          LOAD ALTERNATE CODE LOCATION          16620000
         LTR   A1,A1              IS ONE IN USE?                        16621000
         BNZ   *+8                SKIP IF ONE IS IN USE                 16622000
         L     A1,RETLOC          ELSE LOAD STANDARD LOCATION           16623000
         SR    A1+1,A1+1          INITIALIZE STATEMENT NUMBER = 0       16624000
*                                                                       16625000
*        LOOP TO FIND AUR INSTRUCTIONS                                  16626000
*                                                                       16627000
         BALR  R2,0               SET START OF LOOP ADDRESS             16628000
         CLI   0(A1),X'47'        BRANCH INSTRUCTION?                   16629000
         BE    CALCSTEX           JUMP TO TEST FOR END OF EXPR IF SO    16630000
         CLI   0(A1),X'3E'        IS THIS AN AUR INSTRUCTION?           16631000
*                                                                       16632000
*        MERGE BACK HERE FOR X'47' OPCODE NOT B $$EVLR                  16633000
*                                                                       16634000
CALCSTMM LA    A1,2(,A1)          PUSH CODE POINTER                     16635000
         BCR   NE,R2              LOOP BACK IF NOT AN AUR INSTRUCTION   16636000
*                                                                       16637000
*        COME HERE WHEN WE HAVE FOUND AN AUR INSTRUCTION                16638000
*                                                                       16639000
         BCTR  A1+1,0             COUNT DOWN STATEMENT NUMBER           16640000
         CLI   0(A1),X'47'        FOLLOWED BY NOP INSTRUCTION?          16641000
         BCR   NE,R2              LOOP BACK IF NOT                      16642000
         CLI   4(A1),X'47'        TWO NOPS PRESENT (CODE CODE)?         16643000
         BNE   *+8                SKIP IF NOT                           16644000
         LA    A1,4(,A1)          ELSE POINT TO THE NOP WE WANT         16645000
         EX    0,0(,A1)           EXECUTE POSSIBLE SPECIAL BRANCH       16646000
         AH    A1+1,2(,A1)        ELSE COMPUTE PROPER STATEMENT NUMBER  16647000
         SR    A1,A1              SET INTEGER TYPE CODE                 16648000
         LR    PDR,R0             RESTORE ENTRY VALUE OF PDR            16649000
         BR    A2                 RETURN TO CALLER                      16650000
         EJECT                                                          16651000
*                                                                       16652000
*        CALCSTNO -- CONTINUED                                          16653000
*                                                                       16654000
*        WE COME HERE IF A X'47' (BRANCH) OPCODE IS DETECTED            16655000
*                                                                       16656000
*        THERE ARE THREE POSSIBLE CASES:                                16657000
*                                                                       16658000
*        1)    THE B $$EVLR INSTRUCTION WHICH TERMINATES THE GENERATED  16659000
*              CODE FOR AN EXPRESSION. IN THIS CASE, THE SPECIAL        16660000
*              ROUTINE BELOW IS USED TO FIND THE 'REAL' CODE LOCATION.  16661000
*                                                                       16662000
*        2)    THE BRANCH USING INDEX REGISTER (2) WHICH BYPASSES       16663000
*              THE GENERATED CODE FOR AN EXPRESSION. IN THIS CASE, THE  16664000
*              SCAN LOCATION IS STEPPED PAST THE EXPRESSION CODE        16665000
*              AND THE CODE SCAN CONTINUES.                             16666000
*                                                                       16667000
*        3)    ANY OTHER BRANCH INSTRUCTION. IN THIS CASE, WE MERELY    16668000
*              CONTINUE THE CODE SCAN.                                  16669000
*                                                                       16670000
CALCSTEX CLI   1(A1),X'F2'        UNCOND BRANCH WITH XREG (2)?          16671000
         BNE   CALCSTX1           SKIP IF NOT                           16672000
*                                                                       16673000
*        HERE FOR BRANCH SKIPPING EXPRESSION CODE                       16674000
*                                                                       16675000
         AH    A1,2(,A1)          STEP PAST EXPRESSION CODE             16676000
         BR    R2                 JUMP BACK TO CONTINUE SCAN            16677000
*                                                                       16678000
*        HERE IF NOT B ON XREG (2)                                      16679000
*                                                                       16680000
CALCSTX1 CLC   0(4,A1),BEVLR1     IS IT B $$EVLR?                       16681000
         BNE   CALCSTMM           MERGE BACK IF NOT TO CONTINUE SCAN    16682000
*                                                                       16683000
*        HERE IF THE CODE POINTER POINTS TO THE TERMINATING BRANCH OF   16684000
*        AN UNEVALUATED EXPRESSION. THERE ARE SOME SITUATIONS IN WHICH  16685000
*        THE STACK IS PUSHED PAST THE UNEVALUATED EXPRESSION LEVEL      16686000
*        (E.G. LABEL TRACE) AND THE STACK MUST BE POPPED AN EXTRA TIME  16687000
*                                                                       16688000
         CE    ZR,FBLOKLOC(,PDR)  ARE WE DOWN TO THE PROPER LEVEL?      16689000
         BNZ   CALCPDTF           IF NOT, JUMP TO POP STACK EXTRA TIME  16690000
         SR    A1+1,A1+1          ELSE RESET STATEMENT NUMBER           16691000
         L     A1,RETFLOC(,PDR)   GET CODELOC IN CASE EVAL CALL         16692000
         TM    EVLINK(PDR),X'30'  CHECK CASES (PATTERN MATCH / EVAL)    16693000
         L     PDR,PDRBPTR(,PDR)  POP STACK TO PREVIOUS LEVEL           16694000
         BCR   NZ,R2              LOOP BACK (ALL SET) IF EVAL CASE      16695000
         L     A1,RETLOCP(,PDR)   ELSE LOAD PATTERN MATCH CODE LOC      16696000
         BR    R2                 AND LOOP BACK                         16697000
*                                                                       16698000
*        SPECIAL CALCSTNO ROUTINE FOR PROGRAM TRACE FUNCTION CALL       16699000
*        ALSO USED TO POP BACK TO AN EXPRESSION LEVEL (SEE ABOVE)       16700000
*                                                                       16701000
CALCPDTF SR    A1+1,A1+1          RESET STATEMENT NUMBER COUNT          16702000
         L     A1,RETFLOC(,PDR)   LOAD ADDR OF CALLING CODE             16703000
         L     PDR,PDRBPTR(,PDR)  BACK UP TO NEXT LEVEL ON PDR          16704000
         BR    R2                 JUMP BACK TO MAIN SEARCH LOOP         16705000
         EJECT                                                          16706000
*                                                                       16707000
*        THIS ROUTINE IS ENTERED FROM THE PROGRAM CHECK HANDLER         16708000
*        IF AN EXPONENT OVERFLOW OCCURS AS THE RESULT OF AN AUR         16709000
*        WHICH INCREMENTS THE STATEMENT COUNT REGISTER (SCNT)           16710000
*                                                                       16711000
*        THIS SITUATION CAN BE THE RESULT OF STLIMIT GREATER THAN       16712000
*        2**24, STCOUNT TRACING, A GENUINE STATEMENT COUNT (&STCOUNT)   16713000
*        OVERFLOW, OR IT CAN BE THE RESULT OF A TIMER OVERFLOW WHICH    16714000
*        IS SIGNALLED BY CAUSING A DUMMY STATEMENT COUNT OVERFLOW       16715000
*                                                                       16716000
STMOVER  L     DB4,=A(DTERTNS)    LOAD OUR BASE REGISTER                16717000
         STE   ZR,SCNTSAVE        STOP BAD PATTERN OPTIMIZATIONS ON     16718000
*                                 RETURN TO USER CODE                   16719000
*                                                                       16720000
*        NOW DISTINGUISH BETWEEN REAL OVERFLOW AND TIMER OVERFLOW       16721000
*                                                                       16722000
         TM    STAGE,$OVERTIM     IS TIMER OVERFLOW FLAG SET?           16723000
         BO    $$TIME             OFF TO GIVE ERR MSG IF OVERTIME       16724000
*                                                                       16725000
*        COME HERE FOR STATEMENT COUNT OVERFLOW                         16726000
*                                                                       16727000
         LE    SCNT,SPINMX        LOAD MAXIMUM SCNT VALUE               16728000
         L     R1,STCNTTRC        LOAD TRACE WORD FOR STCOUNT TRACE     16729000
         LTR   R1,R1              ARE WE BEING TRACED?                  16730000
         BZ    AUROVER            NO TRACE IF SET TO ZERO               16731000
         L     R2,V$STCNT         ELSE LOAD AMOUNT COUNTED THUS FAR     16732000
         AH    R2,H1              INCREMENT IT                          16733000
         C     R2,V$STLIM         HAVE WE EXCEEDED THE STATEMENT LIMIT? 16734000
         BH    AUROVER1           OFF TO GIVE ERROR MESSAGE IF SO       16735000
         ST    R2,V$STCNT         ELSE STORE UPDATED STCOUNT            16736000
         ST    RETURN,$$LAST      SAVE RETURN IN CASE LASTNO REFERENCE  16737000
         L     RETURN,SYSPSW+4    MAKE SURE AUR LOC IS RELOCATED        16738000
         BAL   DB2,KEYTRACE       PERFORM PROPER TRACE ACTION           16739000
         DC    Y(E$STCOUN-INITVR1,7-1)      STCOUNT OFFSET, LENGTH      16740000
         L     A1+1,V$STCNT       LOAD FOR TRACE ACCESS                 16741000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           16742000
*                                                                       16743000
*        NOW WE CAN RETURN TO THE CODE, NOTE THAT FRETURN IS PRESERVED  16744000
*                                                                       16745000
         LR    R1,RETURN          COPY LOCATION AFTER AUR               16746000
         L     RETURN,$$LAST      RESTORE RETURN FOR &LASTNO REF        16747000
         BR    R1                 JUMP TO CODE                          16748000
         EJECT                                                          16749000
*                                                                       16750000
*        COME HERE ON STATEMENT COUNT OVERFLOW WHEN STCOUNT IS          16751000
*        NOT BEING TRACED.                                              16752000
*                                                                       16753000
AUROVER  SU    SCNT,STSTART       CALCULATE HOW MANY STMTS EXECUTED     16754000
         STE   SCNT,STSTART       USE STSTART TO SAVE RESULT TEMP       16755000
         L     R2,STSTART         LOAD INTO GENERAL REGISTER            16756000
         LA    R2,0(,R2)          GET RID OF X'7F' EXPONENT             16757000
         A     R2,V$STCNT         ADD IN PREVIOUSLY COUNTED STMTS       16758000
         ST    R2,V$STCNT         SAVE NO. OF STMTS EXECUTED            16759000
         L     R1,SYSPSW+4        EXIT LOCATION = AUR ADDRESS           16760000
         S     R2,V$STLIM         GET NEGATIVE OF STMTS LEFT            16761000
         LCR   R2,R2              GET NO. STMTS LEFT TO EXECUTE         16762000
         BP    AUROVER2           SKIP IF WE HAVEN'T OVERFLOWED         16763000
*                                                                       16764000
*        COME HERE ON GENUINE STLIMIT OVERFLOW                          16765000
*        WE WILL ALLOW 10 MORE STATEMENTS IN CASE OF SETEXIT            16766000
*                                                                       16767000
AUROVER1 LA    R2,10              ALLOW TEN MORE STATEMENTS             16768000
         L     R0,V$STLIM         LOAD STLIM TO FIX IT UP               16769000
         AR    R0,R2              INCREMENT IT BY TEN                   16770000
         ST    R0,V$STLIM         AND STORE UPDATED VALUE               16771000
         MVC   RETLOC,SYSPSW+4    SAVE ERROR LOCATION FOR ERROR MSG     16772000
         LA    R1,AURERROR+2      LOAD PSEUDO EXIT ADDRESS=XERR CALL    16773000
*                                                                       16774000
*        COME HERE WITH NUMBER OF STATEMENTS LEFT TO EXECUTE IN R2      16775000
*                                                                       16776000
AUROVER2 LER   SCNT,SINC          START WITH 1 IF STILL TOO BIG         16777000
         C     R2,=X'00FFFFFF'    WILL WE FIT IN ONE SETTING            16778000
*                                 NOTE THAT WE CAN'T SET SCNT TO ZERO   16779000
         BNL   AUROVER3           SKIP IF TOO BIG FOR ONE SETTING       16780000
         LE    SCNT,SPINMX        LOAD MAXIMUM SCNT VALUE               16781000
         ST    R2,STSTART         USE STSTART AS TEMPORARY              16782000
         MVI   STSTART,X'7F'      SET UP EXPONENT                       16783000
         SU    SCNT,STSTART       AND SET UP SCNT VALUE                 16784000
*                                                                       16785000
*        COME HERE WITH SCNT SET UP TO RE-ENTER CODE                    16786000
*        AT THE ADDRESS IN (R1) MINUS TWO                               16787000
*                                                                       16788000
AUROVER3 STE   SCNT,STSTART       SAVE NEW INITIAL SCNT VALUE           16789000
         SH    R1,H2              BACK OFF TWO BYTES                    16790000
         BR    R1                 OFF TO CODE                           16791000
         EJECT                                                          16792000
*                                                                       16793000
*        TRANSFER IS MADE TO THIS ERROR MESSAGE ON STCOUNT OVERFLOW     16794000
*                                                                       16795000
AURERROR L     FRETURN,SYSPSW+4   LOAD ADDRESS OF AUR INSTRUC + 2       16796000
         SH    FRETURN,H2         POINT TO AUR TO REEXECUTE ON CONTINUE 16797000
         XERR  11,006             STATEMENT LIMIT (&STLIMIT) EXCEEDED   16798000
*                                                                       16799000
*        COME HERE ON TRANSFER TO THE LABEL CONTINUE                    16800000
*                                                                       16801000
L$CONTIN LM    FRETURN,RETURN,SETXTFRT      RESTORE TO/FROM REGISTERS   16802000
         STE   ZR,SETXTFRT        CLEAR TO SIGNAL ERROR PROCESSED       16803000
         TM    STAGE,$OVERTIM     CHECK OVERTIME IN CONTINUE LOOP       16804000
         BO    $$TIME             OFF TO SIGNAL IF OVERTIME             16805000
         LTR   FRETURN,FRETURN    TEST FOR PREVIOUSLY ISSUED ERROR      16806000
         BCR   NZ,FRETURN         FAIL IF ONE HAS BEEN ISSUED           16807000
         XERR  08,003,S           A TRANSFER TO THE LABEL CONTINUE      16808000
*                                 OCCURED, BUT NO PREVIOUS ERROR HAD    16809000
*                                 BEEN INTERCEPTED                      16810000
*                                                                       16811000
*        COME HERE ON A TRANSFER TO THE LABEL ABORT                     16812000
*                                                                       16813000
L$ABORT  L     DB4,=A(DTERTNS)    SET PROPER BASE REGISTER              16814000
         ST    RETURN,RETLOC      SAVE IN CASE OF NO PREVIOUS ERROR     16815000
         L     RETURN,SETXTRET    RESTORE ADDRESS OF STATEMENT IN ERR   16816000
         CE    ZR,V$ERRTYP        CHECK FOR PREVIOUS ERROR MESSAGE      16817000
         BNE   EXERRCS            IF ERR MSG STORE RETURN AND PRT ERROR 16818000
         XERR  08,004             A TRANSFER TO ABORT OCCURED, BUT NO   16819000
*                                 PREVIOUS ERROR HAD BEEN INTERCEPTED   16820000
*                                                                       16821000
*        COME HERE WHEN AN EXECUTION ERROR IS SIGNALLED                 16822000
*                                                                       16823000
EXERR    LR    R1,RETURN          COPY CALL POINTER                     16824000
         BCTR  R1,0               BACK OFF ONE BYTE                     16825000
         CLI   0(R1),RETURN*16+SYS          CASE OF BALR RETURN,SYS?    16826000
         BE    EXERRCC            SKIP IF NORMAL ERROR CALL             16827000
*                                                                       16828000
*        COME HERE WHEN WE EXECUTE THE BR FRETURN WITH FRETURN SET TO   16829000
*        SYS WHICH OCCURS WHEN A STATEMENT HAVING NO S OR F GOTO FAILS  16830000
*        AND THE -NOFAIL OPTION WAS IN EFFECT                           16831000
*                                                                       16832000
         XERR  02,001,S           FAILURE OF STATEMENT HAVING NO        16833000
*                                 CONDITIONAL GOTO WITH -NOFAIL         16834000
*                                 OPTION IN EFFECT                      16835000
         EJECT                                                          16836000
*                                                                       16837000
*        COME HERE FOR NORMAL ERROR PROCESSING                          16838000
*                                                                       16839000
EXERRCC  SDR   ZR,ZR              FP ARITHMETIC MAY LEAVE GARBAGE IN ZR 16840000
         CLI   1(R1),6            CHECK FOR MEMORY OVERFLOW             16841000
         BE    *+10               IF SO, FATAL EVEN IF DURING CON EXPR  16842000
         LTER  SINC,SINC          ARE WE EVALUATING A CONSTANT EXPR?    16843000
         BZ    EXERRCN            SKIP (SPECIAL CASE) IF SO             16844000
         IC    A2+1,1(,R1)        PICK UP MAJOR ERROR CODE              16845000
         LA    A2,X'7F'           GET MASK VALUE (ALSO CLEAR FOR IC)    16846000
         NR    A2+1,A2            MASK OFF SPECIAL CONSTANT CODE BIT    16847000
         IC    A2,2(,R1)          PICK UP MINOR ERROR CODE              16848000
         MH    A2+1,=H'1000'      MAJOR CODE*1000                       16849000
         AR    A2+1,A2            MAJOR CODE*1000 + MINOR CODE          16850000
         ST    A2+1,V$ERRTYP      SAVE FOR SETXIT USE, ETC.             16851000
*                                                                       16852000
*        MERGE HERE FROM KEYWORD CIRCUIT ON SETTING &ERRTYPE NON-ZERO   16853000
*                                                                       16854000
EXERRCM  L     R0,V$ERRLIM        LOAD LIMIT ON NUMBER OF ERRORS        16855000
         SH    R0,H1              DECREMENT IT FOR THIS ERROR           16856000
         BM    EXERRC             JUMP IF NO MORE ERRORS PERMITTED      16857000
*                                                                       16858000
*        HERE IF EXECUTION IS TO CONTINUE AFTER THE ERROR               16859000
*                                                                       16860000
         ST    R0,V$ERRLIM        SAVE NEW ERROR LIMIT                  16861000
         MVI   ZTBL+C',',0        CLEAR POSSIBLE COMMA ENTRY            16862000
         MVI   ZTBL+C'(',0        CLEAR POSSIBLE LEFT PARENTHESIS ENTRY 16863000
         MVI   ZTBL+C')',0        CLEAR POSSIBLE RIGHT PAREN ENTRY      16864000
         MVI   ZTBL+C':',0        CLEAR POSSIBLE COLON ENTRY            16865000
         CE    ZR,FRETLOC         HAS FRETURN BEEN STORED?              16866000
         BE    *+8                SKIP IF NOT                           16867000
         L     FRETURN,FRETLOC    ELSE LOAD PROPER FRETURN VALUE        16868000
         L     RETURN,ALTLOC      LOAD POSSIBLE ALTERNATE CODE LOC      16869000
         LTR   RETURN,RETURN      IS IT CORRECT?                        16870000
         BNZ   *+8                SKIP IF WE ARE TO USE ALTERNATE LOC   16871000
         L     RETURN,RETLOC      ELSE LOAD STANDARD CODE LOC           16872000
         STE   ZR,FRETLOC         CLEAR POSSIBLE ALTERNATE FRETURN LOC  16873000
         STE   ZR,ALTLOC          CLEAR POSSIBLE ALTERNATE RETLOC       16874000
         L     PDR,PDRLOC         RESTORE PROPER PDR LOCATION           16875000
         L     R1,ETYPTRC         LOAD TRACE INFO FOR &ERRTYPE          16876000
         BAL   DB2,KEYTRACE       CALL KEYWORD TRACE ROUTINE            16877000
         DC    Y(E$ERRTYP-INITVR1,7-1)      ERRTYPE OFFSET, 360 LENGTH  16878000
         L     A1+1,V$ERRTYP      INSTRUCTION TO LOAD &ERRTYPE VALUE    16879000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           16880000
         L     R2,EXITLOC         LOAD POSSIBLE SETEXIT ADDRESS         16881000
         STE   ZR,EXITLOC         DO NOT PERMIT ANOTHER INTERRUPT       16882000
         STM   FRETURN,RETURN,SETXTFRT      SAVE STATEMENT ADDRESSES    16883000
*                                 FOR ABORT AND CONTINUE                16884000
         LTR   R2,R2              DO WE HAVE A SETEXIT ADDRESS?         16885000
         BZ    L$CONTIN           DO AN AUTOMATIC CONTINUE IF NOT       16886000
         L     R1,VLABL(,R2)      LOAD LABEL TO TRANSFER TO             16887000
         BR    R1                 OFF TO IT LEAVING RETURN -> OLD STMNT 16888000
         EJECT                                                          16889000
*                                                                       16890000
*        EXECUTION ERROR MESSAGE ROUTINE                                16891000
*                                                                       16892000
*        ENTRY TO SAVE RETURN IN RETLOC (SEE ABORT)                     16893000
*                                                                       16894000
EXERRCS  ST    RETURN,RETLOC      SAVE RETURN LOCATION                  16895000
*                                                                       16896000
*        RETLOC                   CODE LOCATION                         16897000
*        (R1)                     POINTS TO TWO BYTE MESG NUMBER        16898000
*                                                                       16899000
EXERRC   BAL   A2,CALCSTNO        GET STATEMENT NUMBER OF ERROR         16900000
         BAL   FRETURN,PRMSG      PRINT MESSAGE                         16901000
         DC    AL2(30-1)          MESSAGE LENGTH + EDIT PATTERN FLAG    16902000
         DC    CL30'1EXECUTION ERROR IN STATEMENT '                     16903000
         BALR  A2,LINE$           PRINT A BLANK LINE                    16904000
*                                                                       16905000
*        NOW COMPUTE AND CONVERT ERROR CODE                             16906000
*                                                                       16907000
         L     FRETURN,V$ERRTYP   LOAD ERROR MESSAGE CODE               16908000
         SR    R0,R0              CLEAR FOR DIVIDE                      16909000
         LR    R1,FRETURN         COPY ERROR CODE FOR DIVIDE            16910000
         D     R0,=F'1000'        DIVIDE TO GET MAJOR CODE (/500!)     16911000
         LA    DB2,15*2           LOAD DEFAULT OFFSET TO ERR MSG        16912000
         AR    R1,R1              GET PROPOSED OFFSET TO ERROR MESSAGE  16913000
         BZ    EXERRC1            EXIT WITH DEFAULT IF NEW=0            16914000
         CR    R1,DB2             CHECK FOR MAJOR CODE OUT OF RANGE     16915000
         BNL   EXERRC1            EXIT WITH DEFAULT IF NOT IN RANGE     16916000
         LR    DB2,R1             ELSE USE ACTUAL ERROR CODE            16917000
*                                                                       16918000
*        NOW PRINT MESSAGE ITSELF                                       16919000
*                                                                       16920000
EXERRC1  LH    A1,EXERMA-2(DB2)   PICK UP MESSAGE OFFSET                16921000
         LA    A1,EXMSGS(A1)      POINT TO COUNT AND MESSAGE            16922000
         SR    A1+1,A1+1          CLEAR FOR IC                          16923000
         IC    A1+1,0(,A1)        LOAD COUNT                            16924000
         EX    A1+1,EXMSMV        MOVE MESSAGE INTO PLACE               16925000
         LA    DB3,1(A1+1,DB3)    BUMP OVER MESSAGE                     16926000
         BALR  A2,LINE$           PRINT LINE                            16927000
*                                                                       16928000
*        NOW PRINT CODE NUMBER (SAVED IN FRETURN)                       16929000
*                                                                       16930000
         LR    A1+1,FRETURN       COPY CODE FOR PRMSG                   16931000
         BAL   FRETURN,PRMSG      PRINT MESSAGE                         16932000
         DC    AL2(0-11)          MESSAGE LENGTH + EDIT PATTERN FLAG    16933000
         DC    CL12'0ERROR CODE '                                       16934000
         B     XEQSTAT            JUMP TO PRINT EXECUTION STATISTICS    16935000
*                                                                       16936000
EXMSMV   MVC   0(*-*,DB3),1(A1)   MOVE ERROR MESSAGE TO BUFFER          16937000
         EJECT                                                          16938000
*        EXECUTION ERROR MESSAGES                                       16939000
*        EACH MESSAGE IS GIVEN THE NAME XERRNN WHERE NN IS THE MSG NUMB 16940000
*        THE FIRST BYTE IS THE LENGTH - 1, THE REST IS THE MESSAGE      16941000
*                                                                       16942000
EXMSGS   EQU   *                  TABLE OF EXECUTION ERROR MESSAGES     16943000
1        XERM  'ILLEGAL DATATYPE'                                       16944000
2        XERM  'UNEXPECTED FAILURE'                                     16945000
3        XERM  'ERROR IN ARRAY REFERENCE'                               16946000
4        XERM  'COMPILER DETECTED ERROR'                                16947000
5        XERM  'ERROR IN KEYWORD REFERENCE'                             16948000
6        XERM  'MEMORY OVERFLOW'                                        16949000
7        XERM  'EVALUATION OF GOTO FAILED'                              16950000
8        XERM  'ERROR IN GOTO'                                          16951000
9        XERM  'CALL TO UNDEFINED FUNCTION OR OPERATOR'                 16952000
10       XERM  'ERROR IN ARITHMETIC OPERATION'                          16953000
11       XERM  'KEYWORD OR SYSTEM LIMIT EXCEEDED'                       16954000
12       XERM  'INPUT/OUTPUT OR OTHER SYSTEM ERROR'                     16955000
13       XERM  'INCORRECT VALUE FOR OPERATOR OR FUNCTION'               16956000
14       XERM  'VALUE RETURNED WHERE NAME IS REQUIRED'                  16957000
15       XERM  'USER ISSUED ERROR MESSAGE'                              16958000
*                                                                       16959000
*        THE XETB MACRO SETS UP A TABLE OF OFFSETS TO ERROR MESSAGES    16960000
*        THIS TABLE IS GIVEN THE ADDRESS EXERMA                         16961000
*                                                                       16962000
         XETB                                                           16963000
         EJECT                                                          16964000
*                                                                       16965000
*        COME HERE IF AN ERROR OCCURS DURING EVALUATION OF A CONSTANT   16966000
*        EXPRESSION. IN THIS CASE, WE DO NOT WANT TO SIGNAL THE ERROR   16967000
*        AT THIS TIME, BUT RATHER WHEN THE CONSTANT EXPRESSION IS USED. 16968000
*                                                                       16969000
*        TO ACHIEVE THIS END, WE SEARCH AHEAD IN THE CONSTANT EXPR      16970000
*        CODE FOR THE AUR TERMINATING THIS EXPRESSION. JUST BEFORE IS   16971000
*        THE STM INTO THE CONSTANT EXPRESSION BLOCK. THUS WE CAN LOCATE 16972000
*        THIS BLOCK. THE SECOND WORD OF THE BLOCK CONTAINS A POINTER    16973000
*        TO THE CORRESPONDING LOAD SEQUENCE IN THE MAIN CODE. WE        16974000
*        THEN OVERWRITE THIS WITH AN APPROPRIATE XERR CALL.             16975000
*                                                                       16976000
*        (R1)                     POINTS 1 BYTE BEHIND XERR PARAMETERS  16977000
*        RETLOC                   CONTAINS LOC IN EXPR CODE             16978000
*                                                                       16979000
EXERRCN  L     RETURN,ALTLOC      RELOAD POSSIBLE CODELOC               16980000
         LTR   RETURN,RETURN      ALTERNATE LOCATION IN USE?            16981000
         BNZ   EXERRCNL           JUMP IF SO                            16982000
         L     RETURN,RETLOC      ELSE CODELOC IS IN STANDARD LOCATION  16983000
*                                                                       16984000
*        LOOP TO SEARCH FOR AUR AT END OF EXPRESSION                    16985000
*                                                                       16986000
EXERRCNL BALR  R2,0               SET START OF LOOP ADDRESS             16987000
         CLI   0(RETURN),X'3E'    AUR INSTRUCTION?                      16988000
         LA    RETURN,2(,RETURN)  BUMP CODE POINTER ANYWAY              16989000
         BCR   NE,R2              LOOP BACK IF NOT AUR                  16990000
*                                                                       16991000
*        HERE WE HAVE FOUND THE AUR INSTRUCTION                         16992000
*                                                                       16993000
         SH    RETURN,H10         BACK OFF TO ADDRESS STM               16994000
         MVI   4(RETURN),X'41'    CHANGE LM A1,A1+1,                    16995000
         MVI   5(RETURN),X'20'              INTO LA R2,                 16996000
         CLI   0(RETURN),X'58'    STM PRECEDED BY A LOAD INSTRUCTION?   16997000
         BNE   *+8                SKIP IF NOT                           16998000
         EX    0,0(,RETURN)       ELSE EXECUTE POSSIBLE LOAD OF DB4     16999000
         LM    DB2,DB3,$$BAS2     MAKE SURE DATA BASE REGS ARE SET      17000000
         EX    0,4(,RETURN)       NOW EXECUTE THE LA TO GET BLK ADDRESS 17001000
         L     R2,4(,R2)          LOAD ADDR OF LOAD IN MAIN CODE        17002000
         MVC   0(2,R2),SYSERCOD   SET XERR OPCODE                       17003000
         MVC   2(2,R2),1(R1)      SET PROPER XERR PARAMETERS            17004000
         OI    2(R2),X'80'        SET FLAG TO ENSURE STORE OF RETURN    17005000
         L     PDR,PDRLOC         RESET PDR TO PROPER POINT IN CASE     17006000
         B     10(,RETURN)        AND GO COMPUTE NEXT EXPRESSION        17007000
         EJECT                                                          17008000
*                                                                       17009000
*        COME HERE ON A TRANSFER TO THE LABEL END                       17010000
*        NOTE THAT L$ SYMBOLS MUST BE IN SPITBOLX, SEE VARLOC           17011000
*                                                                       17012000
L$END    L     DB4,=A(DTERTNS)    SAME ACTION AS $$STOP FOR END TRANSFR 17013000
*                                                                       17014000
*        $$STOP MERGES HERE TO SAVE RETURN LOCATION FOR STNO DUMP       17015000
*                                                                       17016000
ENDLABEL ST    RETURN,ALTLOC      SAVE END STNO FOR POSSIBLE DUMP       17017000
         BAL   A2,CALCSTNO        GET NUMBER OF STATEMENT WE STOPPED IN 17018000
         BAL   FRETURN,PRMSG      PRINT MESSAGE                         17019000
         DC    AL2(31)            MESSAGE LENGTH AND EDIT PATTERN FLAG  17020000
         DC    CL32'1NORMAL TERMINATION IN STATEMENT'                   17021000
*                                                                       17022000
*        XEQSTAT                  PRINT EXECUTION STATISTICS            17023000
*                                                                       17024000
XEQSTAT  CE    ZR,ALTLOC          IS ALTLOC IN USE (= OK FOR DUMP)      17025000
         BNE   *+10               SKIP IF IN USE                        17026000
         MVC   ALTLOC,RETLOC      ELSE MOVE IN COPY OF RETLOC           17027000
*                                                                       17028000
*        PRINT NUMBER OF STATEMENTS EXECUTED                            17029000
*                                                                       17030000
         LTER  FA,SCNT            TEST AND COPY STATEMENT COUNTER REG   17031000
         BZ    *+8                SKIP SUBTRACT IF NO EXECUTION TRIED   17032000
         SU    FA,STSTART         SUBTRACT TO GET STATEMENT COUNT       17033000
         STE   FA,STOPSV          STORE COUNT                           17034000
         MVI   STOPSV,0           CLEAR EXPONENT                        17035000
         L     A1+1,STOPSV        LOAD TO GR                            17036000
         A     A1+1,V$STCNT       ADD IN STATEMENTS ALREADY COUNTED     17037000
         LR    DB2,A1+1           COPY FOR USE LATER (MSEC/STATEMENT)   17038000
         BAL   FRETURN,PRMSG      PRINT MESSAGE                         17039000
         DC    AL2(29)            LENGTH + EDIT PATTERN FLAG            17040000
         DC    CL30'0NUMBER OF STATEMENTS EXECUTED'                     17041000
*                                                                       17042000
*        PRINT EXECUTION TIME                                           17043000
*                                                                       17044000
         L     R2,VSYSTIME        LOAD ADDR OF SYSTEM TIMER ROUTINE     17045000
         BALR  R1,R2              CALL SYSTEM TIMER ROUTINE             17046000
         NOP   0                  NO ERROR POSSIBLE                     17047000
         S     R0,TIME            SUBTRACT TIME AT START OF EXECUTION   17048000
         LR    A1+1,R0            COPY FOR PRMSG                        17049000
         BAL   FRETURN,PRMSG      PRINT MESSAGE                         17050000
         DC    AL2(0-25)          LENGTH + EDIT PATTERN FLAG            17051000
         DC    CL26'0EXECUTION TIME (SECONDS)'                          17052000
*                                                                       17053000
*        PRINT MSEC/STATEMENT                                           17054000
*                                                                       17055000
         LTR   DB2,DB2            TEST FOR NO STATEMENTS EXECUTED       17056000
         BZ    XEQSTAT1           SKIP THIS PRINT IF SO                 17057000
         M     A1,=F'1000'        CONVERT XEQ TIME TO MICROSECS         17058000
         DR    A1,DB2             DIVIDE BY NUMBER OF STATEMENTS        17059000
         BAL   FRETURN,PRMSG      PRINT MESSAGE                         17060000
         DC    AL2(0-15)          LENGTH + EDIT PATTERN FLAG            17061000
         DC    CL16'0MSEC/STATEMENT'                                    17062000
         EJECT                                                          17063000
*                                                                       17064000
*        PRINT NUMBER OF STORAGE REGENERATIONS                          17065000
*                                                                       17066000
XEQSTAT1 ZAP   STOPSV(8),GCOLCNT  SIMULATE CVD FOR PRMSG                17067000
         BAL   FRETURN,PRMSG+4    MERGE INTO PRMSG PAST CVD             17068000
         DC    AL2(31)            LENGTH OF MESSAGE + EDIT PATTERN      17069000
         DC    CL32'0NUMBER OF STORAGE REGENERATIONS'                   17070000
*                                                                       17071000
*        NOW TEST FOR REQUESTED DUMP                                    17072000
*                                                                       17073000
         L     A1+1,V$DUMP        LOAD VALUE OF &DUMP                   17074000
         LTR   A1+1,A1+1          DUMP REQUESTED?                       17075000
         BZ    STOPRUN            SKIP IF NO DUMP REQUESTED             17076000
         L     DB4,=A(F$DUMP-FCODE)         POINT TO DUMP FUNCTION      17077000
         SR    A1,A1              SET INTEGER TYPE CODE                 17078000
         STM   A1,A1+1,TEM#1(PDR) SET ARGUMENT FOR DUMP FUNCTION        17079000
         BAL   RETURN,FCODE(,DB4) CALL DUMP (NOTE DB4 IS RESET IN DUMP) 17080000
*                                                                       17081000
*        HERE WE RETURN TO THE SYSTEM MONITOR                           17082000
*        WE RETURN NORMALLY OR BOMB DEPENDING ON SETTING OF &ABEND      17083000
*                                                                       17084000
STOPRUN  L     R0,V$CODE          LOAD VALUE OF &CODE (RETURN CODE)     17085000
         L     R2,=V(SYSEOJ)      GET ADDRESS OF EOJ ROUTINE            17086000
         CE    ZR,V$ABEND         SHOULD WE ABEND?                      17087000
         BCR   E,R2               NORMAL END IF &ABEND = 0              17088000
         L     R0,V$ABEND         ELSE LOAD VALUE OF &ABEND             17089000
         L     R2,=V(SYSABEND)    LOAD ABEND ROUTINE ADDRESS            17090000
         BR    R2                 AND OFF TO IT                         17091000
         EJECT                                                          17092000
*                                                                       17093000
*        PRMSG -- ROUTINE TO PRINT MESSAGE AT END OF EXECUTION          17094000
*                                                                       17095000
*        (A1+1)                   BINARY VALUE OF PARAMETER TO EDIT     17096000
*        BAL   FRETURN,PRMSG                                            17097000
*        DC    AL2(LENGTH)        LENGTH OF MESSAGE (360 LENGTH)        17098000
*        DC    C'......MESSAGE.......'                                  17099000
*        -->   NORMAL RETURN                                            17100000
*                                                                       17101000
*        IF LENGTH IS POSITIVE, THE ARGUMENT IS EDITED AS AN INTEGER    17102000
*        IF LENGTH IS NEGATIVE, THREE DECIMAL PLACES ARE GIVEN          17103000
*                                                                       17104000
PRMSG    CVD   A1+1,STOPSV        EDIT ARGUMENT                         17105000
         BAL   A2,LINEINIT        INITIALIZE BUFFER                     17106000
         BCTR  DB3,0              BACK OFF TO POINT TO CTL CHAR         17107000
         MVC   1(34,DB3),0(DB3)   BLANK BUFFER                          17108000
         LH    R1,0(,FRETURN)     LOAD MESSAGE LENGTH                   17109000
         MVC   34(9,DB3),EDITP1   SET INTEGER EDIT PATTERN IN CASE      17110000
         LTR   R1,R1              TEST LENGTH                           17111000
         BP    *+12               SKIP IF POSITIVE                      17112000
         LPR   R1,R1              ELSE MAKE POSITIVE                    17113000
         MVC   33(10,DB3),EDITP2  SET EDIT PATTERN FOR 3 DEC PLACES     17114000
         EX    R1,PRMSGM          MOVE MESSAGE                          17115000
         ED    32(11,DB3),STOPSV+3          EDIT NINE DIGITS            17116000
         LA    DB3,43(,DB3)       BUMP PAST MESSAGE AND EDITED VALUE    17117000
         LA    A2,2+1(FRETURN,R1) POINT TO RETURN LOCATION              17118000
         BR    LINE$              PRINT LINE AND RETURN                 17119000
*                                                                       17120000
EDITP1   DC    X'202020202020202120'        INTEGER EDIT PATTERN        17121000
EDITP2   DC    X'2020202021204B202020'      EDIT PATTERN WI 3 DEC PL    17122000
*                                                                       17123000
PRMSGM   MVC   0(*-*,DB3),2(FRETURN)        MOVE MESSAGE TO BUFFER      17124000
         TITLE 'SPITBOLX -- ROUTINE TO SET CODE INTERCEPTS FOR I/O'     17125000
*                                                                       17126000
*        IOASSOC IS A COMMON ROUTINE CALLED BY INPUT, OUTPUT AND TRACE  17127000
*        FOR INPUT ASSOCIATION  SEARCH OUT AND REPLACE:                 17128000
*                                 LM    A1,A1+1,VALUE                   17129000
*                                 LM    A2,A2+1,VALUE                   17130000
*        FOR OUTPUT ASSOCIATION REPLACE:                                17131000
*                                 STM   A1,A1+1,VALUE                   17132000
*                                 MVI   NCODE,VALUE                     17133000
*        FULLWORD INSTRUCTION FOUND IS REPLACED BY BALR DB1,DB1         17134000
*        FOLLOWED BY HALFWORD.  BITS 0 AND 1 ARE ALWAYS ON              17135000
*        BIT 2 IS ON IF THIS IS AN OUTPUT ASSOCIATION CASE              17136000
*        BIT 3 IS SET IF THE INSTRUCTION REFERENCES A1 AND A1+1         17137000
*        BITS 4-8 ARE USED TO INDICATE WHICH OF 32 BASE REGISTERS       17138000
*        BITS 9-15 INDICATE LOCATION OF VARIABLE BLOCK IN 32 BYTE INCR. 17139000
*                                                                       17140000
*        REGISTERS ON ENTRY:                                            17141000
*        A1    ADDRESS OF VARIABLE BLOCK                                17142000
*        A1+1-A2+1  ARE SCRAP                                           17143000
*        DB2   SCRAP                                                    17144000
*        DB3   X'80' FOR OUTPUT ASSOCIATION                             17145000
*        DB3   X'70' FOR INPUT ASSOCIATION                              17146000
*        DB4   A(IOASSOC)                                               17147000
*                                                                       17148000
*        REGISTERS IN PROGRAM:                                          17149000
*        R0    SCRAP                                                    17150000
*        R1    POINTER TO NEXT BLOCK IN DYNAMIC MEMORY                  17151000
*        R2    HALFWORD CODE ADDRESS, INITIALLY CODEADR                 17152000
*        A1    ADDRESS OF VARIABLE BLOCK                                17153000
*        A1+1  HALFWORD  L  DB4,0                                       17154000
*        A2    S ADDRESS OF DB4 TABLE ENTRY FOR THIS VARIABLE           17155000
*        A2+1  SWITCH FOR DB4 VALUE: 0 IF INCORRECT VALUE IN DB4        17156000
*              1 IF DB4 IS NOT USED OR IF CORRECT VALUE IS LOADED       17157000
*        DB2   S ADDRESS OF VARIABLE                                    17158000
*                                                                       17159000
*        REGISTERS ON EXIT:                                             17160000
*        A1    ADDRESS OF VARIABLE BLOCK                                17161000
*        DB2-DB3                  RESTORED DATA BASE REGISTER VALUES    17162000
*                                                                       17163000
*        FLAGS USED BY IOASSOC ROUTINE                                  17164000
*                                                                       17165000
A1BIT    EQU   X'10'              SET ON IN PSEUDO CODE FOR LM A1,A1+1  17166000
STMBIT   EQU   X'10'              SET ON IN PSEUDO CODE FOR STM A1,A1+1 17167000
WRITEBIT EQU   X'20'              SET ON IN PSEUDO CODE FOR OUTPUT CASE 17168000
INFLAG   EQU   X'70'              FLAG FOR INPUT CALL (NE CC)           17169000
OUTFLAG  EQU   X'80'              FLAG FOR OUTPUT CALL (EQ CC)          17170000
         EJECT                                                          17171000
*                                                                       17172000
*        ENTRY POINT                                                    17173000
*                                                                       17174000
         USING IOASSOC,DB4        OUR BASE REGISTER                     17175000
IOASSOC  LA    DB2,VALUE(,A1)     GET ADDRESS OF VALUE FIELD            17176000
         SR    R1,R1              INITIALIZE POINTER TO BASE TABLE      17177000
         LR    R2,DB1             POINT TO FIRST 4K BLOCK               17178000
         B     IOASSOCM           SKIP INTO LOOP                        17179000
*                                                                       17180000
*        LOOP TO SEARCH FOR PROPER BASE TABLE ENTRY FOR VARIABLE        17181000
*                                                                       17182000
IOASSOC0 LA    R1,4(,R1)          BUMP TO NEXT TABLE ENTRY              17183000
         L     R2,$$BAS1(R1)      LOAD BASE VALUE                       17184000
*                                                                       17185000
*        MERGE HERE FIRST TIME THROUGH LOOP WITH (R2) --> 1ST BLOCK     17186000
*                                                                       17187000
IOASSOCM CR    DB2,R2             COMPARE AGAINST VARIABLE ADDRESS      17188000
         BL    IOASSOC0           VAR BLK MUST BE GE, ELSE GET NEXT BAS 17189000
         LA    R0,4095(,R2)       GET END OF BLOCK (BASE REG) ADDRESS   17190000
         CR    DB2,R0             COMPARE AGAINST VARIABLE ADDRESS      17191000
         BH    IOASSOC0           VAR BLK MUST BE LE, ELSE LOOP BACK    17192000
*                                                                       17193000
*        FOUND THE ENTRY, INITIALIZE CODE SEARCH                        17194000
*                                                                       17195000
         SR    DB2,R2             GET DISPLACEMENT VALUE                17196000
         LR    R0,R1              COPY BASE NUMBER*4                    17197000
         SLL   R0,7-2             POSITION FOR IOASSOC CODE             17198000
         LR    R2,DB2             COPY DISPLACEMENT                     17199000
         SRL   R2,5               /32 TO GET DBLWRD OFFSET FOR IO CODE  17200000
         ALR   R0,R2              GET IO CODE ADDRESS                   17201000
         STH   R0,IOASSCOD+2      STORE FOR INSERTION IN CODE           17202000
         OI    IOASSCOD+2,X'C0'   SET ON BITS FOR CODE SEARCHES         17203000
         SR    A1+1,A1+1          DEFAULT PREVENTS L DB4 FROM BEING FND 17204000
         CH    R1,H12             IS THIS IN THE DB4 DOMAIN?            17205000
         BL    IOASSOC1           SKIP IF NOT                           17206000
         LH    A1+1,IOLDB4        GET INSTRUCTION L  DB4,0 FOR CHECK    17207000
         LH    A2,DB4SAD          PREPARE SADR CALC FOR BASE TBL ENTRY  17208000
         ALR   A2,R1              GET BASE TABLE S ADDRESS              17209000
         LA    R1,(DB4-DB1)*4     SET UP TO GIVE DB4 AS BASE REGISTER   17210000
*                                                                       17211000
*        COME HERE TO CALCULATE VARIABLE BLOCK S ADDRESS                17212000
*                                                                       17213000
IOASSOC1 SLL   R1,12-2            POSITION BASE REGISTER NUMBER         17214000
         ALR   DB2,R1             ADD INTO DISPLACEMENT                 17215000
         AH    DB2,VARBSAD        AND FINISH S ADDRESS CALCULATION      17216000
         CH    DB3,=Y(OUTFLAG)    IS THIS OUTPUT ASSOCIATION?           17217000
         BNE   *+8                SKIP IF NOT OUTPUT OR TRACE           17218000
         OI    IOASSCOD+2,WRITEBIT          SET TO INDICATE OUTPUT REF  17219000
         L     R1,DYNAMB          POINT TO START OF DYNAMIC MEMORY      17220000
         L     R2,CODEADR         POINT TO MAIN CODE BLOCK              17221000
*                                                                       17222000
*        LOOP THROUGH BLOCKS OF CODE (1ST MAIN BLOCK, THE CBLOK'S)      17223000
*                                                                       17224000
IOASSOCL LA    A2+1,IOASSVAR-IOASSRX        SET DB4 CORRECT SWITCH      17225000
         EJECT                                                          17226000
*                                                                       17227000
*        LOOP TO EXAMINE CODE FOR REFS TO OUR VARIABLE OR DB4           17228000
*                                                                       17229000
IOASSOC2 TM    0(R2),X'C0'        TEST INSTRUCTION LENGTH               17230000
         BNM   IOASSRR            SKIP IF RR INSTRUCTION                17231000
         CH    DB2,2(,R2)         DOES RX REFER TO OURVARIABLE?         17232000
         BE    IOASSRX(A2+1)      TAKE ACTION DEPENDANT ON DB4 IF SO    17233000
*                                                                       17234000
*        COME HERE FOR RX INSTRUCTIONS TO CHECK FOR DB4 REFERENCES      17235000
*        NOTE THAT A1+1 IS ZERO UNLESS DB4 IS OUR BASE REGISTER         17236000
*        SO NO DB4 REFERENCES ARE FOUND UNLESS DB4 IS ACTUALLY NEEDED   17237000
*                                                                       17238000
IOASSRX  CH    A1+1,0(,R2)        IS THIS A L OF DB4? (ONLY IF DB4 USD) 17239000
         BNE   IOASSRX1           SKIP PAST IT IF NOT                   17240000
         SR    A2+1,A2+1          INDICATE POTENTIAL INCORRECT DB4 VALU 17241000
         CH    A2,2(,R2)          CHECK FOR CORRECT LOAD OF DB4 FOR US  17242000
         BNE   IOASSRX1           SKIP PAST INSTRUCTION IF NOT          17243000
         LA    A2+1,IOASSVAR-IOASSRX        SET CORRECT DB4 VALUE IF OK 17244000
*                                                                       17245000
*        COME HERE TO SKIP OVER A FOUR BYTE INSTRUCTION                 17246000
*                                                                       17247000
IOASSRX1 LA    R2,4(,R2)          BUMP PAST 4 BYTE INSTRUCTION          17248000
         B     IOASSOC2           LOOP BACK TO CONTINUE SEARCH          17249000
*                                                                       17250000
*        COME HERE ON 2 BYTE INSTRUCTION - CHECK FOR I/O CASE           17251000
*                                                                       17252000
IOASSRR  CLI   1(R2),DB3*16+DB1   CHECK FOR BALR DB3,DB1 (I/O CALL)     17253000
         BNE   IOASSRR1           OFF TO PUSH PAST 2 BYTES IF NOT       17254000
         B     IOASSRX1           ELSE TREAT AS 4 BYTES AND SKIP IT     17255000
*                                                                       17256000
*        COME HERE WHEN A REFERENCE TO OUR VARIABLE IS FOUND            17257000
*                                                                       17258000
IOASSVAR CLI   0(R2),X'98'        COM PARE OP CODE AGAINST LM           17259000
         EX    DB3,IOCHKBR        B IF NOT OP CODE FOR THIS CALL        17260000
         CLI   1(R2),A1*16+A1+1   IS THIS AN A1 REFERENCE?              17261000
         MVC   0(4,R2),IOASSCOD   MOVE IN CODE FOR IO CALL              17262000
         BNE   IOASSRX1           SKIP OVER CODE IF NOT A1 REFERENCE    17263000
         OI    2(R2),A1BIT        INDICATE A1,A1+1 REFERENCE            17264000
         B     IOASSRX1           AND OFF TO SKIP OVER CODE             17265000
         EJECT                                                          17266000
*                                                                       17267000
*        COME HERE FOR TWO BYTE INSTRUCTION                             17268000
*                                                                       17269000
IOASSRR1 CLI   0(R2),X'00'        IS IT X'0000' AT END OF CODE BLOCK?   17270000
         LA    R2,2(,R2)          BUMP POINTER ANYWAY                   17271000
         BNE   IOASSOC2           LOOP BACK IF NOT TO CONTINUE SEARCH   17272000
*                                                                       17273000
*        HERE WE HAVE COMPLETED PROCESSING OF A CODE BLOCK              17274000
*        SEARCH DYNAMIC MEMORY FOR NEXT CBLOK TO PROCESS                17275000
*                                                                       17276000
IOASSBL  CR    R1,FR              ANY BLOCKS LEFT IN DYNAMIC MEMORY?    17277000
         BE    IOASSXT            JUMP IF NOT TO EXIT                   17278000
         CLI   0(R1),CBLOK        ELSE IS NEXT BLOCK A CODE BLOCK?      17279000
         BNE   IOASSBM            SKIP IF NOT TO BUMP PAST BLOCK        17280000
         LA    R2,CODECODE(,R1)   ELSE POINT TO CODE TO BE PROCESSED    17281000
         A     R1,CODNLEN(,R1)    BUMP FREE CORE PTR PAST BLOCK         17282000
         B     IOASSOCL           AND LOOP BACK TO PROCESS CBLOK CODE   17283000
*                                                                       17284000
*        HERE TO BUMP PAST BLOCK IN FREE CORE NOT A CBLOK               17285000
*                                                                       17286000
IOASSBM  LR    R0,A1              SAVE VAR BLOCK POINTER                17287000
         LR    A1,R1              COPY BLOCK ADDRESS FOR BLOKLEN        17288000
         SR    R2,R2              CLEAR FOR IC                          17289000
         IC    R2,DTYPE(,A1)      LOAD BLOCK CODE                       17290000
         EX    0,BLOKLEN(R2)      GET LENGTH OF BLOCK                   17291000
         AR    R1,R2              PUSH FREE CORE POINTER                17292000
         LR    A1,R0              RESTORE VARIABLE BLOCK POINTER        17293000
         B     IOASSBL            LOOP BACK TO LOOK FOR CBLOK'S         17294000
*                                                                       17295000
*        HERE AFTER PROCESSING ALL CBLOK'S IN DYNAMIC MEMORY            17296000
*                                                                       17297000
IOASSXT  LM    DB2,DB3,$$BAS2     RELOAD DATA BASE REGS                 17298000
         BR    RETURN             RETURN TO CALLER                      17299000
*                                                                       17300000
*        CONSTANTS FOR I/O ASSOCIATION ROUTINE                          17301000
*                                                                       17302000
IOLDB4   L     DB4,0              INSTRUCTION FOR DB4 LOAD              17303000
         ORG   *-2                GET RID OF BASE AND DISPLACMENT       17304000
IOCHKBR  BC    *-*,IOASSRX1       EXECUTED TEST FOR PROPER VALUE REF    17305000
DB4SAD   DC    S($$BAS1)          S ADDRESS OF FIRST DATA BASE          17306000
VARBSAD  DC    S(0(DB1))          INDICATE DB1 AS A BASE REGISTER       17307000
*                                                                       17308000
         DROP  DB4                DROP IOASSOC BASE REG                 17309000
         TITLE 'SPITBOLX -- EXECUTION INITIALIZATION ROUTINE'           17310000
*                                                                       17311000
*        HERE WE INITIATE EXECUTION PROPER. THERE ARE TWO CASES --      17312000
*                                                                       17313000
*        1)    COMPILE AND GO MODE. IN THIS CASE, WE COME HERE AFTER    17314000
*        COMPLETING THE COMPUTATION OF CONSTANT EXPRESSIONS             17315000
*                                                                       17316000
*        2)    LOAD MODE. IN THIS CASE, WE HAVE A PREVIOUSLY GENERATED  17317000
*        OBJECT MODULE AND CONTROL WAS PASSED FROM THE RELOAD ROUTINE   17318000
*                                                                       17319000
*        THE CODE FOR CASE 1 IS REQUIRED ONLY IN THE STANDARD MODULES,  17320000
*                                                                       17321000
         USING ECONC,FRETURN      BASE REG SET BY CALLER (EITHER CASE)  17322000
ECONC    DS    0H                 START OF ROUTINE                      17323000
*                                                                       17324000
         AIF   (&LMOD NE 0).SKIPL10                                     17325000
*                                                                       17326000
*        HERE WE HAVE THE STANDARD CASE (CALLED FROM SPITBOLA)          17327000
*                                                                       17328000
         NI    HICINUSE+3,X'F8'   ALLIGN HIGH CORE TO DOUBLEWORD        17329000
         L     PDR,HICINUSE       LOAD NEW PDR (DELETE CONSTANT CODE)   17330000
         SH    PDR,=Y(STACKTOP)   ALLOW STANDARD PDR OFFSET             17331000
         MVI   CLLCTFL,X'FF'      SET SPECIAL COLLECT FLAG              17332000
         XC    LINKLOCS(ENDLINKS-LINKLOCS),LINKLOCS CLEAR LINKAGE LOCS  17333000
         STE   ZR,SRETSV          ZERO TABLE RETURN LOC                 17334000
         BAL   RETURN,GBGCL0S     COLLECT SETTING VALID RETLOC ADDRESS  17335000
*                                 SO CODE SEARCH WORKS                  17336000
         AUR   SCNT,SINC          DUMMY TO STOP CODE SEARCH (SINC=0)    17337000
*                                 NOTE: FRETURN MUST NOT BE RELOCATABLE 17338000
         MVI   CLLCTFL,0          RESET SPECIAL COLLECT FLAG            17339000
         BAL   RETURN,OBJGEN      CHECK FOR POSSIBLE OBJECT MOD GEN     17340000
         CLI   BYPASXEQ,0         TEST FOR -NOEXECUTE OPTION            17341000
         BZ    XEQGOGO            SKIP IF NOT (-EXECUTE)                17342000
         LA    A1,NOEXMSG         ELSE POINT TO MESSAGE                 17343000
         LA    A1+1,L'NOEXMSG     SET LENGTH                            17344000
         BAL   RETURN,XPRINTER    CALL ROUTINE TO PRINT ERROR MESSAGE   17345000
         SR    R0,R0              RETURN CODE = ZERO                    17346000
         L     R2,=V(SYSEOJ)      POINT TO END OF JOB ROUTINE           17347000
         BALR  R1,R2              TERMINATE THIS RUN                    17348000
*                                                                       17349000
NOEXMSG  DC    C'0EXECUTION SUPPRESSED'                                 17350000
.SKIPL10 ANOP                                                           17351000
*                                                                       17352000
*        BOTH CASES MERGE HERE                                          17353000
*                                                                       17354000
XEQGOGO  ST    FR,DYNAMB          SET NEW START OF DYNAMIC MEMORY       17355000
         LE    SCNT,STSTART       LOAD INITIAL STATEMENT COUNT VALUE    17356000
         LE    SINC,=X'7F000001'  LOAD STATEMENT INCREMENT VALUE        17357000
         LCR   R0,PDR             GET NEGATIVE NON-ZERO VALUE = END STK 17358000
         ST    R0,FBLOKLOC(,PDR)  STORE AS END OF STACK MARKER          17359000
         ST    PDR,PDRLOC         INITIALIZE PDR LOCATION FOR THIS LEVL 17360000
         STE   ZR,PNAME(,PDR)     SET PNAME FLD NOT IN USE FOR GBGCLTR  17361000
         LM    DB2,DB3,$$BAS2     LOAD DATA BASE REGS                   17362000
         EJECT                                                          17363000
*                                                                       17364000
*        SET UP IOBLOKS FOR STANDARD FILES                              17365000
*                                                                       17366000
         XC    0(3*IOBSIZE,FR),0(FR)        ZERO OUT 3 IOBLOKS          17367000
         MVI   0(FR),IOBLOK       SET PROPER BLOCK CODE                 17368000
         ST    FR,B$OUTPUT+VIOPTR SET OUTPUT IOBLOK POINTER             17369000
         MVC   OFORMAT(4,FR),OUTFORMP       SET FORMAT = ONE BLANK      17370000
         MVC   OFILE(4,FR),PRINTDCB         SET SYSPRINT DCB POINTER    17371000
         LA    FR,IOBSIZE(,FR)    PUSH PAST FIRST IOBLOK                17372000
         MVI   0(FR),IOBLOK       SET PROPER BLOCK CODE                 17373000
         ST    FR,B$INPUT+VIOPTR  STORE POINTER TO INPUT IOBLOK         17374000
         MVC   IFILE(4,FR),READDCB          SET POINTER TO SYSIN DCB    17375000
         LA    FR,IOBSIZE(,FR)    PUSH PAST THIS IOBLOK                 17376000
         ST    FR,B$PUNCH+VIOPTR  STORE POINTER TO PUNCH IOBLOK         17377000
         MVI   0(FR),IOBLOK       SET PROPER BLOK CODE                  17378000
         MVI   OFORMAT(FR),NCODE  SET FORMAT = NULL                     17379000
         MVC   OFILE(4,FR),PUNCHDCB         COPY PTR TO SYSPUNCH DCB    17380000
         LA    FR,IOBSIZE(,FR)    PUSH PAST PUNCH IOBLOK                17381000
         LA    A1,NEWPAGE         POINT TO NEW PAGE CHARACTER           17382000
         LA    A1+1,1             LENGTH = ONE CHARACTER                17383000
         BAL   RETURN,XPRINTER    CALL ROUTINE TO PRINT TO GET EJECT    17384000
         MVI   CRELFLG,0          NO MORE NEED TO PROCESS CONSTANTS     17385000
         L     R2,=V(SYSTIME)     ADDRESS OF SYSTEM TIMER ROUTINE       17386000
         BALR  R1,R2              GET CURRENT TIME (START OF XEQ)       17387000
         NOP   0                  ERROR RETURN NOT POSSIBLE             17388000
         ST    R0,TIME            SAVE TIME AT START OF EXECUTION       17389000
*                                                                       17390000
*        NOW INITIATE EXECUTION UNLESS WE ARE OVERTIME                  17391000
*                                                                       17392000
         L     R1,TRAADR          LOAD TRANSFER ADDRESS                 17393000
         TM    STAGE,$OVERTIM     ARE WE OVERTIME?                      17394000
         BO    $$TIME             SIGNAL OVERTIME IF SO                 17395000
         CR    FR,PDR             ENOUGH ROOM TO START EXECUTION?       17396000
         BALR  RETURN,0           POINT RETURN FOR POSSIBLE &LASTNO REF 17397000
         BCR   L,R1               OFF TO CODE IF THERE IS ROOM          17398000
         B     GBGCL0S            COLLECT IF NOT ENOUGH ROOM            17399000
         AUR   SCNT,SINC          DUMMY AUR FOR CALCSTNO                17400000
         DC    X'47000001'        NOP 1 SO THAT &LASTNO = 0 FOR ABOVE   17401000
*                                                                       17402000
*        STANDARD FORMAT POINTER FOR OUTPUT IOBLOK (SYSPRINT)           17403000
*                                                                       17404000
OUTFORMP DC    AL1(SCODE)         STRING CODE                           17405000
         DC    AL3(OUTFORM)       POINTER TO FORMAT                     17406000
*                                                                       17407000
OUTFORM  EQU   *-SCHARS           START OF FORMAT - OFFSET              17408000
         DC    C' '               STANDARD OUTPUT FORMAT                17409000
*                                                                       17410000
NEWPAGE  DC    C'1'               CONTROL CHARACTER FOR NEW PAGE        17411000
         EJECT                                                          17412000
*                                                                       17413000
*        SUBROUTINE TO PRINT A LINE ON SYSPRINT                         17414000
*                                                                       17415000
*        (A1,A1+1)                ADDRESS/LENGTH OF MESSAGE             17416000
*        BAL   RETURN,XPRINTER                                          17417000
*        -->                      NORMAL RETURN                         17418000
*                                                                       17419000
XPRINTER L     R0,PRINTDCB        POINT TO SYSPRINT DCB                 17420000
         L     R2,XPRINTV         LOAD POINTER TO OUTPUT ROUTINE        17421000
         SR    A2+1,A2+1          SET UNFORMATTED MODE                  17422000
         BALR  R1,R2              CALL SYSWRITE ROUTINE                 17423000
         NOP   0                  IGNORE ERROR (PAGE LIMIT EXCEEDED)    17424000
         BR    RETURN             RETURN TO XPRINTER CALLER             17425000
         DROP  FRETURN            DONE WITH ECONC BASE REGISTER         17426000
*                                                                       17427000
XPRINTV  DC    V(SYSWRITE)        ADDRESS OF SYSTEM OUTPUT ROUTINE      17428000
         TITLE 'SPITBOLX -- OBJECT MODULE GENERATION'                   17429000
*                                                                       17430000
*        THIS ROUTINE GENERATES AN OBJECT MODULE IF THE SYSOBJ FILE     17431000
*        HAS BEEN DEFINED. IT IS ONLY INCLUDED IN THE STANDARD MODULES  17432000
*                                                                       17433000
         AIF   (&LMOD EQ 1).SKIPS15                                     17434000
*                                                                       17435000
*        THE OBJECT MODULE GENERATED IS DESIGNED TO BE LINKED WITH THE  17436000
*        LIBRARY MODULES, AND CONSISTS OF TWO CONTROL SECTIONS --       17437000
*                                                                       17438000
*        SPITBOLL                 LOW SECTION OF ALLOCATED DATA AREA    17439000
*                                 UP TO THE NEW VALUE OF DYNAMB         17440000
*                                                                       17441000
*        SPITBOLH                 HIGH SECTION OF ALLOCATED DATA AREA   17442000
*                                 FROM HICINUSE ON                      17443000
*                                                                       17444000
*        FIRST SEE IF WE SHOULD GENERATE AN OBJECT MODULE               17445000
*                                                                       17446000
         USING ECONC,FRETURN      BASE REG SET BY CALLER                17447000
OBJGEN   LA    A1,SYSOBJNM        POINT TO NAME = 'SYSOBJ'              17448000
         LA    A1+1,6             LENGTH = 6 CHARACTERS                 17449000
         L     R2,VOPEN           LOAD ADDRESS OF SYSTEM ROUTINE        17450000
         BALR  R1,R2              CALL SYSTEM ROUTINE TO LOCATE DCB PTR 17451000
         B     0(,RETURN)         ALL DONE IF FILE NOT DEFINED          17452000
*                                                                       17453000
*        IF WE SHOULD, PERFORM APPROPRIATE INITIALIZATION               17454000
*                                                                       17455000
         ST    R0,OBJDCB          SAVE POINTER TO SYSOBJ DCB            17456000
         L     A2,HICINUSE        LOAD STARTING ADDRESS OF SPITBOLH     17457000
         SH    A2,H8              SUBTRACT MORE THAN SCHARS,VALUE SO    17458000
*                                 THAT ALL PTRS POINT WITHIN SPITBOLH   17459000
         ZAP   OBJSER,=P'0'       RESET SERIALIZATION COUNTER           17460000
         EJECT                                                          17461000
*                                                                       17462000
*        FIRST GENERATE ESD CARD                                        17463000
*                                                                       17464000
*        THE FORMAT OF AN ESD CARD IS AS FOLLOWS --                     17465000
*                                                                       17466000
*        COL 1                    12-2-9 MULTIPUNCH                     17467000
*        COL 2-4                  ESD                                   17468000
*        COLS 11-12               NUMBER OF BYTES OF INFORMATION        17469000
*        COLS 15-16               ESID NUMBER OF FIRST SD ON THIS CARD  17470000
*        COLS 17-72               VARIABLE INFORMATION                  17471000
*              8 POSITIONS        NAME                                  17472000
*              1 POSITION         TYPE (0=SD,1=LD,2=ER,3=PC,4=CM)       17473000
*              3 POSITIONS        ASSEMBLED ORIGIN                      17474000
*              1 POSITION         BLANK                                 17475000
*              3 POSITIONS        CONTROL SECTION LENGTH                17476000
*        COLS 73-76               PROGRAM ID (= SPIT)                   17477000
*        COLS 77-80               SEQUENCE NUMBER                       17478000
*                                                                       17479000
         BAL   A1,OBJINIT         INITIALIZE BUFFER                     17480000
         MVC   OBJBUFR(40),ESDMOD MOVE MODEL ESD CARD                   17481000
         ST    DREG,OBJBUFR+24    STORE SPITBOLD ADDR + 0 = SD CODE     17482000
         LR    R0,FR              CURRENT END OF SPITBOLL               17483000
         SR    R0,DREG            - START = LENGTH                      17484000
         ST    R0,OBJBUFR+28      STORE LENGTH OF SPITBOLL              17485000
         ST    DREG,SPITLAD       SET ADDRESS OF SPITBOLL               17486000
         MVI   OBJBUFR+28,C' '    BLANK UPPER BYTE                      17487000
         ST    A2,OBJBUFR+40      STORE SPITBOLH ADDR + 0 = SD CODE     17488000
         LR    R2,DREG            START OF DATA AREA ADDR               17489000
         A     R2,DATASIZE        + TOTAL LENGTH                        17490000
         SR    R2,A2              - SPITBOLH START = SPITBOLH LENGTH    17491000
         ST    R2,OBJBUFR+44      STORE LENGTH OF SPITBOLH              17492000
         ST    A2,SPITHAD         STORE ADDRESS OF SPITBOLH             17493000
         MVI   OBJBUFR+44,C' '    BLANK UPPER BYTE                      17494000
         BAL   A1,OBJWRITE        WRITE ESD CARD                        17495000
         EJECT                                                          17496000
*                                                                       17497000
*        NOW WE GENERATE THE REQUIRED TEXT CARDS                        17498000
*                                                                       17499000
*        THE FORMAT OF A TEXT CARD IS AS FOLLOWS                        17500000
*                                                                       17501000
*        COL 1                    12-2-9 MULTI-PUNCH                    17502000
*        COLS 2-4                 TXT                                   17503000
*        COLS 6-8                 ASSEMBLED ORIGIN                      17504000
*        COLS 11-12               NUMBER OF BYTES OF TEXT               17505000
*        COLS 15-16               ESID NUMBER OF SD CONTAINING TEXT     17506000
*        COLS 17-72               UP TO 56 BYTES OF TEXT                17507000
*        COLS 73-76               PROGRAM ID (= 'SPIT')                 17508000
*        COLS 77-80               SEQUENCE NUMBER                       17509000
*                                                                       17510000
         LA    R0,2               SET SD NUMBER = 2 = NUMBER OF CSECTS  17511000
         LR    R1,A2              ADDR OF SPITBOLH (LENGTH IS IN R2)    17512000
*                                                                       17513000
*        LOOP TO GENERATE TEXT CARDS                                    17514000
*                                                                       17515000
TXTLOOP  BAL   A1,OBJINIT         INITIALIZE BUFFER                     17516000
         MVC   OBJBUFR(4),TXTMOD  SET INITIAL BYTES                     17517000
         ST    R1,OBJBUFR+4       STORE ADDR (= ASSEMBLED ORIGIN)       17518000
         MVI   OBJBUFR+4,C' '     BLANK UPPER BYTE                      17519000
         STH   R0,OBJBUFR+14      STORE ESID NUMBER                     17520000
         LA    A1,56              GET CONSTANT 56                       17521000
         CR    R2,A1              CHECK NUMBER OF BYTES OF TEXT TO GO   17522000
         BNH   TXTPART            SKIP IF 56 BYTES OR LESS LEFT         17523000
         STH   A1,OBJBUFR+10      ELSE STORE TEXT LENGTH = 56           17524000
         MVC   OBJBUFR+16(56),0(R1)         MOVE 56 BYTES TO BUFFER     17525000
         SR    R2,A1              DECREMENT COUNT LEFT BY 56            17526000
         AR    R1,A1              PUSH TEXT POINTER                     17527000
         BAL   A1,OBJWRITE        WRITE TXT CARD                        17528000
         B     TXTLOOP            LOOP BACK FOR NEXT CARD               17529000
*                                                                       17530000
*        HERE TO GENERATE LAST TXT CARD OF A CONTROL SECTION            17531000
*                                                                       17532000
TXTPART  STH   R2,OBJBUFR+10      STORE ACTUAL NUMBER OF BYTES          17533000
         BCTR  R2,0               ADJUST FOR 360                        17534000
         EX    R2,TXTMOVE         MOVE WHAT BYTES WE HAVE               17535000
         BAL   A1,OBJWRITE        WRITE LAST TXT CARD FOR CSECT         17536000
         LR    R1,DREG            POINT TO SPITBOLD                     17537000
         LR    R2,FR              END OF SPITBOLD                       17538000
         SR    R2,R1              - START = LENGTH                      17539000
         BCT   R0,TXTLOOP         DECR ESID NUMBER & LOOP IF MORE TO GO 17540000
         EJECT                                                          17541000
*                                                                       17542000
*        NOTE THAT WE DO NOT GENERATE ANY RLD CARDS. INSTEAD, WE DO     17543000
*        OUR OWN RELOCATION WHEN THE PROGRAM IS RELOADED. THIS          17544000
*        SIMPLIFIES THE CODING AND AVOIDS THE NECCESSITY OF             17545000
*        USING SOME OF THE MORE EXOTIC LINK EDITOR OPTIONS              17546000
*                                                                       17547000
*        NOW GENERATE THE END CARD, THE FORMAT IS SIMPLY                17548000
*                                                                       17549000
*        COL 1                    12-2-9 MULTI-PUNCH                    17550000
*        COLS 2-4                 END                                   17551000
*        COLS 73-76               PROGRAM ID (= 'SPIT')                 17552000
*        COLS 77-80               SEQUENCE NUMBER                       17553000
*                                                                       17554000
         STE   ZR,SPITLAD         CLEAR SPECIAL ADDRESSES               17555000
         STE   ZR,SPITHAD         . . . .                               17556000
         BAL   A1,OBJINIT         CLEAR BUFFER                          17557000
         MVC   OBJBUFR(4),ENDMOD  MOVE FIRST FOUR BYTES                 17558000
         BAL   A1,OBJWRITE        WRITE END CARD                        17559000
         LA    A1,OBJOKM          POINT TO MESSAGE                      17560000
         LA    A1+1,L'OBJOKM      LENGTH OF MESSAGE                     17561000
         B     XPRINTER           EXIT VIA ROUTINE TO PRINT MESSAGE     17562000
         EJECT                                                          17563000
*                                                                       17564000
*        SUBROUTINE TO INITIALIZE OUTPUT OF AN OBJECT MODULE CARD       17565000
*                                                                       17566000
*        BAL   A1,OBJINIT                                               17567000
*                                                                       17568000
OBJINIT  MVI   OBJBUFR,C' '       SET BLANK                             17569000
         MVC   OBJBUFR+1(71),OBJBUFR        CLEAR TO BLANKS             17570000
         MVC   OBJBUFR+72(4),SYSOBJID       SET PROGRAM ID              17571000
         UNPK  OBJBUFR+76(4),OBJSER         SET SERIALIZATION           17572000
         OI    OBJBUFR+79,C'0'    SET PROPER ZONE ON LAST DIGIT         17573000
         AP    OBJSER,=P'1'       INCREMENT SERIALIZATION               17574000
         BR    A1                 RETURN TO CALLER                      17575000
*                                                                       17576000
*        SUBROUTINE TO OUTPUT A COMPLETED IMAGE                         17577000
*                                                                       17578000
*        BAL   A1,OBJWRITE                                              17579000
*                                                                       17580000
OBJWRITE STM   R0,A1+1,OBJWSAV    SAVE REGS                             17581000
         LA    A1,OBJBUFR         POINT TO BUFFER                       17582000
         LA    A1+1,80            LENGTH = 80 CHARS                     17583000
         L     R0,OBJDCB          LOAD PTR TO FILE                      17584000
         L     R2,XPRINTV         LOAD ROUTINE ADDRESS (SYSWRITE)       17585000
         SR    A2+1,A2+1          SIGNAL UNFORMATTED                    17586000
         BALR  R1,R2              CALL ROUTINE                          17587000
         B     OBJWRITX           SKIP IF THERE IS AN ERROR             17588000
         LM    R0,A1+1,OBJWSAV    ELSE RESTORE REGS                     17589000
         BR    A1                 AND RETURN TO CALLER                  17590000
*                                                                       17591000
*        COME HERE IF WE GET AN ERROR WRITING THE FILE                  17592000
*                                                                       17593000
OBJWRITX LA    A1,OBJMERR         POINT TO MESSAGE                      17594000
         LA    A1+1,L'OBJMERR     LENGTH OF MESSAGE                     17595000
         B     XPRINTER           EXIT VIA ROUTINE TO PRINT ERROR MSG   17596000
         EJECT                                                          17597000
*                                                                       17598000
*        CONSTANTS FOR OBJGEN                                           17599000
*                                                                       17600000
TXTMOVE  MVC   OBJBUFR+16(*-*),0(R1)        MOVE PARTIAL TXT INFO       17601000
OBJOKM   DC    C'0OBJECT MODULE SUCCESSFULLY WRITTEN TO SYSOBJ FILE'    17602000
OBJMERR  DC    C'0ERROR WRITING SYSOBJ FILE, MODULE NOT GENERATED'      17603000
TXTMOD   DC    C'TXT'            MODEL TXT CARD                        17604000
ENDMOD   DC    C'END'            MODEL END CARD                        17605000
ESDMOD   DC    C'ESD      '      MODEL ESD CARD                        17606000
         DC    AL2(32)            # BYTES                               17607000
         DC    C'  '                                                    17608000
         DC    AL2(1)             FIRST ESID NUMBER                     17609000
         DC    C'SPITBOLL'                                              17610000
         DC    C'XXXX XXX'        ADDR/LENGTH                           17611000
SYSOBJID DC    C'SPITBOLH'        CSECT NAME + DECK NAME (=SPIT)        17612000
SYSOBJNM DC    C'SYSOBJ'          NAME OF OUTPUT FILE                   17613000
         DROP  FRETURN            DROP BASE REG                         17614000
.SKIPS15 ANOP                                                           17615000
         TITLE 'SPITBOLX -- EXECUTION TIME SCAN ROUTINE'                17616000
*                                                                       17617000
*        SCAN ROUTINE FOR EXECUTION TIME ROUTINES                       17618000
*                                                                       17619000
*        CONDITIONS ON ENTRY -                                          17620000
*        (A2)                     BASE REGISTER, ADDRESS OF FIRST CODE  17621000
*        BALR  RETURN,A2          CALL OF SCAN ROUTINE                  17622000
*        ->    RETURN FOR NULL STRING SCANNED, A2+1 CONTAINS STOP CHR   17623000
*        ->    RETURN FOR RUNOUT                                        17624000
*        (A2+1)                   TRT STOP CHARACTER TBL ENTRY          17625000
*                                 ZERO IF RUNOUT WHICH IS IGNORED       17626000
*        NORMAL EXIT IS TO GETNAME, SO (A1) CONTAINS VAR BLK ADDR       17627000
*        FLAG FOR XSCAN CONTROL  --  ZEROED BY XSCANI                   17628000
*        XSCANFLG                 XSIGNRO   IGNORE RUNOUT               17629000
*                                 XSIGNGN   DON'T DO GETNAME CALL       17630000
*        IF GETNAME DOES A COLLECT , IT IS A GBGCLF!                    17631000
*        THIS ROUTINE DOES A TRT ON ZTBL, ASSUMING THAT IT HAS BEEN     17632000
*        SET UP BY CALLER.                                              17633000
*                                                                       17634000
         USING XSCAN,A2           TELL ASSEMBLER OF BASE REGISTER       17635000
XSCAN    LM    R0,R1,XSCANSV      LOAD LENGTH LEFT/ SCAN LOCATION       17636000
         SR    R2,R2              CLEAR TRT INSERT REGISTER             17637000
         BCTR  R0,0               GET 360 LENGTH LEFT                   17638000
         LTR   A1+1,R0            COPY AND TEST LENGTH LEFT             17639000
         BM    XSRUNOUT           RUNOUT IF NO CHARACTERS LEFT          17640000
         LR    A1,R1              COPY CURRENT SCAN LOCATION            17641000
         AR    A1,A1+1            POINT TO LAST CHARACTER               17642000
         LA    R0,256             GET STANDARD CONSTANT                 17643000
*                                                                       17644000
*        LOOP TO TRT OVER MORE THAN 256 CHARACTERS                      17645000
*                                                                       17646000
XSTLP    CR    A1+1,R0            TEST FOR SIZE OF TRT NEEDED           17647000
         BL    XSSML              SKIP IF <= 256 CHARACTERS             17648000
         TRT   0(256,R1),ZTBL     SCAN OUT                              17649000
         BNZ   XSFND              EXIT OF STOP CHARACTER FOUND          17650000
         AR    R1,R0              PUSH TRT SCAN LOCATION                17651000
         SR    A1+1,R0            DECREMENT LENGTH LEFT                 17652000
         B     XSTLP              AND BACK TO TEST LENGTH LEFT          17653000
*                                                                       17654000
*        COME HERE IF <= 256 CHARACTERS LEFT IN ARGUMENT                17655000
*                                                                       17656000
XSSML    EX    A1+1,SCNTRT        DO FINAL TRT                          17657000
         BZ    XSRUNOUT           SKIP IF NO STOP CHARACTER FOUND       17658000
         EJECT                                                          17659000
*                                                                       17660000
*        COME HERE WHEN STOP CHARACTER FOUND                            17661000
*                                                                       17662000
XSFND    L     A1+1,XSCANSV+4     LOAD INITIAL SCAN LOCATION            17663000
         LR    R0,A1+1            COPY IT FOR LATER                     17664000
         SR    R0,R1              GET NEGATIVE LENGTH SCANED OUT        17665000
         LCR   R0,R0              GET POSITIVE LENGTH SCANED OUT        17666000
         BCTR  R0,0               GET 360 LENGTH                        17667000
         SR    A1,R1              GET CHARACTERS LEFT IN STRING         17668000
         ST    A1,XSCANSV         SAVE FOR NEXT CALL                    17669000
         L     A1,TEM#1(,PDR)     GET STRING BASE                       17670000
         SR    A1+1,A1            GET OFFSET+SCHARS IN SCAN START       17671000
         SH    A1+1,=Y(SCHARS)    FUDGE FOR SCHARS                      17672000
         SLL   A1+1,16            POSITION OFFSET ON LEFT               17673000
         ALR   A1+1,R0            AND ADD IN LENGTH                     17674000
         LR    A2+1,R2            SAVE SCAN STOP CHARACTER              17675000
         AH    R1,H1              PUSH SCAN PAST STOP CHARACTER,SV TYPE 17676000
         ST    R1,XSCANSV+4       SAVE FOR NEXT SCAN CALL               17677000
         LTR   R0,R0              WAS STRING SCANNED OUT NULL?          17678000
         BCR   M,RETURN           GIVE APPROPRIATE RETURN IF SO         17679000
         TM    XSCANFLG,XSIGNGN   SHOULD WE DO GETNAME CALL?            17680000
         BO    8(,RETURN)         EXIT IF NOT                           17681000
         LA    RETURN,4(,RETURN)  FUDGE FOR RETURN FROM GETNAME         17682000
         B     GETNAME            AND CALL GETNAME, RETURN TO CALLER    17683000
*                                                                       17684000
*        COME HERE ON RUNOUT                                            17685000
*                                                                       17686000
XSRUNOUT LA    A1+1,1(,A1+1)      GET REAL LENGTH LEFT IN STRING        17687000
         AR    R1,A1+1            POINT PAST LAST CHARACTER             17688000
         TM    XSCANFLG,XSIGNRO   SHOULD WE IGNORE RUNOUT?              17689000
         BO    XSFND              TREAT AS IF FOUND STOP CHAR IF SO     17690000
         B     4(,RETURN)         AND TAKE RUNOUT RETURN                17691000
*                                                                       17692000
SCNTRT   TRT   0(*-*,R1),ZTBL     DO VAR LENGTH TRT                     17693000
         EJECT                                                          17694000
*                                                                       17695000
*        INITIAL CALL TO SCAN COMES HERE                                17696000
*                                                                       17697000
*        NOTE - IF CHARACTERS OTHER THAN (),: CAN BE LEFT IN ZTBL       17698000
*        ON AN ERROR CALL FIX ERROR ROUTINE APPROPRIATELY               17699000
*        GETNAME CALS MUST NOT BE PERMITTED FOR USERS WHO CAN'T GBGCLF! 17700000
*                                                                       17701000
*        TEM#1                    SCAN ARGUMENT                         17702000
*        BAL   A2+1,XSCANI        CALL ROUTINE                          17703000
*        ->    RETURN FOR NON STRING ARGUMENT                           17704000
*        ->    RETURN FOR NULL STRING ARGUMENT                          17705000
*        (A2)  POINTER TO XSCAN FOR NEXT CALLS                          17706000
*                                                                       17707000
XSCANIC  CLI   TEM#1(PDR),NCODE   IS ARGUMENT NULL?                     17708000
         BE    4(,A2+1)           TAKE NULL RETURN IF SO                17709000
         LM    A1,A1+1,TEM#1(PDR) LOAD SCAN ARGUMENT                    17710000
         BAL   RETURN,GETSTG      CONVERT IT TO STRING                  17711000
         BR    A2+1               TAKE ERROR RETURN IF NOT POSSIBLE     17712000
         NOPR  0                  FILLER FOR ERROR RETURN               17713000
         STM   A1,A1+1,TEM#1(PDR) RESTORE SCAN ARGUMENT AS STRING       17714000
         AH    A1,TEM#1+SOFFSET(,PDR)       ADD IN OFFSET               17715000
         AH    A1,=Y(SCHARS)      ADD IN SCHARS OFFSET, SAVE SCODE      17716000
         ST    A1,XSCANSV+4       SAVE FOR NEXT SCAN LOCATION           17717000
         LH    A1+1,TEM#1+SLENGTH(,PDR)     LOAD 360 LENGTH             17718000
         LA    A1+1,1(,A1+1)      GET REAL LENGTH LEFT                  17719000
         ST    A1+1,XSCANSV       SAVE LENGTH LEFT                      17720000
         MVI   XSCANFLG,0         INITIALIZE FLAG FOR SCAN ROUTINE      17721000
         B     8(,A2+1)           TAKE NORMAL EXIT                      17722000
         DROP  A2                 DON'T NEED THIS BASE REGISTER ANYMORE 17723000
         TITLE 'SPITBOLX -- ROUTINE TO ORDER TABLE ELEMENTS'            17724000
*                                                                       17725000
*        THIS ROUTINE IS USED TO COUNT AND CHRONOLOGICALLY LINK THE     17726000
*        NON NULL ELEMENTS IN A TABLE                                   17727000
*                                                                       17728000
*        REGISTERS USED           R0,R1,R2,A1,A1+1,A2,RETURN            17729000
*        (A1)                     TABLE ADDRESS                         17730000
*        BAL   RETURN,TBCHRON     CALL OF SYSTEM ENTRY POINT            17731000
*        ->    RETURN FOR NO NON-NULL ELEMENTS FOUND                    17732000
*        (A1+1)                   COUNT OF NON-NULL ELEMENTS            17733000
*        TBCHRSV                  CHAIN OF TEBLOKS                      17734000
*                                 GBG FIELD IS USED FOR CHAIN           17735000
*                                 THE BLOCK CODES HAVE BEEN CLEARED     17736000
*        (RETURN)                 POINTS TO A ROUTINE TO CLEAR THE GBG  17737000
*                                 FIELDS, RESTORE BLOCK CODES, AND EXIT 17738000
*                                 TO GBGCLF FOR RECALL OF USER          17739000
*                                 RETURN IS SET UP ONLY IF NON-NULL     17740000
*                                 ELEMENTS EXIST                        17741000
*                                                                       17742000
*        THIS ROUTINE WORKS BY USING THE OBSERVATION THAT THE ORDER IN  17743000
*        WHICH THE ENTRIES WERE CREATED CORRESPONDS TO THE ORDER IN     17744000
*        WHICH THE TEBLOK'S APPEAR IN FREE CORE. THERE ARE TWO PASSES,  17745000
*                                                                       17746000
*        1)    MARK ALL NON-NULL TEBLOK'S IN THE TABLE BY SETTING       17747000
*              BYTE 2 OF THE GARBAGE COLLECTION FIELD TO X'80'          17748000
*                                                                       17749000
*        2)    SCAN THROUGH FREE CORE LINEARLY STARTING WITH THE        17750000
*              BLOCK JUST BEYOND THE TBLOK AND CHAINING TEBLOK'S UP     17751000
*              UNTIL THE CORRECT NUMBER (FOUND IN PASS 1) ARE LINKED.   17752000
*                                                                       17753000
         USING TBCHRONC,A2        TELL ASSEMBLER OF BASE REGISTER       17754000
TBCHRONC ST    A1,TBCHRSV         SAVE TABLE ADDRESS                    17755000
         L     R1,TBDIVIDE(,A1)   LOAD NUMBER OF SLOTS * 4              17756000
         AR    R1,A1              GET BXLE END ADDRESS                  17757000
         LA    R0,4               GET BXLE INCREMENT                    17758000
         SR    A1+1,A1+1          INITIALIZE COUNT OF NON-NULL ELEMENTS 17759000
         B     TBCHRON3           AND MAKE INITIAL LOOP ENTRY           17760000
*                                                                       17761000
*        COME HERE TO CHECK FOR NULL VALUED ELEMENT                     17762000
*                                                                       17763000
TBCHRON1 CLI   TEVALUE(R2),NCODE  IS THIS ELEMENT NULL?                 17764000
         BE    *+10               SKIP COUNT AND MARK IF SO             17765000
         MVI   1(R2),X'80'        MARK THE BLOCK AS PART OF THIS TABLE  17766000
         BCTR  A1+1,0             AND COUNT THE ELEMENT                 17767000
         L     R2,TLINK(,R2)      MOVE OUT ON THE LINK                  17768000
*                                                                       17769000
*        COME HERE TO TEST FOR END OF LINK (ZERO)                       17770000
*                                                                       17771000
TBCHRON2 LTR   R2,R2              IS THIS END OF LINK?                  17772000
         BNZ   TBCHRON1           BACK TO CHECK VALUE IF NOT            17773000
         EJECT                                                          17774000
*                                                                       17775000
*        COME HERE TO MOVE TO NEXT SLOT                                 17776000
*                                                                       17777000
TBCHRON3 L     R2,TBLPTRS(,A1)    LOAD NEXT SLOT POINTER                17778000
         BXLE  A1,R0,TBCHRON2     OFF TO CHECK FOR LINK END IF ONE      17779000
         LPR   A1+1,A1+1          GET POSITIVE ELEMENT COUNT,TEST       17780000
         BCR   Z,RETURN           OFF TO CALLER IF NO ELEMENTS          17781000
         L     A1,TBCHRSV         RESTORE TABLE ADDRESS                 17782000
         LA    R1,TBCHRSV         INITIALIZE LINK POINTER               17783000
         LR    R0,A1+1            COPY COUNT OF NON-NULL ELEMENTS       17784000
*                                                                       17785000
*        COME HERE TO SKIP PAST UNMARKED BLOCK, AND INITIALLY THE TABLE 17786000
*                                                                       17787000
TBCHRON4 SR    R2,R2              CLEAR FOR IC                          17788000
         IC    R2,DTYPE(,A1)      GET BLOK TYPE TO SLECT LENGTH ROUTINE 17789000
         EX    0,BLOKLEN(R2)      GET BLOCK LENGTH IN (R2)              17790000
         AR    A1,R2              SKIP OVER BLOCK                       17791000
         CLI   1(A1),X'80'        IS THIS BLOCK MARKED?                 17792000
         BNE   TBCHRON4           SKIP PAST IT IF NOT                   17793000
         ST    A1,0(,R1)          ENTER THIS ELEMENT ON CHAIN           17794000
         LR    R1,A1              SET UP FOR NEXT CHAIN ENTRY           17795000
         BCT   R0,TBCHRON4        LOOP BACK IF MORE ELEMENTS LEFT       17796000
         STE   ZR,DTYPE(,R1)      CLEAR LINK OF LAST BLOCK FOR EASY     17797000
*                                 END OF LINK TEST                      17798000
         BAL   RETURN,4(,RETURN)  RETURN PAST NULL TABLE EXIT           17799000
         DROP  A2                 DONE WITH THIS BASE REGISTER          17800000
         USING *,RETURN           BASE REGISTER SET BY CALLER           17801000
*                                                                       17802000
*        COME HERE TO CLEAR THE GBG FIELDS AND RESTORE TYPE CODES       17803000
*                                                                       17804000
         L     R1,TBCHRSV         LOAD LINK HEAD                        17805000
         L     R0,TEBLOKBT        LOAD TEBLOK GBGFIELD                  17806000
*                                                                       17807000
*        LOOP TO MOVE OUT ON CHAIN, AND ZERO GBG FIELD                  17808000
*                                                                       17809000
TBCHRON5 L     R2,0(,R1)          LOAD ADDRESS OF NEXT ELEMENT          17810000
         ST    R0,0(,R1)          CLEAR GBG FIELD                       17811000
         LTR   R1,R2              COPY POINTER AND TEST FOR END         17812000
         BNZ   TBCHRON5           LOOP BACK IF NOT AT LINK END          17813000
         B     GBGCLF             AND DO FUNCTION GBG CALL              17814000
         DROP  RETURN             DONE WITH THIS BASE REGISTER          17815000
         TITLE 'SPITBOLX -- SYSTEM OPSYN ROUTINE'                       17816000
*                                                                       17817000
*        THIS ROUTINE IS CALLED WHENEVER A FUNCTION ADDRESS IS TO BE    17818000
*        INSERTED INTO A VARIABLE BLOCK IN ORDER TO HANDLE EXTERNAL     17819000
*        FUNCTIONS PROPERLY.                                            17820000
*                                                                       17821000
*        (A1)                     VARIABLE BLOCK ADDRESS                17822000
*        (A1+1)                   FUNCTION ADDRESS TO BE INSERTED       17823000
*        BAL   RETURN,OPSYN$      CALL ROUTINE                          17824000
*        (A1)                     UNCHANGED                             17825000
*        (A1+1)                   UNCHANGED                             17826000
*        (A2)                     BASE REGISTER - POINTS TO ENTRY PT    17827000
*        (R2)                     OLD FUNCTION ADDRESS                  17828000
*                                                                       17829000
         USING OPSYN$C,A2         TELL ASSEMBLER OF BASE REGISTER       17830000
OPSYN$C  L     R2,VFUNC(,A1)      SAVE OLD FUNCTION ADDRESS             17831000
         CLC   FCODE(4,R2),EFBLOKI          CHECK FOR EFBLOK            17832000
         BNE   OPSYN1             NO SPECIAL HANDLING IF NOT            17833000
         SR    R0,R0              CLEAR FOR IC                          17834000
         IC    R0,EFUSE(,R2)      GET CURRENT USE COUNT                 17835000
         BCT   R0,OPSYN2          SKIP IF NO UNLOAD NEEDED              17836000
*                                                                       17837000
*        THE FOLLOWING TEST AVOIDS UNLOADING AN EXTERNAL FUNCTION       17838000
*        WHOSE USE COUNT IS ONE ON A CALL OF THE TYPE OPSYN(.F,.F)      17839000
*                                                                       17840000
         LR    R0,R2              OLD FUNCTION ADDRESS                  17841000
         SR    R0,A1+1            NEW FUNCTION ADDRESS                  17842000
         N     R0,=X'00FFFFFF'    REMOVE UPPER BYTE                     17843000
         BZ    OPSYN2             SKIP UNLOAD IF OLD FUNC = NEW FUNC    17844000
*                                                                       17845000
*        HERE WE UNLOAD AN EXTERNAL MODULE                              17846000
*                                                                       17847000
         STM   A1,A1+1,OPSYNSV    SAVE REGS                             17848000
         L     R2,EFNAME(,R2)     LOAD POINTER TO FUNCTION NAME BLOCK   17849000
         L     A1,VNAME(,R2)      LOAD NAME POINTER                     17850000
         AH    A1,VNAME+SOFFSET(,R2)        ADD OFFSET                  17851000
         LA    A1,SCHARS(,A1)     POINT TO ACTUAL NAME                  17852000
         LH    A1+1,VNAME+SLENGTH(,R2)      LOAD 360 LENGTH OF NAME     17853000
         LA    A1+1,1(,A1+1)      GET REAL LENGTH                       17854000
         L     R2,=V(SYSUNLOD)    POINT TO UNLOAD ROUTINE               17855000
         BALR  R1,R2              CALL UNLOAD ROUTINE                   17856000
         B     SYSERROR           GIVE ERROR IF ONE IS SIGNALLED        17857000
         LM    A1,A1+1,OPSYNSV    ELSE RELOAD REGS                      17858000
         L     R2,VFUNC(,A1)      RELOAD OLD FUNCTION ADDRESS           17859000
         EJECT                                                          17860000
*                                                                       17861000
*        COME HERE TO STORE DECREMENTED USE COUNT, NOTE THAT NO HARM    17862000
*        IS DONE BY STORING A GARBAGE VALUE IN UNLOADED BLOCKS          17863000
*                                                                       17864000
OPSYN2   STC   R0,EFUSE(,R2)      SAVE NEW VALUE OF USE COUNT           17865000
*                                                                       17866000
*        COME HERE AFTER DEALING WITH POSSIBLE EXTERNAL FUNCTION        17867000
*                                                                       17868000
OPSYN1   IC    R0,VFUNC(,A1)      SAVE UPPER BYTE OF FUNCTION WORD      17869000
         ST    A1+1,VFUNC(,A1)    SAVE NEW FUNCTION ADDRESS             17870000
         STC   R0,VFUNC(,A1)      RESTORE UPPER BYTE                    17871000
         CLC   FCODE(4,A1+1),EFBLOKI        IS NEW FUNCTION EXTERNAL?   17872000
         BCR   NE,RETURN          RETURN IF NOT                         17873000
         IC    R1,EFUSE(,A1+1)    LOAD CURRENT USE COUNT                17874000
         LA    R1,1(,R1)          INCREASE IT BY ONE (HOPE ITS LE 254)  17875000
         STC   R1,EFUSE(,A1+1)    STORE NEW USE COUNT IN BLOCK          17876000
         BR    RETURN             AND RETURN TO CALLER                  17877000
         DROP  A2                 GET RID OF BASE REGISTER              17878000
*                                                                       17879000
*        THE FOLLOWING INSTRUCTION IS THE FIRST INSTRUCTION (AT FCODE)  17880000
*        IN ALL EXTERNAL FUNCTION BLOCKS. NO OTHER FUNCTION BLOCKS      17881000
*        START WITH THIS CODE PERMITTING EASY IDENTIFICATION            17882000
*                                                                       17883000
EFBLOKI  B     $$LOAD             FIRST INSTRUCTION IN EFBLOK           17884000
         TITLE 'SPITBOLX -- FAILURE RETURN FOR EVAL'                    17885000
*                                                                       17886000
*        THIS CODE IS CALLED ON A FAILURE RETURN FROM A DEFERRED EXPR   17887000
*                                                                       17888000
DEFFAIL  L     R1,EVLINK(,PDR)    RESTORE LINKAGE REGISTER              17889000
         L     R2,PDRBPTR(,PDR)   GET REAL PDR ABOVE US                 17890000
         ST    R2,PDRLOC          AND SAVE IT FOR THIS LEVEL            17891000
         SPM   R1                 FIND OUT WHO CALLED US                17892000
         BCR   NE,R1              OFF TO CALLER IF NOT PAT MATCH        17893000
         ST    FR,FRSAVE          SAVE NEW FR                           17894000
         L     R0,RETLOCP(,R2)    GET RETURN ADDRESS FOR MATCH ERRORS   17895000
         ST    R0,RETLOC          SAVE FOR ERR MSG ROUTINE              17896000
         LA    PDR,PATSPACE(,PDR) RESTORE STACK POINTER                 17897000
         LM    BPS,PBASE,PSAVBPS(PDR)       RESTORE ALL REGS            17898000
         L     FSADR,PSTRING(,R2) RESTORE STRING ADDRESS                17899000
         AH    FSADR,PSTRING+SOFFSET(,R2)   ADD IN OFFSET               17900000
         AH    FSADR,PSTRING+SLENGTH(,R2)   ADD IN 360 LENGTH           17901000
         LA    FSADR,SCHARS+1(,FSADR)       POINT TO LAST CHARACTER     17902000
         BR    R1                 RETURN TO FAILURE POINT               17903000
*                                                                       17904000
*        THIS CODE IS FOR PAT MATCH WRITES - AUR IS SHARED WITH READ    17905000
*                                                                       17906000
EVALWRIT EQU   *                  START OF DUMMY EXPRESSION CODE        17907000
         L     A2,EVALVAR         RESTORE VARIABLE BLOCK ADDRESS        17908000
         LM    A1,A1+1,VALUE(A2)  RESTORE OUTPUT VALUE                  17909000
         BAL   RETURN,WRIT        DO OUTPUT W/O ST IN RETLOC            17910000
         B     $$EVLR             AND RETURN SUCCESSFULLY               17911000
*                                                                       17912000
*        THIS CODE IS A DUMMY EXPRESSION FOR DEFFERED READS             17913000
*                                                                       17914000
EVALREAD EQU   *                  START OF DUMMY CODE                   17915000
         L     A2,EVALVAR         RESTORE VARIABLE BLOCK ADDRESS        17916000
         BAL   RETURN,$$READ      DO THE READ                           17917000
         B     $$EVLR             AND RETURN SUCCESSFULLY               17918000
         AUR   SCNT,SINC          END OF STATEMENT FOR GBG COLLECTOR    17919000
         TITLE 'SPITBOLA -- START OF CONTROL SECTION'                   17920000
*                                                                       17921000
*        THIS CONTROL SECTION CONTAINS EXECUTION ROUTINES WHICH         17922000
*        ARE ADDRESSABLE UNDER THE SYS BASE REGISTER                    17923000
*                                                                       17924000
         BEGIN A                  START OF SPITBOLA, SPITBLLA CSECT     17925000
         USING SPITBOLA,SYS       BASE REG USED THROUGHOUT              17926000
*                                                                       17927000
*        THE FOLLOWING ROUTINE TO CALL THE ERROR MESSAGE PRINTER MUST   17928000
*        BE AT THIS LOCATION, SINCE IT IS CALLED BY A BALR ON SYS       17929000
*                                                                       17930000
         L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE              17931000
         USING DTERTNS,DB4        TELL ASSEMBLER                        17932000
         TM    0(RETURN),X'80'    CHECK SPECIAL FLAG BIT                17933000
         BNO   EXERR              JUMP IF NOT SET                       17934000
*                                                                       17935000
*        COME HERE IF THE SIGN BIT IS SET. THIS FLAG IS SET IN THE      17936000
*        PARAMETERS OF THE XERR CALL WHICH IS SUBSTITUTED IN THE CODE   17937000
*        WHEN AN ERROR OCCURS DURING EVALUATION OF CONSTANT EXPRESSIONS 17938000
*        THIS BIT ENSURES THAT RETURN GETS STORED PROPERLY IN THIS CASE 17939000
*                                                                       17940000
         ST    RETURN,RETLOC      STORE RETURN POINT                    17941000
         B     EXERR              AND THEN JUMP TO ERROR ROUTINE        17942000
*                                                                       17943000
*        THIS IS THE ENTRY TO THE EXECUTION ERROR MESSAGE ROUTINE       17944000
*        WHICH STORES THE RETURN LOCATION FIRST                         17945000
*                                                                       17946000
EXERRS   ST    RETURN,RETLOC      STORE RETURN LOCATION                 17947000
         L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE REGISTER     17948000
         BCT   R1,EXERRCC         MERGE AS REAL ERROR, FIXING (R1)      17949000
         DROP  DB4                DROP BASE REGISTER                    17950000
*                                                                       17951000
*        EXIT HERE ON ERRORS SIGNALLED BY SYSTEM INTERFACE              17952000
*        IN ALL CASES, (R0) CONTAINS THE ERROR CODE                     17953000
*                                                                       17954000
SYSERROR STC   R0,SYSERCOD+3      SAVE MINOR ERROR CODE                 17955000
         MVI   SYSERCOD+2,12      SET PROPER MAJOR CODE                 17956000
         B     SYSERCOD           AND GO OFF TO ISSUE IT AS ERROR MSG   17957000
         TITLE 'SPITBOLA -- CODE BYTE CONSTANTS'                        17958000
*                                                                       17959000
*        THESE CONSTANTS ARE USED TO SUPPLY THE UPPER BYTES OF DATA     17960000
*        ITEMS --                                                       17961000
*                                                                       17962000
         CNOP  0,4                ALLIGN TO FULL WORD BOUNDARY          17963000
NCODEBT  DC    AL1(NCODE,0,0,0)             NULL                        17964000
*                                                                       17965000
SCODEBT  DC    AL1(SCODE,0,0,0)             STRING                      17966000
*                                                                       17967000
PCODEBT  DC    AL1(PCODE,0,0,0)             PATTERN                     17968000
*                                                                       17969000
ACODEBT  DC    AL1(ACODE,0,0,0)             ARRAY                       17970000
*                                                                       17971000
MCODEBT  DC    AL1(MCODE,0,0,0)             NAME                        17972000
*                                                                       17973000
TCODEBT  DC    AL1(TCODE,0,0,0)             TABLE                       17974000
*                                                                       17975000
RCODEBT  DC    AL1(RCODE,0,0,0)             REAL                        17976000
*                                                                       17977000
ECODEBT  DC    AL1(ECODE,0,0,0)             EXPRESSION                  17978000
*                                                                       17979000
VCODEBT  DC    AL1(VCODE,0,0,0)             *VARIABLE                   17980000
*                                                                       17981000
DCODEBT  DC    AL1(DCODE,0,0,0)             PROG DEF DATATYPE           17982000
*                                                                       17983000
WCODEBT  DC    AL1(WCODE,0,0,0)             DREAL                       17984000
*                                                                       17985000
*                                                                       17986000
$$NULL   EQU   NCODEBT            NULL CONSTANT FOR GENERATED CODE      17987000
$$MCOD   EQU   MCODEBT            MCODE CONSTANT FOR GENERATED CODE     17988000
*                                                                       17989000
*        POINTER TO GET SCODE TYPE NAMES FROM INITV TABLES              17990000
*                                                                       17991000
INITVPTR DC    AL1(SCODE)         TYPE CODE FOR STRINGS                 17992000
         DC    AL3(INITVR1+1-SCHARS)        STG BASE PTR FOR INITV NAME 17993000
*                                                                       17994000
*        HEADER FOR TEBLOCK USED FOR CLEARING AFTER TBCHRON IS USED     17995000
*                                                                       17996000
TEBLOKBT DC    A(TEBLOK*256*256*256)        GBGCL FIELD FOR TEBLOK      17997000
         TITLE 'SPITBOLA -- CONCATENATION ENTRY POINT'                  17998000
*                                                                       17999000
*        $$CNC2                   CONCATENATION ROUTINE                 18000000
*                                                                       18001000
*        THIS ROUTINE IS CALLED FROM THE GENERATED CODE TO CONCATENATE  18002000
*        STRINGS AND/OR PATTERNS                                        18003000
*                                                                       18004000
*                                                                       18005000
*        (A1,A1+1)                LEFT ARG                              18006000
*        (A2,A2+1)                RIGHT ARG                             18007000
*        BAL   RETURN,$$CNC2                                            18008000
*        (A1,A1+1)                CONCATENATED RESULT                   18009000
*                                                                       18010000
*        THE ALLOWABLE ARGUMENTS ARE AS FOLLOWS (WITH THEIR RESULTS)    18011000
*                                                                       18012000
*        INTEGER/INTEGER          STRING                                18013000
*        INTEGER/REAL             STRING                                18014000
*        INTEGER/STRING           STRING                                18015000
*        INTEGER/PATTERN          PATTERN                               18016000
*        INTEGER/EXPRESSION       PATTERN                               18017000
*        REAL/REAL                STRING                                18018000
*        REAL/STRING              STRING                                18019000
*        REAL/PATTERN             PATTERN                               18020000
*        REAL/EXPRESSION          PATTERN                               18021000
*        STRING/STRING            STRING                                18022000
*        STRING/PATTERN           PATTERN                               18023000
*        STRING/EXPRESSION        PATTERN                               18024000
*        PATTERN/PATTERN          PATTERN                               18025000
*        PATTERN/EXPRESSION       PATTERN                               18026000
*        EXPRESSION/EXPRESSION    PATTERN                               18027000
*        ANYTHING/NULL            ANYTHING                              18028000
         EJECT                                                          18029000
$$CNC2   ST    RETURN,RETLOC      SAVE RETURN LOCATION                  18030000
*                                                                       18031000
*        FIRST TEST FOR COMMON CASE OF BOTH ARGUMENTS STRINGS           18032000
*                                                                       18033000
         STM   FR,A2+1,CONCATSF   SAVE FR AND ARGS FOR TESTS            18034000
         CLI   CONCATSV,SCODE     CHECK FOR FIRST ARG STRING            18035000
         BNE   CONCAT2            SKIP IF FIRST ARG NOT STRING          18036000
         CLI   CONCATSV+8,SCODE   CHECK SECOND ARG FOR STRING           18037000
         BE    CONCATS            SKIP IF SECOND ARG IS A STRING        18038000
*                                                                       18039000
*        NOW TEST FOR CASES WHERE ONE ARGUMENT IS NULL                  18040000
*                                                                       18041000
CONCAT2  CLI   CONCATSV+8,NCODE   IS SECOND ARG NULL?                   18042000
         BCR   E,RETURN           IF SO, RETURN FIRST ARG AS RESULT     18043000
         CLI   CONCATSV,NCODE     IS FIRST ARGUMENT NULL?               18044000
         BNE   CONCAT3            SKIP IF NOT                           18045000
         LR    A1,A2              IF FIRST ARG IS NULL, MOVE            18046000
         LR    A1+1,A2+1               2ND ARG TO A1 AS RESULT          18047000
         BR    RETURN             AND RETURN                            18048000
*                                                                       18049000
*        NOW TEST FOR CASES WHERE ARGS CAN BE CONVERTED TO STRINGS      18050000
*                                                                       18051000
CONCAT3  ST    RETURN,CRETSAVE    STORE RETURN LOCATION                 18052000
         BAL   RETURN,GETSTG      TRY TO CONVERT TO STRING              18053000
         B     CONCATP            GO TO PATTERN CASE ON CONVERT ERROR   18054000
         STM   A1,A1+1,CONCATSV   STORE FIRST ARGUMENT                  18055000
         LR    A1,A2              LOAD SECOND ARGUMENT                  18056000
         LR    A1+1,A2+1               INTO FIRST ACCUMULATOR           18057000
         BAL   RETURN,GETSTG      TRY TO CONVERT TO STRING              18058000
         B     CONCATP            SKIP TO PATTERN CASE ON CONVERT ERROR 18059000
         L     RETURN,CRETSAVE    RELOAD RETURN LOCATION                18060000
         LR    A2,A1              MOVE STRING POINTER                   18061000
         LR    A2+1,A1+1          FINISH POSITIONING 2ND ARG            18062000
         LM    A1,A1+1,CONCATSV   RELOAD ARG 1 -- MERGE SCONC           18063000
         EJECT                                                          18064000
*                                                                       18065000
*        SCONC IS THE ENTRY USED TO CONCATENATE STRINGS IN THE PATTERN  18066000
*        REPLACEMENT ROUTINE --                                         18067000
*                                                                       18068000
*        (A1,A1+1)                LEFT ARG                              18069000
*        (A2,A2+1)                RIGHT ARG                             18070000
*        BAL   RETURN,SCONC                                             18071000
*        (A1,A1+1)                SPECIFIER FOR CONCATENATED RESULT     18072000
*                                                                       18073000
SCONC    STM   FR,A2+1,CONCATSF   SAVE FR, ARGS -- MERGE CONCATS        18074000
*                                                                       18075000
*        AT THIS STAGE WE HAVE TO CONCATENATE TWO STRINGS               18076000
*        THE SPECIFIERS FOR THE STRINGS ARE IN CONCATSV AND A1,A2+1     18077000
*                                                                       18078000
*        NOTE THAT THIS CASE IS TESTED FOR FIRST TO SPEED IT UP         18079000
*        SINCE IT IS PROBABLY THE MOST COMMON                           18080000
*                                                                       18081000
*                                                                       18082000
*        REENTER HERE WHEN WE HAD TO DO A GARBAGE COLLECTION            18083000
*                                                                       18084000
*                                                                       18085000
CONCATS  LH    A1+1,SLENGTH+CONCATSV        LOAD 1ST ARG LENGTH         18086000
         LH    A2+1,SLENGTH+CONCATSV+8      LOAD 2ND ARG LENGTH         18087000
         LA    R2,1(A1+1,A2+1)    CALCULATE NEW LENGTH                  18088000
         AH    A2,CONCATSV+SOFFSET+8        PNT TO 1ST CHAR OF 2ND ARG  18089000
         LA    R0,256             CRANK CONSTANT FOR LONG STRINGS       18090000
         C     R2,V$MAXLN         CHECK AGAINST MAXIMUM LENGTH          18091000
         BL    CONCATS1           SKIP IF OK                            18092000
         CLI   CONCATSV,PCODE     ELSE WAS THIS PATTERN CASE?           18093000
         BE    *+8                SKIP IF SO                            18094000
         XERR  11,007             CONCATENATION RESULTED IN THE         18095000
*                                 FORMATION OF A STRING MORE THAN       18096000
*                                 &MAXLNGTH CHARACTERS LONG             18097000
         CH    R2,=X'7FFF'        FOR PATTERN, CHECK AGAINST 32K        18098000
         BL    CONCATS2           AND SKIP IF OK - NO OPT HERE          18099000
*                                                                       18100000
*        HERE FOR PATTERN > 32K (MERGE FROM OPTIMIZATION CIRCUIT)       18101000
*                                                                       18102000
PSIZERR  XERR  11,008             A PATTERN STRUCTURE HAS EXCEEDED THE  18103000
*                                 MAXIMUM PERMITTED SIZE (32K BYTES)    18104000
*                                                                       18105000
*        NOW TEST FOR CASE OF LEFT ARGUMENT THE SAME AS THE RESULT      18106000
*        WE GENERATED ON THE PREVIOUS CALL -- THIS IS SO THAT WE CAN    18107000
*        AVOID NEEDLESS COPIES BY USING THE SBLOK AS IT IS              18108000
*                                                                       18109000
CONCATS1 CLC   CONCATSF(4+8),CONCFRSV       CHECK FR,A1,A1+1 WI OLD VLS 18110000
         BNE   CONCATS2           SKIP IF NOT ALL EQUAL                 18111000
         EJECT                                                          18112000
*                                                                       18113000
*        STRING CONCATENATION (SCONC,CONCATS) -- CONTINUED              18114000
*                                                                       18115000
*                                                                       18116000
*        COME HERE FOR THE SPECIAL CASE OF THE LEFT ARGUMENT IDENTICAL  18117000
*        TO THE RESULT RETURNED LAST TIME -- IN THIS CASE -- JUST       18118000
*        ADD THE RIGHT ARGUMENT ON TO THE EXISTING BLOCK                18119000
*                                                                       18120000
         LA    R1,SCHARS+BOUND+1(A1,R2)     SEE WHERE FR WILL END UP    18121000
         LA    FR,0(A1,A1+1)      GET NEW LENGTH                        18122000
         CR    R1,PDR             DO WE HAVE ENOUGH CORE?               18123000
         BL    CONCATLN           SKIP IF ROOM                          18124000
         L     FR,CONCATSF        ELSE RESTORE FR AND MERGE             18125000
*                                                                       18126000
*        GARBAGE COLLECT HERE IF INSUFFICIENT CORE                      18127000
*                                                                       18128000
CONCATLG LM    A1,A2+1,CONCATSV   RESTORE ARGUMENTS                     18129000
         ST    RETURN,CRETSAVE    SAVE RETURN LOCATION                  18130000
         BAL   RETURN,GBGCL2      COLLECT, SAVING BOTH ARGUMENTS        18131000
         STM   A1,A2+1,CONCATSV   STORE RELOCATED POINTERS              18132000
         L     RETURN,CRETSAVE    RELOAD RETURN LOCATION                18133000
         B     CONCATS            AND JUMP BACK TO TRY AGAIN            18134000
*                                                                       18135000
*        COME HERE FOR NORMAL CASE OF BOTH ARGUMENTS REQUIRE COPYING    18136000
*                                                                       18137000
CONCATS2 LA    R1,SCHARS+BOUND+1(FR,R2)     SEE WHERE FR WILL END UP    18138000
         CR    R1,PDR             CHECK IF WE HAVE ROOM                 18139000
         BNL   CONCATLG           SKIP BACK IF NOT                      18140000
*                                                                       18141000
*        AT THIS POINT WE ARE ALL SET FOR CONCATENATION AND CONSTRUC-   18142000
*        TION OF A NEW SBLOK.                                           18143000
*                                                                       18144000
CONCATL2 AH    A1,CONCATSV+SOFFSET          POINT TO FIRST CHAR         18145000
         LR    R1,FR              SAVE START OF NEW BLOCK               18146000
         CR    A1+1,R0            CHECK NUMBER OF CHARS LEFT IN 1ST ARG 18147000
         BL    CONCATL4           SKIP IF 256 OR LESS                   18148000
*                                                                       18149000
*        THIS IS THE LOOP TO MOVE THE FIRST ARGUMENT IN 256 BYTE CHUNKS 18150000
*                                                                       18151000
CONCATL3 MVC   SCHARS(256,FR),SCHARS(A1)    ELSE MOVE NEXT 256 CHARS    18152000
         AR    A1,R0              BUMP SOURCE POINTER                   18153000
         AR    FR,R0              BUMP DESTINATION POINTER              18154000
         SR    A1+1,R0            DECREMENT COUNT OF CHARS LEFT         18155000
         CR    A1+1,R0            STILL MORE THAN 256 CHARS TO GO?      18156000
         BNL   CONCATL3           LOOP BACK IF YES                      18157000
         EJECT                                                          18158000
*                                                                       18159000
*        STRING CONCATENATION (SCONC,CONCATS) -- CONTINUED              18160000
*                                                                       18161000
*                                                                       18162000
*        COME HERE TO MOVE REMAINING PIECE OF FIRST ARGUMENT            18163000
*                                                                       18164000
CONCATL4 EX    A1+1,CNCTSM1       MOVE REMAINING CHARS                  18165000
         AR    FR,A1+1            BUMP FREE POINTER APPROPRIATELY       18166000
         LR    A1,R1              GET SBLOK START ADDRESS FOR RESULT    18167000
         A     A1,SCODEBT         SUPPLY CODE BYTE FOR STRING           18168000
         STE   ZR,GCOLPTR(,A1)    ZERO GCOL FLD, SET DTYPE=SBLOK=0      18169000
*                                                                       18170000
*        REENTER HERE FROM CASE OF LEFT ARG NOT RECOPIED                18171000
*                                                                       18172000
CONCATLN LR    A1+1,R2            GET NEW SLENGTH IN PROPER REG         18173000
         CR    A2+1,R0            HOW MANY CHARS LEFT?                  18174000
         BL    CONCATSL           IF <257, SHORT STG CIRCUIT COMPLETES  18175000
*                                                                       18176000
*        LOOP TO MOVE 2ND ARG IN CHUNKS OF 256 BYTES                    18177000
*                                                                       18178000
CONCATL5 MVC   SCHARS+1(256,FR),SCHARS(A2)  ELSE MOVE NEXT 256 CHARS    18179000
         AR    A2,R0              BUMP SOURCE POINTER                   18180000
         AR    FR,R0              BUMP DESTINATION POINTER              18181000
         SR    A2+1,R0            DECREMENT COUNT OF CHARS REMAINING    18182000
         CR    A2+1,R0            CHECK FOR MORE THAN 256 CHARS LEFT    18183000
         BNL   CONCATL5           SKIP BACK IF SO                       18184000
*                                                                       18185000
*        COME HERE TO MOVE REMAINING PIECE OF SECOND ARGUMENT           18186000
*                                                                       18187000
CONCATSL EX    A2+1,CNCTSM2       MOVE CHARS (REMAINING) OF 2ND ARG     18188000
         LA    R1,SCHARS+BOUND+1(,A1+1)     CALCULATE SBLOK LENGTH      18189000
         N     R1,FULLWRD         ADJUST TO PROPER BOUNDARY             18190000
         STH   R1,STLENGTH(,A1)   SET SBLOK LENGTH                      18191000
         LA    FR,0(A1,R1)        CALCULATE NEW FR LOCATION             18192000
         STM   FR,A1+1,CONCFRSV   SAVE FR,A1,A1+1 FOR REENTRY CHECK     18193000
         BR    RETURN             RETURN TO CALLER                      18194000
*                                                                       18195000
CNCTSM1  MVC   SCHARS(*-*,FR),SCHARS(A1)    MOVE CHARS OF FIRST ARG     18196000
CNCTSM2  MVC   SCHARS+1(*-*,FR),SCHARS(A2)  MOVE CHARS OF 2ND ARG       18197000
         EJECT                                                          18198000
*                                                                       18199000
*        WE COME HERE WHEN THE RESULT IS A PATTERN -- SET FLAG AND      18200000
*        MERGE WITH ALTERNATION ENTRY POINT                             18201000
*                                                                       18202000
*                                                                       18203000
CONCATP  L     RETURN,RETLOC      RELOAD RET LOC, MERGE PCONC           18204000
         LM    A1,A2+1,CONCATSV   RELOAD OPERANDS                       18205000
*                                                                       18206000
*        PCONC ENTRY TO PATTERN CONCATENATION USED BY DOLLAR AND DOT    18207000
*                                                                       18208000
*                                                                       18209000
*        (A1)                     POINTER TO FIRST PATTERN              18210000
*        (A2)                     POINTER TO SECOND PATTERN             18211000
*        BAL   RETURN,PCONC                                             18212000
*        (A1)                     RESULTING PATTERN                     18213000
*                                                                       18214000
PCONC    MVI   PATFLAG,X'FF'      SET FLAG FOR CONCATENATION            18215000
         B     CNCMR              JUMP TO MERGE                         18216000
         TITLE 'SPITBOLA -- ALTERNATION ENTRY POINT'                    18217000
*                                                                       18218000
*        $$ORP2                   ALTERNATION                           18219000
*                                                                       18220000
*        (A1,A1+1)                LEFT ARGUMENT                         18221000
*        (A2,A2+1)                RIGHT ARGUMENT                        18222000
*        BAL   RETURN,$$ORP2                                            18223000
*        (A1)                     RESULTING PATTERN                     18224000
*                                                                       18225000
*        THIS ROUTINE IS CALLED FROM THE GENERATED CODE TO GENERATE A   18226000
*        PATTERN WHICH IS THE ALTERNATION OF THE TWO ARGUMENTS          18227000
*                                                                       18228000
*        THE PERMISSIBLE ARGUMENTS ARE INTEGERS, REALS, STRINGS, NULL   18229000
*        PATTERNS AND EXPRESSIONS. BOTH ARGUMENTS ARE CONVERTED TO      18230000
*        PATTERNS IF NECCESSARY BEFORE ALTERNATION.                     18231000
*                                                                       18232000
$$ORP2   ST    RETURN,RETLOC      SAVE RETURN                           18233000
*                                                                       18234000
*        MERGE HERE FROM ARBNO TO BUILD ITS SPECIAL PATTERN             18235000
*                                                                       18236000
ORMAK    MVI   PATFLAG,X'00'      SET FLAG FOR ALTERNATION              18237000
*                                                                       18238000
*        PATTERN CONCATENATION MERGES HERE                              18239000
*                                                                       18240000
CNCMR    ST    RETURN,PRETLOC     SAVE RETURN LOCATION                  18241000
         BAL   RETURN,GETPAT      GET FIRST ARGUMENT AS PATTERN         18242000
         XERR  01,024             THE LEFT ARGUMENT FOR ALTERNATION     18243000
*                                 OR CONCATENATION IS NOT A STRING      18244000
*                                 OR PATTERN                            18245000
         ST    A1,CONCATSV        SAVE FIRST PATTERN POINTER            18246000
         LR    A1,A2              MOVE SECOND ARGUMENT                  18247000
         LR    A1+1,A2+1               TO A1                            18248000
         BAL   RETURN,GETPAT      GET SECOND ARG AS PATTERN             18249000
         XERR  01,025             THE RIGHT ARGUMENT TO CONCATENATION   18250000
*                                 OR ALTERNATION IS NOT A STRING        18251000
*                                 OR PATTERN                            18252000
         LR    A2,A1              MOVE 2ND ARG PATTERN PTR TO A2        18253000
         L     A1,CONCATSV        LOAD 1ST ARG PATTERN PTR TO A1        18254000
         L     RETURN,=A(PATSUB)  LOAD ROUTINE ADDRESS                  18255000
         BR    RETURN             OFF TO IT SETTING BASE                18256000
         TITLE 'SPITBOLA -- UNARY DOLLAR ENTRY POINTS'                  18257000
*                                                                       18258000
*        $$DL1V                   INDIRECT ADDRESSING BY VALUE          18259000
*                                                                       18260000
*        (A1,A1+1)                ARGUMENT                              18261000
*        BAL   RETURN,$$DL1V                                            18262000
*        (A1,A1+1)                INDIRECT VALUE                        18263000
*                                                                       18264000
$$DL1V   MVI   DOLLFLG,$BYVAL     SET FLAG FOR BY VALUE                 18265000
         L     R2,=A(DOLLC)       LOAD ROUTINE ADDRESS                  18266000
         BR    R2                 OFF TO IT                             18267000
*                                                                       18268000
*        $$DL1N                   INDIRECT ADDRESSING BY NAME           18269000
*                                                                       18270000
*        (A1,A1+1)                ARGUMENT                              18271000
*        BAL   RETURN,$$DL1N                                            18272000
*        (A1,A1+1)                NAME (ADDRESS) OF INDIRECT CONTENTS   18273000
*                                                                       18274000
$$DL1N   MVI   DOLLFLG,$BYNAM     SET FLAG FOR BY NAME                  18275000
         L     R2,=A(DOLLC)       LOAD ROUTINE ADDRESS                  18276000
         BR    R2                 OFF TO IT                             18277000
         TITLE 'SPITBOLA -- MISCELLANEOUS CONTROL ENTRY POINTS'         18278000
*                                                                       18279000
*                                                                       18280000
*        $$GOTO                   EXECUTE COMPLEX GOTO                  18281000
*                                                                       18282000
*        THE NAME IS IN (A1,A1+1). IT MUST BE A NATURAL VARIABLE TO BE  18283000
*        A LEGAL GOTO                                                   18284000
*                                                                       18285000
$$GOTO   L     R1,VLABL(,A1)      LOAD LABEL ADDRESS IN CASE            18286000
         LA    A1,0(,A1)          CLEAR POSSIBLE UPPER BYTE (MCODE)     18287000
         CR    A1,FR              ARE WE ABOVE DYNAMIC CORE             18288000
         BCR   H,R1               MAKE TRANSFER IF SO (NATURAL VAR)     18289000
         C     A1,DYNAMB          ARE WE BELOW DYNAMIC CORE?            18290000
         BCR   L,R1               NATURAL VARIABLE IF SO, TRANSFER      18291000
         XERR  08,005,S           NAME USED AS A GOTO OPERAND IS NOT    18292000
*                                 A NATURAL VARIABLE                    18293000
*                                                                       18294000
*        $$DGTO                   EXECUTE DIRECT GOTO                   18295000
*                                                                       18296000
*        (A1,A1+1)                VALUE OF DIRECT GOTO OPERAND          18297000
*        BAL   RETURN,$$DGTO                                            18298000
*                                                                       18299000
$$DGTO   ST    A1,TEM#1(,PDR)     STORE CODE TO CHECK IT                18300000
         CLI   TEM#1(PDR),CCODE   IS THE OBJECT CODE?                   18301000
         BE    CODECODE(,A1)      OFF TO EXECUTE THE CODE IF SO         18302000
         XERR  08,006,S           VALUE USED AS DIRECT GOTO OPERAND     18303000
*                                 IS NOT CODE                           18304000
*                                                                       18305000
*        WE ENTER AT THIS POINT AFTER COMPLETION OF COMPUTATION         18306000
*        OF CONSTANT EXPRESSION VALUES. THE CONTINUATION ROUTINE        18307000
*        IS LOCATED IN SPITBOLX AT ECONC.                               18308000
*                                                                       18309000
$$ECON   L     FRETURN,=A(ECONC)  LOAD BASE ADDRESS OF ROUTINE          18310000
         BR    FRETURN            OFF TO ROUTINE                        18311000
*                                                                       18312000
*        THIS ROUTINE IS ENTERED ON A LABEL TRACE CALL                  18313000
*        THE MAIN CODE FOR THIS ROUTINE IS IN SPITBOLX                  18314000
*                                                                       18315000
LABTRAC  L     DB4,=A(DTERTNS)    LOAD PROPER BASE REGISTER             18316000
         USING DTERTNS,DB4        TELL ASSEMBLER                        18317000
         B     LABTRACC           OFF TO REAL CODE FOR LABEL TRACE      18318000
         DROP  DB4                AND GET RID OF BASE REGISTER          18319000
         TITLE 'SPITBOLA -- INPUT-OUTPUT ENTRY POINTS'                  18320000
*                                                                       18321000
*        $$DOIO                   ENTER FROM  BALRS IN CODE TO GET ADDR 18322000
*                                 OF VARIABLE BLOCK - ALSO INTERCEPT    18323000
*                                 LABEL TRACE CALLS                     18324000
*                                                                       18325000
$$DOIO   LTR   DB3,DB3            CHECK REG USED FOR I/O BALR           18326000
         BP    DOIO1              JUMP IF I/O CASE (NOT FAILURE CASE)   18327000
         ST    DB4,TRCSVDB4       SAVE POSSIBLE BASE FOR LABEL TRACE    18328000
         L     DB4,=A(DTERTNS)    GET ADDR OF TRACE ROUTINES            18329000
         USING DTERTNS,DB4        TELL ASSEMBLER                        18330000
         B     READFAIL           OFF TO FAILURE ROUTINE                18331000
         DROP  DB4                GET RID OF THIS BASE REGISTER         18332000
*                                                                       18333000
*        COME HERE FOR IO CALL                                          18334000
*                                                                       18335000
DOIO1    LR    RETURN,DB3         GET ADDR OF PSEUDO CODE AFTER BALR    18336000
         L     DB3,$$BAS3         RESTORE DB3                           18337000
         LH    R0,0(,RETURN)      GET PSEUDO CODE                       18338000
         N     R0,=X'00000FFF'    GET RID OF ALL BUT ADDRESS BITS       18339000
         SR    R1,R1              CLEAR FOR SHIFT INTO R1               18340000
         SRDL  R0,7               SHIFT VAR BLOCK OFFSET INTO (R1)      18341000
         SLL   R0,2               GET DATA BASE OFFSET                  18342000
         SRL   R1,32-7-5          GET OFFSET IN BYTES NOT BLOCKS (32B)  18343000
         LR    R2,R0              GET BASE ADDRESS ADDRESSABLE          18344000
         A     R1,$$BAS1(R2)      ADD IN BASE REGISTER VALUE            18345000
         TM    0(RETURN),WRITEBIT WAS THIS AN OUTPUT CALL?              18346000
         BO    DOIOWRIT           B IF OUTPUT CALL                      18347000
         TM    0(RETURN),A1BIT    WAS THIS LM A1,A1+1?                  18348000
         LA    RETURN,2(,RETURN)  POINT TO NEXT INSTRUCTION             18349000
         BO    DOIORED1           B IF REFERS TO A1                     18350000
         STM   A1,A1+1,READSAVE   ELSE SAVE A1,A1+1                     18351000
         LR    A1,R1              GET VARIABLE BLOCK ADDR               18352000
         MVI   READFLG,2          SET TO RETURN VALUE IN A2,A2+1        18353000
         B     READMRG            AND MERGE WITH READ CALL              18354000
*                                                                       18355000
*        COME HERE IF VALUE TO BE RETURNED IN A1,A1+1                   18356000
*                                                                       18357000
DOIORED1 STM   A2,A2+1,READSAVE   SAVE A2,A2+1                          18358000
         LR    A1,R1              POINT TO VARIABLE BLCOK               18359000
*                                                                       18360000
*        $$READ                   NORMAL READ OPERATION                 18361000
*                                                                       18362000
$$READ   MVI   READFLG,1          SET FOR VALUE TO BE RETURNED IN A1    18363000
*                                                                       18364000
*        MERGE HERE IF RESULT BELONGS IN A2                             18365000
*                                                                       18366000
READMRG  L     A2+1,=A(READ)      GET ROUTINE ADDRESS                   18367000
         ST    RETURN,RETLOC      STORE RETURN IN CASE OF ERRORS        18368000
         BR    A2+1               OFF TO IT                             18369000
         EJECT                                                          18370000
*                                                                       18371000
*        COME HERE FOR BALR CALL TO DO OUTPUT                           18372000
*                                                                       18373000
DOIOWRIT LR    A2,R1              GET VARIABLE BLOCK ADDRESS            18374000
         SR    A2+1,A2+1          CLEAR OFFSET TO 0                     18375000
         TM    0(RETURN),STMBIT   WAS THIS A STM A1,A1+1?               18376000
         LA    RETURN,2(,RETURN)  POINT TO NEXT INSTRUCTION             18377000
         BO    *+8                SKIP (VALUE LOADED) IF STM            18378000
         L     A1,NCODEBT         ELSE LOAD NULL IF MVI ..,NCODE        18379000
         ST    RETURN,RETLOC      STORE RETURN POINT, MERGE WRIT        18380000
*                                                                       18381000
*        WRIT -- INTERNAL ENTRY POINT USED BY EXECUTION ROUTINES TO     18382000
*        ASSIGN A VALUE WITH A CHECK FOR I/O ASSIGNMENT                 18383000
*                                                                       18384000
*        (A1,A1+1)                VALUE TO BE ASSIGNED                  18385000
*        (A2)                     VARIABLE ADDRESS (NAME+BASE)          18386000
*        (RETLOC)                 CODE PTR ALREADY STORED               18387000
*        BAL   RETURN,WRIT                                              18388000
*        ->  RETURN HERE WITH ASSIGNMENT (AND I/O) COMPLETE             18389000
*                                                                       18390000
WRIT     STM   A1,A1+1,VALUE(A2)  FIRST, MAKE THE ASSIGNMENT            18391000
         TM    VFLAGS(A2),VOUA+VTRC         CHECK FOR SOMETHING TO DO   18392000
         BCR   Z,RETURN           RETURN IF NOT ASSOCIATED              18393000
*                                                                       18394000
*        MERGE HERE FROM $$ASSN, $$RASN                                 18395000
*                                                                       18396000
WRIT1    L     A2+1,=A(WRITE)     GET ROUTINE BASE ADDRESS              18397000
         LA    A2,0(,A2)          CLEAR POSSIBLE UPPER BYTE             18398000
         CR    A2,PDR             ARE WE ABOVE DYNAMIC CORE?            18399000
         BCR   H,A2+1             OFF TO WRITE IF NATURAL VARIABLE      18400000
         C     A2,DYNAMB          ARE WE BELOW FREE CORE?               18401000
         BCR   NL,RETURN          NOT NATURAL VARIABLE IF NOT           18402000
         BR    A2+1               OFF TO IT                             18403000
         TITLE 'SPITBOLA -- ASSIGNMENT ENTRY POINTS'                    18404000
*                                                                       18405000
*        $$ASSN                   ASSIGN WITH CHECK FOR I/O ASSOCIATION 18406000
*                                                                       18407000
*        (A1,A1+1)                NAME OF VARIABLE TO ASSIGN TO         18408000
*        (A2,A2+1)                VALUE TO BE ASSIGNED                  18409000
*        BAL   RETURN,$$ASSN                                            18410000
*                                                                       18411000
$$ASSN   AR    A1,A1+1            ADD NAME OFFSET TO BASE               18412000
         STM   A2,A2+1,VALUE(A1)  PERFORM ASSIGNMENT                    18413000
         TM    VFLAGS(A1),VOUA+VTRC         POSSIBLE ASSOCIATED VBLOK   18414000
         BCR   Z,RETURN           RETURN (ALL DONE) IF NOT              18415000
         LR    A2,A1              ELSE COPY NAME POINTER                18416000
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE TO BE ASSIGNED             18417000
         ST    RETURN,RETLOC      STORE RETURN POINT                    18418000
         B     WRIT1              MERGE BACK INTO WRIT ROUTINE          18419000
*                                                                       18420000
*        $$RASN                   LIKE $$ASSN BUT WITH ARGS REVERSED    18421000
*                                                                       18422000
*        (A1,A1+1)                VALUE TO BE ASSIGNED                  18423000
*        (A2,A2+1)                NAME OF VARIABLE TO BE ASSIGNED       18424000
*        BAL   RETURN,$$RASN                                            18425000
*                                                                       18426000
$$RASN   AR    A2,A2+1            ADD VARIABLE OFFSET TO NAME BASE      18427000
         STM   A1,A1+1,VALUE(A2)  FIRST PERFORM ASSIGNMENT              18428000
         TM    VFLAGS(A2),VOUA+VTRC         POSSIBLE ASSOCIATED VBLOK?  18429000
         BCR   Z,RETURN           RETURN (ALL DONE) IF NOT?             18430000
         ST    RETURN,RETLOC      ELSE STORE RETURN LOCATION            18431000
         B     WRIT1              AND MERGE INTO WRIT ROUTINE           18432000
         TITLE 'SPITBOLA -- PATTERN MATCH ENTRY POINTS'                 18433000
*                                                                       18434000
*        $$PTNL                   PATTERN BY NAME WITH NULL REPLACEMENT 18435000
*                                                                       18436000
*        SAME CALL AS $$PTN2                                            18437000
*                                                                       18438000
$$PTNL   O     A1,X80             SET SIGN BIT FLAG AND MERGE $$PTN2    18439000
*                                                                       18440000
*        $$PTN2                   PATTERN MATCH BY NAME                 18441000
*                                                                       18442000
*        (A1,A1+1)                NAME OF VARIABLE CONTAINING STRING    18443000
*        (A2,A2+1)                PATTERN                               18444000
*        BAL   RETURN,$$PTN2                                            18445000
*        THIS ENTRY IS CALLED WHEN THE STATEMENT CONTAINS A PATTERN     18446000
*        REPLACEMENT -- EVERYTHING IS LEFT SET UP FOR A $$PATA CALL     18447000
*                                                                       18448000
*        SEE THE PATTERN MATCHING ROUTINES FOR A BETTER UNDERSTANDING   18449000
*        OF WHAT THIS ROUTINE ACCOMPLISHES                              18450000
*                                                                       18451000
$$PTN2   STM   A1,A1+1,PNAME(PDR) STORE NAME ON STACK                   18452000
         AR    A1,A1+1            ADD OFFSET TO NAME                    18453000
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE AND MERGE $$PTV2           18454000
*                                                                       18455000
*        $$PTV2                   PATTERN MATCH BY VALUE                18456000
*                                                                       18457000
*        (A1,A1+1)                SUBJECT STRING                        18458000
*        (A2,A2+1)                PATTERN                               18459000
*        BAL   RETURN,$$PTV2                                            18460000
*                                                                       18461000
*        PATTERN MATCH ROUTINE FOR CASE OF NO PATTERN REPLACEMENT       18462000
*                                                                       18463000
$$PTV2   L     DB2,=A(PTV2C)      LOAD ADDRESS OF CONTINUATION          18464000
         BR    DB2                AND OFF TO IT                         18465000
         TITLE 'SPITBOLA -- PATTERN EXIT POINTS'                        18466000
*                                                                       18467000
*        COME HERE TO ABORT (TERMINATE) PATTERN MATCH FOR ANY           18468000
*        OF A VARIETY OF REASONS --                                     18469000
*                                                                       18470000
PABORT   L     DB1,PSAVDB1(,PDR)  RESTORE PROPER DATA BASE ADDRESS      18471000
*                                                                       18472000
*        MERGE HERE WHEN DB1 WAS NOT SAVED (STRING MATCH CASE)          18473000
*                                                                       18474000
PABORTMM L     PDR,PDRLOC         RESTORE PDR                           18475000
         LM    DB2,DB3,$$BAS2     RELOAD DB2,DB3                        18476000
         L     FR,FRSAVE          RESTORE FREE POINTER                  18477000
         STE   ZR,PNAME(,PDR)     CLEAR POSSIBLE NAME ON STACK          18478000
         LM    FRETURN,RETURN,FRETLOCP(PDR) LOAD FAILURE ADDR & RETURN  18479000
         BR    FRETURN            AND FAIL BACK TO CODE                 18480000
*                                                                       18481000
*        PATTERN EXIT ON SUCCESSFUL MATCH                               18482000
*                                                                       18483000
PATENDE  L     DB1,PSAVDB1(,PDR)  RESTORE PROPER DB1 VALUE              18484000
*                                                                       18485000
*        MERGE HERE WHEN DB1 HAS NOT BEEN SAVED (SIMPLE STRING CASE)    18486000
*                                                                       18487000
PATENDEM L     PDR,PDRLOC         RESTORE REAL TOP OF STACK ADDRESS     18488000
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3                       18489000
         L     FR,FRSAVE          RELOAD FREE REGISTER                  18490000
         LM    FRETURN,RETURN,FRETLOCP(PDR) LOAD RETURN REGS            18491000
         TM    PNAME(PDR),X'80'   TEST FOR $$PTNL FLAG                  18492000
         BCR   NO,RETURN          LEAVE IF NOT SET                      18493000
         L     A1,NCODEBT         ELSE LOAD A NULL AND MERGE $$PATA     18494000
         TITLE 'SPITBOLA -- PATTERN REPLACEMENT ENTRY POINT'            18495000
*                                                                       18496000
*        $$PATA                   PATTERN REPLACEMENT (ASSIGNMENT)      18497000
*                                                                       18498000
*        (A1,A1+1)                REPLACING ARGUMENT                    18499000
*        BAL   RETURN,$$PATA                                            18500000
*                                                                       18501000
*        THE FOLLOWING RELEVANT VALUES HAVE BEEN LEFT SET UP BY THE     18502000
*        PATTERN MATCH ROUTINES --                                      18503000
*                                                                       18504000
*        PNAME(,PDR)              NAME (AND OFFSET) OF VARIABLE         18505000
*        PSTRING(,PDR)            STRING SPECIFIER OF SUBJECT STRING    18506000
*        MATCHPB(,PDR)            NUM CHARS LEFT AT START OF MATCH      18507000
*        MATCHPE(,PDR)            NUM CHARS LEFT AT END OF MATCH        18508000
*                                                                       18509000
*        BASICALLY, IT IS NECCESSARY TO CONCATENATE THREE SEPARATE      18510000
*        PARTS --                                                       18511000
*                                                                       18512000
*        PART 1                   THE PART OF THE SUBJECT STRING NOT    18513000
*                                 MATCHED AT THE START                  18514000
*                                                                       18515000
*        PART 2                   THE SUPPLIED ARGUMENT TO $$PATA       18516000
*                                                                       18517000
*        PART 3                   THE PART OF THE STRING NOT MATCHED    18518000
*                                 AT THEN END                           18519000
*                                                                       18520000
*        THE RESULT OF THIS CONCATENATION IS THEN ASSIGNED TO THE       18521000
*        VARIABLE, CHECKING FOR I/O ASSOCIATION                         18522000
*                                                                       18523000
$$PATA   L     DB2,=A(PATAC)      LOAD CONTINUATION ROUTINE ADDRESS     18524000
         BR    DB2                AND GO OFF TO IT                      18525000
         TITLE 'SPITBOLA -- ENTRY POINTS FOR FUNCTION PROCESSING'       18526000
*                                                                       18527000
*        $$WNAG                   WRONG NUMBER OF ARGUMENTS ROUTINE     18528000
*                                                                       18529000
*        B     $$WNAG                                                   18530000
*        (SUPPLIES ONE EXTRA NULL ARGUMENT AND RETURNS TO FCODE(DB4) )  18531000
*                                                                       18532000
$$WNAG   LR    R1,R0              COPY ARGUMENT COUNT                   18533000
         LA    R0,1(R1)           BUMP ARGUMENT COUNT BY ONE            18534000
         SLL   R1,3               ARGUMENT COUNT * 8 TO INDEX TEMP LOCS 18535000
         LCR   R1,R1              NEGATE (BECAUSE STACK IS BUILT DOWN)  18536000
         AR    R1,PDR             ADD STACK POINTER                     18537000
         MVI   TEM#1(R1),NCODE    SET NEXT ARGUMENT TO NULL             18538000
         B     FCODE(,DB4)        BACK TO SEE WHETHER THAT IS ENOUGH    18539000
*                                                                       18540000
*        $$FLCN                   CONTINUE PROCESSING FROM FFBLOK       18541000
*                                                                       18542000
*        THIS FUNCTION COMPLETES THE PROCESS OF REFERENCING A FIELD     18543000
*        OF A PROGRAMMER DEFINED DATATYPE THROUGH A CALL TO ITS         18544000
*        ASSOCIATED FIELD FUNCTION (SEE PDBLOK AND FFBLOK STRUCTURES)   18545000
*                                                                       18546000
$$FLCN   L     A1,TEM#1(,PDR)     PICK UP POINTER TO PDBLOK             18547000
         L     R0,PDFPTR(,A1)     PICK UP ASSOCIATED PDFBLOK POINTER    18548000
         C     R0,PDFPTR(,DB4)    CHECK FOR MATCH WITH FIELD FUNC DEF   18549000
         BE    FLCN1              SKIP IF THEY MATCH                    18550000
*                                                                       18551000
*        COME HERE IF FFBLOK DOES NOT MATCH ARGUMENT TYPE               18552000
*                                                                       18553000
FLCN0    L     DB4,FFBLNEXT(,DB4) LINK TO NEXT FFBLOK WITH SAME NAME    18554000
         EX    0,FCODE+4(,DB4)    EXECUTE THE LA                        18555000
         C     R0,PDFPTR(,DB4)    CHECK FOR MATCH WITH FIELD FUNC DEF   18556000
         BNE   FLCN0              LOOP BACK IF NO MATCH                 18557000
*                                                                       18558000
*        COME HERE WHEN WE ARE FINALLY IN THE RIGHT FFBLOK              18559000
*                                                                       18560000
FLCN1    LA    A1,0(,A1)          CLEAR UPPER BYTE IN CASE BY NAME      18561000
         AL    A1,MCODEBT         TYPE CODE = MCODE                     18562000
         CLC   0(4,RETURN),BFRVN  CHECK FOR CALL BY NAME (B $$FRVN)     18563000
         L     PDR,PDRLOC         RESTORE STACK POINTER                 18564000
         BE    4(RETURN)          RETURN PAST IT WITH NAME IF SO        18565000
         AR    A1,A1+1            ELSE CALL BY VALUE, POINT TO CONTENTS 18566000
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE                            18567000
         BR    RETURN             AND RETURN                            18568000
*                                                                       18569000
*        CONSTANT TO CHECK FOR CALL BY NAME (B $$FRVN)                  18570000
*                                                                       18571000
BFRVN    B     $$FRVN             FOUR BYTE CHECK CONSTANT              18572000
         EJECT                                                          18573000
*                                                                       18574000
*        JUMP HERE FROM FFBLOK WHEN ARG IS NOT PRG DEF DATATYPE         18575000
*                                                                       18576000
$$FLE1   L     DB4,FFBLNEXT(,DB4)           POINT TO NEXT IN CHAIN      18577000
         C     DB4,=A(FLCERR-FCODE)         IS THIS END OF CHAIN?       18578000
         BNE   FCODE(,DB4)        OFF TO FUNCTION IF NOT END OF CHAIN   18579000
         XERR  01,026,S           THE ARGUMENT TO A FIELD FUNCTION IS   18580000
*                                 NOT A PROGRAM DEFINED DATATYPE        18581000
*                                                                       18582000
*        ENTRY POINT FROM EFBLOK TO CALL EXTERNAL FUNCTION              18583000
*                                                                       18584000
$$LOAD   L     DB3,=A(LOADC)      LOAD CONTINUATION ROUTINE ADDRESS     18585000
         BR    DB3                OFF TO ROUTINE                        18586000
*                                                                       18587000
*        COME HERE TO SIGNAL A FAILURE RETURN                           18588000
*                                                                       18589000
FAILRL   L     RETURN,RETLOC      RESTORE RETURN POINT                  18590000
*                                                                       18591000
*        USE THIS ENTRY POINT IF RETURN ALREADY SET                     18592000
*                                                                       18593000
FAILR    L     PDR,PDRLOC         RESTORE ACTUAL PDR LOCATION           18594000
         BR    FRETURN            AND FAIL                              18595000
*                                                                       18596000
*        COME HERE FROM FUNCTION CALL TO RETURN NULL RESULT             18597000
*                                                                       18598000
EXITNULL L     A1,NCODEBT         LOAD NULL AS RESULT, MERGE            18599000
*                                                                       18600000
*        STANDARD EXIT POINT FOR FUNCTIONS (RESULT IS IN A1,A1+1)       18601000
*                                                                       18602000
EXIT     L     RETURN,RETLOC      RESTORE RETURN LOCATION               18603000
         L     PDR,PDRLOC         RESTORE STACK POINTER                 18604000
         BR    RETURN             RETURN TO CALLER                      18605000
         EJECT                                                          18606000
*                                                                       18607000
*        ENTRY POINT FROM FBLOK ON FUNCTION CALL                        18608000
*                                                                       18609000
$$FUNC   CH    R0,FNARGS(,DB4)    ARE THERE ENOUGH ARGS?                18610000
         BL    $$WNAG             GET NULLS IF NOT                      18611000
         LR    DB3,DB4            COPY ADDRESS OF FBLOK FOR LOOPS       18612000
         LH    R2,FNARGS(,DB4)    GET NUMBER OF ARGS                    18613000
         LR    R1,R2              COPY INTO REG 1                       18614000
         AH    R2,FNLOCS(,DB4)    ADD NUMBER OF LOCALS                  18615000
         SLL   R2,3               *8 EQUALS NUMBER OF BYTES ON STACK    18616000
         LCR   R2,R2              GET NEGATIVE FOR STACK CALC           18617000
         AR    R2,PDR             PUSH DOWN BY NUMBER OF TEMPORARIES    18618000
         L     A2,FNAME(,DB4)     GET VAR BLOCK POINTER                 18619000
         LM    A1,A1+1,VALUE(A2)  GET PRESENT VALUE                     18620000
         STM   A1,A1+1,TEM#1(R2)  STORE AT TEM#N+1, N=A GS+LOCS         18621000
         MVI   VALUE(A2),NCODE    NULL NAME                             18622000
         BCTR  R1,0               NUMBER OF ARGUMENTS - 1               18623000
         SLL   R1,2               *4 = SPACE FOR ARGUMENT ADDRESSES     18624000
         AR    R1,DB4             ADDRESS OF LAST ARG PTR (DON'T DO LA) 18625000
         LA    R0,4               GET THE CORRECT INCREMENT             18626000
         LA    DB2,8              GET STACK CONSTANT                    18627000
         CR    R1,DB4             WERE THERE ANY ARGUMENTS?             18628000
         BL    FUNCNXT            SKIP IF NOT                           18629000
*                                                                       18630000
*        LOOP TO SAVE OLD ARGUMENT VALUES & SET NEW VALUES              18631000
*                                                                       18632000
FUNCLP1  L     R2,FARGS(,DB3)     GET VAR BLOCK ADDRESS                 18633000
         LM    A1,A1+1,TEM#1(PDR) PICK UP ARG VALUE                     18634000
         LM    A2,A2+1,VALUE(R2)  PICK UP VALUE TO BE SAVED             18635000
         STM   A1,A1+1,VALUE(R2)  STORE THE ARGUMENT VALUE              18636000
         STM   A2,A2+1,TEM#1(PDR) SAVE OLD VALUE                        18637000
         SR    PDR,DB2            BACK UP ON STACK                      18638000
         BXLE  DB3,R0,FUNCLP1     PUSH UP FARGS PTR, TEST AND LOOP      18639000
         EJECT                                                          18640000
*                                                                       18641000
*        COME HERE WHEN ALL ARGUMENTS HAVE BEEN PROCESSED               18642000
*                                                                       18643000
FUNCNXT  LH    A1,FNLOCS(,DB4)    PICK UP NUMBER OF LOCALS              18644000
         AR    A1,A1              *2                                    18645000
         BZ    FUNCEND            SKIP IF NO LOCALS                     18646000
         AR    A1,A1              *4                                    18647000
         AR    R1,A1              GET NEW END ADDRESS                   18648000
*                                                                       18649000
*        LOOP TO SAVE OLD LOCAL VALUES AND SET NULL                     18650000
*                                                                       18651000
FUNCLP2  L     R2,FARGS(,DB3)     GET VAR BLOCK ADDRESS                 18652000
         LM    A1,A1+1,VALUE(R2)  GET VALUE TO BE SAVED                 18653000
         STM   A1,A1+1,TEM#1(PDR) SAVE IT                               18654000
         MVI   VALUE(R2),NCODE    MAKE LOCAL VALUE NULL                 18655000
         SR    PDR,DB2            BACK UP 1 TEMP                        18656000
         BXLE  DB3,R0,FUNCLP2     PUSH UP FARGS PTR, TEST AND LOOP      18657000
*                                                                       18658000
*        COME HERE WITH ALL ARGUMENTS AND LOCALS PROCESSED              18659000
*                                                                       18660000
FUNCEND  LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           18661000
         SH    PDR,=Y(STACKTOP-TEM#1)       PUSH DOWN STACK MIN AMOUNT  18662000
         STE   ZR,PNAME(,PDR)     TO PLEASE THE GBGCOLLECTOR            18663000
         STM   FRETURN,RETURN,FRETFLOC(PDR) SAVE RETURN POINTS          18664000
         ST    DB4,FBLOKLOC(,PDR) SAVE THIS FUNCTION ADDRESS            18665000
         L     R1,PDRLOC          GET CURRENT PDR LOCATION ABOVE US     18666000
         ST    R1,PDRBPTR(,PDR)   SAVE IT ON STACK                      18667000
         ST    PDR,PDRLOC         AND STORE THIS LEVEL'S PDR            18668000
         LM    A1+1,A2+1,V$FNCLEV LOAD FNCLEVEL,TRACE, AND FTRACE       18669000
         ALR   A2,A2+1            TEST TRACE AND FTRACE                 18670000
         BNZ   FUNCTRC            SKIP TO TRY TRACE UNLESS BOTH ZERO    18671000
         LA    A1+1,1(,A1+1)      INCREMENT &FNCLEVEL                   18672000
         ST    A1+1,V$FNCLEV      AND STORE UPDATED VALUE               18673000
         EJECT                                                          18674000
*                                                                       18675000
*        RE-ENTER HERE AFTER TRACE -- NOTE DB4 HAS BEEN RESTORED        18676000
*                                                                       18677000
FTRACECE L     A1,FLABEL(,DB4)    LOAD ADDRESS OF LABEL VBLOK           18678000
*                                                                       18679000
*        CHECK TO MAKE SURE NO COLLECT NEEDED                           18680000
*                                                                       18681000
FUNCRENT L     R1,VLABL(,A1)      LOAD LABEL ADDRESS FOR FUNCTION       18682000
         CR    FR,PDR             CHECK FOR COLLECT NEEDED              18683000
         BCR   L,R1               OFF TO FUNCTION CODE IF SAFE          18684000
         ST    RETURN,$$LAST      SAVE RETURN LOC IN COLLECTABLE LOC    18685000
         ST    R1,RETLOC          SAVE TARGET ADDR AS GBGCL3 CODE LOC   18686000
         BAL   RETURN,GBGCL0      DO COLLECT                            18687000
         L     RETURN,$$LAST      RELOAD RETURN POINT FOR &LASTNO       18688000
         B     FUNCRENT           AND BACK TO DO ANOTHER FREE CORE TEST 18689000
*                                                                       18690000
*        COME HERE IF BOTH &TRACE AND &FTRACE ARE NOT ZERO              18691000
*                                                                       18692000
FUNCTRC  LR    DB3,DB4            SAVE FUNCTION BLOCK ADDRESS           18693000
         L     DB4,=A(DTERTNS)    GET TRACE ROUTINES BASE REGISTER      18694000
         USING DTERTNS,DB4        TELL ASSEMBLER                        18695000
         B     FNCTRC             OFF TO TRACE ROUTINES                 18696000
         DROP  DB4                                                      18697000
         TITLE 'SPITBOLA -- KEYWORD ACCESS ENTRY POINTS'                18698000
*                                                                       18699000
*        $$KGET                   ACCESS VALUE OF A KEYWORD             18700000
*                                                                       18701000
*        (A1,A1+1)                NAME OF ARGUMENT                      18702000
*        BAL   RETURN,$$KGET                                            18703000
*        (A1,A1+1)                VALUE OF KEYWORD                      18704000
*                                                                       18705000
$$KGET   L     R2,=A(KGETC)       LOAD ROUTINE ADDRESS                  18706000
         BR    R2                 AND GO OFF TO IT                      18707000
*                                                                       18708000
*        $$KPUT                   STORE VALUE OF KEYWORD                18709000
*                                                                       18710000
*        (A1,A1+1)                NAME OF KEYWORD ARGUMENT              18711000
*        (A2,A2+1)                VALUE TO BE STORED                    18712000
*        BAL   RETURN,$$KPUT                                            18713000
*        ->  NORMAL RETURN WITH VALUE STORED                            18714000
*                                                                       18715000
$$KPUT   L     DB3,=A(KPUTC)      LOAD ROUTINE ADDRESS                  18716000
         BR    DB3                AND GO OFF TO IT                      18717000
         TITLE 'SPITBOLA -- ROUTINES USED IN PATTERN MATCHING'          18718000
*                                                                       18719000
*        GBAL                     ROUTINE TO SCAN OUT A BALANCED STRING 18720000
*                                                                       18721000
*                                                                       18722000
*        USED BY BAL PATTERN ROUTINE AND ITS EXTEND ROUTINES            18723000
*                                                                       18724000
*        (NCP)                    CURRENT SCAN LOC (NUM CHARS LEFT)     18725000
*        BAL   RETURN,GBAL                                              18726000
*        (NCP)                    SCAN LOC AFTER SCANNING OUT BAL STRIN 18727000
*                                                                       18728000
         USING QPATSUBS,PBASE     MAKE FAIL,LFAIL ADDRESSABLE           18729000
GBAL     LTR   NCP,NCP            TEST NUMBER OF CHARACTERS REMAINING   18730000
         BZ    FAIL               NORMAL FAILURE IF NO CHARACTERS LEFT  18731000
         BAL   R2,PTIMTST         TEST FOR OVERTIME                     18732000
         LR    R1,FSADR           POINT R1 TO END OF STRING             18733000
         SR    R1,NCP             MINUS NUM CHARS LEFT = CURRENT LOC    18734000
         SR    R2,R2              ZERO PARENTHESES COUNT                18735000
BALEXT1  CLI   0(R1),C')'         IS NEXT CHAR A RIGHT PAREN?           18736000
         BH    BALEXT3            SKIP IF NEITHER ( NOR )               18737000
         BE    BALEXT2            SKIP IF )                             18738000
         CLI   0(R1),C'('         IS CHAR A LEFT PAREN?                 18739000
         BNE   BALEXT3            SKIP IF NOT A PAREN                   18740000
         LA    R2,1(,R2)          FOR LEFT PAREN -- BUMP PAREN COUNT    18741000
BALEXT1A LA    R1,1(R1)           BUMP CHARACTER POINTER                18742000
         BCT   NCP,BALEXT1        BACK TO TEST NEXT CHARACTER           18743000
         B     FAIL               FAIL IF NO MORE CHARS TO TEST         18744000
BALEXT2  BCTR  R2,0               FOR RIGHT PAREN, DECREASE PAREN COUNT 18745000
BALEXT3  LTR   R2,R2              TEST PAREN COUNT                      18746000
         BM    FAIL               FAIL IF IT HAS GONE NEGATIVE          18747000
         BP    BALEXT1A           KEEP GOING IF GREATER THAN ZERO       18748000
         BCTR  NCP,RETURN         MINUS ONE MORE FOR LAST CHAR, RETURN  18749000
         BR    RETURN             RETURN EVEN IF BCTR FALLS THROUGH     18750000
         DROP  PBASE              DROP QPATSUBS BASE REG                18751000
         EJECT                                                          18752000
*                                                                       18753000
*        ROUTINES CALLED FROM PATTERN MATCH ROUTINES TO GET UNEVALUATED 18754000
*        ARGUMENTS EVALUATED (SPAN,BREAK,ANY,NOTANY,(R)POS,(R)TAB,LEN)  18755000
*                                                                       18756000
*                                                                       18757000
*        ENTRY TO GET A DEFERRED INTEGER                                18758000
*                                                                       18759000
*                                                                       18760000
*        BAL   NCP,DEFEXPI                                              18761000
*        ->  ERROR RETURN IF UNCONVERTIBLE TO INTEGER                   18762000
*        ->  ERROR RETURN IF NON-POSITIVE                               18763000
*        ->  NORMAL RETURN -- INTEGER STORED IN PARAM1 FIELD OF NODE    18764000
*                                                                       18765000
DEFEXPI  L     RETURN,PARAM2(PB,PO)         LOAD EXPR OR VAR POINTER    18766000
         CR    R0,R0              SET CC FOR PAT MATCH CALL             18767000
         BAL   R1,$EVAL           EVALUATE                              18768000
         USING QPATSUBS,PBASE     BASE REG FOR NEXT INSTRUC             18769000
         B     FAIL               ON CODE FAILURE -- FAIL               18770000
         DROP  PBASE              DROP BASE REG                         18771000
         BAL   RETURN,GETINT      CONVERT RESULT TO INTEGER             18772000
         B     DEFEXPE1           ERROR RETURN FOR UNCONVERTABLE        18773000
         LTR   A1+1,A1+1          TEST INTEGER                          18774000
         BM    DEFEXPE2           GIVE ERROR RETURN IF NON-POSITIVE     18775000
         L     PO,PSAVPO(,PDR)    RESTORE PO TO CONTINUE MATCH          18776000
         ST    A1+1,PARAM1(PB,PO) STORE INTEGER IN PARAM1               18777000
         LM    A1,A1+1,PSAVBPS(PDR)         RELOAD A1,A1+1 (BPS,PS2)    18778000
         B     10(,NCP)           GIVE NORMAL RETURN                    18779000
         EJECT                                                          18780000
*                                                                       18781000
*        ENTRY TO GET A DEFERRED STRING                                 18782000
*                                                                       18783000
*        (PB,PO)                  POINTS TO PATTERN NODE                18784000
*        BAL   NCP,DEFEXPS                                              18785000
*        ->  ERROR RETURN IF UNCONVERTIBLE TO STRING                    18786000
*        ->  ERROR RETURN IF NULL                                       18787000
*        ->  NORMAL RETURN                                              18788000
*        (RETURN)                 START OF STRING                       18789000
*        (R2)                     ACTUAL LENGTH OF STRING               18790000
*                                                                       18791000
*        DEFEXPS ALSO DOES AN ANY/NOTANY TEST ON THE NEXT CHARACTER AND 18792000
*        LEAVES THE CC SET NONZERO IF THE CHAR WAS FOUND (ANY SUCCEEDS) 18793000
*        AND ZERO IF IT WAS NOT FOUND (NOTANY SUCCEEDS)                 18794000
*                                                                       18795000
DEFEXPS  L     RETURN,PARAM2(PB,PO)         LOAD EXPR OR VAR POINTER    18796000
         CR    R0,R0              SET CC FOR CALL BY PAT MATCH          18797000
         BAL   R1,$EVAL           EVALUATE                              18798000
         USING QPATSUBS,PBASE     BASE REG FOR NEXT INSTRUC             18799000
         B     FAIL               ON FAIL RETURN FROM CODE -- FAIL      18800000
         DROP  PBASE              DROP BASE REG                         18801000
         BAL   RETURN,GETSTGS     GET STRING FROM RESULT                18802000
         B     DEFEXPE1           ERROR RETURN IF UNCONVERTABLE         18803000
         LR    RETURN,A1          SAVE STRING POINTER                   18804000
         LTR   R2,A1+1            MOVE AND TEST LENGTH                  18805000
         BM    DEFEXPE2           ERROR RETURN IF NULL                  18806000
         LCR   R1,CP              MINUS NUM CHARS LEFT                  18807000
         SR    A1,A1              CLEAR IC REG                          18808000
         IC    A1,0(R1,FSADR)     LOAD CHARACTER TO TEST                18809000
         LA    R1,1               GET PLUG CHAR                         18810000
         STC   R1,ZTBL(A1)        PLUG CHARACTER IN ZEROS TABLE         18811000
         EX    R2,CHARTRT         DO TRT TO TEST FOR AMONG GIVEN CHARS  18812000
         LA    R1,0               CLEAR R1 WITHOUT CLOBBERING CC        18813000
         STC   R1,ZTBL(A1)        RESTORE ALTERED LOCATION IN ZTBL      18814000
         LA    R2,1(,A1+1)        CONVERT 360 LENGTH TO ACTUAL LENGTH   18815000
         LM    BPS,PS2,PSAVBPS(PDR)         RELOAD BPS,PS2 (A1,A1+1)    18816000
         L     PO,PSAVPO(,PDR)    RESTORE PO TO CONTINUE MATCH          18817000
         B     8(,NCP)            RETURN TO CALLER                      18818000
*                                                                       18819000
CHARTRT  TRT   SCHARS(*-*,RETURN),ZTBL      TRT TO TEST CHARACTER       18820000
         EJECT                                                          18821000
*                                                                       18822000
*        COME HERE IF ARGUMENT UNCONVERTABLE AS REQUESTED               18823000
*                                                                       18824000
DEFEXPE1 LR    RETURN,NCP         COPY RETURN ADDRESS FOR ERROR MSG     18825000
         B     $EVALERR           OFF TO GIVE RECURSIVE ERROR CALL      18826000
*                                                                       18827000
*        COME HERE IF RESULT NOT VALID                                  18828000
*                                                                       18829000
DEFEXPE2 LA    RETURN,4(,NCP)     GET ERROR MESSAGE ADDRESS AS RETURN   18830000
*                                                                       18831000
*        COME HERE TO RESTORE R1 FROM PREVIOUS EVAL CALL, FOR ERROR     18832000
*                                                                       18833000
         USING QPATSUBS,PBASE     INDICATE PAT MATCH BASE REGISTER      18834000
$EVALERR LA    R1,FAIL            SET RETURN ADDRESS TO FAIL            18835000
         STM   PS1,PB,PSAVPS1(PDR)          SAVE PS1,PB (A2,A2+1)       18836000
         B     $EVAL1A            AND SAVE PAT STACK FOR SETEXIT (FAIL) 18837000
         DROP  PBASE              GET RID OF BASE REGISTER              18838000
         EJECT                                                          18839000
*        $EVAL ENTRY TO EVALUATE EXPRESSION                             18840000
*                                                                       18841000
*        CONDITION CODE IS EQ IF CALLED FROM PAT MATCH ROUTINE          18842000
*                                                                       18843000
*        (RETURN)                 EXPRESSION OR VARIABLE POINTER        18844000
*        BAL   R1,$EVAL                                                 18845000
*        -> ERROR EXIT FOR CODE FAILURE -- ALL REGS RESTORED            18846000
*        -> (A1,A1+1) (BPS,PS2) RESULT -- ALL OTHER REGS RESTORED       18847000
*        EXCEPT DB1/PO WHICH POINTS TO DATA AREA (IS DB1 VALUE)         18848000
*                                                                       18849000
$EVAL    ST    PO,PSAVPO(,PDR)    SAVE CURRENT PATTERN OFFSET           18850000
         L     DB1,PSAVDB1(,PDR)  AND GET DATA AREA ADDRESS             18851000
         C     RETURN,ECODEBT     TEST FOR SIMPLE VARIABLE CASE         18852000
         BNL   $EVAL1             SKIP IF NOT                           18853000
         TM    VFLAGS(RETURN),VINP+VINA     IS IT READ ASSOCIATED?      18854000
         BO    $EVALRR            SKIP IF SO                            18855000
         STM   A1,A1+1,PSAVBPS(PDR)         SAVE A1,A1+1                18856000
         LM    A1,A1+1,VALUE(RETURN)        LOAD VARIABLE VALUE         18857000
         B     4(,R1)             TAKE SUCCESS EXIT                     18858000
*                                                                       18859000
*        HERE FOR REFERENCE TO A VCODE FOR A READ ASSOCIATED VALUE      18860000
*        IN THIS CASE, WE OBTAIN A DUMMY EXPRESSION POINTER AND GO      18861000
*        THROUGH THE FULL ECODE LOGIC (I.E. A DEFFERED CALL)            18862000
*                                                                       18863000
$EVALRR  ST    RETURN,EVALVAR     SAVE VAR BLOCK ADDR FOR CALL          18864000
         L     RETURN,EVALRCON    GET ADDRESS OF DUMMY CODE             18865000
*                                                                       18866000
*        COME HERE FOR EXPRESSION CASE (READ ASSOC VARIABLE MERGES)     18867000
*                                                                       18868000
$EVAL1   STM   BPS,PB,PSAVBPS(PDR)          SAVE REGISTERS BELOW PO     18869000
*                                                                       18870000
*        COME HERE TO ISSUE AN ERROR MESSAGE DURING PATTERN MATCHING    18871000
*        (RETURN)                 POINTS TO ERROR MESSAGE               18872000
*        ALL REGISTERS ARE ON THE STACK, DB1 IS CORRECT                 18873000
*        THE PURPOSE OF THIS RECURSIVE CALL IS TO SAVE THE PATTERN      18874000
*        STACK SO THAT A SETEXIT/CONTINUE HAS THE EFFECT OF ELEMENT     18875000
*        FAILURE IN THE MATCH                                           18876000
*        NOTE THAT (R1) MUST BE AS ON ORIGINAL CALL FOR SETEXIT         18877000
*                                                                       18878000
$EVAL1A  STM   CP,PBASE,PSAVCP(PDR)         SAVE REGS ABOVE PO          18879000
         L     FR,FRSAVE          RESTORE FREE CORE POINTER             18880000
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3                       18881000
         SH    PDR,=Y(PATSPACE)   PUSH STACK PROPER AMOUNT              18882000
         STD   ZR,FRETFLOC(,PDR)  CLEAR POSSIBLE GARBAGE RETURN LOCS    18883000
         EJECT                                                          18884000
*                                                                       18885000
*        EVAL FUNCTION MERGES HERE                                      18886000
*                                                                       18887000
$EVAL2   STE   ZR,PNAME(,PDR)     SET NAME FIELD UNUSED                 18888000
         STE   ZR,FBLOKLOC(,PDR)  SAY THIS IS DEFFERED EXPRESSION       18889000
         ST    R1,EVLINK(,PDR)    SAVE LINKAGE WITH CONDITION CODE      18890000
         L     FRETURN,=A(DEFFAIL)          GET ADDRESS IN CASE OF FAIL 18891000
         L     R0,PDRLOC          GET CURRENT PDR BACK POINTER          18892000
         ST    R0,PDRBPTR(,PDR)   PUT IT ON STACK                       18893000
         ST    PDR,PDRLOC         AND SET BACK POINTER FOR THIS LEVEL   18894000
         CR    FR,PDR             DO WE NEED A COLLECT?                 18895000
         BCR   L,RETURN           OFF TO CODE IF NOT                    18896000
         B     GBGCL0S            SAVE NOTHING, STORE RETURN FOR GBGCOL 18897000
*                                                                       18898000
*        COME HERE FOR SUCCESSFUL RETURN FROM CODE                      18899000
*                                                                       18900000
$$EVLR   L     R1,EVLINK(,PDR)    RESTORE CALLERS CC AND ADDRESS        18901000
         SPM   R1                 RESTORE CONDITION CODE                18902000
         BNE   EVLR1              NO RE-EVALUATE FOR EXPRESSION CALL    18903000
         ST    A1,EVALSV          STORE RESULT TO TEST TYPE CODE        18904000
         TM    EVALSV,EXPRBIT     TEST FOR EXPRESSION RETURNED          18905000
         BNO   EVLR1              SKIP IF NOT EXPRESSION                18906000
         TM    STAGE,$OVERTIM     CHECK FOR UNCAUGHT OVERTIME           18907000
         BO    $$TIME             OFF TO GIVE ERROR MESSAGE IF OVERTIME 18908000
         LR    RETURN,A1          COPY EXPRESSION POINTER               18909000
         CLI   EVALSV,ECODE       IS IT COMPLEX VAR CASE?               18910000
         BCR   E,RETURN           OFF TO CODE IF SO                     18911000
*                                                                       18912000
*        COME HERE FOR SIMPLE VARIABLE EXPRESSION RETURNED AS VALUE     18913000
*                                                                       18914000
         LM    A1,A1+1,VALUE(RETURN)        LOAD VALUE                  18915000
         TM    VFLAGS(RETURN),VINP+VINA     IS IT READ ASSOCIATED?      18916000
         BNO   EVLR1              OFF TO RESTORE REGS IF NOT            18917000
         ST    RETURN,EVALVAR     SAVE VAR BLOCK ADDRESS FOR READ       18918000
         L     RETURN,EVALRCON    GET ADDRESS OF DUMMY CODE             18919000
         BR    RETURN             OFF TO CODE                           18920000
*                                                                       18921000
*        COME HERE WITH VALUE TO RETURN TO CALLER                       18922000
*                                                                       18923000
EVLR1    L     R2,PDRBPTR(,PDR)   RESTORE ACTUAL PDR IN CODE ABOVE US   18924000
         ST    R2,PDRLOC          SET IN CASE OF ERROR OR FAIL          18925000
         SPM   R1                 SEE WHO CALLED US                     18926000
         BNE   4(,R1)             RETURN TO CALLER FOR EVAL CASE        18927000
         LA    PDR,PATSPACE(,PDR) PUSH UP STACK                         18928000
         LM    PS1,PB,PSAVPS1(PDR)          RESTORE REGISTERS BELOW PO  18929000
         LM    CP,PBASE,PSAVCP(PDR)         RESTORE REGISTERS ABOVE PO  18930000
         ST    FR,FRSAVE          SAVE NEW FREE CORE ADDRESS            18931000
         L     R0,RETLOCP(,R2)    GET RETURN ADDR FOR PAT MATCH ERRORS  18932000
         ST    R0,RETLOC          AND STORE FOR ERROR MESSAGE ROUTINE   18933000
         L     FSADR,PSTRING(,R2) GET START OF STRING ADDRESS           18934000
         AH    FSADR,PSTRING+SOFFSET(,R2)   ADD IN OFFSET               18935000
         AH    FSADR,PSTRING+SLENGTH(,R2)   ADD IN 360 LENGTH           18936000
         LA    FSADR,SCHARS+1(,FSADR)       POINT PAST LAST CHARACTER   18937000
         B     4(,R1)             RETURN PAST FAIL RETURN               18938000
         TITLE 'SPITBOLA -- ARITHMETIC OPERATOR ROUTINES'               18939000
*                                                                       18940000
*        $$INCR                   INCREMENT (BY ONE)                    18941000
*                                                                       18942000
*        (A1,A1+1)                ARG TO BE INCREMENTED                 18943000
*        BAL   RETURN,$$INCR                                            18944000
*        (A1,A1+1)                INCREMENTED RESULT                    18945000
*                                                                       18946000
$$INCR   LA    A2+1,1             GET A ONE                             18947000
         LTR   A1,A1              WAS ARGUMENT AN INTEGER?              18948000
         BZ    ADDI               IF SO, JUMP TO ADD ONE                18949000
         SR    A2,A2              ELSE MAKE INTEGER 1 AND MERGE $$ADD2  18950000
*                                                                       18951000
*        $$ADD2                   SUM                                   18952000
*                                                                       18953000
*        (A1,A1+1)                LEFT ARG                              18954000
*        (A2,A2+1)                RIGHT ARG                             18955000
*        BAL   RETURN,$$ADD2                                            18956000
*        (A1,A1+1)                SUM                                   18957000
*                                                                       18958000
$$ADD2   ALR   A1,A2              ADD TYPE CODES                        18959000
         BZ    ADDI               IF SUM=0, BOTH ARGS ARE INTEGERS      18960000
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES         18961000
         XERR  01,027             OPERAND OF BINARY + IS NON-NUMERIC    18962000
*                                                                       18963000
*        INSTRUCTIONS EXECUTED IN REAL,DREAL CASES                      18964000
*                                                                       18965000
         AD    FA,ARITHSV+8       INSTRUCTION FOR DREAL CASE            18966000
         AE    FA,ARITHSV+12      INSTRUCTION FOR REAL CASE             18967000
*                                                                       18968000
*        CASE OF ADDITION OF TWO INTEGERS                               18969000
*                                                                       18970000
ADDI     AR    A1+1,A2+1          PUT SUM IN A1+1 (A1 IS SET OK)        18971000
         BCR   NO,RETURN          RETURN IF NO OVERFLOW                 18972000
         XERR  10,007,S           INTEGER ADDITION OVERFLOW             18973000
         EJECT                                                          18974000
*                                                                       18975000
*        $$DECR                   DECREMENT (BY ONE)                    18976000
*                                                                       18977000
*        (A1,A1+1)                ARGUMENT TO BE DECREMENTED            18978000
*        BAL   RETURN,$$DECR                                            18979000
*        (A1,A1+1)                DECREMENTED RESULT                    18980000
*                                                                       18981000
$$DECR   LA    A2+1,1             GET A ONE                             18982000
         LTR   A1,A1              WAS ARGUMENT AN INTEGER?              18983000
         BZ    SUBI               IF SO, JUMP TO SUBTRACT ONE           18984000
         SR    A2,A2              ELSE MAKE INTEGER 1 AND MERGE $$SUB2  18985000
*                                                                       18986000
*        $$SUB2                   SUBTRACTION                           18987000
*                                                                       18988000
*        (A1,A1+1)                LEFT ARGUMENT                         18989000
*        (A2,A2+1)                RIGHT ARGUMENT                        18990000
*        BAL   RETURN,$$SUB2                                            18991000
*        (A1,A1+1)                DIFFERENCE                            18992000
*                                                                       18993000
$$SUB2   ALR   A1,A2              ADD TYPE CODES                        18994000
         BZ    SUBI               SUM=0 IF BOTH ARGS INTEGERS           18995000
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES         18996000
         XERR  01,028             OPERAND OF BINARY - IS NON-NUMERIC    18997000
*                                                                       18998000
*        INSTRUCTIONS EXECUTE IN REAL,DREAL CASES                       18999000
*                                                                       19000000
         SD    FA,ARITHSV+8       INSTRUCTION FOR DREAL CASE            19001000
         SE    FA,ARITHSV+12      INSTRUCTION FOR REAL CASE             19002000
*                                                                       19003000
*        CASE OF SUBTRACTION OF TWO INTEGERS                            19004000
*                                                                       19005000
SUBI     SR    A1+1,A2+1          DO SUBTRACTION                        19006000
         BCR   NO,RETURN          RETURN TO CODE IF NO OVERFLOW         19007000
         XERR  10,008,S           INTEGER SUBTRACTION OVERFLOW          19008000
         EJECT                                                          19009000
*                                                                       19010000
*        $$MLT2                   MULTIPLICATION                        19011000
*                                                                       19012000
*        (A1,A1+1)                LEFT ARGUMENT                         19013000
*        (A2,A2+1)                RIGHT ARGUMENT                        19014000
*        BAL   RETURN,$$MLT2                                            19015000
*        (A1,A1+1)                PRODUCT                               19016000
*                                                                       19017000
$$MLT2   ALR   A1,A2              ADD TYPE CODES                        19018000
         BZ    MLTI               RESULT IS ZERO IF BOTH INTEGERS       19019000
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES         19020000
         XERR  01,029             OPERAND OF BINARY * IS NON-NUMERIC    19021000
*                                                                       19022000
*        INSTRUCTIONS EXECUTED FOR REAL,DREAL CASES                     19023000
*                                                                       19024000
         MD    FA,ARITHSV+8       INSTRUCTION FOR DREAL CASE            19025000
         ME    FA,ARITHSV+12      INSTRUCTION FOR REAL CASE             19026000
*                                                                       19027000
*        MULTIPLICATION OF TWO INTEGERS                                 19028000
*                                                                       19029000
MLTI     MR    A1,A2+1            DO MULTIPLICATION                     19030000
         LTR   A1+1,A1+1          TEST SIGN OF RESULT                   19031000
         BNM   *+8                SKIP IF POSITIVE                      19032000
         X     A1,=X'FFFFFFFF'    ELSE COMPLEMENT UPPER REG (SIGN BITS) 19033000
         LTR   A1,A1              UPPER REG SHOULD BE ALL ZEROS         19034000
         BCR   Z,RETURN           RETURN TO CODE IF SO                  19035000
         XERR  10,009,S           INTEGER MULTIPLICATION OVERFLOW       19036000
         EJECT                                                          19037000
*                                                                       19038000
*        $$DVD2                   DIVISION                              19039000
*                                                                       19040000
*        (A1,A1+1)                LEFT ARGUMENT                         19041000
*        (A2,A2+1)                RIGHT ARGUMENT                        19042000
*        BAL   RETURN,$$DVD2                                            19043000
*        (A1,A1+1)                QUOTIENT                              19044000
*                                                                       19045000
$$DVD2   ALR   A1,A2              ADD TYPE CODES                        19046000
         BZ    DVDI               IF ZERO, BOTH INTEGERS                19047000
         BAL   R2,ARITH           CALL COMMON ROUTINE IN OTHER CASES    19048000
         XERR  01,030             OPERAND OF BINARY / IS NON-NUMERIC    19049000
*                                                                       19050000
*        INSTRUCTIONS EXECUTED IN REAL,DREAL CASES                      19051000
*                                                                       19052000
         DD    FA,ARITHSV+8       INSTRUCTION FOR DREAL CASE            19053000
         DE    FA,ARITHSV+12      INSTRUCTION FOR REAL CASE             19054000
*                                                                       19055000
*        CASE OF DIVISION OF TWO INTEGERS                               19056000
*                                                                       19057000
DVDI     LTR   A1+1,A1+1          TEST SIGN OF DIVIDEND                 19058000
         BNM   *+6                SKIP IF ZERO OR POSITIVE              19059000
         BCTR  A1,0               ELSE PROPOGATE MINUS SIGN IN A1       19060000
         DR    A1,A2+1            DO DIVISION                           19061000
*                                                                       19062000
*        NOTE -- INTERRUPT LOCATION -- ERROR EXIT DVDIZ                 19063000
*                                                                       19064000
DVDII    BR    0                  ENSURE PRECISE INTERRUPT              19065000
         SR    A1,A1              IF OK, CLEAR TYPE CODE TO INTEGER     19066000
         BR    RETURN             RETURN TO CODE                        19067000
         EJECT                                                          19068000
*                                                                       19069000
*        $$CMPR                   COMPARISON                            19070000
*                                                                       19071000
*        (A1,A1+1)                LEFT ARGUMENT                         19072000
*        (A2,A2+1)                RIGHT ARGUMENT                        19073000
*        BAL   RETURN,$$CMPR                                            19074000
*        (CONDITION CODE IS LEFT SET CORRECTLY)                         19075000
*                                                                       19076000
$$CMPR   ALR   A1,A2              ADD TYPE CODES                        19077000
         BZ    CMPI               SKIP ON CASE OF BOTH INTEGERS         19078000
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES         19079000
         XERR  01,031             ARGUMENT TO NE,EQ,LE,GE,LT OR GT      19080000
*                                 IS NON-NUMERIC                        19081000
*                                                                       19082000
*        INSTRUCTIONS EXECUTED IN REAL AND DREAL CASES                  19083000
*                                                                       19084000
         B     CMPD               JUMP ON DREAL CASE                    19085000
         B     CMPR               JUMP ON REAL CASE                     19086000
*                                                                       19087000
*        CASE OF COMPARISON OF TWO INTEGERS                             19088000
*                                                                       19089000
CMPI     CR    A1+1,A2+1          COMPARE INTEGER VALUES                19090000
         BR    RETURN             RETURN TO CODE                        19091000
*                                                                       19092000
*        CASE OF COMPARISON OF DREALS                                   19093000
*                                                                       19094000
CMPD     CD    FA,ARITHSV+8       DO COMPARISON                         19095000
         BR    RETURN             LEAVE WITH CC SET                     19096000
*                                                                       19097000
*        CASE OF COMPARISON OF REALS                                    19098000
*                                                                       19099000
CMPR     CE    FA,ARITHSV+12      DO REAL COMPARISON                    19100000
         BR    RETURN             RETURN WITH CC SET                    19101000
         EJECT                                                          19102000
*                                                                       19103000
*        $$EXP2                   EXPONENTIATION                        19104000
*                                                                       19105000
*        (A1,A1+1)                LEFT ARGUMENT                         19106000
*        (A2,A2+1)                RIGHT ARGUMENT                        19107000
*        BAL   RETURN,$$EXP2                                            19108000
*        (A1,A1+1)                RESULT                                19109000
*                                                                       19110000
$$EXP2   ALR   A1,A2              ADD TYPE CODES                        19111000
         BZ    EXPI               SKIP IF BOTH INTEGERS                 19112000
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES         19113000
         XERR  01,032             OPERAND OF BINARY ** IS NON-NUMERIC   19114000
*                                                                       19115000
*        INSTRUCTIONS EXECUTED IN DREAL,REAL CASES                      19116000
*                                                                       19117000
         BAL   R0,EXPDD           JUMP TO        (SEE TEST AT ARITH1    19118000
         BAL   R0,EXPRR            GIVE ERROR     TO EXPLAIN BAL)       19119000
*                                                                       19120000
*        CASE OF EXPONENTIATION OF TWO INTEGERS                         19121000
*                                                                       19122000
EXPI     LTR   A2+1,A2+1          TEST EXPONENT                         19123000
         BP    EXPOS              SKIP IF EXPONENT > 0                  19124000
         LA    A1+1,1             PREPARE RESULT OF 1 FOR N ** 0        19125000
         BCR   Z,RETURN           AND RETURN FOR THIS CASE (EXPONENT=0) 19126000
         XERR  10,010,S           NEGATIVE EXPONENT FOR                 19127000
*                                 INTEGER ** INTEGER                    19128000
*                                                                       19129000
*        CASE OF EXPONENT > 0                                           19130000
*                                                                       19131000
EXPOS    LR    R1,A1+1            COPY BASE                             19132000
         B     EXPOS2             JUMP TO END OF LOOP                   19133000
*                                                                       19134000
*        LOOP TO MULTIPLY BY BASE (EXPONENT - 1) TIMES                  19135000
*                                                                       19136000
EXPOSL   MR    A1,R1              MULTIPLY BY BASE                      19137000
         SLDA  A1,32              TEST FOR OVERFLOW                     19138000
         BNO   *+10               SKIP IF NONE                          19139000
         XERR  10,011,S           OVERFLOW IN INTEGER EXPONENTIATION    19140000
         SRDA  A1,32              REPOSITION RESULT                     19141000
*                                                                       19142000
*        JUMP TO THIS POINT IN LOOP FIRST TIME                          19143000
*                                                                       19144000
EXPOS2   BCT   A2+1,EXPOSL        BACK TO MULTIPLY AGAIN                19145000
         SR    A1,A1              WHEN ALL DONE, SET CODE = 0 (ICODE)   19146000
         BR    RETURN             AND RETURN TO CODE                    19147000
*                                                                       19148000
*        ERROR EXITS FOR DREAL AND REAL CASES                           19149000
*                                                                       19150000
EXPDD    XERR  10,012             DREAL ** DREAL IS NOT PERMITTED       19151000
EXPRR    XERR  10,013             REAL ** REAL IS NOT PERMITTED         19152000
         EJECT                                                          19153000
*                                                                       19154000
*        SPECIAL EXPONENTIATION ROUTINE FOR DREAL ** INTEGER            19155000
*                                                                       19156000
EXPWTOI  LR    A2+1,A1+1          SAVE EXPONENT                         19157000
         BAL   FRETURN,ARITHWM    MERGE INTO ARITHSV TO LOAD DREAL      19158000
         MDR   ZR,FA              + EXP INSTRUC (R2 => HERE ON RETURN)  19159000
         DDR   ZR,FA              - EXP INSTRUCTION                     19160000
         B     EXPWRI             ARITH EXECUTES THIS INSTRUCTION       19161000
*                                                                       19162000
*        SPECIAL ROUTINE FOR REAL ** INTEGER                            19163000
*                                                                       19164000
EXPRTOI  BAL   FRETURN,ARITHIM    USE ARITH TO LOAD REAL ARGUMENT       19165000
         MER   ZR,FA              + EXPONENT INSTRUCTION                19166000
         DER   ZR,FA              MINUS EXPONENT INSTRUCTION            19167000
         NOP   0                  4 EXTRA BYTES (EXECUTE IS OF 8(R2))   19168000
         B     EXPWRI             ARITH EXECUTES THIS INSTRUCTION       19169000
*                                                                       19170000
*        COMMON ROUTINE FOR DREAL ** INTEGER AND REAL ** INTEGER        19171000
*                                                                       19172000
EXPWRI   LE    ZR,=E'1.0'         LOAD INITIAL VALUE OF ONE             19173000
         LTR   A2+1,A2+1          TEST EXPONENT                         19174000
         BP    EXPWRI1            SKIP IF EXPONENT IS POSITIVE          19175000
         BZ    EXPWRI2            SKIP IF EXPONENT IS ZERO              19176000
*                                                                       19177000
*        HERE FOR NEGATIVE EXPONENT                                     19178000
*                                                                       19179000
         LPR   A2+1,A2+1          FORCE EXPONENT POSITIVE               19180000
         LA    R2,2(,R2)          POINT TO DIVIDE INSTEAD OF MULTIPLY   19181000
*                                                                       19182000
*        COME HERE TO DO EXPONENTIATION                                 19183000
*                                                                       19184000
EXPWRI1  BALR  R1,0               SET START OF LOOP ADDRESS             19185000
         EX    0,0(,R2)           EXECUTE MDR,MER,DDR,DER               19186000
*                                                                       19187000
*        THIS IS AN INTERRUPT LOCATION -- EXIT TO EXPWRO ON FPT OVERFLO 19188000
*                                                                       19189000
EXPWRE   BR    0                  ENSURE PRECISE INTERRUPT              19190000
         BCTR  A2+1,R1            IF NO OVERFLOW, LOOP TILL DONE        19191000
*                                                                       19192000
*        COME HERE TO STORE RESULT                                      19193000
*                                                                       19194000
EXPWRI2  LDR   FA,ZR              PUT RESULT IN PROPER REG              19195000
         SDR   ZR,ZR              CLEAR ZR BACK TO ZERO                 19196000
         TM    0(R2),X'10'        CHECK FOR BIT INDICATING SHORT-FORM   19197000
         BNO   DREALIL            SKIP BACK TO RETURN DREAL             19198000
         STE   FA,ARITHSV+4       ELSE STORE REAL RESULT                19199000
         LM    A1,A1+1,ARITHSV    LOAD INTO RESULT REGS                 19200000
         BR    RETURN             RETURN TO CALLER                      19201000
         EJECT                                                          19202000
*        ARITH ROUTINE -- CALLED BY BINARY ARITHMETIC ROUTINES TO DO    19203000
*        TYPE ANALYSIS AND CONVERSION IN ALL BUT SIMPLE CASES           19204000
*                                                                       19205000
*        (A1)                     SUM OF TYPE CODES                     19206000
*        (A1+1)                   SECOND WORD OF LEFT ARG               19207000
*        (A2,A2+1)                RIGHT ARG                             19208000
*        BAL   R1,ARITH                                                 19209000
*        ->  ERROR EXIT FOR ARGUMENTS NOT CONVERTIBLE                   19210000
*        -> INSTRUCTION EXECUTED IN DREAL/DREAL CASE                    19211000
*        -> INSTRUCTION EXECUTED IN REAL/REAL CASE                      19212000
*        -> EXIT POINT FOR INTEGER/INTEGER CASE                         19213000
*        (A1,A1+1)                CONVERTED LEFT ARGUMENT               19214000
*        (A2,A2+1)                CONVERTED RIGHT ARGUMENT              19215000
*                                                                       19216000
*        NORMALLY BOTH ARGUMENTS ARE CONVERTED TO THE HIGHER TYPE --    19217000
*        THE ONE EXCEPTION TO THIS CASE IS FOR EXPONENTIATION           19218000
*        (RECOGNIZED BY THE XERR FOR DREAL/DREAL CASE). HERE THE CASES  19219000
*        DREAL ** INTEGER, REAL ** INTEGER RETURN TO THE SPECIAL        19220000
*        ROUTINES EXPWTOI AND EXPRTOI RESPECTIVELY                      19221000
*                                                                       19222000
ARITH    BC    CZ,ARITHRR         IMMEDIATE SKIP ON REAL/REAL CASE      19223000
         STM   FRETURN,RETURN,FRETLOC       SAVE RETURN REGISTERS       19224000
         SR    A1,A2              RESTORE TYPE CODES                    19225000
         LR    FRETURN,R2         SAVE ARITH LINKAGE                    19226000
         BAL   RETURN,GETNUM      CONVERT FIRST ARG TO NUMERIC          19227000
         BR    FRETURN            ERROR RETURN IF UNCONVERTIBLE         19228000
         NOPR  0                  SPACE TO FILL ERROR RETURN TO 4 BYTES 19229000
         STM   A1,A1+1,ARITHSV    SAVE CONVERTED FIRST ARGUMENT         19230000
         LR    A1,A2              COPY SECOND ARGUMENT                  19231000
         LR    A1+1,A2+1          ...                                   19232000
         BAL   RETURN,GETNUM      CONVERT SECOND ARGUMENT TO NUMERIC    19233000
         BR    FRETURN            ERROR RETURN IF UNCONVERTIBLE         19234000
         NOPR  0                  FILL ERROR RETURN TO 4 BYTES          19235000
         BNP   ARITH1             SKIP IF SECOND ARG REAL OR INTEGER    19236000
*                                                                       19237000
*        COME HERE WITH SECOND ARGUMENT DREAL                           19238000
*                                                                       19239000
ARITHWW  SLDL  A1,8               POSITION DREAL FOR ARITHMETIC         19240000
         STM   A1,A1+1,ARITHSV+8  SAVE DREAL SECOND ARGUMENT            19241000
*                                                                       19242000
*        EXPWI MERGES HERE TO LOAD ITS ARGUMENT                         19243000
*                                                                       19244000
ARITHWM  LM    A1,A1+1,ARITHSV    LOAD FIRST ARGUMENT                   19245000
         BAL   RETURN,GETDREAL    CONVERT FIRST ARG TO DREAL            19246000
         NOP   0                  NO ERROR IS POSSIBLE                  19247000
         SLDL  A1,8               POSITION FIRST ARG FOR ARITHMETIC     19248000
         STM   A1,A1+1,ARITHSV    SAVE DREAL FIRST ARG                  19249000
         LD    FA,ARITHSV         LOAD FIRST ARGUMENT                   19250000
         LR    R2,FRETURN         RESTORE LINKAGE TO ARITHSV            19251000
         LM    FRETURN,RETURN,FRETLOC       RESTORE RETURN REGS         19252000
         STE   ZR,FRETLOC         INDICATE FRETLOC NOT IN USE           19253000
         EX    0,4(,R2)           EXECUTE ARITHMETIC INSTRUCTION        19254000
         EJECT                                                          19255000
*                                                                       19256000
*        ARITH -- CONTINUED                                             19257000
*                                                                       19258000
*                                                                       19259000
*        THIS IS AN INTERRUPT LOCATION, ON FLOATING OVERFLOW, THE EXIT  19260000
*        IS TO DREALO, ON FLOATING DIVIDE, THE EXIT IS TO DREALDZ       19261000
*                                                                       19262000
DREALIL  BR    0                  ENSURE PRECISE INTERRUPT              19263000
         STD   FA,ARITHSV         IF OK, STORE RESULT                   19264000
         LM    A1,A1+1,ARITHSV    LOAD INTO PROPER REG                  19265000
         SRDL  A1,8               POSITION                              19266000
         AL    A1,WCODEBT         SUPPLY TYPE CODE                      19267000
         BR    RETURN             RETURN TO CALLER                      19268000
*                                                                       19269000
*        COME HERE IF SECOND ARGUMENT IS INTEGER OR REAL                19270000
*                                                                       19271000
ARITH1   CLI   ARITHSV,WCODE      IS FIRST ARG DREAL?                   19272000
         BNE   ARITH2             SKIP IF NOT                           19273000
         LTR   A1,A1              IS SECOND ARG INTEGER?                19274000
         BNZ   ARITH1A            SKIP IF NOT                           19275000
         CLI   4(FRETURN),X'45'   IS THIS EXPONENTIATION CASE? (BAL R0) 19276000
         BE    EXPWTOI            SKIP IF SO TO GET DREAL ** INTEGER    19277000
*                                                                       19278000
*        COME HERE IF BOTH ARGS TO BE CONVERTED TO DREAL                19279000
*                                                                       19280000
ARITH1A  BAL   RETURN,GETDREAL    CONVERT SECOND ARGUMENT TO DREAL      19281000
         NOP   0                  NO ERROR RETURN IS POSSIBLE           19282000
         B     ARITHWW            MERGE BACK FOR DREAL/DREAL CASE       19283000
*                                                                       19284000
*        COME HERE IF NEITHER ARGUMENT IS A DREAL                       19285000
*                                                                       19286000
ARITH2   LTR   A1,A1              TEST SECOND ARGUMENT                  19287000
         BZ    ARITH3             SKIP IF SECOND ARGUMENT INTEGER       19288000
         LR    A2+1,A1+1          MOVE REAL SECOND ARGUMENT             19289000
         LR    A2,A1              ...                                   19290000
         LM    A1,A1+1,ARITHSV    LOAD FIRST ARGUMENT                   19291000
         BAL   RETURN,GETREAL     CONVERT FIRST ARGUMENT TO REAL        19292000
         NOP   0                  NO ERROR RETURN IS POSSIBLE           19293000
*                                                                       19294000
*        REENTER HERE FOR REAL/INTEGER CONVERTED TO REAL/REAL           19295000
*                                                                       19296000
ARITH2A  LR    R2,FRETURN         RELOAD ARITH LINKAGE                  19297000
         LM    FRETURN,RETURN,FRETLOC       RELOAD RETURN REGS          19298000
         STE   ZR,FRETLOC         INDICATE FRETLOC NOT IN USE           19299000
*                                                                       19300000
*        COME HERE IF BOTH ARGUMENTS ARE REAL                           19301000
*                                                                       19302000
ARITHRR  STM   A1+1,A2+1,ARITHSV+4          STORE REAL ARGS             19303000
         LE    FA,ARITHSV+4       LOAD LEFT ARGUMENT                    19304000
         EX    0,8(,R2)           EXECUTE PROPER ARITHMETIC INSTRUC     19305000
         EJECT                                                          19306000
*                                                                       19307000
*        THIS IS AN INTERRUPT LOCATION -- ON FLOATING OVERFLOW, THE     19308000
*        EXIT IS TO REALO, ON FLOATING DIVIDE, THE EXIT IS TO REALDZ    19309000
*                                                                       19310000
REALIL   BR    0                  ENSURE PRECISE INTERRUPT              19311000
         STE   FA,ARITHSV+12      STORE RESULT                          19312000
         LM    A1,A1+1,ARITHSV+8  LOAD RESULT INTO PROPER REG           19313000
         BR    RETURN             RETURN TO CALLER                      19314000
*                                                                       19315000
*        COME HERE IS SECOND ARG IS INTEGER, FIRST ARG REAL OR INTEGER  19316000
*                                                                       19317000
ARITH3   CLI   ARITHSV,ICODE      IS FIRST ARG INTEGER?                 19318000
         BE    ARITH4             SKIP IF SO (BOTH INTEGERS)            19319000
         CLI   4(FRETURN),X'45'   IS THIS EXPONENTIATION CASE? (BAL R0) 19320000
         BE    EXPRTOI            IF SO, JUMP TO COMPUTE REAL**INTEGER  19321000
         BAL   RETURN,GETREAL     ELSE CONVERT SECOND ARG TO REAL       19322000
         NOP   0                  NO ERROR IS POSSIBLE                  19323000
*                                                                       19324000
*        EXPRI MERGES HERE TO LOAD ITS ARGUMENT                         19325000
*                                                                       19326000
ARITHIM  LR    A2+1,A1+1          MOVE SECOND ARGUMENT                  19327000
         LR    A2,A1              ...                                   19328000
         LM    A1,A1+1,ARITHSV    LOAD REAL FIRST ARGUMENT              19329000
         B     ARITH2A            AND JUMP BACK FOR REAL/REAL CASE      19330000
*                                                                       19331000
*        COME HERE FOR INTEGER/INTEGER CASE                             19332000
*                                                                       19333000
ARITH4   LR    A2,A1              MOVE FIRST ARG TO A2,A2+1             19334000
         LR    A2+1,A1+1                                                19335000
         LM    A1,A1+1,ARITHSV    RELOAD FIRST ARGUMENT                 19336000
         LR    R2,FRETURN         RELOAD ARITH LINKAGE                  19337000
         LM    FRETURN,RETURN,FRETLOC       RESTORE RETURN REGS         19338000
         STE   ZR,FRETLOC         INDICATE FRETLOC NOT IN USE           19339000
         B     12(,R2)            JUMP TO INTEGER/INTEGER CODE          19340000
         EJECT                                                          19341000
*                                                                       19342000
*        $$ADD1                   AFFIRMATION                           19343000
*                                                                       19344000
*        (A1,A1+1)                ARGUMENT                              19345000
*        BAL   RETURN,$$ADD1                                            19346000
*        (A1,A1+1)                RESULT                                19347000
*                                                                       19348000
$$ADD1   ST    RETURN,RETLOC      STORE RETURN LOCATION (FOR XERR)      19349000
         LR    A2,RETURN          SAVE RETURN LOCATION                  19350000
         BAL   RETURN,GETNUM      CONVERT TO NUMERIC                    19351000
         XERR  01,033             OPERAND OF UNARY + IS NON-NUMERIC     19352000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               19353000
         BR    A2                 RETURN TO CODE                        19354000
*                                                                       19355000
*        $$SUB1                   NEGATION                              19356000
*                                                                       19357000
*        (A1,A1+1)                ARGUMENT                              19358000
*        BAL   RETURN,$$SUB1                                            19359000
*        (A1,A1+1)                NEGATIVE                              19360000
*                                                                       19361000
$$SUB1   ST    RETURN,RETLOC      SAVE RETURN LOCATION                  19362000
         BAL   RETURN,GETNUM      CONVERT TO NUMERIC                    19363000
         XERR  01,034             OPERAND OF UNARY - IS NON-NUMERIC     19364000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               19365000
         BZ    SUB1I              SKIP ON INTEGER CASE                  19366000
         BO    SUB1R              SKIP ON REAL CASE                     19367000
*                                                                       19368000
*        HERE FOR DREAL                                                 19369000
*                                                                       19370000
         X     A1,=X'00800000'    INVERT SIGN BIT                       19371000
         BR    RETURN             RETURN TO CODE                        19372000
*                                                                       19373000
*        HERE FOR INTEGER CASE                                          19374000
*                                                                       19375000
SUB1I    LCR   A1+1,A1+1          NEGATE INTEGER                        19376000
         BCR   NO,RETURN          RETURN IF NO OVERFLOW                 19377000
         XERR  10,014             INTEGER OVERFLOW FOR UNARY MINUS      19378000
*                                 (HAPPENS ONLY WITH LARGEST NEG NUM)   19379000
*                                                                       19380000
*        HERE FOR REAL CASE                                             19381000
*                                                                       19382000
SUB1R    X     A1+1,X80           INVERT SIGN BIT                       19383000
         BR    RETURN             RETURN TO CODE                        19384000
         TITLE 'SPITBOLA -- ARRAY ENTRY POINTS'                         19385000
*                                                                       19386000
*        THESE FUNCTIONS ARE CALLED TO CALCULATE ARRAY NAMES AND VALUES 19387000
*        THE ACTUAL ROUTINES ARE IN THE UNADDRESSABLE REGION            19388000
*        THIS CODING IS REPEATED IN THE ITEM FUNCTION                   19389000
*                                                                       19390000
*                                                                       19391000
*        $$AR1N                   SINGLE SUBSCRIPTED ARRAY BY NAME      19392000
*                                                                       19393000
$$AR1N   MVI   NAMEFL,0           SET BY NAME FLAG AND MERGE $$AR1V     19394000
         L     R2,SUBSC1AD        GET ADDRESS OF ROUTINE                19395000
         BR    R2                 AND GO TO IT                          19396000
*                                                                       19397000
*        $$AR1V                   SINGLE SUBSCRIPTED ARRAY BY VALUE     19398000
*                                                                       19399000
$$AR1V   MVI   NAMEFL,X'FF'       SET CALL BY VALUE                     19400000
         L     R2,SUBSC1AD        GET ADDRESS OF ROUTINE                19401000
         BR    R2                 AND GO TO IT                          19402000
*                                                                       19403000
SUBSC1AD DC    A(SUBSC1)          ADDRESS OF ROUTINE                    19404000
*                                                                       19405000
*        $$ARMN                   MULTIPLE SUBSCRIPT ARRAY BY NAME      19406000
*                                                                       19407000
$$ARMN   MVI   NAMEFL,0           SET BY NAME FLAG AND MERGE $$ARMV     19408000
         L     A2,SUBSCMAD        GET ADDRESS OF ROUTINE                19409000
         BR    A2                 AND OFF TO IT                         19410000
*                                                                       19411000
$$ARMV   MVI   NAMEFL,X'FF'       SET FOR CALL BY VALUE                 19412000
         L     A2,SUBSCMAD        GET ADDRESS OF ROUTIEN                19413000
         BR    A2                 AND OFF TO IT                         19414000
*                                                                       19415000
SUBSCMAD DC    A(SUBSCM)          ADDRESS OF ROUTINE                    19416000
         TITLE 'SPITBOLA -- MISCELLANEOUS OPERATOR ENTRY POINTS'        19417000
*                                                                       19418000
*        $$DTTP                             DATATYPE FUNCTION           19419000
*                                                                       19420000
$$DTTP   L     R2,=A(DATATPP)     LOAD ROUTINE ADDRESS                  19421000
         BR    R2                 OFF TO IT                             19422000
*                                                                       19423000
*        SYSTEM ENTRY POINT FOR OPSYN ROUTINE                           19424000
*                                                                       19425000
OPSYN$   L     A2,=A(OPSYN$C)     GET BASE REGISTER                     19426000
         BR    A2                 AND OFF TO ROUTINE                    19427000
*                                                                       19428000
*        SYSTEM ENTRY POINT FOR XSCAN INITIALIZATION                    19429000
*                                                                       19430000
XSCANI   L     A2,=A(XSCAN)       LOAD BASE REGISTER                    19431000
         USING XSCAN,A2           TELL ASSEMBLER                        19432000
         B     XSCANIC            OFF TO INITIALIZATION CODE            19433000
         DROP  A2                 GET RID OF BASE REGISTER              19434000
*                                                                       19435000
*        SYSTEM ENTRY POINT FOR ROUTINE TO ORDER TABLE ELEMENTS         19436000
*                                                                       19437000
TBCHRON  L     A2,=A(TBCHRONC)    LOAD ROUTINE ADDRESS                  19438000
         BR    A2                 AND OFF TO IT                         19439000
         EJECT                                                          19440000
*                                                                       19441000
*        $$LCMP                   LEXICAL COMPARISON                    19442000
*                                                                       19443000
*        (A1,A1+1)                FIRST ARGUMENT                        19444000
*        (A2,A2+1)                SECOND ARGUMENT                       19445000
*        BAL   RETURN,$$LCMP                                            19446000
*        (RETURN WITH CONDITION CODE SET CORRECTLY)                     19447000
*                                                                       19448000
*        THIS ROUTINE IS USED BY LEQ,LNE,LGT,LLT,LLE,LGE                19449000
*                                                                       19450000
$$LCMP   ST    RETURN,RETLOC      SAVE RETURN LOCATION                  19451000
         BAL   RETURN,GETSTGT     CONVERT LEFT ARG TO STRING            19452000
         XERR  01,035             ARGUMENT FOR LEQ,LNE,LGT,LLT,         19453000
*                                 LGE OR LLE IS NOT A STRING            19454000
         LR    RETURN,A1          SWITCH ARGUMENTS                      19455000
         LR    A1,A2              ...                                   19456000
         LR    A2,RETURN          ...                                   19457000
         LR    RETURN,A1+1        ...                                   19458000
         LR    A1+1,A2+1          ...                                   19459000
         LR    A2+1,RETURN        ...                                   19460000
         BAL   RETURN,GETSTGS     CONVERT TO STRING                     19461000
         XERN  01,035             ARGUMENT FOR LEQ,LNE,LGT,LLT,         19462000
*                                 LGE OR LLE IS NOT A STRING            19463000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               19464000
*                                                                       19465000
*        THE DUMP FUNCTION ENTERS HERE TO COMPARE TWO STRINGS AND IT    19466000
*        IS IMPORTANT THAT ONLY A1,A1+1,A2,A2+1,R1 ARE USED FROM NOW ON 19467000
*                                                                       19468000
LCMPM    CR    A2+1,A1+1          COMPARE LENGTHS                       19469000
         BALR  R1,0               SAVE RESULT OF THIS COMPARISON        19470000
         BNL   *+6                SKIP IF A1+1 HAS SHORTER LENGTH       19471000
         LR    A1+1,A2+1          ELSE GET THE SHORTER LENGTH           19472000
         LTR   A1+1,A1+1          IS EITHER OR BOTH ARGS NULL?          19473000
         BM    LCMP3              SKIP IF SO TO SET CC BY LENGTHS       19474000
*                                                                       19475000
*        HERE WE ARE READY TO COMPARE TWO STRINGS                       19476000
*                                                                       19477000
         LA    A2+1,256           GET CRANK CONSTANT                    19478000
         CR    A1+1,A2+1          256 CHARACTERS OR LESS?               19479000
         BL    LCMP2              SKIP IF SO                            19480000
         EJECT                                                          19481000
*                                                                       19482000
*        $$LCMP -- CONTINUED                                            19483000
*                                                                       19484000
*                                                                       19485000
*        LOOP TO CHECK 256 CHARACTERS AT A TIME                         19486000
*                                                                       19487000
LCMP1    CLC   SCHARS(256,A2),SCHARS(A1)    CHECK 256 CHARS             19488000
         BCR   NE,RETURN          ALL DONE IF NO MATCH                  19489000
         AR    A1,A2+1            ELSE BUMP ARG ONE POINTER             19490000
         AR    A2,A2+1            BUMP ARG TWO POINTER                  19491000
         SR    A1+1,A2+1          DECREMENT CHARS LEFT                  19492000
         CR    A1+1,A2+1          STILL MORE THAN 256 CHARACTERS?       19493000
         BNL   LCMP1              LOOP BACK IF SO                       19494000
*                                                                       19495000
*        COME HERE TO CHECK FINAL CHARACTERS                            19496000
*                                                                       19497000
LCMP2    EX    A1+1,LCMPC         CHECK LAST CHARS                      19498000
         BCR   NE,RETURN          ALL SET IF THEY DO NOT MATCH          19499000
*                                                                       19500000
*        COME HERE IF ALL CHARS MATCH -- SET CC BY LENGTHS              19501000
*                                                                       19502000
LCMP3    SPM   R1                 RECALL CC FROM LENGTH COMPARISON      19503000
         BR    RETURN             RETURN TO CALLER                      19504000
*                                                                       19505000
LCMPC    CLC   SCHARS(*-*,A2),SCHARS(A1)    CHECK REMAINING CHARS       19506000
         EJECT                                                          19507000
*        $$IDNT                   IDENT                                 19508000
*                                                                       19509000
*        (A1,A1+1)                LEFT ARG                              19510000
*        (A2,A2+1)                RIGHT ARG                             19511000
*        BAL   RETURN,$$IDNT                                            19512000
*        (CC SET EQUAL OR UNEQUAL DEPENDING ON RESULT)                  19513000
*                                                                       19514000
*        NOTE -- THIS ROUTINE MUST NOT USE R0,R1,R2 SINCE IT IS CALLED  19515000
*        FROM WITHIN THE SYSTEM (SEE $ ROUTINES AND TABLE LOOK UP)      19516000
*                                                                       19517000
$$IDNT   CR    A1,A2              COMPARE FIRST WORDS                   19518000
         BNE   IDENTN             SKIP IF FIRST WORDS UNEQUAL           19519000
         CR    A1+1,A2+1          ELSE CHECK SECOND WORDS               19520000
         BCR   E,RETURN           DEFINITELY IDENT IF BOTH MATCH        19521000
*                                                                       19522000
*        HERE WE HAVE THE SITUATION WHERE THE FIRST WORDS MATCH BUT     19523000
*        THE SECOND WORD DOES NOT. THE ARGUMENTS ARE STILL IDENT        19524000
*        EXCEPT FOR NUMERIC DATATYPES AND NAMES WHICH ARE DIFFER,       19525000
*        AND STRINGS WHICH MUST BE COMPARED TO GET THE RESULT           19526000
*                                                                       19527000
         STM   A1,A2+1,IDNTSV     STORE ARGS IN CASE STRING             19528000
         C     A1,ACODEBT         CHECK FOR NUMERIC,STRING,NAME         19529000
         BL    IDENTT             JUMP IF ANY OF THESE                  19530000
         CR    R0,R0              ELSE SET CONDITION CODE FOR IDENT     19531000
         BR    RETURN             RETURN TO CALLER                      19532000
*                                                                       19533000
*        COME HERE IF THE FIRST WORDS ARE UNEQUAL. CAN STILL BE         19534000
*        IDENT FOR STRINGS AND NULLS                                    19535000
*                                                                       19536000
IDENTN   STM   A1,A2+1,IDNTSV     SAVE ARGUMENTS                        19537000
         CLC   IDNTSV(1),IDNTSV+8 ARE DATATYPES THE SAME?               19538000
         BCR   NE,RETURN          DEFINITELY DIFFER IF NOT              19539000
         CLI   IDNTSV,NCODE       ELSE ARE THEY NULLS?                  19540000
         BCR   E,RETURN           IDENT IF SO                           19541000
*                                                                       19542000
*        MERGE HERE TO TEST FOR STRING (DIFFER IF ANYTHING ELSE)        19543000
*                                                                       19544000
IDENTT   CLI   IDNTSV,SCODE       ARE ARGUMENTS STRINGS?                19545000
         BCR   NE,RETURN          RETURN (DIFFER) IF NOT                19546000
         EJECT                                                          19547000
*                                                                       19548000
*        IDENT -- CONTINUED                                             19549000
*                                                                       19550000
*        CASE OF STRING ARGUMENTS                                       19551000
*                                                                       19552000
IDENTS   LH    A1+1,IDNTSV+SLENGTH          GET 360 LENGTH OF 1ST ARG   19553000
         CH    A1+1,IDNTSV+SLENGTH+8        COMPARE WITH 2ND ARG LENGTH 19554000
         BCR   NE,RETURN          DIFFER IF LENGTHS UNEQUAL             19555000
         AH    A1,IDNTSV+SOFFSET            ELSE ADD LEFT ARG OFFSET    19556000
         AH    A2,IDNTSV+SOFFSET+8          ADD RIGHT ARG OFFSET        19557000
*                                                                       19558000
*        SPECIAL ENTRY USED BY $ TO COMPARE STRINGS                     19559000
*                                                                       19560000
IDENTM   LA    A2+1,256           GET CRANK CONSTANT                    19561000
         CR    A1+1,A2+1          TEST FOR 256 CHARS OR LESS            19562000
         BL    IDENTSE            SKIP IF 256 CHARS OR LESS             19563000
*                                                                       19564000
*        LOOP TO COMPARE 256 CHARACTER CHUNKS                           19565000
*                                                                       19566000
IDENTSL  EX    0,LCMP1            COMPARE 256 CHARACTERS                19567000
         BCR   NE,RETURN          DIFFER IF NOT THE SAME                19568000
         AR    A1,A2+1            PUSH LEFT ARG STRING POINTER          19569000
         AR    A2,A2+1            PUSH RIGHT ARG STRING POINTER         19570000
         SR    A1+1,A2+1          DECREMENT LENGTH                      19571000
         CR    A1+1,A2+1          MORE THAN 256 CHARS TO GO?            19572000
         BNL   IDENTSL            SKIP BACK IF SO                       19573000
*                                                                       19574000
*        COME HERE TO COMPARE 256 CHARS OR LESS AT END                  19575000
*                                                                       19576000
IDENTSE  EX    A1+1,IDENTC        COMPARE REMAINING CHARACTERS          19577000
         BR    RETURN             LEAVE WITH CC CORRECTLY SET           19578000
*                                                                       19579000
IDENTC   EQU   LCMPC              COMPARE LAST CHARACTERS               19580000
         EJECT                                                          19581000
*                                                                       19582000
*        THIS ROUTINE IS PASSED THE CORRECT ADDRESS -- IT MERELY        19583000
*        SUPPLIES THE UPPER BYTE (TYPE CODE) AND RETURNS                19584000
*                                                                       19585000
*        $$AST1                   UNARY * (DEFERRED EXPRESSION)         19586000
*                                                                       19587000
*        (R2)                     4 BYTES BEHIND CODE (FROM BALR)       19588000
*        BAL   RETURN,$$AST1                                            19589000
*        (A1,A1+1)                EXPRESSION SPECIFIER                  19590000
*                                                                       19591000
$$AST1   LA    A1,4(,R2)          POINT TO CODE & CLEAR UPPER BYTE      19592000
         A     A1,ECODEBT         SUPPLY TYPE CODE                      19593000
         BR    RETURN             AND RETURN                            19594000
*                                                                       19595000
*        $$INTG                   INTEGER                               19596000
*                                                                       19597000
*        (A1,A1+1)                ARGUMENT                              19598000
*        BAL   RETURN,$$INTG                                            19599000
*        -->   0(FRETURN) IF NOT AN INTEGER                             19600000
*        -->   0(RETURN)  IF AN INEGER                                  19601000
*                                                                       19602000
$$INTG   LR    A2,RETURN          SAVE RETURN POINT                     19603000
         BAL   RETURN,GETNUM      CONVERT TO NUMERIC                    19604000
*                                                                       19605000
*        HERE IF CONVERSION ATTEMPT FAILS                               19606000
*                                                                       19607000
         LR    RETURN,A2          RESTORE RETURN POINT                  19608000
         BR    FRETURN            GIVE FAILURE RETURN                   19609000
*                                                                       19610000
*        HERE IF CONVERSION ATTEMPT SUCCEEDS                            19611000
*                                                                       19612000
         LR    RETURN,A2          RESTORE RETURN POINT                  19613000
         LTR   A1,A1              IS RESULT AN INTEGER?                 19614000
         BCR   NZ,FRETURN         FAILURE RETURN IF NOT AN INTEGER      19615000
         BR    RETURN             AND RETURN TO CALLER                  19616000
         TITLE 'SPITBOLA -- GARBAGE COLLECTION ENTRY POINTS'            19617000
*                                                                       19618000
*        THE GARBAGE COLLECTOR NEEDS THREE PARAMETERS --                19619000
*                                                                       19620000
*        1)    THE CODE LOCATION                                        19621000
*                                 A)        IN RETURN (S ENTRY POINTS)  19622000
*                                 B)        AT RETLOC (NORMAL ENTRIES)  19623000
*                                                                       19624000
*        2)    RETURN POINT                 IN RETURN                   19625000
*                                                                       19626000
*        3)    NUMBER OF ACCUMULATORS TO RELOCATE (DEPENDS ON ENTRY)    19627000
*                                                                       19628000
*                                                                       19629000
*        STORE CODE LOCATION -- RELOCATE NO REGISTERS                   19630000
*                                                                       19631000
GBGCL0S  ST    RETURN,RETLOC      STORE RETURN, MERGE GBGCL0            19632000
*                                                                       19633000
*        NO CODE LOC STORE, NO REGISTER RELOCATION                      19634000
*                                                                       19635000
GBGCL0   MVI   GCOLNRG,0          SET FOR NO REGS TO RELOCATE           19636000
         B     GCOLC              JUMP TO COMMON CALL POINT             19637000
*                                                                       19638000
*        STORE CODE LOCATION -- RELOCATE CONTENTS OF (A1,A1+1)          19639000
*                                                                       19640000
GBGCL1S  ST    RETURN,RETLOC      STORE CODE LOCATION, MERGE GBGCL1     19641000
*                                                                       19642000
*        NO CODE LOC SAVE -- RELOCATE (A1,A1+1)                         19643000
*                                                                       19644000
GBGCL1   MVI   GCOLNRG,GRELOC1    SET TO SAVE ONE REG                   19645000
         B     GCOLC              JUMP TO COMMON CALL POINT             19646000
*                                                                       19647000
*        STORE CODE LOCATION -- RELOCATE (A1,A1+1) , (A2,A2+1)          19648000
*                                                                       19649000
GBGCL2S  ST    RETURN,RETLOC      SAVE CODE LOCATION                    19650000
*                                                                       19651000
*        NO CODE LOC SAVE -- RELOCATE (A1,A1+1) , (A2,A2+1)             19652000
*                                                                       19653000
GBGCL2   MVI   GCOLNRG,GRELOC1+GRELOC2      SET TO RELOCATE A1 & A2     19654000
*                                                                       19655000
*        COMMON CALL POINT                                              19656000
*                                                                       19657000
GCOLC    L     R1,=A(GCOL)        LOAD ROUTINE ADDRESS                  19658000
         BR    R1                 OFF TO IT                             19659000
*                                                                       19660000
*        SPECIAL ENTRY FROM THE MIDDLE OF A FUNCTION CALL               19661000
*                                                                       19662000
GBGCLF   MVI   GCOLNRG,GGBGCLF    SET SPECIAL FLAG                      19663000
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3                       19664000
         B     GCOLC              JUMP TO COMMON CALL POINT             19665000
         TITLE 'SPITBOLA -- END OF RUN ENTRY POINT'                     19666000
*                                                                       19667000
*        $$STOP                   COME HERE ON FLOW INTO END LABEL      19668000
*                                                                       19669000
$$STOP   L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE REG          19670000
         USING DTERTNS,DB4        TELL ASSEMBLER                        19671000
         B     ENDLABEL           AND MERGE WITH END LABEL TRANSFER     19672000
         DROP  DB4                DROP BASE REG                         19673000
         TITLE 'SPITBOLA -- MISCELLANEOUS ERROR EXITS'                  19674000
*                                                                       19675000
*        ENTER HERE FROM STATEMENT WITH COMPILATION ERROR               19676000
*                                                                       19677000
$$SERR   XERR  04,001,S           ATTEMPTED EXECUTION OF A STATEMENT    19678000
*                                 FOUND ERRONEOUS BY THE COMPILER       19679000
*                                                                       19680000
*        ENTER HERE ON FAILURE WITHIN GOTO                              19681000
*                                                                       19682000
$$FING   XERR  07,001,S           THE EVALUATION OF A COMPLEX GOTO      19683000
*                                 ITSELF FAILED                         19684000
*                                                                       19685000
*        ENTER HERE WHEN FUNCTION CALLED BY NAME RETURNS VALUE          19686000
*                                                                       19687000
$$FRVN   XERR  14,001,S           A FUNCTION CALLED BY NAME RETURNED    19688000
*                                 A VALUE                               19689000
*                                                                       19690000
*        HERE FOR OTHER VALUE WHERE NAME REQUIRED CASES                 19691000
*                                                                       19692000
$$NMVL   XERR  14,002,S           AN EXPRESSION OTHER THAN A FUNCTION   19693000
*                                 CALL RETURNED A VALUE WHERE A NAME    19694000
*                                 WAS REQUIRED                          19695000
*                                                                       19696000
*        HERE TO TEST FOR OVERTIME DURING PATTERN MATCHING. ANY         19697000
*        PATTERN EXTENSION ROUTINE WHICH IS LIKELY TO LEAD TO LONG      19698000
*        OR INFINITE PATTERN MATCH LOOPS USES THIS OVERTIME CHECK       19699000
*                                                                       19700000
*        CALLED BY:                                                     19701000
*                                                                       19702000
*        BAL   R2,PTIMTST                                               19703000
*        -->                      RETURN IF OK (R1,R2) DESTROYED        19704000
*                                                                       19705000
PTIMTST  L     R1,PSAVDB1(,PDR)   GET DATA AREA POINTER                 19706000
         TM    STAGE-SPITBOLD(R1),$OVERTIM  ARE WE OVERTIME?            19707000
         BCR   NO,R2              RETURN IF NOT OVERTIME                19708000
         LR    DB1,R1             ELSE RESTORE DATA AREA PTR AND MERGE  19709000
*                                                                       19710000
*        HERE FOR OVERTIME TRAP                                         19711000
*                                                                       19712000
$$TIME   LE    SCNT,SCNTTSAV      RESTORE PROPER VALUE OF SCNT          19713000
         NI    STAGE,X'FF'-$OVERTIM         TURN OFF OVERTIME FLAG      19714000
         XERR  11,009             TIME LIMIT EXCEEDED                   19715000
         TITLE 'SPITBOLA -- PATTERN CONTRUCTION ROUTINES'               19716000
*                                                                       19717000
*        THE FOLLOWING ROUTINES IMPLEMENT THE OPERATORS AND FUNCTIONS   19718000
*        WHICH RETURN PATTERNS WHEN CALLED                              19719000
*                                                                       19720000
*                                                                       19721000
*        MPBLOK                   MAKE A PATTERN BLOCK                  19722000
*                                                                       19723000
*        THIS IS THE UTILITY ROUTINE USED TO CREATE PATTERN BLOCKS      19724000
*                                                                       19725000
*        (R2)                     MINMATCH FIELD CONTENTS               19726000
*        (A1,A1+1)                PARAMS (AS NEEDED)                    19727000
*        BAL   R1,MPBLOK                                                19728000
*        DC    YL1(FLAGS)         CONTENTS TO BE PLACED IN PFLAGS FIELD 19729000
*        DC    YL1(PTLENG)        LENGTH (28,32,36 -- 0,1,2 PARAMS)     19730000
*                                                                       19731000
*        FOLLOWED BY EITHER --                                          19732000
*                                                                       19733000
*        DC    Y(CODELOC-PATSUBS)           FOR CASE WITH NO EXTEND     19734000
*                                                                       19735000
*        OR                                                             19736000
*                                                                       19737000
*        DC    YL2(CODELOC-PATSUBS+X'8000') FOR CASE WITH EXTEND        19738000
*        DC    YL2(EXTEND-QPATSUBS)         OFFSET TO QUICKSCAN ROUTINE 19739000
*                                                                       19740000
*                                                                       19741000
*        MPBLOK RETURNS WITH THE PATTERN POINTER IN A1 (NO GCOL TEST)   19742000
*                                                                       19743000
*        MPBLOKX                  IS CALLED IN THE SAME WAY, BUT        19744000
*                                 RETURNS TO THE GENERATED CODE VIA     19745000
*                                 (RETURN) AFTER TESTING FOR GCOL       19746000
*                                                                       19747000
*        MPBLOKXR                 ALSO RESTORES DB2                     19748000
*                                                                       19749000
MPBLOKXR L     DB2,$$BAS2         RESTORE DB2 BEFORE CALL               19750000
*                                                                       19751000
*        MPBLOKX ENTRY POINT                                            19752000
*                                                                       19753000
MPBLOKX  MVI   PBLOKSW,X'00'      SET SWITCH, MERGE MPBLOK              19754000
         B     *+8                MERGE PAST SWITCH SET                 19755000
*                                                                       19756000
*        MPBLOK ENTRY POINT                                             19757000
*                                                                       19758000
MPBLOK   MVI   PBLOKSW,X'FF'      SET X FLAG OFF                        19759000
         L     DB3,=A(MPBLOKC)    LOAD ADDRESS OF CONTINUATION          19760000
         BR    DB3                JUMP TO IT                            19761000
         EJECT                                                          19762000
*                                                                       19763000
*        BINARY DOT/DOLLAR ROUTINES                                     19764000
*                                                                       19765000
*        $$DOTD                   DOT WITH DEFERRED NAME                19766000
*        $$DOT2                   DOT -- NORMAL CASE                    19767000
*        $$DOLD                   DOLLAR WITH DEFERRED NAME             19768000
*        $$DOL2                   DOLLAR -- NORMAL CASE                 19769000
*                                                                       19770000
*        FOR $$DOLD,$$DOTD                                              19771000
*                                                                       19772000
*        (A2,A2+1)                EXPRESSION                            19773000
*        (A1,A1+1)                PATTERN (MAY NEED CONVERTING)         19774000
*        BAL   RETURN,$$DOLD      ($$DOTD)                              19775000
*        (A1,A1+1)                RESULTING PATTERN                     19776000
*                                                                       19777000
*        FOR $$DOL2,$$DOT2                                              19778000
*                                                                       19779000
*        (A1,A1+1)                PATTERN (MAY NEED CONVERTING)         19780000
*        (A2,A2+1)                NAME AND OFFSET                       19781000
*        BAL   RETURN,$$DOL2      ($$DOT2)                              19782000
*        (A1,A1+1)                RESULTING PATTERN                     19783000
*                                                                       19784000
*                                                                       19785000
*                                                                       19786000
*        THESE FOUR OPERATORS GENERATE A STRUCTURE AS FOLLOWS           19787000
*                                                                       19788000
*        +------------+         +------------+         +------------+   19789000
*        |            |  THEN   |            |  THEN   |            |   19790000
*        |    MARK    |-------->|   PATTERN  |-------->|   DOLDOT   |   19791000
*        |            |         |            |         |            |   19792000
*        +------------+         +------------+         +------------+   19793000
*                                                                       19794000
*        MARK IS A SPECIAL PATTERN WHICH SAVES THE CURRENT CURSOR LOC   19795000
*        PATTERN IS THE LEFT ARGUMENT TO THE $ OR . OPERATOR            19796000
*        DOLDOT IS THE PATTERN NODE FOR THE APPROPRIATE CASE            19797000
*                                                                       19798000
*        THE FOLLOWING PATTERN MATCH ROUTINES ARE INVOLVED --           19799000
*                                                                       19800000
*        DOL,DOT,DOLD,DOTD,MARK,DOTEXT,DOLEXT,MARKEXT                   19801000
*                                                                       19802000
*        PCONC IS USED TO PERFORM THE NECCESSARY PATTERN CONCATENATIONS 19803000
*                                                                       19804000
         EJECT                                                          19805000
*                                                                       19806000
*        DOLLAR/DOT ROUTINES -- CONTINUED                               19807000
*                                                                       19808000
*                                                                       19809000
*        DOTD ENTRY POINT (DEFERRED DOT CASE)                           19810000
*                                                                       19811000
*                                                                       19812000
*        PARAM1                   NOT USED                              19813000
*        PARAM2                   EXPRESSION POINTER                    19814000
*        EXTEND                   DOTEXT                                19815000
*                                                                       19816000
$$DOTD   BAL   R2,DOLDOTD         GO TO COMMON ROUTINE                  19817000
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) 2ND PARAM IS RELOC     19818000
         DC    AL2(PN$DOTD-PATSUBS+X'8000')                             19819000
         DC    AL2(DOTEXT-QPATSUBS)                                     19820000
*                                                                       19821000
*        $$DOLD                   DOLLAR (DEFERRED CASE)                19822000
*                                                                       19823000
*        PARAM1                   NOT USED                              19824000
*        PARAM2                   EXPRESSION POINTER                    19825000
*        EXTEND                   DOLEXT                                19826000
*                                                                       19827000
$$DLRD   BAL   R2,DOLDOTD         GO TO COMMON ROUTINE                  19828000
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) 2ND PARAM IS RELOC     19829000
         DC    AL2(PN$DOLD-PATSUBS+X'8000')                             19830000
         DC    AL2(DOLEXT-QPATSUBS)                                     19831000
*                                                                       19832000
*        $$DOT2                   DOT NORMAL CASE                       19833000
*                                                                       19834000
*        PARAM1                   NAME BASE                             19835000
*        PARAM2                   NAME OFFSET                           19836000
*        EXTEND                   DOTEXT                                19837000
*                                                                       19838000
$$DOT2   BAL   R2,DOLDOT          OFF TO COMMON ROUTINE                 19839000
         DC    YL1(PARM1+PARM2+QF+PRELOC1,LPRM2)                        19840000
         DC    AL2(PN$DOT-PATSUBS+X'8000')                              19841000
         DC    AL2(DOTEXT-QPATSUBS)                                     19842000
*                                                                       19843000
*        $$DLR2                   DOLLAR NORMAL CASE                    19844000
*                                                                       19845000
*        PARAM1                   NAME BASE                             19846000
*        PARAM2                   NAME OFFSET                           19847000
*        EXTEND                   DOLEXT                                19848000
*                                                                       19849000
$$DLR2   BAL   R2,DOLDOT          CALL COMMON ROUTINE                   19850000
         DC    YL1(PARM1+PARM2+QF+PRELOC1,LPRM2)                        19851000
         DC    AL2(PN$DOL-PATSUBS+X'8000')                              19852000
         DC    AL2(DOLEXT-QPATSUBS)                                     19853000
         EJECT                                                          19854000
*                                                                       19855000
*        DOLLAR/DOT ROUTINES -- CONTINUED                               19856000
*                                                                       19857000
*                                                                       19858000
*        COMMON ROUTINE FOR DEFERRED CASE                               19859000
*                                                                       19860000
DOLDOTD  LR    A2+1,A2            MOVE EXPR PTR TO PARAM2 POSITION      19861000
         C     A2,ECODEBT         CHECK FOR COMPLEX EXPRESSION          19862000
         BNL   DOLDOT             BRANCH IF COMPLEX EXPRESSION          19863000
         SR    A2+1,A2+1          ELSE CLEAR OFFSET FOR SIMPLE VARIABLE 19864000
         LA    R2,$$DOT2-$$DOTD(R2)         POINT TO NON-DEFERRED CASE  19865000
*                                                                       19866000
*        COMMON ROUTINE FOR NORMAL CASE                                 19867000
*                                                                       19868000
DOLDOT   MVC   DOLDOTX(14),DOLDOTXX         MOVE CODE TO EXECUTE IT     19869000
         MVC   DOLDOTX+4(6),0(R2) MOVE PARAMS INTO OUT OF LINE CODE     19870000
         ST    RETURN,RETLOC      SAVE RETURN LOCATION                  19871000
         BAL   RETURN,GETPAT      CONVERT LEFT ARG TO PATTERN           19872000
         XERR  01,038             LEFT ARGUMENT OF BINARY $ OR . IS NOT 19873000
*                                 A PATTERN                             19874000
         LR    A1+1,A2+1          MOVE SECOND PARAM INTO PLACE          19875000
         LR    A2+1,A1            SAVE PATTERN POINTER                  19876000
         LR    A1,A2              MOVE FIRST PARAM INTO PLACE           19877000
         SR    R2,R2              MINMATCH=0 FOR ALL TYPES              19878000
         B     DOLDOTX            JUMP TO OUT OF LINE CODE              19879000
*                                                                       19880000
*        RETURN HERE AFTER CALL TO MPBLOK                               19881000
*                                                                       19882000
DOLDOTR  LR    A2,A1              MOVE DOL/DOT PATTERN PTR TO ACCUM 2   19883000
         LR    A1,A2+1            MOVE LEFT ARGUMENT PATTERN PTR TO A1  19884000
         BAL   RETURN,PCONC       CONCATENATE PATTERNS                  19885000
         LR    A2,A1              PUT RESULT IN A2                      19886000
         L     A1,MARKPTR         LOAD POINTER TO MARK PATTERN          19887000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               19888000
         B     PCONC              CONCATENATE AND LEAVE                 19889000
*                                                                       19890000
*        THE FOLLOWING CODE IS MOVED INTO THE DATA AREA SINCE IT HAS    19891000
*        TO BE MODIFIED BY FILLING IN PARAMETERS                        19892000
*                                                                       19893000
DOLDOTXX BAL   R1,MPBLOK          CALL ROUTINE TO BUILD PATTERN         19894000
         DC    6X'00'             6 BYTE PARAMETER FILLED IN            19895000
         B     DOLDOTR            RETURN TO MAINLINE CODE               19896000
         EJECT                                                          19897000
*                                                                       19898000
*        @ PATTERN CONSTRUCTION ROUTINES                                19899000
*                                                                       19900000
*        $$ATSP                   @ OPERATOR (ARGUMENT IS NAME)         19901000
*                                                                       19902000
*        (A1,A1+1)                ARGUMENT (NAME BASE/OFFSET)           19903000
*        BAL   RETURN,$$ATSP                                            19904000
*        (A1,A1+1)                RESULTING PATTERN                     19905000
*                                                                       19906000
*                                                                       19907000
*        COME HERE FROM EXPRESSION CASE WHERE EXPRESSION WAS VCODE      19908000
*        SINCE A VCODE IS EQUIVALENT TO A SIMPLE VARIABLE WE TREAT IT   19909000
*        AS A SIMPLE VARIABLE                                           19910000
*                                                                       19911000
ATSPM    SR    A1+1,A1+1          SET NAME OFFSET FOR SIMPLE VAR = 0    19912000
$$ATSP   SR    R2,R2              SET MINMATCH = 0                      19913000
         BAL   R1,MPBLOKX         MAKE BLOCK AND EXIT                   19914000
         DC    YL1(PARM1+PARM2+QF+PRELOC1,LPRM2) FLAGS AND LENGTH       19915000
         DC    YL2(PN$@-PATSUBS)  CODELOC OFFSET                        19916000
*                                                                       19917000
*        $$ATSD                   @ OPERATOR (ARGUMENT IS EXPRESSION)   19918000
*                                                                       19919000
*        (A1,A1+1)                EXPRESSION ARGUMENT                   19920000
*        BAL   RETURN,$$ATSD                                            19921000
*        (A1,A1+1)                RESULTING PATTERN                     19922000
*                                                                       19923000
$$ATSD   C     A1,ECODEBT         CHECK FOR VCODE AS EXPRESSION         19924000
         BL    ATSPM              TREAT AS NORMAL IF VCODE              19925000
         SR    R2,R2              SET MINMATCH = 0                      19926000
         LR    A1+1,A1            MOVE EXPR PTR TO STORE AS PARAM2      19927000
         BAL   R1,MPBLOKX         MAKE PATTERN BLOCK AND EXIT           19928000
         DC    YL1(PARM1+PARM2+QF+PRELOC2,LPRM2) FLAGS AND LENGTH       19929000
         DC    YL2(PN$@D-PATSUBS) CODELOC OFFSET                        19930000
         EJECT                                                          19931000
*                                                                       19932000
*        $$LENP                   LEN FUNCTION                          19933000
*        $$POSP                   POS FUNCTION                          19934000
*        $$TABP                   TAB FUNCTION                          19935000
*        $$RPSP                   RPOS FUNCTION                         19936000
*        $$RTBP                   RTAB FUNCTION                         19937000
*                                                                       19938000
*        (A1,A1+1)                ARGUMENT (EXPRESSION OR INTEGER)      19939000
*        BAL   RETURN,$$....                                            19940000
*        (A1,A1+1)                RESULTING PATTERN                     19941000
*                                                                       19942000
$$LENP   BAL   A2,PATSET          CALL COMMON ROUTINE                   19943000
         DC    AL2(PN$LEN-PATSUBS)          MINMATCH=ARG                19944000
         XERR  01,039             ARGUMENT TO LEN IS NOT AN INTEGER     19945000
         XERR  13,012             ARGUMENT TO LEN IS NEGATIVE           19946000
*                                                                       19947000
*        $$POSP                   POS                                   19948000
*                                                                       19949000
$$POSP   BAL   A2,PATSET          CALL COMMON ROUTINE                   19950000
         DC    AL2(PN$POS-PATSUBS+X'8000')  MINMATCH=0                  19951000
         XERR  01,040             ARGUMENT TO POS IS NOT AN INTEGER     19952000
         XERR  13,013             ARGUMENT TO POS IS NEGATIVE           19953000
*                                                                       19954000
*        $$TABP                   TAB                                   19955000
*                                                                       19956000
$$TABP   BAL   A2,PATSET          CALL COMMON ROUTINE                   19957000
         DC    AL2(PN$TAB-PATSUBS+X'8000')  MINMATCH=0                  19958000
         XERR  01,041             ARGUMENT TO TAB IS NOT AN INTEGER     19959000
         XERR  13,014             ARGUMENT TO TAB IS NEGATIVE           19960000
*                                                                       19961000
*        $$RPSP                   RPOS                                  19962000
*                                                                       19963000
$$RPSP   BAL   A2,PATSET          CALL COMMON ROUTINE                   19964000
         DC    AL2(PN$RPOS-PATSUBS+X'8000') MINMATCH=0                  19965000
         XERR  01,042             ARGUMENT TO RPOS IS NOT AN INTEGER    19966000
         XERR  13,015             ARGUMENT TO RPOS IS NEGATIVE          19967000
*                                                                       19968000
*        $$RTBP                   RTAB                                  19969000
*                                                                       19970000
$$RTBP   BAL   A2,PATSET          CALL COMMON ROUTINE                   19971000
         DC    AL2(PN$RTAB-PATSUBS+X'8000') MINMATCH=0                  19972000
         XERR  01,043             ARGUMENT TO RTAB IS NOT AN INTEGER    19973000
         XERR  13,016             ARGUMENT TO RTAB IS NEGATIVE          19974000
*                                                                       19975000
*        PATSET -- COMMON ROUTINE FOR ABOVE                             19976000
*                                                                       19977000
PATSET   L     A2+1,=A(PATSETC)   LOAD ADDRESS OF ROUTINE               19978000
         BR    A2+1               OFF TO IT                             19979000
         EJECT                                                          19980000
*                                                                       19981000
*        ETEST                    COMMON ROUTINE USED BY SPAN,BREAK ETC 19982000
*                                                                       19983000
*        (A1,A1+1)                ARGUMENT                              19984000
*        BAL   DB3,ETEST          CALLED ON DB3                         19985000
*        ->  ERROR EXIT IF NEITHER STRING NOR EXPRESSION                19986000
*        ->  ERROR EXIT FOR NULL STRING ARGUMENT                        19987000
*        ->  A(EXIT ADDRESS IF NON-NULL STRING)                         19988000
*        MPBLOK PARAMETERS FOR USE IF IT IS EXPRESSION CASE             19989000
*                                                                       19990000
*        IF THE ARGUMENT IS AN EXPRESSION -- ETEST BUILDS THE BLOCK     19991000
*        AND RETURNS CONTROL TO THE CODE                                19992000
*                                                                       19993000
*        ENTER HERE FOR MINMATCH=1 CASES                                19994000
*                                                                       19995000
ETEST1   LA    R2,1               SET MINMATCH VALUE TO 1               19996000
         B     *+6                ENTER WITH PROPER MINMATCH VALUE      19997000
*                                                                       19998000
*        COME HERE FOR MINMATCH = 0 CASES                               19999000
*                                                                       20000000
ETEST    SR    R2,R2              SET MINMATCH VALUE TO 0               20001000
         ST    A1,ETESTSV         SAVE ARGUMENT TO TEST CODE            20002000
         TM    ETESTSV,EXPRBIT    TEST FOR EXPRESSION                   20003000
         BNO   ETESTS             SKIP IF NOT EXPRESSION                20004000
*                                                                       20005000
*        COME HERE FOR EXPRESSION CASE                                  20006000
*                                                                       20007000
         LR    A1+1,A1            COPY TO SET EXPR PTR IN PARAM2        20008000
         LA    R1,12(,DB3)        POINT TO MPBLOK PARAMETERS            20009000
         B     MPBLOKXR           RESTORE DBS&BUILD EXPRESSION PATTERN  20010000
*                                                                       20011000
*        COME HERE IF NOT EXPRESSION                                    20012000
*                                                                       20013000
ETESTS   ST    RETURN,RETLOC      SAVE RETURN REG                       20014000
         BAL   RETURN,GETSTGS     CONVERT ARGUMENT TO STRING            20015000
         BR    DB3                ERROR EXIT IF UNCONVERTABLE           20016000
         NOPR  0                  FILL UP 4 BYTE ERROR RETURN           20017000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               20018000
         LTR   A1+1,A1+1          TEST FOR NULL                         20019000
         BM    4(,DB3)            TAKE ERROR EXIT IF NULL STRING        20020000
         L     DB3,8(,DB3)        ELSE LOAD CONTINUATION ROUTINE ADDR   20021000
         BR    DB3                AND GO OFF TO IT                      20022000
         EJECT                                                          20023000
*                                                                       20024000
*        $$SPNP                   SPAN FUNCTION                         20025000
*        $$BRKP                   BREAK FUNCTION                        20026000
*        $$BRKX                   BREAKX FUNCTION                       20027000
*                                                                       20028000
*        (A1,A1+1)                ARGUMENT -- STRING OR EXPRESSION      20029000
*        BAL   RETURN,$$....                                            20030000
*        (A1,A1+1)                RESULTING PATTERN                     20031000
*                                                                       20032000
*        ALL THESE FUNCTIONS BUILD TRANSLATE AND TEST TABLES            20033000
*                                                                       20034000
*        FOR SPAN, THE TABLE IS NON-ZERO EXCEPT FOR SELECTED CHARS      20035000
*        FOR BREAK,BREAKX, THE TABLE IS ZERO EXCEPT FOR SELECTED CHARS  20036000
*                                                                       20037000
*                                                                       20038000
*        $$SPNP                   SPAN                                  20039000
*                                                                       20040000
*        PARAM1                   TBLOK OR CODE POINTER (STR OR EXPR)   20041000
*        EXTEND                   NONE                                  20042000
*                                                                       20043000
         CNOP  0,4                MAKE SURE ADCON IS ON FULLWORD BDRY   20044000
$$SPNP   BAL   DB3,ETEST1         TEST FOR EXPRESSION, MINMATCH = 1     20045000
         XERR  01,044             SPAN ARG NOT STRING OR EXPR           20046000
         XERR  13,017             ARGUMENT TO SPAN IS NULL              20047000
         DC    A(SPANPP)          STRING CASE ROUTINE ADDRESS           20048000
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC 20049000
         DC    Y(PN$SPAND-PATSUBS)          CODELOC FOR EXPR CASE       20050000
*                                                                       20051000
*        $$BRKX                   BREAKX                                20052000
*                                                                       20053000
*        PARAM1                   TBLOK OR CODE POINTER (STR OR EXPR)   20054000
*        EXTEND                   BRKXEXT                               20055000
*                                                                       20056000
         CNOP  0,4                MAKE SURE ADCON IS ON FULLWORDBOUND   20057000
$$BRKX   BAL   DB3,ETEST          TEST FOR EXPRESSION, MINMATCH = 0     20058000
         XERR  01,045             ARGUMENT TO BREAKX NOT STRING OR EXPR 20059000
         XERR  13,018             ARGUMENT TO BREAKX IS NULL            20060000
         DC    X'FF'              SET ADCON NEGATIVE TO SIGNAL BREAKX   20061000
         DC    AL3(BREAKPP)       ADDR OF ROUTINE FOR STRING CASE       20062000
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC 20063000
         DC    AL2(PN$BRKXD-PATSUBS+X'8000')                            20064000
         DC    AL2(BRKXDEXT-QPATSUBS)       EXTENT FOR EXPR CASE        20065000
         EJECT                                                          20066000
*                                                                       20067000
*        $$BRKP                   BREAK                                 20068000
*                                                                       20069000
*        PARAM1                   TBLOK OR CODE POINTER (STR OR EXPR)   20070000
*        EXTEND                   NONE                                  20071000
*                                                                       20072000
         CNOP  0,4                MAKE SURE ADCON IS ON FULLWORD BOUND  20073000
$$BRKP   BAL   DB3,ETEST          TEST FOR EXPRESSION, MINMATCH = 0     20074000
         XERR  01,046             ARGUMENT TO BREAK NOT STRING OR EXPR  20075000
         XERR  13,019             ARGUMENT FOR BREAK IS NULL            20076000
         DC    A(BREAKPP)         ADDR OF ROUTINE FOR STRING CASE       20077000
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC 20078000
         DC    Y(PN$BRKD-PATSUBS) ..                                    20079000
         EJECT                                                          20080000
*                                                                       20081000
*        $$ANYP                   ANY FUNCTION                          20082000
*        $$NTNP                   NOTANY FUNCTION                       20083000
*                                                                       20084000
*        (A1,A1+1)                ARGUMENT INTEGER OR EXPRESSIONS       20085000
*        BAL   RETURN,$$....                                            20086000
*        (A1,A1+1)                RESULTING PATTERN                     20087000
*                                                                       20088000
*        EACH ANY PATTERN USES ONE BIT POSITION OUT OF EIGHT IN A TBLOK 20089000
*        FOR THE SELECTED CHARACTERS, THE BITS ARE SET ON               20090000
*                                                                       20091000
*        NOTANY IS TREATED AS ANY OF ITS COMPLEMENT                     20092000
*                                                                       20093000
*        ANYTPTR                  POINTER TO CURRENT TBLOK              20094000
*        ANYMASK                  LAST BIT USED (LEFT MOST USED FIRST)  20095000
*                                                                       20096000
*        FOR STRING CASE --                                             20097000
*        PARAM1                   TBLOK POINTER                         20098000
*        PARAM2                   TM    CTCHARS(R2),BITMASK             20099000
*        EXTEND                   NONE                                  20100000
*                                                                       20101000
*        FOR EXPRESSION CASE --                                         20102000
*        PARAM1                   CODE POINTER                          20103000
*        EXTEND                   NONE                                  20104000
*                                                                       20105000
*                                                                       20106000
*        $$NTNP                   NOTANY                                20107000
*                                                                       20108000
         CNOP  2,4                MAKE SURE ADCON IS ON FULLWORD BOUND  20109000
$$NTNP   SR    DB2,DB2            SET FLAG FOR NOTANY CASE              20110000
         BAL   DB3,ETEST1         TEST FOR EXPRESSION, MINMATCH = 1     20111000
         XERR  01,047             ARGUMENT TO NOTANY NOT STRING OR EXPR 20112000
         XERR  13,020             ARGUMENT TO NOTANY IS NULL            20113000
         DC    A(NTNANY)          ROUTINE ADDRESS FOR STRING CASE       20114000
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC 20115000
         DC    AL2(PN$NANYD-PATSUBS)        CODELOC FOR EXPR CASE       20116000
*                                                                       20117000
*        $$ANYP                   ANY                                   20118000
*                                                                       20119000
         CNOP  0,4                MAKE SURE ADCON IS ON FULLWORD BOUND  20120000
$$ANYP   LA    DB2,NTNANYA-NTNANYN          SET FOR ANY CASE            20121000
         BAL   DB3,ETEST1         TEST FOR EXPRESSION, MINMATCH = 1     20122000
         XERR  01,048             ARGUMENT TO ANY NOT STRING OR EXPR    20123000
         XERR  13,021             ARGUMENT TO ANY IS NULL               20124000
         DC    A(NTNANY)          ROUTINE ADDRESS FOR STRING ARGUMENT   20125000
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC 20126000
         DC    AL2(PN$ANYD-PATSUBS)         CODELOC FOR EXPR CASE       20127000
         TITLE 'SPITBOLA -- TYPE CONVERSION ROUTINES'                   20128000
*                                                                       20129000
*        GETPAT -- CONVERT TO PATTERN ROUTINE                           20130000
*                                                                       20131000
*        (A1,A1+1)                ARGUMENT                              20132000
*        BAL   RETURN,GETPAT                                            20133000
*        (ERROR RETURN -- CONVERSION NOT POSSIBLE)                      20134000
*        RETURNS TO 4(RETURN) WITH PATTERN POINTER IN A1                20135000
*                                                                       20136000
*                                                                       20137000
GETPAT   STM   DB2,DB3,GETPATSV   SAVE REGS                             20138000
         L     DB2,=A(GETPATC)    LOAD ADDRESS OF CONTINUATION          20139000
         BR    DB2                JUMP TO IT                            20140000
         EJECT                                                          20141000
*                                                                       20142000
*        GETREAL                  CONVERT TO REAL                       20143000
*                                                                       20144000
*        (A1,A1+1)                ARGUMENT TO BE CONVERTED              20145000
*        BAL   RETURN,GETREAL                                           20146000
*        => ERROR RETURN IF UNCONVERTIBLE                               20147000
*        => NORMAL RETURN                                               20148000
*        (A1,A1+1)                CONVERTED REAL RESULT                 20149000
*                                                                       20150000
GETREAL  BAL   R2,CVNUM           CONVERT ARGUMENT TO NUMERIC           20151000
         BO    4(,RETURN)         RETURN IF WE HAVE A REAL              20152000
         BZ    GETRLI             JUMP TO COMMON ROUTINE IF INTEGER     20153000
         SLDL  A1,8               POSITION FOR MERGE                    20154000
*                                                                       20155000
*        RETURN HERE FROM GETRLI                                        20156000
*                                                                       20157000
         LR    A1+1,A1            POSITION CORRECTLY                    20158000
         L     A1,RCODEBT         SET TYPE CODE FOR REAL                20159000
         B     4(,RETURN)         RETURN TO CALLER                      20160000
*                                                                       20161000
*        GETDREAL                 CONVERT TO DREAL                      20162000
*                                                                       20163000
*        (A1,A1+1)                ARGUMENT TO BE CONVERTED              20164000
*        BAL   RETURN,GETDREAL                                          20165000
*        => ERROR RETURN IF UNCONVERTIBLE                               20166000
*        => NORMAL RETURN                                               20167000
*        (A1,A1+1)                CONVERTED DREAL RESULT                20168000
*                                                                       20169000
GETDREAL BAL   R2,CVNUM           CONVERT ARGUMENT TO NUMERIC           20170000
         BP    4(,RETURN)         RETURN IF WE HAVE A DREAL             20171000
         BZ    GETRLI             USE COMMON ROUTINE FOR INTEGER CASE   20172000
         LR    A1,A1+1            POSITION REAL FOR MERGE               20173000
         SR    A1+1,A1+1          CLEAR LOW ORDER                       20174000
*                                                                       20175000
*        RETURN HERE FROM GETRLI                                        20176000
*                                                                       20177000
         SRDL  A1,8               POSITION FOR DREAL                    20178000
         AL    A1,WCODEBT         SUPPLY TYPE CODE                      20179000
         B     4(,RETURN)         RETURN TO CALLER                      20180000
         EJECT                                                          20181000
*                                                                       20182000
*        COMMON ROUTINE USED TO CONVERT INTEGER TO DREAL                20183000
*                                                                       20184000
*        USED BY GETREAL,GETDREAL                                       20185000
*                                                                       20186000
GETRLI   L     R0,=X'4E00000000000000'      LOAD 4E EXPONENT            20187000
         LPR   R1,A1+1            FORCE INTEGER + (OK EVEN ON OVERFLOW) 20188000
         STM   R0,R1,GETSVV       STORE PREPARED UNNORMALIZED REAL      20189000
         LD    FA,GETSVV          LOAD INTO FLOATING REG                20190000
         ADR   FA,ZR              NORMALIZE THE NUMBER                  20191000
         LTR   A1+1,A1+1          TEST ORIGINAL SIGN                    20192000
         BNM   *+6                SKIP IF POSITIVE                      20193000
         LCDR  FA,FA              IF NEGATIVE, MAKE RESULT NEGATIVE     20194000
         STD   FA,GETSVV          STORE CONVERTED RESULT                20195000
         LM    A1,A1+1,GETSVV     LOAD CONVERTED LONG REAL              20196000
         B     12(,R2)            RETURN TO PROPER ROUTINE              20197000
         EJECT                                                          20198000
*                                                                       20199000
*        GETINT                   CONVERT TO INTEGER                    20200000
*                                                                       20201000
*        (A1,A1+1)                ARGUMENT                              20202000
*        BAL   RETURN,GETINT                                            20203000
*        ->  ERROR RETURN IF UNCONVERTIBLE                              20204000
*        ->  NORMAL RETURN                                              20205000
*        (A1,A1+1)                CONVERTED INTEGER                     20206000
*                                                                       20207000
GETINT   BAL   R2,CVNUM           CONVERT ARGUMENT TO NUMERIC           20208000
         BZ    4(,RETURN)         IMMEDIATE RETURN IF WE HAVE INTEGER   20209000
*                                                                       20210000
*        COME HERE TO CONVERT REAL OR DREAL TO INTEGER                  20211000
*                                                                       20212000
         SLDL  A1,8               POSITION POSSIBLE DREAL LEFT IN A1    20213000
         BP    *+8                SKIP IF DREAL                         20214000
         SLDL  A1,24              ELSE COMPLETE POSITIONING FOR REAL    20215000
         STM   A1,A1+1,GETSVV     STORE THE REAL                        20216000
         LD    FA,GETSVV          LOAD INTO FLOATING REG                20217000
         LPDR  FA,FA              SET SIGN POSITIVE                     20218000
         CD    FA,=X'4E0000007FFFFFFF'      CHECK AGAINST MAXIMUM       20219000
         BCR   H,RETURN           ERROR IF TOO LARGE                    20220000
         AW    FA,=X'4E00000000000000'      RIGHT POSITION BINARY POINT 20221000
         TM    GETSVV,X'80'       TEST ORIGINAL SIGN                    20222000
         STD   FA,GETSVV          STORE UNNORMALIZED RESULT             20223000
         L     A1+1,GETSVV+4      LOAD INTEGER INTO PROPER REG          20224000
         LA    A1,0               SET TYPE CODE FOR INTEGER (LEAVE CC)  20225000
         BNO   4(,RETURN)         ALL DONE IF ORIGINAL SIGN +           20226000
         LCR   A1+1,A1+1          ELSE NEGATE                           20227000
         B     4(,RETURN)         AND RETURN                            20228000
         EJECT                                                          20229000
*                                                                       20230000
*        GETNUM                   CONVERT TO NUMERIC (REAL OR INTEGER)  20231000
*                                                                       20232000
*        (A1,A1+1)                ARGUMENT                              20233000
*        BAL   RETURN,GETNUM                                            20234000
*        ->  ERROR RETURN IF UNCONVERTIBLE                              20235000
*        ->  NORMAL RETURN                                              20236000
*        (A1,A1+1)                CONVERTED REAL OR INTEGER             20237000
*        CC = Z(INTEGER), O(REAL), P(DREAL)                             20238000
*                                                                       20239000
GETNUM   LA    R2,4(,RETURN)      ADJUST (R2) TO MERGE INTO CVNUM       20240000
*                                                                       20241000
*        CVNUM -- UTILITY ROUTINE USED BY GETINT,GETREAL,GETNUM TO      20242000
*        CONVERT ARGUMENTS TO NUMERIC (REAL OR INTEGER)                 20243000
*                                                                       20244000
*        (A1,A1+1)                ARGUMENT                              20245000
*        BAL   R2,CVNUM                                                 20246000
*        (RETURNS TO (RETURN) IF ARGUMENT CANNOT BE CONVERTED)          20247000
*        ->  NORMAL RETURN  (TO 0(R2))                                  20248000
*        (A1,A1+1)                CONVERTED RESULT                      20249000
*        CC = Z(INTEGER), O(REAL), P(DREAL)                             20250000
*                                                                       20251000
CVNUM    LCR   R0,A1              TEST TYPE                             20252000
         BCR   NM,R2              RETURN WITH CC SET IF NUMERIC         20253000
         STM   A1,A1+1,GETSV      ELSE STORE ARGUMENT                   20254000
         CLI   GETSV,SCODE        IS IT A STRING?                       20255000
         BE    CVNUMS             SKIP IF IT IS                         20256000
         SR    A1,A1              ELSE PREPARE AN INTEGER               20257000
         SR    A1+1,A1+1          WITH VALUE = ZERO                     20258000
         CLI   GETSV,NCODE        IS ARGUMENT NULL?                     20259000
         BCR   E,R2               RETURN NORMALLY WITH INTEGER 0 IF SO  20260000
         EJECT                                                          20261000
*                                                                       20262000
*        GETNUM -- CONTINUED                                            20263000
*                                                                       20264000
*        HERE THE ONLY VALID POSSIBLITY IS A NAME                       20265000
*                                                                       20266000
         CLI   GETSV,MCODE        IS IT A NAME?                         20267000
         BCR   NE,RETURN          CONVERSION ERROR IF ANYTHING ELSE     20268000
         L     A1,GETSV           RESTORE NAME BLOCK POINTER            20269000
         LA    A1,0(,A1)          STRIP OFF UPPER BYTE (MCODE)          20270000
         CR    A1,FR              ARE WE ABOVE FREE CORE = NAT VAR?     20271000
         BH    *+10               SKIP IF NATURAL VARIABLE              20272000
         C     A1,DYNAMB          ARE WE BELOW FREE CORE?               20273000
         BCR   NL,RETURN          GIVE ERROR RETURN IF NOT              20274000
         LM    A1,A1+1,VNAME(A1)  LOAD NAME OF VARIABLE                 20275000
         B     CVNUM              AND RE-ENTER                          20276000
*                                                                       20277000
*        COME HERE TO CONVERT A STRING TO NUMERIC                       20278000
*                                                                       20279000
CVNUMS   ST    R2,GETSV           SAVE LINKAGE                          20280000
         AH    A1,GETSV+SOFFSET   ADD OFFSET TO POINT TO START OF STG   20281000
         LH    A1+1,GETSV+SLENGTH           LOAD 360 LENGTH OF STRING   20282000
         L     R2,=A(STGTONUM)    LOAD ADDRESS OF CONVERT ROUTINE       20283000
         BALR  R1,R2              CALL CONVERSION ROUTINE               20284000
         B     0(,RETURN)         GIVE ERROR RETURN ON CONVERT ERROR    20285000
         LCR   R0,A1              SET CC TO SHOW TYPE                   20286000
         L     R2,GETSV           RELOAD CVNUM LINKAGE                  20287000
         BR    R2                 RETURN TO CALLER                      20288000
         EJECT                                                          20289000
*                                                                       20290000
*        GETSTG                   CONVERT TO STRING                     20291000
*                                                                       20292000
*        (A1,A1+1)                ARGUMENT                              20293000
*        BAL   RETURN,GETSTG                                            20294000
*        ->  ERROR RETURN IF UNCONVERTIBLE                              20295000
*        ->  NORMAL RETURN                                              20296000
*        (A1,A1+1)                SPECIFIER FOR CONVERTED STRING        20297000
*                                                                       20298000
*        NOTE THAT THIS ROUTINE (UNLIKE GETSTGS) CONSTRUCTS A NEW SBLOK 20299000
*        IN FREE CORE WHERE NEEDED (HOWEVER, NO GCOL TEST IS MADE)      20300000
*                                                                       20301000
*        NOTE THAT THE NULL STRING IS RETURNED UNCHANGED                20302000
*                                                                       20303000
GETSTG   STM   A1,A1+1,GETSV      STORE ARGUMENT                        20304000
         CLI   GETSV,SCODE        TEST FOR STRING                       20305000
         BE    4(,RETURN)         NORMAL RETURN IF STRING               20306000
         CLI   GETSV,NCODE        IS ARG  NULL?                         20307000
         BE    4(,RETURN)         NORMAL RETURN IF NULL                 20308000
         LTR   A1,A1              TEST CODE FOR REMAINING CASES         20309000
         BP    GETSTGNN           SKIP IF NON-NUMERIC                   20310000
         L     R0,GETSTGC         ELSE LOAD CONVERSION PARAMETERS       20311000
         L     R2,=A(NUMTOSTG)    LOAD POINTER TO CONVERT ROUTINE       20312000
         BALR  R1,R2              CALL ROUTINE TO CONVERT TO STRING     20313000
         BZ    GETSTGL1           SKIP IF NO NEED TO COPY TO FREE CORE  20314000
*                                                                       20315000
*        NOW MOVE THE STRING TO FREE CORE AND MAKE A NEW SBLOK          20316000
*        THIS ENTRY POINT IS ALSO USED BY STG TO BUILD A NEW SBLOK      20317000
*                                                                       20318000
GETSTGL  STE   ZR,0(,FR)          SET DTYPE=SBLOK=0, GCOLPTR=0          20319000
         LA    R0,SCHARS+BOUND+1(,A1+1)     NEW SBLOK LENGTH WITH FUDGE 20320000
         N     R0,FULLWRD         ADJUST TO PROPER BOUNDARY             20321000
         STH   R0,STLENGTH(,FR)   STORE IN SBLOK LENGTH FIELD           20322000
         EX    A1+1,GETSTGMM      MOVE CHARACTERS TO SBLOK              20323000
         LR    A1,FR              SET ADDRESS OF SBLOK                  20324000
         AR    FR,R0              BUMP FREE POINTER                     20325000
*                                                                       20326000
*        HERE TO EXIT, SKIP HERE FOR CASE OF NO NEED TO COPY TO FREECOR 20327000
*                                                                       20328000
GETSTGL1 O     A1,SCODEBT         SUPPLY TYPE CODE                      20329000
         B     4(,RETURN)         GIVE SUCCESS RETURN                   20330000
         EJECT                                                          20331000
*                                                                       20332000
*        GETSTG -- CONTINUED                                            20333000
*                                                                       20334000
*                                                                       20335000
*        HERE THE ONLY REMAINING POSSIBILITY IS A NAME                  20336000
*                                                                       20337000
GETSTGNN CLI   GETSV,MCODE        IS IT A NAME?                         20338000
         BCR   NE,RETURN          CONVERSION ERROR IF ANYTHING ELSE     20339000
         LA    R1,0(,A1)          IF A NAME, COPY & STRIP UPPER BYTE    20340000
         CR    R1,FR              ARE WE ABOVE FREE CORE?               20341000
         BH    GETSTGN1           SKIP IF SO=NATURAL VARIABLE           20342000
         C     R1,DYNAMB          ARE EW BELOW FREE CORE?               20343000
         BCR   NL,RETURN          GIVE ERROR RETURN IF NOT              20344000
*                                                                       20345000
*        COME HERE FOR NATURAL VARIABLE TO LOAD STRING NAME             20346000
*                                                                       20347000
GETSTGN1 LM    A1,A1+1,VNAME(A1)  LOAD NAME OF VARIABLE                 20348000
         B     4(,RETURN)         AND GIVE SUCCESS RETURN               20349000
*                                                                       20350000
GETSTGMM MVC   SCHARS(*-*,FR),SCHARS(A1)    MOVE CHARS TO FREE CORE     20351000
         CNOP  0,4                ALLIGN CONVERSION PARAMETERS          20352000
GETSTGC  DC    AL1(0,14,0,7)      FORMAT=0(GZ), DIGS=7(REAL),14(DREAL)  20353000
         EJECT                                                          20354000
*                                                                       20355000
*        GETSTGS                  CONVERT TO STRING SPECIFICATION       20356000
*                                                                       20357000
*        (A1,A1+1)                ARGUMENT                              20358000
*        BAL   RETURN,GETSTGS                                           20359000
*        ->  ERROR RETURN IF UNCONVERTIBLE                              20360000
*        ->  NORMAL RETURN                                              20361000
*        (A1)                     FIRST ADDRESS OF CONVERTED STRING     20362000
*        (A1+1)                   360 LENGTH OF CONVERTED STRING        20363000
*                                                                       20364000
*        UNLIKE GETSTG, THIS ROUTINE DOES NOT BUILD A NEW SBLOK IN      20365000
*        FREE CORE -- IT IS USED IN SITUATIONS WHERE THE USE OF THE     20366000
*        CONVERTED STRING IS EPHEMERAL                                  20367000
*                                                                       20368000
*        THE NULL STRING RETURNS WITH A 360 LENGTH OF -1                20369000
*                                                                       20370000
GETSTGS  STM   A1,A1+1,GETSV      STORE ARGUMENT                        20371000
         CLI   GETSV,SCODE        CHECK FOR STRING                      20372000
         BNE   GETSTGS1           SKIP IF NOT STRING                    20373000
*                                                                       20374000
*        REENTER HERE AFTER CONVERTING A NAME TO A STRING               20375000
*                                                                       20376000
GETSTGS0 AH    A1,GETSV+SOFFSET   ADD STRING OFFSET                     20377000
         LH    A1+1,GETSV+SLENGTH           LOAD 360 LENGTH             20378000
         B     4(,RETURN)         GIVE NORMAL RETURN                    20379000
*                                                                       20380000
*        COME HERE TO TEST FOR NULL CASE                                20381000
*                                                                       20382000
GETSTGS1 CLI   GETSV,NCODE        IS ARGUMENT NULL?                     20383000
         BNE   GETSTGS2           SKIP IF NOT                           20384000
         SR    A1+1,A1+1          ELSE SET 360 LENGTH = 0               20385000
         BCT   A1+1,4(,RETURN)    NORMAL RETURN SETTING 360 LEN TO -1   20386000
*                                                                       20387000
*        COME HERE TO TEST REMAINING CASES                              20388000
*                                                                       20389000
GETSTGS2 LTR   A1,A1              TEST TYPE                             20390000
         BP    GETSTGS3           SKIP IF NON-NUMERIC                   20391000
         L     R0,GETSTGC         ELSE LOAD CONVERSION PARAMETERS       20392000
         L     R2,=A(NUMTOSTG)    LOAD ADDRESS OF CONVERT ROUTINE       20393000
         BALR  R1,R2              CALL CONVERT ROUTINE                  20394000
         B     4(,RETURN)         AND RETURN TO CALLER                  20395000
*                                                                       20396000
*        AT THIS POINT, THE ONLY LEGAL REMAINING POSSIBILITY IS A NAME  20397000
*                                                                       20398000
GETSTGS3 CLI   GETSV,MCODE        IS IT A NAME?                         20399000
         BCR   NE,RETURN          ERROR RETURN IF NOT                   20400000
         LA    R1,0(,A1)          IF IT IS A NAME, COPY AND STRIP       20401000
         CR    R1,FR              ARE WE ABOVE FREE CORE?               20402000
         BH    *+10               SKIP IF SO - NATURAL VARIABLE         20403000
         C     R1,DYNAMB          ARE WE BELOW FREE CORE?               20404000
         BCR   NL,RETURN          ERROR IF NOT NATURAL VARIABLE         20405000
         L     A1,VNAME(,R1)      IF SO, LOAD STRING NAME POINTER       20406000
         AH    A1,VNAME+SOFFSET(,R1)        ADD STRING OFFSET           20407000
         LH    A1+1,VNAME+SLENGTH(,R1)      LOAD STRING LENGTH          20408000
         B     4(,RETURN)         GIVE SUCCESSFUL CONVERSION EXIT       20409000
         EJECT                                                          20410000
*                                                                       20411000
*        GETSTGT                  CONVERT TO STRING (TEMPORARY)         20412000
*                                                                       20413000
*        (A1,A1+1)                ARGUMENT TO BE CONVERTED              20414000
*        BAL   RETURN,GETSTGT                                           20415000
*        => ERROR RETURN IF UNCONVERTIBLE                               20416000
*        => NORMAL RETURN                                               20417000
*        (A1,A1+1)                STRING IN ADDRESS,LENGTH FORM         20418000
*                                                                       20419000
*        THIS STRING CONVERSION ROUTINE IS LIKE GETSTGS IN THAT THE     20420000
*        STRING IS IN ADDRESS/LENGTH FORMAT AND IS ONLY FOR TEMPORARY   20421000
*        USE -- HOWEVER, THE CONVERTED RESULT FROM A NUMERIC IS MOVED   20422000
*        TO FREE CORE (FR IS NOT MOVED PAST IT)                         20423000
*                                                                       20424000
GETSTGT  LTR   R0,A1              TEST TYPES                            20425000
         BP    GETSTGS            MERGE WITH GETSTGS IF NON-NUMERIC     20426000
*                                                                       20427000
*        HERE FOR ALL NUMERIC CASES                                     20428000
*                                                                       20429000
         L     R0,GETSTGC         LOAD CONVERSION PARAMETERS            20430000
         L     R2,=A(NUMTOSTG)    ADDRESS OF CONVERT ROUTINE            20431000
         BALR  R1,R2              CONVERT NUMERIC TO STRING             20432000
         BZ    4(,RETURN)         RETURN IF NO NEED TO COPY             20433000
         EX    A1+1,GETSTGMM      MOVE CHARACTERS TO FREE CORE          20434000
         LR    A1,FR              SET ADDRESS OF CHARACTERS             20435000
         B     4(,RETURN)         RETURN TO CALLER                      20436000
*                                                                       20437000
*        USE OF THE THREE ROUTINES GETSTG,GETSTGS,GETSTGT               20438000
*                                                                       20439000
*        GETSTG IS USED IF THE RESULT IS TO BE KEPT AROUND OR           20440000
*        SUBJECTED TO A GARBAGE COLLECTION -- THE SCODE BYTE IS ALWAYS  20441000
*        SUPPLIED AND THE SOFFSET MAY BE NON-ZERO -- NULL IS RETURNED   20442000
*        AS A NULL WITH NCODE                                           20443000
*                                                                       20444000
*        GETSTGS IS USED IF THE RESULT IS TO BE IMMEDIATELY USED AND    20445000
*        DISCARDED. SCODE IS NOT NECCESSARILY SUPPLIED. SOFFSET IS      20446000
*        ALWAYS ZERO. NULL IS RETURNED WITH A LENGTH OF -1.             20447000
*                                                                       20448000
*        GETSTGT IS USED WHEN TWO TEMPORARY STRINGS ARE NEEDED, TWO     20449000
*        SUCCESSIVE CALLS TO GETSTGS MAY CAUSE OVERWRITING OF CONVERTED 20450000
*        STRINGS -- IN THIS SITUATION, THE FIRST CALL SHOULD BE TO      20451000
*        GETSTGT -- IN OTHER RESPECTS, GETSTGS AND GETSTGT ARE IDENTICL 20452000
         EJECT                                                          20453000
*                                                                       20454000
*        GETNAME                  CONVERT TO NAME                       20455000
*                                                                       20456000
*        (A1,A1+1)                ARGUMENT                              20457000
*        BAL   RETURN,GETNAME                                           20458000
*        ->  ERROR RETURN IF UNCONVERTIBLE                              20459000
*        ->  NORMAL RETURN                                              20460000
*        (A1)                     ADDRESS OF VARIABLE BLOCK             20461000
*                                                                       20462000
GETNAME  MVI   DOLLFLG,$BYNAM+$GETNM        SET GETNAME, BY NAME FLGS   20463000
         L     R2,=A(DOLLC)       LOAD ROUTINE ADDRESS                  20464000
         USING DOLLC,R2           TEMP BASE REGISTER FOR JUMP           20465000
         B     DOLLC1             JUMP TO ROUTINE PAST ST IN RETLOC     20466000
         DROP  R2                 GET RID OF BASE REGISTER              20467000
         TITLE 'SPITBOLA -- CONSTANT POOL'                              20468000
*                                                                       20469000
*        EQUATE FOR BOUNDARY ALIGNMENT FUDGE                            20470000
*                                                                       20471000
BOUND    EQU   3                  BOUNDARY ALIGNMENT FUDGE              20472000
*                                                                       20473000
*                                                                       20474000
*        THE CONSTANTS HERE ARE USED BY ALL THE EXECUTION ROUTINES      20475000
*                                                                       20476000
         CNOP  0,4                FULLWORD ALLIGNMENT FOR POOL          20477000
X80      EQU   RCODEBT            RCODEBT IS A X'80000000'              20478000
*                                                                       20479000
*        PATTERN POINTERS                                               20480000
*                                                                       20481000
NULLPTR  DC    AL1(PCODE)         TYPE CODE FOR PATTERN                 20482000
         DC    AL3(NULLPAT)       POINTER TO NULL PATTERN               20483000
*                                                                       20484000
MARKPTR  DC    AL1(PCODE)         CODE FOR PATTERN                      20485000
         DC    AL3(MARKPAT)       POINTER TO MARK PATTERN               20486000
*                                                                       20487000
*        MISCELLANEOUS CONSTANTS                                        20488000
*                                                                       20489000
BEVLR1   B     $$EVLR             CONSTANT TO CHECK END OF EXPR CODE    20490000
FBLOKI   B     $$FUNC             1ST INSTRUC IN FBLOK (TO CHECK FBLOK) 20491000
SPINMX   DC    X'7FFFFFFF'        MAXIMUM VALUE OF STATEMENT COUNTER    20492000
FULLWRD  DC    X'FFFFFFFC'        USED TO MASK TO FULL WORD BOUNDARY    20493000
VCLOSE   DC    V(SYSCLOSE)        ADDRESS OF INTERFACE ROUTINE          20494000
VOPEN    DC    V(SYSDCB)          ADDRESS OF INTERFACE ROUTINE          20495000
VSYSTIME DC    V(SYSTIME)         ADDRESS OF INTERFACE GETTIME          20496000
AIOASSOC DC    A(IOASSOC)         ADDR OF ROUTINE TO PLUG CODE FOR IO   20497000
CODXEQAD DC    A(COMPILER)        EXECUTE TIME COMPILER LOAD ROUTINE    20498000
H1       DC    H'1'               HALF WORD 1                           20499000
H2       DC    H'2'               HALF WORD 2                           20500000
H3       DC    H'3'               HALF WORD 3                           20501000
H4       DC    H'4'               HALF WORD 4                           20502000
H6       DC    H'6'               HALF WORD 6                           20503000
H8       DC    H'8'               HALF WORD 8                           20504000
H10      DC    H'10'              HALF WORD 10                          20505000
H12      DC    H'12'              HALF WORD 12                          20506000
H16      DC    H'16'              HALF WORD 16                          20507000
H256     DC    H'256'             HALF WORD 256                         20508000
*                                                                       20509000
*        DUMMY EXPRESSION VALUES USED DURING PATTERN MATCHING & EVAL    20510000
*                                                                       20511000
         DS    0F                 ALLIGN                                20512000
EVALWCON DC    AL1(ECODE)         EXPRESSION TYPE CODE                  20513000
         DC    AL3(EVALWRIT)      DEFERRED WRITE CALL                   20514000
EVALRCON DC    AL1(ECODE)         EXPRESSION TYPE CODE                  20515000
         DC    AL3(EVALREAD)      DEFERRED READ CALL                    20516000
EVALGCOL EQU   BEVLR1             JUST DEFERRED CALL TAKES CARE OF GCOL 20517000
         EJECT                                                          20518000
*                                                                       20519000
*        LITERALS FOR SPITBOLP, SPITBOLX, SPITBOLA                      20520000
*                                                                       20521000
         LTORG ,                  ADDRESSABLE UNDER SYS BASE REG        20522000
*                                                                       20523000
         TITLE 'SPITBOLA -- PATCH SPACE'                                20524000
*                                                                       20525000
         DC    S(*)               S ADDRESS FOR FIRST PATCH             20526000
         DC    30AL4(0)           PATCH SPACE, INITIALIZE TO ZEROS      20527000
*                                                                       20528000
         ORG   SPITBOLA+4096-2-2  ORIGIN TO END OF ADDRESSABLE AREA - 2 20529000
         DC    S(*)               S ADDRESS FOR LAST PATCH              20530000
         TITLE 'SPITBOLA -- GET FREE CORE BLOCK LENGTH ROUTINE'         20531000
*                                                                       20532000
*        BLOKLEN                  GET LENGTH OF BLOCK IN FREE CORE      20533000
*                                                                       20534000
*        USED IN GARBAGE COLLECTOR, COPY, CONVERT, DUMP, IOASSOC        20535000
*                                                                       20536000
*        (OLD) OR (A1)            POINTS TO BLOCK                       20537000
*        (R2)                     MUST HAVE UPPER THREE BYTES ZERO      20538000
*        EX    0,BLOKLEN(REGISTER WITH DTYPE BLOK CODE)                 20539000
*        (R2)                     NUMBER OF BYTES IN BLOCK              20540000
*                                                                       20541000
*        TABLE OF INSTRUCTIONS EXECUTED TO GET LENGTH OF BLOCKS         20542000
*                                                                       20543000
         ORG   SPITBOLA+4096-2    ORIGIN TO LAST ADDRESSABLE LOCATION   20544000
BLOKLEN  EQU   *                  START OF INSTRUCTIONS                 20545000
*                                                                       20546000
         LH    R2,STLENGTH(,OLD)            SBLOK                       20547000
*                                                                       20548000
         LA    R2,CTCHARS+256               TBLOK                       20549000
*                                                                       20550000
         LH    R2,FNLENG(,OLD)              FBLOK                       20551000
*                                                                       20552000
         LH    R2,EFLENG(,OLD)              EFBLOK                      20553000
*                                                                       20554000
         LA    R2,IOBSIZE                   IOBLOK                      20555000
*                                                                       20556000
         L     R2,NBYTESA(,OLD)             ABLOK                       20557000
*                                                                       20558000
         IC    R2,NBYTESD(,OLD)             PDBLOK                      20559000
*                                                                       20560000
         LA    R2,FFBSIZE                   FFBLOK                      20561000
*                                                                       20562000
         LH    R2,NBYTESDF(,OLD)            PDFBLOK                     20563000
*                                                                       20564000
         LH    R2,PTLENG(,OLD)                                          20565000
*                                                                       20566000
         L     R2,TBLENGTH(,OLD)            TBBLOK                      20567000
*                                                                       20568000
         LA    R2,TESIZE                    TEBLOK                      20569000
*                                                                       20570000
         L     R2,CODNLEN(,OLD)             CBLOK                       20571000
*                                                                       20572000
         LA    R2,TRBSIZE                   TRBLOK                      20573000
*                                                                       20574000
*        LAST ENTRY -- OFFSET MUST BE LTBLOK                            20575000
*                                                                       20576000
         ORG   BLOKLEN+LTBLOK     POSITION FOLLOWING ENTRY CORRECTLY    20577000
         LA    R2,LTSIZE                    LTBLOK                      20578000
         TITLE 'SPITBOLF -- START OF SECTION'                           20579000
*                                                                       20580000
*        THIS CSECT CONTAINS THE STANDARD SYSTEM FUNCTION DEFINITIONS   20581000
*                                                                       20582000
         BEGIN F                  START OF SPITBOLF, SPITBLLF CSECT     20583000
         TITLE 'SPITBOLF -- INTRINSIC FUNCTIONS'                        20584000
*        THE FOLLOWING FUNCTIONS ARE USUALLY INTRINSIC -- THAT IS, CODE 20585000
*        IS GENERATED IN LINE, USUALLY A DIRECT CALL TO AN ENTRY        20586000
*        POINT IN THE ADDRESSABLE REGION. THESE ENTRY POINTS ARE USED   20587000
*        WHEN THE FUNCTION IS APPLIED OR AS A RESULT OF AN OPSYN OR     20588000
*        THE COMPILATION OF THE CALL OCCURED IN -NOOPTIMIZE MODE.       20589000
*                                                                       20590000
*        ENTRY FOR IDENT FUNCTION                                       20591000
*                                                                       20592000
         USING F$IDENT-FCODE,DB4  FUNCTION BASE REGISTER                20593000
F$IDENT  BAL   R2,IDDIFR          JUMP TO COMMON IDENT/DIFFER ROUTINE   20594000
         BCR   E,RETURN           SUCCESS RETURN IF ARGS IDENT          20595000
         B     FAILR              ELSE FAIL RETURN                      20596000
*                                                                       20597000
*        ENTRY FOR DIFFER FUNCTION                                      20598000
*                                                                       20599000
         USING F$DIFFER-FCODE,DB4 FUNCTION BASE REGISTER                20600000
F$DIFFER BAL   R2,IDDIFR          JUMP TO COMMON IDENT/DIFFER ROUTINE   20601000
         BCR   NE,RETURN          SUCCESS RETURN IF DIFFER              20602000
         B     FAILR              ELSE FAIL RETURN                      20603000
         DROP  DB4                DROP FUNCTION BASE                    20604000
*                                                                       20605000
*        IDDIFR -- COMMON ROUTINE USED BY IDENT AND DIFFER              20606000
*                                                                       20607000
IDDIFR   CH    R0,H2              MUST HAVE TWO ARGUMENTS               20608000
         BL    $$WNAG             USE $$WNAG TO SUPPLY MISSING ONES     20609000
         LM    A1,A2+1,TEM#2(PDR) LOAD ARGS (WRONG WAY ROUND IS OK)     20610000
         L     PDR,PDRLOC         RESET STACK POINTER                   20611000
         ST    RETURN,RETLOC      SAVE RETURN LOCATION                  20612000
         BAL   RETURN,$$IDNT      CALL IDENT ROUTINE WHICH SETS CC      20613000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               20614000
         L     A1,NCODEBT         LOAD NULL RESULT                      20615000
         BR    R2                 RETURN TO IDDIFR CALLER               20616000
         EJECT                                                          20617000
*                                                                       20618000
*        ENTRY POINT FOR ANY                                            20619000
*                                                                       20620000
         USING F$ANY-FCODE,DB4    FUNCTION BASE REGISTER                20621000
F$ANY    BAL   R2,LOADARG         CALL COMMON ARGUMENT LOAD ROUTINE     20622000
         DC    Y($$ANYP-SPITBOLA) SYS OFFSET OF STANDARD ROUTINE        20623000
*                                                                       20624000
*        THE ENTRY POINTS FOR THE REMAINING ONE ARGUMENT INTRINSICS ARE 20625000
*        GENERATED WITH THE FUNC MACRO WHICH GENERATES ANALOGOUS        20626000
*        CODE TO THE ANY FUNCTION ABOVE                                 20627000
*                                                                       20628000
BREAK    FUNC  $$BRKP             BREAK                                 20629000
BREAKX   FUNC  $$BRKX             BREAKX                                20630000
LEN      FUNC  $$LENP             LEN                                   20631000
NOTANY   FUNC  $$NTNP             NOTANY                                20632000
POS      FUNC  $$POSP             POS                                   20633000
RPOS     FUNC  $$RPSP             RPOS                                  20634000
RTAB     FUNC  $$RTBP             RTAB                                  20635000
SPAN     FUNC  $$SPNP             SPAN                                  20636000
TAB      FUNC  $$TABP             TAB                                   20637000
*                                                                       20638000
*        LOADARG -- COMMON ROUTINE USED BY ALL THE ABOVE                20639000
*        NOTE THAT THERE IS ALWAYS ONE ARGUMENT ON STACK ALREADY        20640000
*                                                                       20641000
         DROP  DB4                THIS ROUTINE NEEDS NO BASE REG        20642000
LOADARG  LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         20643000
         L     PDR,PDRLOC         RESET STACK POINTER                   20644000
         LH    R2,0(,R2)          LOAD OFFSET TO STANDARD ROUTINE       20645000
         B     0(R2,SYS)          AND JUMP TO IT                        20646000
*                                                                       20647000
*        ENTRY POINT FOR INTEGER                                        20648000
*                                                                       20649000
F$INTEGE LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         20650000
         L     PDR,PDRLOC         RESET STACK POINTER                   20651000
         ST    RETURN,RETLOC      SAVE RETURN POINT                     20652000
         BAL   RETURN,GETNUM      CONVERT ARGUMENT TO NUMERIC           20653000
         B     FAILRL             NOT INTEGER IF CONVERT ERROR          20654000
         LTR   A1,A1              IF OK CONVERT, IS RESULT INTEGER      20655000
         BCR   NZ,RETURN          BACK TO GIVE FAILURE IF NOT           20656000
         B     EXITNULL           ELSE RETURN NULL                      20657000
         EJECT                                                          20658000
*                                                                       20659000
*        NOTE THAT FOR CALLS TO THE LOGICAL FUNCTIONS DB4 IS ACTUALLY   20660000
*        SET 2 BYTES LOWER THAN USING AT MERGE POINT INDICATES          20661000
*        THIS ONLY MEANS THAT CALLS TO CMPRFUNC ENTER 2 BYTES BEFORE    20662000
*        CMPRFUNC.  TO GET AROUND THIS WE NEED ONLY PUT A NOPR BEFORE   20663000
*        CMPRFUNC, SINCE DB4 IS NOT THE BASE REGISTER FOR IT            20664000
*                                                                       20665000
*        ENTRY POINT FOR LEQ                                            20666000
*                                                                       20667000
F$LEQ    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE EQ      20668000
*                                                                       20669000
*        ENTRY POINT FOR EQ                                             20670000
*                                                                       20671000
         USING F$EQ-FCODE,DB4     FUNCTION BASE REGISTER                20672000
F$EQ     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE                20673000
         BCR   E,RETURN           SUCCESS RETURN IF EQUAL               20674000
*                                                                       20675000
*        ENTRY POINT FOR LNE                                            20676000
*                                                                       20677000
F$LNE    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE NE      20678000
*                                                                       20679000
*        ENTRY POINT FOR NE                                             20680000
*                                                                       20681000
         USING F$NE-FCODE,DB4     FUNCTION BASE REGISTER                20682000
F$NE     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE                20683000
         BCR   NE,RETURN          SUCCESS RETURN IF UNEQUAL             20684000
*                                                                       20685000
*        ENTRY POINT FOR LGE                                            20686000
*                                                                       20687000
F$LGE    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE GE      20688000
*                                                                       20689000
*        ENTRY POINT FOR GE                                             20690000
*                                                                       20691000
         USING F$GE-FCODE,DB4     FUNCTION BASE REGISTER                20692000
F$GE     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE                20693000
         BCR   NH,RETURN          SUCCESS RETURN IF 2ND ARG <= 1ST ARG  20694000
*                                                                       20695000
*        ENTRY POINT FOR LGT                                            20696000
*                                                                       20697000
F$LGT    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE GT      20698000
*                                                                       20699000
*        ENTRY POINT FOR GT                                             20700000
*                                                                       20701000
         USING F$GT-FCODE,DB4     FUNCTION BASE REGISTER                20702000
F$GT     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE                20703000
         BCR   L,RETURN           SUCCESS RETURN IF 2ND ARG < 1ST ARG   20704000
         EJECT                                                          20705000
*                                                                       20706000
*        ENTRY POINT FOR LLE                                            20707000
*                                                                       20708000
F$LLE    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE LE      20709000
*                                                                       20710000
*        ENTRY POINT FOR LE                                             20711000
*                                                                       20712000
         USING F$LE-FCODE,DB4     FUNCTION BASE REGISTER                20713000
F$LE     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE                20714000
         BCR   NL,RETURN          SUCCESS RETURN IF 2ND ARG >= 1ST ARG  20715000
*                                                                       20716000
*        ENTRY POINT FOR LLT                                            20717000
*                                                                       20718000
F$LLT    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE LT      20719000
*                                                                       20720000
*        ENTRY POINT FOR LT                                             20721000
*                                                                       20722000
         USING F$LT-FCODE,DB4     FUNCTION BASE REGISTER                20723000
F$LT     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE                20724000
         BCR   H,RETURN           SUCCESS RETURN IF 2ND ARG > 1ST ARG   20725000
*                                                                       20726000
*        CMPRFUNC -- COMMON FUNCTION USED BY ABOVE ENTRY POINTS         20727000
*                                                                       20728000
         DROP  DB4                THIS ROUTINE DOES NOT USE A BASE REG  20729000
*                                                                       20730000
*        THIS NOPR IS SO CALLS FOR LOGICAL FUNCTIONS DON'T HAVE         20731000
*        TROUBLE WITH MIS-SET BASE REG DB4                              20732000
*                                                                       20733000
         NOPR  0                  DO NOTHING IF WE ENTER EARLY          20734000
CMPRFUNC ST    R2,CMPRSAVE        SAVE R2 (LINKAGE)                     20735000
         ST    RETURN,ALTLOC      SAVE RETURN FOR POSSIBLE ERROR        20736000
         CH    R0,H2              MAKE SURE WE HAVE AT LEAST TWO ARGS   20737000
         BL    $$WNAG             USE $$WNAG TO SUPPLY ANY MISSING ARGS 20738000
         LM    A1,A2+1,TEM#2(PDR) LOAD ARGUMENTS WRONG WAY ROUND        20739000
         L     PDR,PDRLOC         RESET STACK POINTER                   20740000
         LA    RETURN,$$CMPR      TENTATIVELY SET ADDRESS OF ARITH CMPR 20741000
         CR    DB3,DB1            TEST CASES (ARITH/LEXICAL)            20742000
         BALR  DB3,0              GET A BASE REGISTER                   20743000
         USING *,DB3              TELL ASSEMBLER                        20744000
         BNE   *+8                SKIP IF THIS IS WHAT WE WANT          20745000
         DROP  DB3                DROP SILLY BASE REGISTER              20746000
         LA    RETURN,$$LCMP      ELSE POINT TO LEXICAL COMPARE         20747000
         L     DB3,$$BAS3         RESTORE DB3                           20748000
         BALR  RETURN,RETURN      CALL PROPER ROUTINE                   20749000
         L     R2,CMPRSAVE        RELOAD LINKAGE REG                    20750000
         L     RETURN,ALTLOC      RELOAD CODE RETURN LOC                20751000
         STE   ZR,ALTLOC          CLEAR ALTERNATE RETURN LOC            20752000
         L     A1,NCODEBT         LOAD NULL AS RETURNED RESULT          20753000
         EX    0,0(,R2)           EXECUTE CONDITIONAL SUCCESS BRANCH    20754000
         B     FAILR              FAIL IF IT DOES NOT BRANCH            20755000
         LTORG ,                  LITERALS FOR INTRINSIC FUNCTIONS      20756000
         TITLE 'SPITBOLF -- APPLY FUNCTION'                             20757000
APPLY    FUNCTION  2              ENTRY POINT -- AT LEAST 2 ARGS        20758000
         LR    DB4,R0             SAVE NUMBER OF ARGUMENTS              20759000
         LM    A1,A1+1,TEM#1(PDR) LOAD FUNCTION SPECIFIER               20760000
         SH    PDR,H8             ADJUST STACK TO POINT TO ARGS         20761000
         BAL   RETURN,GETNAME     GET VARBLOCK FOR FUNCTION             20762000
         XERR  01,051             1ST ARG TO APPLY NOT A FUNCTION       20763000
         LR    R0,DB4             IF OK, RECALL ARGUMENT COUNT          20764000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               20765000
         L     DB4,VFUNC(,A1)     POINT TO FUNCTION TO BE APPLIED       20766000
         BCT   R0,FCODE(,DB4)     ADJUST ARG COUNT, OFF TO FUNCTION     20767000
*                                                                       20768000
*        NOTE THAT THE ABOVE BCT CANNOT FALL THROUGH SINCE WE REQUIRED  20769000
*        TWO ARGUMENTS IN THE FUNCTION HEADER FOR APPLY                 20770000
         TITLE 'SPITBOLF -- ARBNO FUNCTION'                             20771000
ARBNO    FUNCTION 1               ENTRY POINT -- ONE ARGUMENT REQUIRED  20772000
*                                                                       20773000
*        ARBNO(PATTERN) IS THE FOLLOWING PATTERN STRUCTURE --           20774000
*                                                                       20775000
*        +------------+                                                 20776000
*        |            |                                                 20777000
*        |    NULL    |                                                 20778000
*        |            |                                                 20779000
*        +------------+                                                 20780000
*              |                                                        20781000
*              | OR                                                     20782000
*              |                                                        20783000
*              V                                                        20784000
*        +------------+         +------------+         +------------+   20785000
*        |            |  THEN   |            |  THEN   |            |   20786000
*    +-->|    MARK    |-------->|   PATTERN  |-------->|    ARBNO   |   20787000
*    |   |            |         |            |         |            |   20788000
*    |   +------------+         +------------+         +------------+   20789000
*    |                                                       |          20790000
*    |                                           PARAM1      |          20791000
*    +-------------------------------------------------------+          20792000
*                                                                       20793000
*        NOTE THAT THIS DEVIATES FROM GBGCLF RULE                       20794000
*                                                                       20795000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT FOR CONVERT             20796000
         L     PDR,PDRLOC         RESET STACK POINTER                   20797000
         BAL   RETURN,GETPAT      CONVERT ARGUMENT TO PATTERN           20798000
         XERR  01,050             ARGUMENT TO ARBNO IS NOT A PATTERN    20799000
         LR    A2+1,A1            SAVE POINTER                          20800000
         LH    A1,PTLENG(,A2+1)   PICK UP LENGTH OF ARBNO ARGUMENT      20801000
         SH    A1,H4              ADJUST TO GET PARAMETER VALUE         20802000
         SR    R2,R2              MINMATCH = 0 FOR ARBNO                20803000
         BAL   R1,MPBLOK          MAKE BLOCK FOR ARBNO                  20804000
         DC    YL1(QF+PARM1,LPRM1)          ONE PARAM, NOT RELOCATABLE  20805000
         DC    AL2(PN$ARBNO-PATSUBS+X'8000')                            20806000
         DC    AL2(ARBNOEXT-QPATSUBS)                                   20807000
         LR    A2,A1              PUT ARBNO POINTER IN A2               20808000
         LR    A1,A2+1            RECALL ARG POINTER TO A1              20809000
         BAL   RETURN,PCONC       CONCATENATE PATTERN, ARBNO BLOCK      20810000
         LR    A2,A1              PUT RESULT IN A2                      20811000
         L     A1,MARKPTR         LOAD POINTER TO MARK PATTERN          20812000
         BAL   RETURN,PCONC       WE HAVE WHOLE LOWER PART NOW          20813000
         LR    A2,A1              MOVE TO A2                            20814000
         L     A1,NULLPTR         LOAD POINTER TO NULL PATTERN          20815000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               20816000
         B     ORMAK              JUMP TO OR THEM AND RETURN            20817000
ARBNO    ENDFUNC ,                END OF ARBNO FUNCTION                 20818000
         TITLE 'SPITBOLF -- ARG FUNCTION'                               20819000
ARG      FUNCTION  2              ENTRY POINT -- TWO ARGS REQUIRED      20820000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         20821000
         BAL   RETURN,GETNAME     FIND VARIABLE BLOCK                   20822000
ARGERR   XERR  01,052             FIRST ARG TO ARG NOT FUNCTION NAME    20823000
         LR    A2,A1              ELSE IF OK, SAVE POINTER              20824000
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT        20825000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    20826000
         XERR  01,053             SECOND ARGUMENT TO ARG NOT AN INTEGER 20827000
         L     A2+1,VFUNC(,A2)    LOAD FUNCTION POINTER                 20828000
         CLC   FCODE(4,A2+1),FBLOKI         TEST FOR PROG DEF FUNCTION  20829000
         BNE   ARGERR             ERROR IF NOT                          20830000
         CH    A1+1,FNARGS(,A2+1)           IS COUNT TOO LARGE?         20831000
         BH    FAILRL             FAIL IF SO                            20832000
         SLA   A1+1,2             MULTIPLY COUNT BY FOUR                20833000
         BNP   FAILRL             FAIL IF ZERO OR NEGATIVE              20834000
         L     A1,FARGS-4(A2+1,A1+1)        LOAD ARGUMENT POINTER       20835000
         LM    A1,A1+1,VNAME(A1)  LOAD NAME OF ARGUMENT                 20836000
         B     EXIT               RETURN TO CALLER                      20837000
ARG      ENDFUNC   ,              END OF ARG FUNCTION                   20838000
         TITLE 'SPITBOLF -- ARRAY FUNCTION'                             20839000
ARRAY    FUNCTION  2              ENTRY POINT -- 2 ARGUMENTS NEEDED     20840000
         STE   ZR,0(,FR)          ZERO THE GARBAGE COLLECTION FIELD     20841000
         MVI   0(FR),ABLOK        SET BLOCK CODE                        20842000
         MVC   ASPEC(8,FR),TEM#1(PDR)       SAVE PROTOTYPE IN ARRAY     20843000
         LR    DB2,FR             COPY ARRAY POINTER                    20844000
         LA    DB3,8              INITIAL SUBFAC IS 8                   20845000
         STE   ZR,SUBLBD(,FR)     INITIALIZE 1ST LBD/DIMENSION          20846000
         MVI   SUBLBD+1(FR),1     SET LOW BOUND DEFAULT = 1             20847000
         CLI   TEM#1(PDR),ICODE   CHECK FOR INTEGER SUBSCRIPT CASE      20848000
         BE    ARRAYI             SKIP FOR SPEEDY HANDLING IF INTEGER   20849000
         BAL   A2+1,XSCANI        INITIALIZE SCAN ROUTINE               20850000
         XERR  01,054             FIRST ARG TO ARRAY IS NOT A STRING    20851000
         XERR  13,022             THE FIRST ARGUMENT IN A CALL TO THE   20852000
*                                 ARRAY FUNCTION IS NULL                20853000
         OI    XSCANFLG,XSIGNRO+XSIGNGN     IGNORE RUNOUT, NO GETNAME   20854000
         MVI   ZTBL+C':',LOWBND-ARRAYRO     SET TO STOP ON :            20855000
         MVI   ZTBL+C',',HIBND-ARRAYRO      SET TO STOP ON ,            20856000
*                                                                       20857000
*        COME HERE TO SCAN OUT NEXT ELEMENT IN PROTOTYPE                20858000
*                                                                       20859000
ARRAYSCN BALR  RETURN,A2          SCAN OUT AN ELEMENT                   20860000
         XERR  13,023             AN ARRAY BOUND IN A CALL TO THE ARRAY 20861000
*                                 FUNCTION IS NULL                      20862000
*                                                                       20863000
*        SINCE THE RUNOUT ERROR IS IMPOSSIBLE, WE CAN USE THIS WORD     20864000
*                                                                       20865000
AMAXVAL  DC    X'7FFF'            MAXIMUM VALUE FOR SUB OR DIM          20866000
         NOPR  0                  PAD OUT THE WORD                      20867000
         BAL   RETURN,GETINT      CONVERT THE BOUND TO INTEGER          20868000
         XERR  13,024             AN ARRAY BOUND IN A CALL TO THE ARRAY 20869000
*                                 FUNCTION IS NON-NUMERIC               20870000
         B     ARRAYRO(A2+1)      TAKE ACTION PROPER FOR LOW OR HIBND   20871000
*                                                                       20872000
*        COME HERE ON RUNOUT RETURN                                     20873000
*                                                                       20874000
ARRAYRO  NOPR  0                  DO NOTHING, MERGE WITH HIBND          20875000
         EJECT                                                          20876000
*                                                                       20877000
*        COME HERE WHEN AN UPPER BOUND SCANNED OUT                      20878000
*                                                                       20879000
HIBND    ST    DB3,SUBFAC(,DB2)   SAVE THE SUBFACTOR                    20880000
         SH    A1+1,SUBLBD(,DB2)  - LOWER BOUND = DIMENSION-1           20881000
         BM    ADIMERR            ERROR IF LE ZERO ELEMENTS             20882000
         CH    A1+1,AMAXVAL       CHECK FOR HALFWORD DIMENSION          20883000
         BNL   ADIMERR            ERRONEOUS DIMENSION IF NOT HALFWORD   20884000
         LA    A1+1,1(,A1+1)      ADD ONE TO GET DIMENSION              20885000
         STH   A1+1,SUBDIM(,DB2)  SAVE DIMENSION IN BLOCK               20886000
         MH    DB3,SUBDIM(,DB2)   CALC NEXT FACTOR IGNORE OVERFLOW      20887000
         LA    DB2,8(,DB2)        POINT TO NEXT SUBSCRIPT INFO          20888000
         STE   ZR,SUBLBD(,DB2)    INITIALIZE LOWBND/DIM FIELD           20889000
         MVI   SUBLBD+1(DB2),1    DEFAULT LOW BOUND IS ONE              20890000
         LTR   A2+1,A2+1          ARE WE AT END OF STRING?              20891000
         BNZ   ARRAYSCN           SCAN NEXT ELEMENT IF NOT AT END       20892000
*                                                                       20893000
*        COME HERE WHEN ENTIRE PROTOTYPE PROCESSED                      20894000
*                                                                       20895000
         MVI   ZTBL+C':',0        CLEAR ZEROS TABLE                     20896000
         MVI   ZTBL+C',',0        CLEAR ZEROS TABLE                     20897000
         LA    R2,AVALS-8(DB3,DB2)          FIND NEW FREE CORE ADDRESS  20898000
         CR    R2,PDR             WILL WE NEED A COLLECT?               20899000
         BNL   GBGCLF             COLLECT AND RE-ENTER IF SO            20900000
         SR    R2,FR              GET BLOCK LENGTH                      20901000
         ST    R2,NBYTESA(,FR)    STORE IN BLOCK                        20902000
         LR    R0,DB2             COPY END OF SUBSCRIPTS ADDR           20903000
         SR    R0,FR              GET ROOM USED FOR SUBSCRIPTS          20904000
         SRL   R0,3               CALCULATE NUMBER OF SUBSCRIPTS        20905000
         STC   R0,NSUBS(,FR)      AND SAVE IN BLOCK                     20906000
         LA    R0,16              GET ROOM NEEDED BY TWO ELEMENTS       20907000
         LA    R1,AVALS-16(DB3,DB2)         GET END ADDR FOR BXLE       20908000
         LM    A1,A1+1,TEM#2(PDR) LOAD INITIALIZE VALUE                 20909000
         LM    A2,A2+1,TEM#2(PDR) LOAD INITIALIZE VALUE                 20910000
         STM   A1,A2+1,AVALS-8(DB2)         STORE TWO ELEMENTS          20911000
         BXLE  DB2,R0,*-4         LOOP UNTIL ALL ELEMENTS FILLED        20912000
         LR    A1,FR              COPY ARRAY ADDRESS                    20913000
         AL    A1,ACODEBT         ADD IN TYPE CODE                      20914000
         AR    FR,R2              PUSH FR PAST BLOCK                    20915000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           20916000
         B     EXIT               RETURN TO CALLER                      20917000
         EJECT                                                          20918000
*                                                                       20919000
*        COME HERE TO PROCESS A LOWER BOUND                             20920000
*                                                                       20921000
LOWBND   CLI   SUBDIM(DB2),0      TEST FOR TWO LOW BOUNDS               20922000
         BE    *+8                SKIP IF THIS IS ONLY FOR SUBSCRIPT    20923000
         XERR  13,025             A SUBSCRIPT BOUND HAS TWO COLONS      20924000
*                                 IN A CALL TO THE ARRAY FUNCTION       20925000
         STH   A1+1,SUBLBD(,DB2)  SAVE NEW LOW BOUNDS                   20926000
         MVI   SUBDIM(DB2),1      SET FLAG FOR LOW BOUND FOUND          20927000
*                                                                       20928000
*        COME HERE TO MAKE SURE THE BOUND VALUE IS REASONABLE           20929000
*                                                                       20930000
         LPR   R0,A1+1            GET MAGNITUDE OF LOW BOUND            20931000
         CH    R0,AMAXVAL         CHECK AGAINST MAXIMUM ABS VALUE       20932000
         BNH   ARRAYSCN           SCAN OUT NEXT ELEMENT IF IN RANGE     20933000
         XERR  13,026             AN ARRAY LOWER BOUND IS NOT IN THE    20934000
*                                 RANGE -32767 TO 32767 IN A CALL TO    20935000
*                                 THE ARRAY FUNCTION                    20936000
*                                                                       20937000
*        COME HERE IF THE ARRAY PROTOTYPE IS AN INTEGER                 20938000
*                                                                       20939000
ARRAYI   LM    A1,A1+1,TEM#1(PDR) LOAD INTEGER RESULT                   20940000
         SR    A2+1,A2+1          INDICATE END OF PROTOTYPE             20941000
         B     HIBND              AND PROCESS AS A HIGH BOUND           20942000
*                                                                       20943000
*        COME HERE WHEN THE DIMENSION IS IN ERROR                       20944000
*                                                                       20945000
ADIMERR  XERR  13,027             THE DIMENSION FOR AN ARRAY BOUND      20946000
*                                 IS NOT IN THE RANGE 1 TO 32767        20947000
ARRAY    ENDFUNC                  END OF ARRAY FUNCTION                 20948000
         TITLE 'SPITBOLF -- CLEAR FUNCTION'                             20949000
CLEAR    FUNCTION  2              ENTRY POINT -- TWO ARGUMENTS REQUIRED 20950000
         BAL   A2+1,XSCANI        INITIALIZE EXECUTION SCAN ROUTINE     20951000
         XERR  01,055             FIRST ARGUMENT TO CLEAR NOT A STRING  20952000
         B     CLEARS             SKIP MARKING PHASE IN NULL FIRST ARG  20953000
         OI    XSCANFLG,XSIGNRO   SET TO IGNORE RUNOUT                  20954000
         MVI   ZTBL+C',',1        SET TO STOP ON COMMAS                 20955000
         OI    STAGE,$CLEARFG     TELL VARLOC NOT TO ADD 4K BLOCK       20956000
*                                                                       20957000
*        LOOP TO FIND AND MARK NOCLEAR BLOCKS IN FIRST ARGUMENT         20958000
*                                                                       20959000
CLEARSCN BALR  RETURN,A2          SCAN OUT A NAME                       20960000
         NI    STAGE,X'FF'-$CLEARFG         ON ULL, 1ST KILL SPCL FLAG! 20961000
         XERR  13,028             NAME IN FIRST ARGUMENT TO THE CLEAR   20962000
*                                 FUNCTION IS NULL                      20963000
         LTR   A1,A1              CHECK FOR NOTHING AS RESULT OF HASH   20964000
*                                 WHICH WOULD OCCUR IF VARLOC WAS       20965000
*                                 ASKED TO CREATE A NEW 4K DATAAREA BLK 20966000
         BZ    *+8                SKIP IF NO BLCOK ADDRESS RETURNED     20967000
         OI    VCLEAR(A1),CLEARSW INDICATE THIS VAR VALUE TO BE SAVED   20968000
         LTR   A2+1,A2+1          TEST END OF ARGUMENTS                 20969000
         BNZ   CLEARSCN           LOOP BACK IF NOT AT END OF STRING     20970000
         MVI   ZTBL+C',',0        CLEAR ZTBL FOR LATER REUSE            20971000
         NI    STAGE,X'FF'-$CLEARFG         TURN OFF SPECIAL VARLOC FLG 20972000
*                                                                       20973000
*        COME HERE TO GO DOWN HASH CHAINS CLEARING VARIABLE BLOCKS      20974000
*                                                                       20975000
CLEARS   SR    R2,R2              SET SWITCH VALUE FORPATTERN CLEAR     20976000
         CLI   TEM#2(PDR),NCODE   IS SECOND CLEAR ARG NULL?             20977000
         BE    *+8                DON'T SAVE PATTERNS IF NULL           20978000
         LA    R2,4               ELSE SET TO NOT NULL PATTERNS         20979000
         LA    A1,4               GET BXLE INCREMENT                    20980000
         L     A2,HASHTBAD        LOAD START OF HASH TABLE ADDRESS      20981000
         LA    A1+1,HASHTBNS*4(,A2)         LOAD END OF HASH TB ADDRESS 20982000
         L     R0,=X'00FFFFFF'    LOAD MASK TO TEST FOR LINK END        20983000
         B     CLEARE             MAKE INITIAL LOOP ENTRY               20984000
         EJECT                                                          20985000
*                                                                       20986000
*        LOOP TO CLEAR VARIABLE BLOCKS AS FOUND IF NTO MARKED           20987000
*                                                                       20988000
CLEARL   TM    VCLEAR(R1),CLEARSW ARE WE TO SAVE THIS BLOCKS VALUE?     20989000
         BO    CLEARSV            SKIP IF SO                            20990000
         CLI   VALUE(R1),PCODE    IS THIS VALUE A PATTERN?              20991000
         BE    *+4(R2)            IF PAT, TAKE ACTION SPEC BY 2ND CLEAR 20992000
*                                 ARGUMENT (R2 SET UP AT CLEARS)        20993000
         MVI   VALUE(R1),NCODE    SET VARIABLE BLOCK VALUE TO NULL      20994000
*                                                                       20995000
*        COME HERE WHEN BLOCK MARKED NOT TO BE CLEARED                  20996000
*                                                                       20997000
CLEARSV  NI    VCLEAR(R1),X'FF'-CLEARSW     TURN OFF CLEAR SWITCH       20998000
*                                                                       20999000
*        COME HERE TO MOVE OUT ON LINK OR GET HASH SLOT VALUE           21000000
*                                                                       21001000
CLEART   L     R1,VLINK(,R1)      MOVE OUT ON LINK                      21002000
         NR    R1,R0              MAKE CHECK FOR 0 LINK ADDRESS         21003000
         BNZ   CLEARL             LOOP TO CLEAR BLOCK IF NOT LINK END   21004000
*                                                                       21005000
*        COME HERE TO MOVE TO NEXT HASH SLOT                            21006000
*                                                                       21007000
CLEARE   LR    R1,A2              COPY SLOT ADDRESS-VLINK               21008000
         BXLE  A2,A1,CLEART       LOOP BACK AFTER CHECK FOR DONE        21009000
         B     EXITNULL           RETURN NULL AS RESULT                 21010000
CLEARSW  EQU   X'01'              USE RIGHTMOST BIT AS FLAG             21011000
VCLEAR   EQU   VFUNC+3            USE VFUNC FIELD (COLLECT IMPOSSIBLE   21012000
*                                 BECAUSE OF CLEARFG FUGE TO VARLOC)    21013000
CLEAR    ENDFUNC   ,              END OF CLEAR FUNCTION                 21014000
         TITLE 'SPITBOLF -- CODE FUNCTION'                              21015000
CODE     FUNCTION  1              ONE ARGUMENT REQUIRED                 21016000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         21017000
         CLI   TEM#1(PDR),CCODE   IS ARGUMENT ALREADY CODE?             21018000
         BE    EXIT               RETURN ARG AS RESULT IF SO            21019000
         BAL   RETURN,GETSTG      CONVERT ARGUMENT TO STRING            21020000
         B     FAILRL             FAIL IF NOT A STRING                  21021000
         L     R1,CODXEQAD        ELSE LOAD ADDR OF COMPILER ROUTINE    21022000
         MVI   CODXSW,CCODE       SET TYPE CODE                         21023000
         BALR  RETURN,R1          CALL COMPILER                         21024000
         B     FAILRL             SIGNAL FAILURE IF SYNTAX ERROR        21025000
         B     EXIT               RETURN TO CALLER                      21026000
CODE     ENDFUNC   ,              END OF CODE FUNCTION                  21027000
         TITLE 'SPITBOLF -- COLLECT FUNCTION'                           21028000
*                                                                       21029000
*        THE COLLECT FUNCTION EXPECTS 0 OR 1 ARGUMENTS ON THE STACK     21030000
*        IF AN ARGUMENT IS PRESENT, IT SPECIFIES THE NUMBER OF BYTES    21031000
*        NEEDED AFTER A COLLECT FOR THIS FUNCTION TO SUCCEED            21032000
*                                                                       21033000
COLLECT  FUNCTION  1              ENTRY POINT -- ONE ARG REQUIRED       21034000
         MVI   GCOLNRG,GGBGCLF+GCMPRSS      SET FOR SUPER COMPRESS GCOL 21035000
         TS    CLLCTFL            TEST COLLECT FLAG AND SET IT          21036000
         BZ    GCOLC              COLLECT IF NOT DONE ALREADY           21037000
*                                                                       21038000
*        WE COME HERE ON THE SECOND ENTRY (AFTER COLLECTION)            21039000
*                                                                       21040000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         21041000
         BAL   RETURN,GETINT      GET AN INTEGER VALUE                  21042000
         XERR  01,057             ARGUMENT TO COLLECT IS NOT AN INTEGER 21043000
         LR    A2,A1+1            GET ARGUMENT LENGTH                   21044000
         LR    A1+1,PDR           INTEGER RESULT = PDR                  21045000
         SR    A1+1,FR                 MINUS FR = STORAGE FREE          21046000
         MVI   CLLCTFL,0          RESET COLLECT FLAG                    21047000
         CR    A1+1,A2            CHECK RESULT AGAINST ARGUMENT         21048000
         BNL   EXIT               EXIT IF OK                            21049000
         B     FAILRL             ELSE FAIL                             21050000
COLLECT  ENDFUNC   ,              END OF COLLECT FUNCTION               21051000
         TITLE 'SPITBOLF -- CONVERT FUNCTION'                           21052000
CONVERT  FUNCTION  2              ENTRY POINT -- 2 ARGS REQUIRED        21053000
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT        21054000
         BAL   RETURN,GETSTGS     GET STRING SPECIFIER FOR SECOND ARG   21055000
         XERR  01,058             CONVERT SECOND ARGUMENT NOT A STRING  21056000
         LR    A2,A1              MOVE TO SECOND ACCUMULATOR            21057000
         LR    A2+1,A1+1          ...                                   21058000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         21059000
         LA    R0,CVTSTD          SET TO TRY STANDARD TYPES             21060000
         LA    R1,CVTABL          POINT TO FIRST ENTRY                  21061000
         LR    R2,PDR             SAVE ENTRY STACK POINTER              21062000
         L     PDR,PDRLOC         AND THEN RESET STACK POINTER          21063000
*                                                                       21064000
*        THIS LOOP DEALS WITH THE CASES IN WHICH CONVERSION IS          21065000
*        ACTUALLY POSSIBLE (STRING,NUMERIC,PATTERN,ARRAY,TABLE)         21066000
*                                                                       21067000
CNVRTL   CH    A2+1,0(,R1)        CHECK LENGTHS                         21068000
         BNE   CNVTRE             SKIP TO END OF LOOP IF UNEQUAL        21069000
         EX    0,2(,R1)           EXECUTE CHARACTER COMPARISON          21070000
         BNE   CNVTRE             SKIP TO END OF LOOP IF NOT EQUAL      21071000
         EX    0,8(,R1)           EXECUTE CALL TO CONVERT ROUTINE       21072000
         B     FAILRL             FAIL IF UNCONVERTIBLE                 21073000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               21074000
         CR    FR,PDR             DO WE NEED A COLLECT?                 21075000
         BCR   L,RETURN           RETURN IF NO COLLECT NEEDED           21076000
         B     GBGCL1             ELSE COLLECT AND RETURN SAVING A1     21077000
*                                                                       21078000
*        COME HERE AT END OF LOOP                                       21079000
*                                                                       21080000
CNVTRE   LA    R1,12(,R1)         POINT TO NEXT ENTRY                   21081000
         BCT   R0,CNVRTL          SKIP BACK IF MORE TO GO               21082000
*                                                                       21083000
*        COME HERE FOR ALL OTHER CASES -- CONVERT ONLY SUCCEEDS IF      21084000
*        THE DATATYPES MATCH (I.E. NULL CONVERSION)                     21085000
*                                                                       21086000
         BAL   RETURN,$$DTTP      GET DATATYPE OF FIRST ARGUMENT        21087000
         LM    A2,A2+1,TEM#2(R2)  LOAD SECOND ARGUMENT                  21088000
         BAL   RETURN,$$IDNT      COMPARE ARGUMENTS                     21089000
         LM    A1,A1+1,TEM#1(R2)  RELOAD FIRST ARG AS RESULT            21090000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               21091000
         BCR   E,RETURN           ALL OK IF DATATYPES MATCH             21092000
         BR    FRETURN            ELSE FAIL                             21093000
         EJECT                                                          21094000
*                                                                       21095000
*        TABLE FOR CONVERTABLE TYPES                                    21096000
*                                                                       21097000
CVTABL   DC    Y(4-1)             360 LENGTH OF 'REAL'                  21098000
         CLC   SCHARS(4,A2),=C'REAL'        CHECK CHARS FOR 'REAL'      21099000
         BAL   RETURN,GETREAL     CALL TO CONVERT TO REAL               21100000
*                                                                       21101000
         DC    Y(7-1)             360 LENGTH OF 'INTEGER'               21102000
         CLC   SCHARS(7,A2),=C'INTEGER'     CHECK CHARS FOR 'INTEGER'   21103000
         BAL   RETURN,GETINT      CALL TO CONVERT TO INTEGER            21104000
*                                                                       21105000
         DC    Y(6-1)             360 LENGTH OF 'STRING'                21106000
         CLC   SCHARS(6,A2),=C'STRING'      CHECK CHARS FOR 'STRING'    21107000
         BAL   RETURN,CVTSTG      CALL CONVERT TO STRING ROUTINE        21108000
*                                                                       21109000
         DC    Y(7-1)             360 LENGTH OF 'PATTERN'               21110000
         CLC   SCHARS(7,A2),=C'PATTERN'     CHECK CHARS FOR 'PATTERN'   21111000
         BAL   RETURN,GETPAT      CALL TO CONVERT TO PATTERN            21112000
*                                                                       21113000
         DC    Y(5-1)             360 LENGTH OF 'DREAL'                 21114000
         CLC   SCHARS(5,A2),=C'DREAL'       CHECK CHARS FOR 'DREAL'     21115000
         BAL   RETURN,GETDREAL    CALL TO CONVERT TO DREAL              21116000
*                                                                       21117000
         DC    Y(7-1)             360 LENGTH OF 'NUMERIC'               21118000
         CLC   SCHARS(7,A2),=C'NUMERIC'     CHECK CHARS FOR 'NUMERIC'   21119000
         BAL   RETURN,GETNUM      CALL TO CONVERT TO NUMERIC            21120000
*                                                                       21121000
         DC    Y(5-1)             360 LENGTH OF 'ARRAY'                 21122000
         CLC   SCHARS(5,A2),=C'ARRAY'       CHECK CHARS FOR 'ARRAY'     21123000
         BAL   RETURN,CVTARR      CALL TO CONVERT TO ARRAY              21124000
*                                                                       21125000
         DC    Y(5-1)             360 LENGTH OF 'TABLE'                 21126000
         CLC   SCHARS(5,A2),=C'TABLE'       CHECK CHARS FOR 'TABLE'     21127000
         BAL   RETURN,CVTTAB      CALL TO CONVERT TO TABLE              21128000
*                                                                       21129000
         DC    Y(4-1)             360 LENGTH OF 'NAME'                  21130000
         CLC   SCHARS(4,A2),=C'NAME'        CHECK CHARS FOR 'NAME'      21131000
         BAL   RETURN,CVTNAME     OFF TO GETNAME CODE                   21132000
*                                                                       21133000
         DC    Y(4-1)             360 LENGTH OF 'CODE'                  21134000
         CLC   SCHARS(4,A2),=C'CODE'        CHECK CHARS FOR 'CODE'      21135000
         BAL   RETURN,CVTCODE     OFF TO CODE TO CONVERT TO CODE        21136000
*                                                                       21137000
         DC    Y(10-1)            360 LENGTH OF 'EXPRESSION'            21138000
         CLC   SCHARS(10,A2),=C'EXPRESSION'                             21139000
         BAL   RETURN,CVTEXPR     OFF TO SPECIAL EXPR CONVERT ROUTINE   21140000
*                                                                       21141000
CVTSTD   EQU   (*-CVTABL)/12      NUMBER OF ITEMS IN CVT LIST           21142000
         EJECT                                                          21143000
*                                                                       21144000
*        SPECIAL ROUTINE FOR CONVERT TO STRING                          21145000
*                                                                       21146000
CVTSTG   BAL   RETURN,GETSTG      CONVERT TO STRING                     21147000
         BAL   RETURN,$$DTTP      GET DATATYPE IF NOT CONVERTIBLE       21148000
         L     RETURN,RETLOC      RESTORE RETURN POINT                  21149000
         CR    FR,PDR             CHECK FOR GCOL REQUIRED               21150000
         BCR   L,RETURN           RETURN IF NOT                         21151000
         B     GBGCL1             ELSE RETURN VIA GARBAGE COLLECTOR     21152000
*                                                                       21153000
*        SPECIAL ROUTINE FOR CONVERT TO NAME                            21154000
*                                                                       21155000
CVTNAME  CLI   TEM#1(R2),MCODE    ALREADY A NAME?                       21156000
         BNE   GETNAME            USE STANDARD VBLK GETNAME IF NOT      21157000
         B     4(,RETURN)         ELSE SIGNAL OK CONVERT IF ALREADY NM  21158000
*                                                                       21159000
*        SPECIAL ROUTINE FOR CONVERT TO CODE                            21160000
*                                                                       21161000
CVTCODE  MVI   CODXSW,CCODE       SET TYPE CODE                         21162000
         B     CVTEXPRM           MERGE WITH EXPRESSION CASE            21163000
*                                                                       21164000
*        SPECIAL ROUTINE FOR CONVERT TO EXPRESSION                      21165000
*                                                                       21166000
CVTEXPR  MVI   CODXSW,ECODE       SET TYPE CODE                         21167000
*                                                                       21168000
*        CONVERT TO CODE MERGES HERE                                    21169000
*                                                                       21170000
CVTEXPRM CLC   TEM#1(1,R2),CODXSW IS CONVERSION REQUIRED?               21171000
         L     RETURN,RETLOC      RELOAD RETURN IN CASE                 21172000
         BCR   E,RETURN           RETURN IF ALREADY CONVERTED           21173000
         BAL   RETURN,GETSTG      ELSE CONVERT TO STRING                21174000
         B     FAILRL             FAIL, LOAD RETURN IF CAN'T CONVERT    21175000
         L     R1,CODXEQAD        LOAD ADDRESS OF COMPILER              21176000
         BALR  RETURN,R1          CALL COMPILER                         21177000
         B     FAILRL             FAIL IF CANNOT COMPILE                21178000
         L     RETURN,RETLOC      ELSE LOAD RETURN POINT                21179000
         BR    RETURN             AND RETURN TO CALLER                  21180000
         EJECT                                                          21181000
*                                                                       21182000
*        COME HERE TO CONVERT ARGUMENT TO AN ARRAY                      21183000
*        THIS FAILS UNLESS THE ARGUMENT IS AN ARRAY OR TABLE            21184000
*                                                                       21185000
CVTARR   CLI   TEM#1(R2),ACODE    IS IT ALREADY AN ARRAY?               21186000
         BE    4(,RETURN)         SUCCEED IF SO                         21187000
         CLI   TEM#1(R2),TCODE    ELSE IS IT A TABLE?                   21188000
         BCR   NE,RETURN          FAIL IF NOT                           21189000
         BAL   RETURN,TBCHRON     COUNT AND CHRONOLOGICALLY ORDER ELEMS 21190000
         B     FAILRL             FAIL WITH RELOAD IF NO NON-NULL ELEMS 21191000
         LR    A2,A1+1            COPY ELEMENT COUNT                    21192000
         LR    R1,A1+1            COPY COUNT FOR COLLECT CHECK          21193000
         SLL   R1,4               *(8*2) IS ROOM FOR ARRAY ELEMENTS     21194000
         LA    R1,AVALS+8+SCHARS+10+BOUND(FR,R1)      GET NEW FREE CORE 21195000
         CR    R1,PDR             WILL WE OVERFLOW AFTER STRING&ARRAY?  21196000
         BCR   NL,RETURN          OFF TO TBCHRON TO FIX UP AND GBGCLF   21197000
         SR    A1,A1              INDICATE INTEGER                      21198000
         BAL   RETURN,GETSTGS     CONVERT DIM1 TO STRING FOR ASPEC      21199000
         NOP   0                  ERROR NOT POSSIBLE                    21200000
         MVC   SCHARS(7,FR),SCHARS(A1)      COPY STRING TO FREE CORE    21201000
         LR    A1,FR              COPY POINTER TO NEW SBLOK             21202000
         STE   ZR,0(,FR)          SET DTYPE = SBLOK = 0, GCOLPTR = 0    21203000
         LA    R1,1(A1,A1+1)      POINT PAST STRING                     21204000
         MVC   SCHARS(2,R1),=C',2'          COMPLETE SPECIFIER          21205000
         LA    R1,SCHARS+3+BOUND(,A1+1)     GET LENGTH OF SBLOK + FUDGE 21206000
         N     R1,FULLWRD         PUT ON BOUNDARY                       21207000
         STH   R1,STLENGTH(,FR)   STORE LENGTH IN SBLOK                 21208000
         AR    FR,R1              PUSH FR PAST SBLOK                    21209000
         LA    A1+1,2(,A1+1)      GET NEW LENGTH                        21210000
         STM   A1,A1+1,ASPEC(FR)  STORE SPECIFIER                       21211000
         MVI   ASPEC(FR),SCODE    MAKE IT A STRING                      21212000
         EJECT                                                          21213000
*                                                                       21214000
*        HERE WE COMPLETE THE CONSTRUCTION OF THE ARRAY DV              21215000
*                                                                       21216000
         STE   ZR,0(,FR)          CLEAR GBGCOL FIELD                    21217000
         MVI   0(FR),ABLOK        MAKE THIS AN ARRAY                    21218000
         LR    R1,A2              COPY ELEMENT COUNT TO GET ARRAY SIZE  21219000
         SLL   R1,4               *(8*2) IS ROOM NEEDED IN ARRAY        21220000
         LA    R1,AVALS+8(,R1)    GET ARRAY LENGTH                      21221000
         ST    R1,NBYTESA(,FR)    SAVE IN PROPER FIELD                  21222000
         MVI   NSUBS(FR),2        SET NUMBER OF SUBSCRIPTS              21223000
         LA    A1,8               FIRST SUBFACTOR=8                     21224000
         LR    A1+1,A2            COPY NUM OF ELEMENTS = SUBDIM 1       21225000
         SLL   A2,3               ELEMENTS*8 IS 2ND SUBFACTOR           21226000
         LA    A2+1,2             SECOND DIMENSION IS TWO               21227000
         STM   A1,A2+1,SUBFAC(FR) NON-SYMBOLIC SETUP OF ARRAY INFO      21228000
         MVI   SUBLBD+1(FR),1     SET LOW BOUND OF SUB 1 TO 1           21229000
         MVI   SUBLBD+1+8(FR),1   SET LOW BOUND OF SUBSC 2 TO 1         21230000
         LA    A2+1,AVALS+8(,FR)  POINT TO FIRST ARRAY ELEMENT VALUE    21231000
         L     R2,TEBLOKBT        LOAD GBGFLD OF A TEBLOK FOR CLEAR     21232000
         L     A1+1,TBCHRSV       LOAD HEAD OF CHRONOLOGICAL LIST       21233000
*                                                                       21234000
*        LOOP TO MOVE DOWN LINK COPYING ELEMENTS INTO ARRAY, CLEARING   21235000
*                                 TEBLOKS AS THEY ARE USED              21236000
*                                                                       21237000
CVTARR1  L     A1,0(,A1+1)        MOVE OUT ON CHAIN                     21238000
         ST    R2,0(,A1+1)        RESET GBG FIELD                       21239000
         LM    R0,R1,TENAME(A1+1) LOAD NAME FIELD                       21240000
         STM   R0,R1,0(A2+1)      SAVE IN FIRST ARRAY FIELD             21241000
         LM    R0,R1,TEVALUE(A1+1)          LOAD ELEMENT VALUE          21242000
         ST    R0,0(A2,A2+1)      STORE 1ST WORD OF 2ND ARRAY FIELD     21243000
         ST    R1,4(A2,A2+1)      STORE 2ND WORD OF 2ND ARRAY FIELD     21244000
         LA    A2+1,8(,A2+1)      PUSH ARRAY SUBSCRIPT                  21245000
         LTR   A1+1,A1            COPY AND TEST FOR END OF LINK         21246000
         BNZ   CVTARR1            LOOP BACK IF NOT END OF CHAIN         21247000
         LR    A1,FR              COPY ARRAY ADDRESS                    21248000
         LA    FR,0(A2,A2+1)      POSITION FR CORRECTLY                 21249000
         AL    A1,ACODEBT         MAKE AN ARRAY TYPE                    21250000
         L     RETURN,RETLOC      RESTORE RETURN ADDRESS                21251000
         BR    RETURN             RETURN TO CALLER                      21252000
         EJECT                                                          21253000
*                                                                       21254000
*        COME HERE TO CONVERT A TABLE OR ARRAY TO TABLE                 21255000
*                                                                       21256000
CVTTAB   CLI   TEM#1(R2),TCODE    ALREADY A TABLE?                      21257000
         BE    4(,RETURN)         SUCCEED IF SO                         21258000
         CLI   TEM#1(R2),ACODE    ELSE IS IT AN ARRAY?                  21259000
         BCR   NE,RETURN          FAIL IF NOT                           21260000
         CLI   NSUBS(A1),2        IS IT RECTANGULAR?                    21261000
         BNE   FAILRL             FAIL IF NOT                           21262000
         LH    R1,SUBDIM(,A1)     GET NUMBER OF NAMES IN ARRAY          21263000
         MH    R1,=Y(TESIZE)      * SIZE REQUIRED PER NAME              21264000
         LA    R1,TBLPTRS+40(R1,FR)         + TBL SIZE + FREE CORE PTR  21265000
         CR    R1,PDR             WILL WE OVERFLOW?                     21266000
         BNL   GBGCLF             IF SO, COLLECT AND RE-ENTER           21267000
         ST    FR,CVTSAVE         SAVE ADDRESS OF TABLE                 21268000
         MVI   CVTSAVE,TCODE      AND MAKE IT LOOK LIKE A TABLE         21269000
         STE   ZR,0(,FR)          CLEAR START OF HASH TABLE             21270000
         MVI   0(FR),TBBLOK       MAKE IT A TABLE                       21271000
         LA    R0,4*10            GET TABLE SIZE (10 SLOTS)             21272000
         ST    R0,TBDIVIDE(,FR)   STORE AS NUMBE OF SLOTS*4            21273000
         LA    R0,4*10+TBLPTRS    GET TABLE LENGTH                      21274000
         ST    R0,TBLENGTH(,FR)   STORE IN CORRECT LOCATION             21275000
         XC    TBLPTRS(40,FR),TBLPTRS(FR)   CLEAR HASH TABLE            21276000
         AR    FR,R0              CORRECTLY POSITION FR PAST TABL)      21277000
         LA    DB3,AVALS+8(,A1)   POINT TO FIRST VALUE LOCATION         21278000
         L     DB2,SUBFAC+8(,A1)  GET DIFFERENCE BETWEEN NAME & VALUE   21279000
         AR    DB2,DB3            POINT TO FIRST VALUE FIELD            21280000
         ST    DB2,CVTEND         SAVE POINTER PAST LAS NAME FIELD      21281000
         L     R2,SUBSC1AD        GET BASE REGISTER FOR ROUTINE         21282000
*                                                                       21283000
*        LOOP TO PICK UP ARRAY VALUES AND CALL TABLE ROUTINE            21284000
*                                                                       21285000
CVTTAB1  CLI   0(DB2),NCODE       IS NEXT ELEMENT VALUE NULL?           21286000
         BE    CVTTAB2            SKIP CALL IF SO                       21287000
         LM    A1,A1+1,0(DB3)     GET NAME OF ELEMENT                   21288000
         L     A2,CVTSAVE         GET ADDRESS OF TABLE                  21289000
         MVI   NAMEFL,0           SET CALL BY NAME                      21290000
         USING SUBSC1,R2          TELL ASSEMBLER                        21291000
         BAL   RETURN,TBLOOK      HASH THE TABLE ELEMENT                21292000
         DROP  R2                 DON'T NEED THIS BASE REG ANYMORE      21293000
         LM    R0,R1,0(DB2)       GET VALUE                             21294000
         STM   R0,R1,TEVALUE(A1)  STORE IT IN VALUE FIELD               21295000
         EJECT                                                          21296000
*                                                                       21297000
*        COME HERE TO PUSH TO NEXT ELEMENT IN ARRAY                     21298000
*                                                                       21299000
CVTTAB2  LA    DB3,8(,DB3)        INCREMENT OFFSET                      21300000
         LA    DB2,8(,DB2)        PUSH POINTER TO VALUES                21301000
         C     DB3,CVTEND         HAVE WE FINISHED?                     21302000
         BL    CVTTAB1            LOOP IF NOT                           21303000
         L     A1,CVTSAVE         GET TABLE POINTER                     21304000
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3                       21305000
         L     RETURN,RETLOC      RESTORE RETURN ADDRESS                21306000
         BR    RETURN             BACK TO CALLER                        21307000
CONVERT  ENDFUNC                  END OF CONVERT FUNCTION               21308000
         TITLE 'SPITBOLF -- COPY FUNCTION'                              21309000
COPY     FUNCTION  1              ENTRY POINT -- ONE ARGUMENT           21310000
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT               21311000
         TM    TEM#1(PDR),RELOCBIT          IS ARGUMENT RELOCATABLE     21312000
         BNO   EXIT               RETURN ARG AS COPY IF NOT             21313000
         CLI   TEM#1(PDR),MCODE   IS IT A NAME?                         21314000
         BE    EXIT               IF SO, RETURN ARG AS COPY             21315000
         CLI   TEM#1(PDR),ECODE   IS IT AN EXPRESSION?                  21316000
         BE    EXIT               IF SO, RETURN ARGUMENT AS COPY        21317000
*                                                                       21318000
*        AT THIS POINT WE HAVE FOUND SOMETHING WHICH REALLY NEEDS       21319000
*        TO BE COPIED -- SO FIND ITS LENGTH                             21320000
*                                                                       21321000
         LR    A2+1,A1            COPY POINTER                          21322000
         LA    A2,0(,A1)          COPY ALL BUT TYPE CODE                21323000
         SR    A2+1,A2            SUBTRACT TO ISOLATE TYPE CODE         21324000
         SR    R2,R2              CLEAR FOR IC                          21325000
         IC    R2,DTYPE(,A1)      LOAD CODE FOR BLOCK TYPE              21326000
         EX    0,BLOKLEN(R2)      GET LENGTH OF BLOCK                   21327000
         LR    R0,R2              COPY LENGTH TO (R0)                   21328000
*                                                                       21329000
*        THE LENGTH IS NOW IN (R0) -- SO PERFORM COPY                   21330000
*                                                                       21331000
         LR    R1,R0              SAVE LENGTH                           21332000
         AR    R0,FR              SEE WHERE FR WILL END UP              21333000
         CR    R0,PDR             WILL WE HAVE ROOM?                    21334000
         BH    GBGCLF             GARBAGE COLLECT IF NOT                21335000
         LA    R2,256             GET CRANK CONSTANT FOR LOOP           21336000
         LR    A2,FR              COPY START OF BLOCK                   21337000
         CR    R1,R2              IS BLOCK SHORT OR LONG                21338000
         BL    COPY2              SKIP IF 256 CHARS OR LESS             21339000
*                                                                       21340000
*        LOOP TO MOVE 256 CHARACTERS AT A TIME                          21341000
*                                                                       21342000
COPY1    MVC   0(256,A2),0(A1)    MOVE 256 CHARACTERS                   21343000
         AR    A1,R2              BUMP SOURCE POINTER                   21344000
         AR    A2,R2              BUMP DESTINATION POINTER              21345000
         SR    R1,R2              DECREMENT COUNT LEFT                  21346000
         CR    R1,R2              MORE THAN 256 CHARS LEFT?             21347000
         BNL   COPY1              LOOP BACK IF SO                       21348000
*                                                                       21349000
*        COME HERE TO MOVE LAST CHUNK OF 256 CHARS OR LESS              21350000
*                                                                       21351000
COPY2    EX    R1,COPYM           MOVE REMAINING CHARS (+1 GARBAGE CHR) 21352000
         CLI   DTYPE(FR),TBBLOK   WAS THIS A TABLE?                     21353000
         BE    COPYT              SKIP ON SPECIAL CASE OF A TABLE       21354000
         LR    A1,FR              ELSE GET LOCATION OF NEW BLOCK        21355000
         ALR   A1,A2+1            SUPPLY TYPE BYTE                      21356000
         LR    FR,R0              SET NEW FR LOCATION                   21357000
         B     EXIT               RETURN                                21358000
*                                                                       21359000
COPYM    MVC   0(*-*,A2),0(A1)    MOVE LAST CHUNK IN MAIN COPY          21360000
         EJECT                                                          21361000
*                                                                       21362000
*        IN THE SPECIAL CASE OF A TABLE -- WE MUST COPY ALL TEBLOKS     21363000
*                                                                       21364000
COPYT    LR    A2+1,R0            GET FREE CORE PTR PAST NEW TABLE      21365000
         L     A1,TEM#1(,PDR)     GET OLD TABLE ADDRESS FOR TBCHRON     21366000
         BAL   RETURN,TBCHRON     CHRONOLLOGICALLY ORDER NON-NULL ELEMT 21367000
         B     COPYTNUL           SKIP ELEMENT COPY IF NONE TO COPY     21368000
         MH    A1+1,=Y(TESIZE)    CALCULATE ROOM NEEDED FOR TEBLOKS     21369000
         AR    A1+1,A2+1          ADD IN CURRENT FREE CORE ADDR         21370000
         CR    A1+1,PDR           CHECK FOR COLLECT NEEDED              21371000
         BCR   NL,RETURN          OFF TO CLEAN UP CORE IF NEED GBGCLT   21372000
         L     A1+1,TBCHRSV       LOAD POINTER TO CHAIN OF TEBLOKS      21373000
         L     R2,TEBLOKBT        LOAD GBG WRD FOR TEBLOKS TO FIX UP    21374000
*                                                                       21375000
*        LOOP HERE COPYING NON-NULL TEBLOKS TO FREE CORE                21376000
*        AFTER COPYING, OLD COPIES HAVE PTR TO NEW COPIES IN GBG FIELD  21377000
*                                                                       21378000
COPYTL   L     A1,0(,A1+1)        MOVE OUT ON TEBLOK CHAIN              21379000
         ST    A2+1,0(,A1+1)      STORE ADDR OF NEW COPY                21380000
         MVC   4(TESIZE-4,A2+1),4(A1+1)     COPY ALL BUT GBGFLD         21381000
         ST    R2,0(,A2+1)        FIX UP GBG FLD IN NEW BLOCK           21382000
         LA    A2+1,TESIZE(,A2+1) PUSH FREE CORE POINTER PAST BLOK      21383000
         LTR   A1+1,A1            COPY AND TEST LINK TO NEXT BLOK       21384000
         BNZ   COPYTL             LOOP BACK FOR MORE IF NOT CHN END     21385000
*                                                                       21386000
*        COME HERE AFTER ALL TEBLOKS COPIED (OR IF NONE TO COPY)        21387000
*                                                                       21388000
COPYTNUL LA    R0,4               GET BXLE CONSTANT FOR TBL LOOP        21389000
         L     R1,TBDIVIDE(,FR)   LOAD SIZE OF TBL PTRS                 21390000
         ST    FR,TBCHRSV         SAVE ADDRESS OF NEW TABLE             21391000
         MVI   TBCHRSV,TCODE      SET DATATYPE TO TABLE                 21392000
         SH    FR,=Y(TLINK-TBLPTRS)         GIVE PTRS A 'TLINK' OFFSET  21393000
         AR    R1,FR              CALCULATE BXLE END OF LOOP ADDRESS    21394000
         B     COPYTL3            AND MAKE INITIAL LOOP ENTRY           21395000
         EJECT                                                          21396000
*                                                                       21397000
*        COME HERE WITH POINTER TO TEBLOK IN (A1)                       21398000
*        IF VALUE IS NULL, THEN NO COPY MADE AND GBG FLD IS EMPTY       21399000
*        IF IT IS NOT EMPTY, THEN ADDR IS THAT OF NEW TEBLOK AND IS NEW 21400000
*        LINK FIELD FOR HASH CHAIN                                      21401000
*                                                                       21402000
COPYTL1  CLI   TEVALUE(A1),NCODE  WAS THIS ELEMENT COPIED?              21403000
         BE    COPYTL2            SKIP LINK FIXUP IF NOT COPIED         21404000
         L     A2,0(,A1)          LOAD ADDRESS OF NEW BLOCK             21405000
         ST    A2,TLINK(,A1+1)    STORE LINK TO NEW BLOCK               21406000
         LR    A1+1,A2            AND NEW BLOCK NOW NEEDS LINKING       21407000
         ST    R2,0(,A1)          FIX UP GBG FLD IN OLD BLOCK           21408000
*                                                                       21409000
*        COME HERE TO MOVE OUT ON HASH CHAIN                            21410000
*                                                                       21411000
COPYTL2  L     A1,TLINK(,A1)      LOAD BLOCK'S LINK FIELD               21412000
         LTR   A1,A1              TEST FOR END OF CHIN                  21413000
         BNZ   COPYTL1            LOOP BACK IF NOT CHAIN END            21414000
         STE   ZR,TLINK(,A1+1)    SET END OF CHAIN IN NEW TBL CHAIN     21415000
*                                                                       21416000
*        COME HERE TO MOVE TO NEXT HASH TABLE SLOT                      21417000
*                                                                       21418000
COPYTL3  LR    A1,FR              PRETEND SLOT IS A TABLE ELEMENT       21419000
         LR    A1+1,FR            SAVE LINK ADDRESS FOR NEW CHAIN       21420000
         BXLE  FR,R0,COPYTL2      TEST FOR TBL END, LOOP BACK IF NOT    21421000
         LR    FR,A2+1            SET PROPER FREE CORE POINTER          21422000
         L     A1,TBCHRSV         LOAD POINTER TO NEW TABLE             21423000
         B     EXIT               RETURN                                21424000
COPY     ENDFUNC   ,              END OF COPY FUNCTION                  21425000
         TITLE 'SPITBOLF -- DATA FUNCTION'                              21426000
DATA     FUNCTION  1              ENTRY POINT -- ONE ARGUMENT REQUIRED  21427000
         BAL   A2+1,XSCANI        INITIALIZE SCAN, SET SCAN BASE REG    21428000
         XERR  01,059             ARGUMENT TO DATA IS NOT A STRING      21429000
         XERR  13,030             ARGUMENT TO DATA IS NULL              21430000
         STE   ZR,0(,FR)          CLEAR GBG FIELD FOR PDF               21431000
         MVI   0(FR),PDFBLOK      SET PROPER BLOCK CODE                 21432000
         MVC   8(PDMODL+4-8,FR),DATAMODL    MOVE IN STD CODE            21433000
         MVI   ZTBL+C'(',1        SET TO SCAN OUT LEFT PAREN            21434000
         BALR  RETURN,A2          GET FIRST NAME ADDRESS                21435000
         XERR  13,031             DATATYPE NAME IN ARGUMENT TO DATA     21436000
*                                 FUNCTION IS NULL                      21437000
         XERR  13,032             ARGUMENT TO DATA FUNCTION DOES NOT    21438000
*                                 CONTAIN A LEFT PARENTHESIS            21439000
         ST    A1,PDFNPTR(,FR)    SAVE ADDRESS OF FUNCTION NAME         21440000
         MVI   ZTBL+C'(',0        NO LONGER STOP ON (                   21441000
         MVI   ZTBL+C',',DATASCCM-DATASCAN  SET JUMP AMOUNT FOR COMMA   21442000
         MVI   ZTBL+C')',DATASCRP-DATASCAN  SET JUMP AOUNT FOR RT PAREN 21443000
         LR    DB2,FR             COPY ADDRESS FOR STORING FIELD NAMES  21444000
*                                                                       21445000
*        THIS IS THE BASE FOR INDEXED JUMPS AFTER FIELD PROCESSED       21446000
*                                                                       21447000
DATASCAN EQU   *-4                BASE FOR JUMPS (MUST BE LT DATASCNM)  21448000
*                                                                       21449000
*        COME HERE TO PROCESS ANOTHER FIELD ENTRY                       21450000
*                                                                       21451000
DATASCCM BALR  RETURN,A2          CALL THE SCAN ROUTINE                 21452000
         XERR  13,033             FIELD NAME IN ARGUMENT TO DATA        21453000
*                                 FUNCTION IS NULL                      21454000
*                                                                       21455000
*        BRANCH TO HERE IF CHARACTERS FOUND AFTER THE RIGHT PARENTHESIS 21456000
*                                                                       21457000
DATAERR1 XERR  13,034             ARGUMENT TO DATA FUNCTION DOES NOT    21458000
*                                 END WITH A RIGHT PARENTHESIS          21459000
         ST    A1,FLDNPTR(,DB2)   SAVE FIELD NAME IN NEXT LOCATION      21460000
         LA    DB2,4(,DB2)        POINT PAST USED LOCATION              21461000
         B     DATASCAN(A2+1)     TAKE PROPER ACTION FOR COMA OR RT PAR 21462000
         EJECT                                                          21463000
*                                                                       21464000
*        COME HERE IF STOP CHARACTER WAS A RIGHT PARENTHESIS            21465000
*                                                                       21466000
DATASCRP MVI   ZTBL+C',',0        CLEAR OUT TABLE                       21467000
         MVI   ZTBL+C')',0        OF ZEROS FOR NEXT USE                 21468000
         CE    ZR,XSCANSV         CHECK NUMBER OF CHARS LEFT IN ARG     21469000
         BNE   DATAERR1           ISSUE ERROR IF ANY CHARACTERS LEFT    21470000
         SR    DB2,FR             GET # OF FIELDS * 4 IN DB2            21471000
         LR    A2+1,DB2           SAVE FOR LATER USE                    21472000
         SRL   DB2,2              /4 = NUMBER OF FIELDS                 21473000
         CH    DB2,=H'30'         CHECK AGAINST FIELD LIMIT             21474000
         BNH   *+8                SKIP IF WITHIN LIMIT                  21475000
         XERR  13,035             ARGUMENT TO DATA FUNCTION CONTAINS    21476000
*                                 MORE THAN 30 FIELDS                   21477000
         STH   DB2,NFLDSDF(,FR)   SAVE NUMBER OF FIELDS IN BLOCK        21478000
         LA    R0,FLDNPTR(,A2+1)  GET TOTAL BLOCK SIZE                  21479000
         STH   R0,NBYTESDF(,FR)   AND SAVE IT IN THE BLOCK              21480000
         ST    FR,PDMODL+PDFPTR(,FR)        SAVE POINTER TO THIS BLOCK  21481000
         LA    A2,0(A2+1,A2+1)    GET NO. OF ARGS * 8                   21482000
         LA    R1,TEM#1+8         GET OFFSET TO ZEROITH TEMPORARY LOC   21483000
         SR    R1,A2              AND CALCULATE OFFSET TO 1ST TEM FOR   21484000
*                                 THE MVC IN BUILDING A DATA BLOCK      21485000
         STH   R1,DATAMVC+4(,FR)  SAVE OFSET IN MVC INSTRUCTION         21486000
         OI    DATAMVC+4(FR),PDR*16         USE PDR AS BASE REGISTER    21487000
         LA    R1,PDFLDS(,A2)     GET SIZE OF A PDBLOK                  21488000
         STC   R1,PDMODL+PDFPTR(,FR)        SAVE LENGTH OF PDBLOK W/PTR 21489000
         STH   R1,DATAFRMV+2(,FR) AND SAVE AS PUSH FOR FR IN BLOCK      21490000
         BCTR  A2,0               GET 360 LENGTH OF ARGS ON STACK       21491000
         STC   A2,DATAMVC+1(,FR)  AND SAVE IN MVC IN PDFBLOK            21492000
         L     A1,PDFNPTR(,FR)    LOAD ADDRESS OF NAME BLOCK            21493000
         LR    A1+1,FR            SET ADDRESS OF NEW FUNCTION           21494000
         BAL   RETURN,OPSYN$      DO FUNC ADDR ASSGN, SET UP BASE REG   21495000
         LR    DB2,FR             SAVE ADDRESS OF PDFBLOK               21496000
         AH    FR,NBYTESDF(,FR)   PUSH PAST PDFBLOK                     21497000
         LA    DB3,PDFLDS-VALUE   LOAD OFFSET FOR LAST FIELD            21498000
         EJECT                                                          21499000
*                                                                       21500000
*        LOOP TO BUILD FFBLOKS BACKWARDS (STARTING WITH LAST FIELD      21501000
*                                 FUNCTION)                             21502000
*                                                                       21503000
FFBUILD  MVC   1(7,FR),PDMODL+1(DB2)        MOVE IN PDFPTR, CLR GBGFLD  21504000
         MVI   0(FR),FFBLOK       SET BLOCK TYPE CODE                   21505000
         MVC   FCODE(FFBSIZE,FR),DARGCODE   MOVE IN REST OF BLOCK       21506000
         STH   DB3,FFBLA+2(,FR)   SAVE OFFSET TO PROPER FIELD           21507000
         LA    DB3,8(,DB3)        PREPARE OFFSET FOR NEXT FIELD         21508000
         L     A1,FLDNPTR-4(A2+1,DB2)       GET NAME PTR FOR THIS FLD   21509000
         LR    A1+1,FR            GET FUNCTION ADDRESS                  21510000
         LTR   FR,FR              SET CC NZ FOR DYNAMIC FUNCTION        21511000
         BALR  RETURN,A2          CALL OPSYN FUNCTION (BASE STILL SET)  21512000
         CLC   FCODE(4,R2),DARGCODE         IS OLD FUNC A FIELD FUNC?   21513000
         BNE   DATANDF            SKIP IF NOT                           21514000
         ST    R2,FFBLNEXT(,FR)   ESLE CAHIN REFERENCE ON THIS BLOCK    21515000
*                                                                       21516000
*        COME HERE AFTER DEALING WITH POSSIBLE OLD FFBLOK POINTER       21517000
*                                                                       21518000
DATANDF  LA    FR,FFBSIZE(,FR)    PUSH FR PAST THIS BLOCK               21519000
         SH    A2+1,H4            DECREMENT AND TEST FIELD NAME OFFSET  21520000
         BP    FFBUILD            LOOP BACK IF MORE FIELDS TO BUILD     21521000
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3                       21522000
         L     PDR,PDRLOC         RESET STACK POINTER                   21523000
         L     A1,NCODEBT         LOAD NULL AS RETURNED RESULT          21524000
         L     RETURN,RETLOC      RESTORE RETURN LOCATION               21525000
         CR    FR,PDR             DO WE NEED A COLLECT?                 21526000
         BCR   L,RETURN           EXIT IF NOT                           21527000
         B     GBGCL0             ELSE COLLECT (DO PROCESS NULL VALUE)  21528000
         EJECT                                                          21529000
*                                                                       21530000
*        STANDARD BLOCK INFORMATION FOR DATA                            21531000
*                                                                       21532000
*        MODEL FOR PDFBLOK                                              21533000
*                                                                       21534000
DATAMODL CH    R0,NFLDSDF(DB4)    ENOUGH ARGS? (DB4 MUST BE INDEX)      21535000
         BL    $$WNAG             SUPPLY NULLS IF NOT                   21536000
         LM    R0,R1,PDMODL(DB4)  PICK UP PDMODL                        21537000
         STM   R0,R1,0(FR)        STORE AS START OF PDBLOK              21538000
DATAMVC  EQU   *-(DATAMODL-FCODE) OFFSET TO MVC INSTRUCTION IN BLOCK    21539000
         MVC   PDFLDS(*-*,FR),*-* PICK UP N ARGS FROM TEM#N             21540000
         LR    A1,FR              POINT TO NEW PDBLOK                   21541000
         A     A1,DCODEBT         ADD PROPER DATATYPE CODE              21542000
DATAFRMV EQU   *-(DATAMODL-FCODE) OFFSET TO LA OF FR IN PDFBLOK         21543000
         LA    FR,*-*(FR)         PUSH UP FREE CORE POINTER             21544000
         L     PDR,PDRLOC         RESTORE STACK ADDRESS                 21545000
         CR    FR,PDR             DO WE NEED A CLOOECT?                 21546000
         BCR   L,RETURN           RETURN TO CODE IF NOT                 21547000
         B     GBGCL1S            ELSE COLLECT SAVING VALUE             21548000
         DC    AL4(0)             PDFNPTR                               21549000
         DC    AL1(PDBLOK,0,0,0)  DTYPE, GCOLPTR FOR PDBLOK             21550000
*                                                                       21551000
*        MODEL FOR FFBLOK                                               21552000
*                                                                       21553000
DARGCODE CLI   TEM#1(PDR),DCODE   IS ARGUMENT A DATA ITEM?              21554000
         LA    A1+1,PDFLDS-VALUE  OFFSET TO FIELD FOR LAST ITEM         21555000
         BE    $$FLCN             IF DATA ITEM, GO LOAD IT              21556000
         B     $$FLE1             ELSE GIVE ERROR                       21557000
         DC    AL4(FLCERR-FCODE)  FFBLNEXT DOES NOT EXIST               21558000
FFBLA    EQU   DARGCODE+4-(DARGCODE-FCODE)  OFFSET TO LA IN FFBLOK      21559000
DATA     ENDFUNC                  END OF DATA FUNCTION                  21560000
         TITLE 'SPITBOLF -- DATATYPE FUNCTION'                          21561000
DATATYPE FUNCTION  1,N            ENTRY POINT -- ONE ARGUMENT           21562000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         21563000
         L     PDR,PDRLOC         RESET STACK POINTER                   21564000
         B     $$DTTP             JUMP TO STANDARD SYSTEM ROUTINE       21565000
DATATYPE ENDFUNC ,                END OF DATATYPE FUNCTION              21566000
         TITLE 'SPITBOLF -- DATE FUNCTION'                              21567000
DATE     FUNCTION  0,N            ENTRY POINT -- NO ARGS                21568000
         L     PDR,PDRLOC         RESET STACK POINTER                   21569000
         L     R2,DATEV           LOAD ADDRESS OF INTERFACE ROUTINE     21570000
         BALR  R1,R2              CALL IT                               21571000
         B     SYSERROR           ERROR RETURN (IMPOSSIBLE)             21572000
         LR    A1,R0              LOAD POINTER TO PROPER REG            21573000
         SH    A1,H6              SET OFFSET (SCHARS)                   21574000
         A     A1,SCODEBT         ADD CODE FOR STRING                   21575000
         LA    A1+1,8-1           INDICATE OFFSET = 0, LENGTH = 7       21576000
         BR    RETURN             RETURN TO CALLER                      21577000
DATEV    DC    V(SYSDATE)         ADDRESS OF ROUTINE                    21578000
DATE     ENDFUNC   ,              END OF DATE FUNCTION                  21579000
         TITLE 'SPITBOLF -- DEFINE FUNCTION'                            21580000
DEFINE   FUNCTION  2              ENTRY POINT -- TWO ARGUMENTS REQUIRED 21581000
         BAL   A2+1,XSCANI        INITIALIZE THE SCAN ROUTINE           21582000
         XERR  01,060             FIRST ARGUMENT TO DEFINE FUNCTION     21583000
*                                 IS NOT A STRING                       21584000
         XERR  13,036             FIRST ARGUMENT TO DEFINE FUNCTION     21585000
*                                 IS NULL                               21586000
         MVC   0(12,FR),FBLKMOD   MOVE IN START OF FBLOK                21587000
         MVI   ZTBL+C'(',1        SET TO STOP ON LEFT PARENTHESIS       21588000
         BALR  RETURN,A2          SCAN OUT A NAME                       21589000
         XERR  13,037             FUNCTION NAME IN DEFINE FIRST         21590000
*                                 ARGUMENT IS NULL                      21591000
         XERR  13,038             FIRST ARGUMENT TO DEFINE FUNCTION     21592000
*                                 IS MISSING A LEFT PARENTHESIS         21593000
         MVI   ZTBL+C'(',0        DON'T STOP ON ( ANYMORE               21594000
         ST    A1,FNAME(,FR)      SAVE FUNCTION NAME BLOCK ADDRESS      21595000
         LR    DB2,FR             COPY POINT TO FARGS LOCATION          21596000
         MVI   ZTBL+C',',DEFARGL-DEFARG     MARK TO STOP ON ,           21597000
         LM    A1,A1+1,XSCANSV    PICK UP SCAN POINTERS TO CHECK FOR    21598000
*                                 CASE OF NO ARGUMENTS                  21599000
         CLI   0(A1+1),C')'       IS NEXT CHARACTER A )?                21600000
         BE    DEFNOARG           SKIP FOR NO ARGS IF SO                21601000
         MVI   ZTBL+C')',DEFARGDN-DEFARG    SET FOR STOP ON )           21602000
*                                                                       21603000
*        THIS IS THE BASE FOR INDEXED JUMPS AFTER FIELD PROCESSING      21604000
*                                                                       21605000
DEFARG   EQU   *-4                MUST AVOID OFFSET OF ZERO             21606000
*                                                                       21607000
*        COME HERE TO PROCESS AN ARGUMENT NAME                          21608000
*                                                                       21609000
DEFARGL  BALR  RETURN,A2          SCAN OUT A NAME                       21610000
*                                                                       21611000
*        COME HERE TO GIVE ERROR MESSAGE IF NO CHARACTERS FOUND         21612000
*        AFTER INITIAL LEFT PARENTHESIS                                 21613000
*                                                                       21614000
DEFNULER XERR  13,039             FIRST ARGUMENT TO DEFINE FUNCTION     21615000
*                                 CONTAINS A NULL ARGUMENT NAME         21616000
         XERR  13,040             FIRST ARGUMENT TO DEFINE FUNCTION     21617000
*                                 IS MISSING A RIGHT PARENTHESIS        21618000
         ST    A1,FARGS(,DB2)     SAVE VAR BLOCK ADDR OF ARG NAME       21619000
         LA    DB2,4(,DB2)        BUMP OVER THIS ARGUMENT ENTRY         21620000
         B     DEFARG(A2+1)       AND TAKE PROPER STOP CHAR ACTION      21621000
*                                                                       21622000
*        COME HERE WHEN THERE ARE NO ARGUMENTS FOR FUNCTION             21623000
*                                                                       21624000
DEFNOARG SH    A1,H1              DECREMENT AND TEST LENGTH LEFT        21625000
         BM    DEFNULER           ERROR IF END OF STRING                21626000
         AH    A1+1,H1            BUMP OVER ), SAVE TYPE CODE           21627000
         STM   A1,A1+1,XSCANSV    STORE NEW SCAN POINTERS               21628000
         EJECT                                                          21629000
*                                                                       21630000
*        COME HERE AFTER LAST ARGUMENT PROCESSED                        21631000
*                                                                       21632000
DEFARGDN MVI   ZTBL+C')',0        NO LONGER STOP ON )                   21633000
         LR    R0,DB2             COPY POINTER TO FARGS                 21634000
         SR    R0,FR              GET NO. OF ARGS * 4                   21635000
         SRL   R0,2               /4 = NUMBER OF ARGUMENT FIELDS        21636000
         STH   R0,FNARGS(,FR)     SAVE IN BLOCK                         21637000
         CE    ZR,XSCANSV         HAVE WE EXHAUSTED THE STRING?         21638000
         BE    DLOCDONE           LOCALS DONE IF NO CHARS LEFT          21639000
         OI    XSCANFLG,XSIGNRO   SET TO IGNORE RUNOUT CONDITION        21640000
*                                                                       21641000
*        LOOP TO PROCESS LOCAL FIELDS                                   21642000
*                                                                       21643000
DEFLOCL  BALR  RETURN,A2          SCAN OUT A LOCAL                      21644000
         XERR  13,041             FIRST ARGUMENT TO THE DEFINE FUNCTION 21645000
*                                 CONTAINS A NULL LOCAL NAME            21646000
         NOP   0                  IMPOSSIBLE RETURN LOCATION            21647000
         ST    A1,FARGS(,DB2)     SAVE LOCAL ADDRESS                    21648000
         LA    DB2,4(,DB2)        PUSH OVER LOCAL ADDRESS               21649000
         LTR   A2+1,A2+1          TEST FOR RUNOUT                       21650000
         BNZ   DEFLOCL            LOOP BACK FOR MORE IF NOT             21651000
*                                                                       21652000
*        COME HERE WHEN ALL LOCALS PROCESSED                            21653000
*                                                                       21654000
DLOCDONE LR    R0,DB2             COPY FARGS POSITION FOR # CALC        21655000
         SR    R0,FR              GET NUMBER OF ARGS+LOCS*4             21656000
         SRL   R0,2               /4 = NUMBER OF ARGS+LOCS              21657000
         SH    R0,FNARGS(,FR)     MINUS NUMBER OF ARGS=NUMBER OF LOCS   21658000
         STH   R0,FNLOCS(,FR)     SAVE IN BLOCK                         21659000
         MVI   ZTBL+C',',0        CLEAR ZTBL                            21660000
         LA    DB2,FARGS(,DB2)    POINT PAST TBLOK                      21661000
         CR    DB2,PDR            HAVE WE OVERFLOWED CORE?              21662000
         BNL   GBGCLF             COLLECT IF SO                         21663000
         SR    DB2,FR             GET LENGTH OF BLOCK                   21664000
         STH   DB2,FNLENG(,FR)    SAVE IN BLOCK                         21665000
         L     A1,FNAME(,FR)      LOAD DEFAULT LABEL ADDRESS            21666000
*                                                                       21667000
*        COME HERE TO PROCESS THE ENTRY POINT ARGUMENT                  21668000
*                                                                       21669000
         CLI   TEM#2(PDR),NCODE   IS SECOND ARGUMENT NULL?              21670000
         BE    DEFLABEL           OFF WITH LABEL IF NULL 2ND ARG        21671000
         LM    A1,A1+1,TEM#2(PDR) LOAD LABEL ADDRESS                    21672000
         BAL   RETURN,GETNAME     GET VARIABLE BLOCK ADDR FOR LABEL     21673000
         XERR  01,061             SECOND ARGUMENT TO DEFINE FUNCTION    21674000
*                                 IS NOT A VALID LABEL NAME             21675000
         EJECT                                                          21676000
*                                                                       21677000
*        COME HERE WITH A1 POINTING TO ENTRY POINT VARIABLE BLOCK       21678000
*                                                                       21679000
DEFLABEL ST    A1,FLABEL(,FR)     SAVE IN FUNCTION BLOCK                21680000
         L     A1,FNAME(,FR)      LOAD ADDRESS OF FUNCTION NAME         21681000
         MVC   FFLAGS(1,FR),VFLAGS(A1)      SET CURRENT FUNCTION FLGS   21682000
         LR    A1+1,FR            SET NEW FUNCTION ADDRESS              21683000
         BAL   RETURN,OPSYN$      MOVE IN FUNCTION ADDRESS              21684000
         AR    FR,DB2             BUMP PAST FUNCTION BLOCK              21685000
         L     DB2,$$BAS2         RESTORE DATA BASE REGISTER            21686000
         B     EXITNULL           RETURN NULL AS RESULT                 21687000
*                                                                       21688000
*        MODEL BLOCK FOR FBLOK CONSTRUCTION                             21689000
*                                                                       21690000
         DS    0H                 ALLIGN TO HALFWORD                    21691000
FBLKMOD  DC    AL1(FBLOK)         DTYPE IS FBLOK                        21692000
         DC    AL3(0)             GCOLPTR=0                             21693000
         DC    AL2(0)             LENGTH OF BLOCK                       21694000
         DC    AL1(0,0)           FLAGS AND UNUSED BYTE                 21695000
         B     $$FUNC             CALL FUNCTION ENTRY ROUTINE           21696000
DEFINE   ENDFUNC                  END OF DEFINE FUNCTION                21697000
         TITLE 'SPITBOLF -- DETACH FUNCTION'                            21698000
DETACH   FUNCTION  1              ENTRY POINT -- 1 ARG REQUIRED         21699000
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT               21700000
         BAL   RETURN,GETNAME     GET VARIABLE BLOCK                    21701000
         XERR  01,062             ARGUMENT TO DETACH IS NOT THE NAME    21702000
*                                 OF A NATURAL VARIABLE                 21703000
         LA    RETURN,EXITNULL    SET TO RETURN NULL AS RESULT          21704000
         LR    A1+1,A1            COPY VARIABLE BLOCK ADDRESS           21705000
         CE    ZR,VIOPTR(,A1+1)   DO WE HAVE AN IOBLOK?                 21706000
         BCR   E,RETURN           ALL DONE IF NO IOBLOK                 21707000
         NI    VFLAGS(A1+1),X'FF'-VINA-VOUA SET TO NO IO ASSOCIATIONS   21708000
         L     R1,VIOPTR(,A1+1)   LOAD IOBLOK ADDRESS                   21709000
         CE    ZR,IOFUNC(,R1)     IS THERE ACTIVE TRACE INFORMATION?    21710000
         BCR   NE,RETURN          ALL DONE IF TRACE IS ACTIVE           21711000
         XC    VIOPTR+1(3,A1+1),VIOPTR+1(A1+1)        CLEAR OUT ADDR    21712000
         BR    RETURN             AND RETURN TO CALLER                  21713000
DETACH   ENDFUNC                  END OF DETACH FUNCTION                21714000
         TITLE 'SPITBOLF -- DUMP FUNCTION'                              21715000
*                                                                       21716000
*        THIS ROUTINE CAN BE CALLED FROM THE GENERATED CODE AND         21717000
*        AND AT THE END OF THE RUN IF A DUMP IS REQUESTED               21718000
*                                                                       21719000
DUMP     FUNCTION  1,N            ENTRY POINT -- ONE ARGUMENT REQUIRED  21720000
         STM   FRETURN,RETURN,FRETLOC       SAVE RETURN REGISTERS       21721000
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT               21722000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    21723000
         LA    A1+1,1             ASSUME VALUE OF 1 IF ERROR            21724000
         LTR   A1+1,A1+1          TEST VALUE OF ARGUMENT                21725000
         BNP   DUMPOUT            EXIT IF NOT POSITIVE                  21726000
         STC   A1+1,DMPARG        SAVE FOR LATER TEST                   21727000
*                                                                       21728000
*        HERE WE CHECK FOR ARGUMENT = 3 (SYSTEM MEMORY DUMP)            21729000
*                                                                       21730000
         CLI   DMPARG,3           IS IT DUMP(3)?                        21731000
         BNE   DUMPD              SKIP IF NOT                           21732000
         L     R2,=V(SYSDUMP)     POINT TO SYSTEM DUMP ROUTINE          21733000
         BALR  R1,R2              CALL SYSTEM DUMP ROUTINE              21734000
         NOP   0                  UNUSED ERROR RETURN                   21735000
         B     DUMPOUT            JUMP TO EXIT                          21736000
*                                                                       21737000
*        GENERAL INITIALIZATION                                         21738000
*                                                                       21739000
*        IF ARGUMENT IS TWO, WE MUST SET ID NUMBERS IN DYNAMIC BLOCKS   21740000
*                                                                       21741000
DUMPD    CLI   DMPARG,2           IS ARGUMENT TWO? DUMP(2) CASE?        21742000
         BNE   DMPINIT            GO INITIALIZE DUMP IF NOT             21743000
         L     A1,DYNAMB          LOAD START OF DYNAMIC CORE            21744000
         CR    FR,A1              IS FREE CORE EMPTY?                   21745000
         BCR   E,RETURN           BACK TO GETINT ERROR RETURN IF SO     21746000
         SR    DB3,DB3            INITIALIZE COUNTER TO ZERO            21747000
*                                                                       21748000
*        LOOP THROUGH BLOCKS IN DYNAMIC CORE SETTING ID NUMBERS         21749000
*                                                                       21750000
DMPSIDL  CLI   0(A1),ABLOK        IS IT ARRAY?                          21751000
         BE    DMPSID             JUMP TO SET ID IF SO                  21752000
         CLI   0(A1),PDBLOK       IS IT PROGRAM DEFINED DATATYPE?       21753000
         BE    DMPSID             JUMP TO SET ID IF SO                  21754000
         CLI   0(A1),TBBLOK       IS IT TABLE?                          21755000
         BNE   DMPSIDX            JUMP TO END OF LOOP IF NOT            21756000
*                                                                       21757000
*        COME HERE TO SET ID NUMBER                                     21758000
*                                                                       21759000
DMPSID   LA    DB3,1(,DB3)        BUMP ID NUMBER                        21760000
         STH   DB3,2(,A1)         STORE ID NUMBER IN PLACE              21761000
*                                                                       21762000
*        COME HERE TO BUMP PAST THIS BLOCK                              21763000
*                                                                       21764000
DMPSIDX  SR    R2,R2              CLEAR FOR IC                          21765000
         IC    R2,DTYPE(,A1)      LOAD BLOCK TYPE AS TABLE OFFSET       21766000
         EX    0,BLOKLEN(R2)      LOAD LENGTH OF BLOCK IN R2            21767000
         AR    A1,R2              PUSH POINTER PAST BLOCK               21768000
         CR    A1,FR              ARE WE AT FREE CORE END?              21769000
         BL    DMPSIDL            LOOP BACK IF MORE TO GO               21770000
         EJECT                                                          21771000
*                                                                       21772000
*        COME HERE TO INITIALIZE VARIABLE BLOCK SORT                    21773000
*                                                                       21774000
*        THE NON-NULL VARIABLE BLOCK ARE CHAINED TOGETHER IN SORTED     21775000
*        ORDER USING THE VIOPTR FIELD TO HOLD THE FORWARD LINK.  IF     21776000
*        THE BLOCK WAS USING ITS VIOPTR FIELD THE BLOCKS ADDRESS IS     21777000
*        SAVED IN THE GBGCOL FIELD OF THE CONCERNED IOBLOK.  AFTER THE  21778000
*        DUMP IS COMPLETE, DURING THE FINAL SCAN THROUGH DYNAMIC CORE   21779000
*        THE VIOPTRS ARE RESTORED                                       21780000
*                                                                       21781000
DMPINIT  L     DB3,HASHTBAD       GET ADDRESS OF MAIN HASH TABLE        21782000
         L     R0,=X'00FFFFFF'    LOAD MASK TO CHECK FOR LINK )N:       21783000
         STE   ZR,VARCHAIN        INITIALIZE CHAIN TO NO VARI|B6)S      21784000
         B     DMPHSSKP           MAKE LOOP ENTRY TO GET HASH SLOT      21785000
*                                                                       21786000
*        COME HERE TO CHECK VALUE FOR NULL                              21787000
*                                                                       21788000
DMPNVL   CLI   VALUE(DB2),NCODE   IS THIS VALUE NULL?                   21789000
         BE    DMPNVS             SKIP IT IF NULL                       21790000
         CE    ZR,VIOPTR(,DB2)    DOES IT USE ITS IOPTR SLOT?           21791000
         BE    DMPNVCHN           NO PREPARATION IF NOT USED            21792000
         L     R1,VIOPTR(,DB2)    LOAD IOBLOK ADDRESS                   21793000
         ST    DB2,0(,R1)         SAVE VARBLOK BACKPTR IN IOBLOK        21794000
         MVI   0(R1),IOBLOK       PUT BACK TYPE CODE FOR BLOKLEN        21795000
*                                                                       21796000
*        COME HERE WHEN VIOPTR HAS BEEN FREED FOR LINK USAGE            21797000
*                                                                       21798000
DMPNVCHN LA    R2,VARCHAIN-VIOPTR SET UP DUMMY CHAIN START              21799000
*                                                                       21800000
*        COME HERE TO SEARCH FOR SPOT ON CHAIN                          21801000
*                                                                       21802000
DMPNVCN  LR    FRETURN,R2         SAVE BACK POINTER FOR INSERT          21803000
         L     R2,VIOPTR(,FRETURN)          MOVE OUT ON CHAIN           21804000
         NR    R2,R0              TEST FOR END OF CHAIN                 21805000
         BZ    DMPNVINS           OFF TO INSERT HERE IF END OF CHAIN    21806000
         L     A1,VNAME(,DB2)     LOAD NAME BASE POINTER                21807000
         AH    A1,VNAME+SOFFSET(,DB2)       ADD IN NAME OFFSET          21808000
         LH    A1+1,VNAME+SLENGTH(,DB2)     LOAD NAME LENGTH            21809000
         L     A2,VNAME(,R2)      LOAD NAME OF ELEMENT ON CHAIN         21810000
         AH    A2,VNAME+SOFFSET(,R2)        ADD IN NAME OFFSET          21811000
         LH    A2+1,VNAME+SLENGTH(,R2)      LOAD NAME LENGTH            21812000
         BAL   RETURN,LCMPM       COMPARE THE NAMES                     21813000
         BL    DMPNVCN            IF NEW NAME LOW, KEEP LOOKING         21814000
         EJECT                                                          21815000
*                                                                       21816000
*        COME HERE TO INSERT A BLOCK ON THE LIST                        21817000
*                                                                       21818000
DMPNVINS MVC   VIOPTR+1(3,DB2),VIOPTR+1(FRETURN)      LINK NEW BLOCK    21819000
*                                 IN FRONT OF HIGHER OR NON-EXISTANT    21820000
*                                 BLOCK ON OLD CHAIN                    21821000
         IC    R1,VIOPTR(,FRETURN)          SAVE UPPER BYTE FOR LINK    21822000
         ST    DB2,VIOPTR(,FRETURN)         POINT LAST LOW BLOCK TO NEW 21823000
         STC   R1,VIOPTR(,FRETURN)          AND RESTORE UPPER BYTE      21824000
*                                                                       21825000
*        COME HERE TO MOVE OUT ON MAIN HASH CHAIN                       21826000
*                                                                       21827000
DMPNVS   L     DB2,VLINK(,DB2)    MOVE OUT ON HASH CHAIN                21828000
         NR    DB2,R0             TEST FOR LINK END                     21829000
         BNZ   DMPNVL             OFF TO CHECK VALUE IF NOT LINK END    21830000
*                                                                       21831000
*        COME HERE TO MOVE TO NEXT HASH SLOT                            21832000
*                                                                       21833000
DMPHSSKP LR    DB2,DB3            PRETEND HASH SLOT VLINK FIELD         21834000
         LA    DB3,4(,DB3)        PUSH TO NEXT SLOT                     21835000
         C     DB3,HASHTBEN       CHECK FOR PAST END OF HASH TABLE      21836000
         BNH   DMPNVS             OFF TO GET LINK IF NOT END OF TBL     21837000
         LA    FRETURN,DMPBASRG   POINT TO BASE REGISTER LOCATION       21838000
         DROP  DB4                GET RID OF OLD BASE REGISTER          21839000
         USING DMPBASRG,FRETURN   TELL ASSEMBLER OF NEW BASE REGISTER   21840000
         L     DB4,=A(DTERTNS)    LOAD TRACE ROUTINES BASE              21841000
         USING DTERTNS,DB4        TELL ASSEMBLER                        21842000
         BAL   A2,LINEINIT        INITIALIZE OUTPUT                     21843000
         BCTR  DB3,0              BACK UP TO CONTROL CHARACTER          21844000
         MVC   0(26,DB3),=C'1DUMP OF NATURAL VARIABLES'         MV MSSG 21845000
         LA    DB3,26(,DB3)       BUMP OVER IT                          21846000
         BAL   A2+1,DMPUND        UNDERLINE IT AND PRINT BLANK LINE     21847000
         L     R0,VARCHAIN        POINT TO FIRST NON-NULL VARIABLE BLOK 21848000
         BAL   R1,DMPNVPT1        MAKE LOOP ENTRY SETTING (R1)          21849000
*                                                                       21850000
*        COME HERE TO DUMP A NAME AND VALUE                             21851000
*                                                                       21852000
DMPNVPT  LM    A1,A1+1,VNAME(DB2) LOAD NAME                             21853000
         BAL   RETURN,LINESTR     PRINT NAME                            21854000
         LM    A1,A1+1,VALUE(DB2) LOAD VALUE                            21855000
         BAL   A2,LINEQVAL        PRINT VALUE AFTER ' = '               21856000
         BALR  A2,LINE$           TERMINATE LINE                        21857000
*                                                                       21858000
*        BASE REGISTER FRETURN POINTS HERE FOR REST OF ROUTINE          21859000
*                                                                       21860000
DMPBASRG L     R1,VIOPTR(,DB2)    MOVE OUT ON CHAIN                     21861000
         LA    R0,0(,R1)          GET LINK WITHOUT UPPER BYTE           21862000
         SR    R1,R0              LEAVE ONLY UPPER BYTE IN R1           21863000
         ST    R1,VIOPTR(,DB2)    STORE BACK ZEROS AND UPPER BYTE       21864000
         L     R1,=A(DMPNVPT)     GET LOOP START ADDRESS                21865000
*                                                                       21866000
*        COME HERE TO POINT DB2 TO NEXT BLOCK AND TEST FOR LINK END     21867000
*                                                                       21868000
DMPNVPT1 LTR   DB2,R0             COPY AND TEST LINK FOR END            21869000
         BCR   NZ,R1              LOOP BACK IF NOT AT LINK END          21870000
         EJECT                                                          21871000
*                                                                       21872000
*        INITIALIZE DUMP OF KEYWORDS                                    21873000
*                                                                       21874000
         BCTR  DB3,0              POINT TO CONTROL CHARACTER POSITION   21875000
         MVC   0(17,DB3),=C'0DUMP OF KEYWORDS'        MOVE IN TITLE     21876000
         LA    DB3,17(,DB3)       BUMP PAST IT                          21877000
         BAL   A2+1,DMPUND        UNDERLINE IT AND PRINT BLANK LINE     21878000
         LA    DB2,DMPKYLST-DMPKYTBL        GET OFFSET TO LAST(FIRST)   21879000
*                                 KEYWORD TABLE ENTRY                   21880000
*                                                                       21881000
*        COME HERE TO PRINT OUT A KEYWORD NAME AND VALUE                21882000
*                                                                       21883000
DMPKWL   LH    A1,DMPKYTBL(DB2)   LOAD CURRENT KEYWORD INITV LOC&LENGTH 21884000
         SR    A1+1,A1+1          CLEAR TO PREPARE FOR SHIFT            21885000
         SRDL  A1,12              SEPARATE LENGTH/ADDRESS OFFSET        21886000
         SRL   A1+1,32-12-16      POSITION OFFSET IN SOFFSET FIELD      21887000
         ALR   A1+1,A1            MOVE LENGTH INTO SLENGTH FIELD        21888000
         L     A1,INITVPTR        SUPPLY BASE ADDRESS + SCODE           21889000
         MVI   0(DB3),C'&&'       PUT AN & IN THE BUFFER                21890000
         LA    DB3,1(,DB3)        BUMP OVER IT (NO OVERFLOW POSSIBLE)   21891000
         BAL   RETURN,LINESTR     PUT KEYWORD NAME ON THE LINE          21892000
*                                                                       21893000
*        WHEN LINESTR RETURNS A1 POINTS TO NAME CHARACTERS, A1+1=360 LN 21894000
*        THERE FORE ADDING THE REAL LENGTH OF NAME TO A1 WILL POINT     21895000
*        TO THE FLAG BYTE.  JUST BEYOND FLAG IS THE KEYWORD NUMBER      21896000
*                                                                       21897000
         SR    R1,R1              CLEAR FOR IC                          21898000
         IC    R1,SCHARS+1+1(A1,A1+1)       PICK UP CHAR PAST FLG & LEN 21899000
         L     R2,=A(KGETC)       LOAD KEYWORD BASE ADDRESS             21900000
         USING KGETC,R2           TELL ASSEMBLER OF BASE REGISTER       21901000
         BAL   RETURN,KGETC2      MERGE AT PROPER POINT                 21902000
         DROP  R2                 GET RID OF BASE REGISTER              21903000
         BAL   A2,LINEQVAL        PUT VALUE ON LINE PAST C' = '         21904000
         BALR  A2,LINE$           PRINT THE LINE                        21905000
         SH    DB2,H2             DECREMENT TBL OFFSET, PT TO NXT ENTRY 21906000
         BNM   DMPKWL             LOOP BACK IF NOT FINISHED             21907000
         EJECT                                                          21908000
*                                                                       21909000
*        COME HERE TO CHECK FOR CASE 2 DUMP                             21910000
*                                                                       21911000
         CLI   DMPARG,2           IS THIS A CASE 2 DUMP?                21912000
         BNE   DMPEXIT            OFF TO FIX UP IOBLOKS IF NOT          21913000
*                                                                       21914000
*        COME HERE FOR A CASE 2 DUMP TO DUMP DYNAMIC BLOKS              21915000
*                                                                       21916000
         BALR  A2,LINE$           PRINT A BLANK LINE                    21917000
         L     A1,DYNAMB          POINT TO START OF DYNAMIC CORE        21918000
*                                                                       21919000
*        LOOP TO FIND USED BLOCKS AND DUMP THEM (USED BLOCKS HAVE MARK) 21920000
*                                                                       21921000
DMPDNL   ST    A1,DMPBSAV         SAVE BLOCK ADDRESS FOR DUMP ROUTINES  21922000
         CLI   0(A1),ABLOK        IS THIS AN ARRAY BLOCK?               21923000
         BE    DMPAR              OFF TO DUMP IT IF SO                  21924000
         CLI   0(A1),TBBLOK       IS THIS A TABLE?                      21925000
         BE    DMPTB              OFF TO DUMP IT IF TABLE               21926000
         CLI   0(A1),PDBLOK       IS THIS A PROGRAMER DEFINED DATATYPE? 21927000
         BNE   DMPSK              SKIP OVER IT IF NOT                   21928000
*                                                                       21929000
*        COME HERE TO DUMP A PROGRAMER DEFINED DATATYPE                 21930000
*                                                                       21931000
         L     DB2,PDFPTR(,A1)    LOAD POINTER TO PDFBLOK               21932000
         L     R1,PDFNPTR(,DB2)   LOAD POINTER TO DATATYPE NAME         21933000
         LM    A1,A1+1,VNAME(R1)  LOAD NAME                             21934000
         BAL   RETURN,LINESTR     PRINT STRING NAME                     21935000
         L     A1,DMPBSAV         RESTORE POINTER TO BLOCK              21936000
         BAL   A2,LINEPDID        GET PDBLOK ID ON LINE                 21937000
         BAL   A2+1,DMPUND        UNDERLINE AND PRINT MESSAGE           21938000
         LH    A2+1,NFLDSDF(,DB2) LOAD NUMBER OF FIELDS                 21939000
         SLL   A2+1,3             * 8 IS OFFSET TO FIRST (LAST) FIELD   21940000
         A     A2+1,DMPBSAV       POINT TO LAST FIELD                   21941000
*                                                                       21942000
*        LOOP TO DUMP FIELD VALUES                                      21943000
*                                                                       21944000
DMPPDL   L     R1,FLDNPTR(,DB2)   LOAD POINTER TO NAME BLOCK            21945000
         LA    DB2,4(,DB2)        BUMP POINTER                          21946000
         LM    A1,A1+1,VNAME(R1)  LOAD FIELD NAME                       21947000
         BAL   RETURN,LINESTR     PRINT STRING NAME                     21948000
         LM    A1,A1+1,PDFLDS-8(A2+1)       LOAD FIELD VALUE            21949000
         BAL   A2,LINEQVAL        OUTPUT FIELD VALUE AFTER C' = '       21950000
         BALR  A2,LINE$           AND PRINT THE LINE                    21951000
         SH    A2+1,H8            POINT TO NEXT FIELD                   21952000
         C     A2+1,DMPBSAV       ARE WE AT BLOCK END?                  21953000
         BH    DMPPDL             KEEP LOOPING IF NOT                   21954000
*                                                                       21955000
*        RETURN HERE FROM BLOCK DUMP ROUTINES                           21956000
*                                                                       21957000
DMPRTN   BALR  A2,LINE$           PRINT A BLANK LINE                    21958000
         L     A1,DMPBSAV         RESTORE BLOCK POINTER                 21959000
         EJECT                                                          21960000
*                                                                       21961000
*        COME HERE TO BUMP PAST A FREE CORE BLOCK                       21962000
*                                                                       21963000
DMPSK    SR    R2,R2              CLEAR FOR IC                          21964000
         IC    R2,DTYPE(,A1)      GET BLOCK TYPE                        21965000
         EX    0,BLOKLEN(R2)      GET BLOCK LENGTH IN R2                21966000
         AR    A1,R2              BUMP BLOCK POINTER                    21967000
         CR    A1,FR              ARE WE DONE?                          21968000
         BL    DMPDNL             LOOP BACK IF NOT                      21969000
*                                                                       21970000
*        COME HERE TO RESTORE IOB PTRS AND CLEAR OUT ID NUMBERS         21971000
*                                                                       21972000
DMPEXIT  L     A1,DYNAMB          POINT TO START OF DYNAMIC CORE        21973000
         B     DMPCLRL2           OFF TO CHECK FOR EMPTY FREE CORE      21974000
*                                                                       21975000
*        LOOP THROUGH BLOCKS                                            21976000
*                                                                       21977000
DMPCLRL  CLI   0(A1),IOBLOK       IS THIS AN IOBLOK?                    21978000
         BNE   DMPCLRL1           OFF TO CLEAR OUT ID IF NOT            21979000
         CE    ZR,0(,A1)          WAS THIS BLOCK POINTED TO?            21980000
         BE    DMPCLRL1           NO MORE TO DO IF NOT USED             21981000
         L     R1,0(,A1)          GET VARIABLE BLOCK ADDRESS            21982000
         IC    R0,VIOPTR(,R1)     SAVE LEFT BYTE                        21983000
         ST    A1,VIOPTR(,R1)     STORE IOBLOK ADDRESS                  21984000
         STC   R0,VIOPTR(,R1)     RESTORE LEFT BYTE                     21985000
*                                                                       21986000
*        COME HERE TO CLEAR A BLOCKS GARBAGE COLLECTOR FIELD            21987000
*                                                                       21988000
DMPCLRL1 SR    R2,R2              CLEAR FOR IC                          21989000
         IC    R2,DTYPE(,A1)      GET BLOCK TYPE                        21990000
         STE   ZR,0(,A1)          CLEAR COLLECT FIELD                   21991000
         STC   R2,DTYPE(,A1)      RESTORE BLOCK CODE                    21992000
         EX    0,BLOKLEN(R2)      GET BLOCK LENGTH IN R2                21993000
         AR    A1,R2              BUMP PAST BLOCK                       21994000
*                                                                       21995000
*        COME HERE TO CHECK FOR FREE CORE END                           21996000
*                                                                       21997000
DMPCLRL2 CR    A1,FR              ARE WE AT END OF FREE CORE?           21998000
         BL    DMPCLRL            BACK TO CLEAR MORE IF NOT             21999000
*                                                                       22000000
*        COME HERE WITH EVERYTHING CLEANED UP                           22001000
*                                                                       22002000
         MVI   0(FR),C'1'         THIS IS CHEATING, SET FOR NEW PAGE    22003000
         BALR  A2,LINE$           SKIP TO NEW PAGE                      22004000
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS           22005000
*                                                                       22006000
*        COME HERE TO EXIT BEFORE DBS USED                              22007000
*                                                                       22008000
DUMPOUT  L     FRETURN,FRETLOC    RESTORE FRETURN                       22009000
         STE   ZR,FRETLOC         AND CLEAR SAVED FRETURN AS REQUIRED   22010000
         B     EXITNULL           RETURN NULL AS RESULT                 22011000
         EJECT                                                          22012000
*                                                                       22013000
*        COME HERE TO DUMP AN ARRAY                                     22014000
*                                                                       22015000
DMPAR    AL    A1,ACODEBT         MAKE A VALUE POINTER FOR NM & ID, ETC 22016000
         BAL   A2+1,DMPNMFN       FIND NAME, PRINT ID INFORMATION       22017000
         L     A2+1,DMPBSAV       LOAD ARRAY ADDRESS                    22018000
         SR    R1,R1              CLEAR FOR IC                          22019000
         IC    R1,NSUBS(,A2+1)    AND LOAD NUMBER OF SUBSCRIPTS         22020000
*                                                                       22021000
*        DURING THE DUMP WE USE THE SUBFAC FIELDS TO KEEP THE CURRENT   22022000
*        SUBSCRIPTS -- THIS LOOP INITIALIZES THEM TO THE LBD VALUES     22023000
*                                                                       22024000
DMPARL   LH    R0,SUBLBD(,A2+1)   LOAD LOW BOUND                        22025000
         ST    R0,SUBFAC(,A2+1)   STORE AS INITIAL SUBSCRIPT            22026000
         LA    A2+1,8(,A2+1)      BUMP TO NEXT SUBSCRIPT SET            22027000
         BCT   R1,DMPARL          LOOP BACK IF MORE SUBSCRIPTS TO GO    22028000
         ST    A2+1,DMPSV1        SAVE END OF SUBSCRIPT INFO FOR LATER  22029000
*                                                                       22030000
*        THIS LOOP DUMPS THE NON-NULL ARRAY ELEMENTS                    22031000
*                                                                       22032000
DMPARL1  L     DB2,DMPBSAV        LOAD THE ARRAY ADDRESS                22033000
         CLI   AVALS-8(A2+1),NCODE          IS THE NEXT VALUE NULL?     22034000
         BE    DMPARL3            SKIP ITS PRINT IF NULL                22035000
         BAL   RETURN,DMNAMPRT    PRINT A NAME IF POSSIBLE              22036000
         MVI   0(DB3),C'<'        SET LEFT BRACKET AND MERGE            22037000
*                                                                       22038000
*        LOOP TO PRINT SUBSCRIPT VALUES                                 22039000
*                                                                       22040000
DMPARL2  LA    DB3,1(,DB3)        BUMP PAST < OR ,                      22041000
         SR    A1,A1              SET INTEGER TYPE CODE                 22042000
         L     A1+1,SUBFAC(,DB2)  LOAD SUBSCRIPT                        22043000
         BAL   A2,LINEVAL         PRINT SUBSCRIPT VALUE                 22044000
         LA    DB2,8(,DB2)        POINT TO NEXT SUBSCRIPT               22045000
         MVI   0(DB3),C','        MOVE IN A COMMA                       22046000
         C     DB2,DMPSV1         ARE WE THROUGH WITH SUBSCRIPTS?       22047000
         BL    DMPARL2            LOOP BACK IF NOT                      22048000
*                                                                       22049000
*        COME HERE WITH ALL SUBSCRIPTS PRINTED                          22050000
*                                                                       22051000
         MVC   0(4,DB3),DMPRBBEB  OVERWRITE , WITH '> = '               22052000
         LA    DB3,4(,DB3)        BUMP PAST IT                          22053000
         LM    A1,A1+1,AVALS-8(A2+1)        LOAD VALUE OF ELEMENT       22054000
         BAL   A2,LINEVAL         PRINT OUT VALUE OF ELEMENT            22055000
         BALR  A2,LINE$           PRINT OUT LINE                        22056000
         EJECT                                                          22057000
*                                                                       22058000
*        COME HERE TO SKIP A VALUE                                      22059000
*                                                                       22060000
DMPARL3  LA    A2+1,8(,A2+1)      POINT TO NEXT ELEMENT                 22061000
         L     DB2,DMPBSAV        LOAD ARRAY ADDRESS                    22062000
*                                                                       22063000
*        THIS LOOP INCREMENTS THE SUBSCRIPTS BY ONE                     22064000
*                                                                       22065000
DMPARL4  L     R1,SUBFAC(,DB2)    LOAD CURRENT SUBSCRIPT VALUE          22066000
         AH    R1,H1              INCREMENT BY ONE                      22067000
         ST    R1,SUBFAC(,DB2)    STORE AS NEW SUBSCRIPT                22068000
         SH    R1,SUBLBD(,DB2)    SUBTRACT LOW BOUND                    22069000
         CH    R1,SUBDIM(,DB2)    CHECK FOR HIGH BOUND EXCEEDED         22070000
         BL    DMPARL1            LOOP BACK TO DUMP NEXT ELEMENT IF NOT 22071000
         LH    R1,SUBLBD(,DB2)    ELSE LOAD LOW BOUND                   22072000
         ST    R1,SUBFAC(,DB2)    AND STORE AS NEW SUBSCRIPT VALUE      22073000
         LA    DB2,8(,DB2)        BUMP TO NEXT SUBSCRIPT                22074000
         C     DB2,DMPSV1         HAVE WE EXCEEDED BOUNDS?              22075000
         BL    DMPARL4            IF NOT, BACK TO INCREMENT NEXT SUBSCR 22076000
*                                                                       22077000
*        COME HERE WHEN ALL ELEMENTS HAVE BEEN DUMPED                   22078000
*                                                                       22079000
         LA    R0,8               LOAD INITIAL MULTIPLIER OF 8          22080000
         L     DB2,DMPBSAV        LOAD ARRAY ADDRESS                    22081000
*                                                                       22082000
*        LOOP TO RESTORE FACTORS                                        22083000
*                                                                       22084000
DMPARL5  ST    R0,SUBFAC(,DB2)    STORE VALUE OF THIS MULTIPLIER        22085000
         MH    R0,SUBDIM(,DB2)    MULTIPLY BY THIS DIMENSION            22086000
         LA    DB2,8(,DB2)        BUMP TO NEXT BOUNDS                   22087000
         C     DB2,DMPSV1         HAVE WE DONE ALL BOUNDS               22088000
         BL    DMPARL5            LOOP BACK IF MORE TO GO               22089000
         B     DMPRTN             ELSE GO BACK FOR NEXT BLOCK           22090000
         EJECT                                                          22091000
*                                                                       22092000
*        COME HERE TO DUMP A TABLE                                      22093000
*                                                                       22094000
DMPTB    AL    A1,TCODEBT         MAKE A TABLE VALUE TO GET HEADING     22095000
         BAL   A2+1,DMPNMFN       FIND A NAME IF POSSIBLE, GETID ETC.   22096000
         L     A1,DMPBSAV         RESTORE TABLE POINTER                 22097000
         BAL   RETURN,TBCHRON     GET A CHRONOLOGICAL LIST, KIPIF NULL 22098000
         B     DMPRTN             NO MORE TO PRINT IF NO ELEMENTS       22099000
         LR    A2+1,A1+1          COPY NON-NULL ELEMENT COUNT           22100000
         L     DB2,TBCHRSV        LOAD POINTER TO FIRST ELEMENT         22101000
*                                                                       22102000
*        THIS LOOP DUMPS A TABLE ELEMENT                                22103000
*                                                                       22104000
DMPTBL   BAL   RETURN,DMNAMPRT    PRINT A NAME IF POSSIBLE              22105000
         MVI   0(DB3),C'<'        MOVE IN LEFT BRACKET                  22106000
         LA    DB3,1(,DB3)        PUSH OVER IT                          22107000
         LM    A1,A1+1,TENAME(DB2)          PICK UP ELEMENT NAME        22108000
         BAL   A2,LINEVAL         PRINT IT AS A VALUE                   22109000
         MVC   0(4,DB3),DMPRBBEB  MOVE IN C'> = '                       22110000
         LA    DB3,4(,DB3)        PUSH OVER IT                          22111000
         LM    A1,A1+1,TEVALUE(DB2)         PICK UP ELEMENT VALUE       22112000
         BAL   A2,LINEVAL         PRINT IT AS VALUE                     22113000
         BALR  A2,LINE$           PRINT THE LINE                        22114000
         MVI   0(DB2),TEBLOK      SET TYPE CODE FOR EXIT ROUTINE, ETC.  22115000
*                                 GBGFLDS ARE CLEARED AT EXIT           22116000
         L     DB2,0(,DB2)        MOVE OUT ON CHAIN                     22117000
         BCT   A2+1,DMPTBL        LOOP BACK IF NOT OUT OF ELEMENTS      22118000
         B     DMPRTN             ALL DONE, RETURN TO GET NEXT BLOCK    22119000
*                                                                       22120000
*        TABLE OF KEYWORDS TO BE DUMPED - MUST BE IN REVERSE ORDER      22121000
*                                                                       22122000
DMPKYTBL KEYOFF TRIM              &TRIM LAST TO BE DUMPED               22123000
         KEYOFF TRACE             &TRACE                                22124000
         KEYOFF STNO              &STNO                                 22125000
         KEYOFF STLIMIT           &STLIMIT                              22126000
         KEYOFF STCOUNT           &STCOUNT                              22127000
         KEYOFF RTNTYPE           &RTNTYPE                              22128000
         KEYOFF OUTPUT            &OUTPUT                               22129000
         KEYOFF MAXLNGTH          &MAXLNGTH                             22130000
         KEYOFF INPUT             &INPUT                                22131000
         KEYOFF FULLSCAN          &FULLSCAN                             22132000
         KEYOFF FTRACE            &FTRACE                               22133000
         KEYOFF FNCLEVEL          &FNCLEVEL                             22134000
         KEYOFF ERRTYPE           &ERRTYPE                              22135000
         KEYOFF ERRLIMIT          &ERRLIMIT                             22136000
         KEYOFF DUMP              &DUMP                                 22137000
         KEYOFF CODE              &CODE                                 22138000
         KEYOFF ANCHOR            &ANCHOR                               22139000
DMPKYLST KEYOFF ABEND             &ABEND IS END OF LIST, FIRST DUMPED   22140000
         EJECT                                                          22141000
*                                                                       22142000
*        ROUTINE TO FIND POSSIBLE NAME FOR ARRAY OR TABLE               22143000
*        I.E. A NATURAL VARIABLE CONTAINING THE OBJECT AS VALUE         22144000
*        MERGES WITH ID PRINT AND UNDERLINE ROUTINES                    22145000
*                                                                       22146000
*        (A1)                     POINTER TO OBJECT WITH TYPE CODE      22147000
*        BAL   A2+1,DMPNMFN       CALL OF THIS ROUTINE                  22148000
*        DMNAMSV                  ON EXIT, PTR TO VAR BLOCK OR ZERO     22149000
*        USES R0,R1,R2,A1,A1+1,A2,A2+1                                  22150000
*                                                                       22151000
DMPNMFN  LA    R0,4               GET BXLE INCREMENT                    22152000
         L     R2,HASHTBAD        LOAD POINTER TO MAIN HASH TABLE       22153000
         LA    R1,HASHTBNS*4(,R2) GET BXLE END ADDRESS                  22154000
         L     A2,=X'00FFFFFF'    GET MASK TO TEST FOR CHAIN END        22155000
         B     DMPNMBG            MAKE INITIAL LOOP ENTRY               22156000
*                                                                       22157000
*        COME HERE TO TEST FOR CORRECT VALUE                            22158000
*                                                                       22159000
DMPNMLP  C     A1,VALUE(,A1+1)    IS THIS THE CORRECT VALUE?            22160000
         BE    DMPNMND            END OF SEARCH IF FND CORRECT PTR      22161000
         L     A1+1,VLINK(,A1+1)  MOVE OUT ON LINK                      22162000
*                                                                       22163000
*        COME HERE TO CHECK FOR END OF LINK                             22164000
*                                                                       22165000
DMPNMCK  NR    A1+1,A2            TEST FOR ZERO ADDRESS FIELD           22166000
         BNZ   DMPNMLP            LOOP BACK IF NOT END OF LINK          22167000
*                                                                       22168000
*        COME HERE TO MOVE TO ANOTHER HASH SLOT                         22169000
*                                                                       22170000
DMPNMBG  L     A1+1,VLINK(,R2)    PICK UP CONTENTS OF POTENTIAL SLOT    22171000
         BXLE  R2,R0,DMPNMCK      OFF TO CHECK FOR END OF LINK          22172000
         SR    A1+1,A1+1          INDICATE NO NAME FOUND                22173000
*                                                                       22174000
*        COME HERE TO STORE NAME BLOCK ADDRESS OR ZERO FOR LATER USE    22175000
*                                                                       22176000
DMPNMND  ST    A1+1,DMNAMSV       SAVE BLK PTR OR ZERO                  22177000
*                                                                       22178000
*        COME HERE TO PUT DATATYPE, PROTOTYPE, AND ID # ON LINE         22179000
*                                                                       22180000
         BAL   A2,LINEVAL         GET ABOVE INFORMATION ON LINE         22181000
*                                 MERGE WITH DMPUND                     22182000
         EJECT                                                          22183000
*                                                                       22184000
*        ENTRY TO UNDERLINE COMPLETED MESSAGE                           22185000
*                                                                       22186000
*        BAL   A2+1,DMPUND        CALL TO THIS ROUTINE                  22187000
*                                                                       22188000
DMPUND   ST    DB3,DMPSV1         SAVE CURRENT BUFFER POINTER           22189000
         BALR  A2,LINE$           PRINT LINE                            22190000
         BCTR  DB3,0              BACK UP TO CONTROL CHARACTER          22191000
         MVC   0(2,DB3),=C'+_'    SET FOR OVERPRINT + UNDERLINE CHAR    22192000
         L     R2,DMPSV1          RESTORE OLD END OF LINE BUFR POINTER  22193000
         SR    R2,DB3             GET NUMBER OF CHARACTERS TO UNDERLINE 22194000
         SH    R2,H3              ADJUST TO PROPER VALUE                22195000
         EX    R2,DMPIDM          PROPAGATE UNDERLINE CHARACTER         22196000
         LA    DB3,3(R2,DB3)      PUSH PAST UNDERLINE CHARACTERS        22197000
         BALR  A2,LINE$           PRINT LINE OF UNDERLINE CHARACTERS    22198000
         BALR  A2,LINE$           PRINT BLANK LINE                      22199000
         BR    A2+1               RETURN TO CALLER                      22200000
*                                                                       22201000
DMPIDM   MVC   2(*-*,DB3),1(DB3)  PROPAGATE UNDERLINE CHARACTER         22202000
*                                                                       22203000
*        ROUTINE TO PRINT ARRAY OR TABLE NAME FOUND BY DMPNMFN          22204000
*                                                                       22205000
*        (DB3)                    BUFFER POINTER (SET FOR LINESTR)      22206000
         BAL   RETURN,DMNAMPRT    CALL TO PRINT NAME                    22207000
*        USES A1,A1+1                                                   22208000
*                                                                       22209000
DMNAMPRT L     A1,DMNAMSV         LOAD POSSIBLE NAME POINTER            22210000
         LTR   A1,A1              WAS A NAME FOUND?                     22211000
         BCR   Z,RETURN           IMMEDIATE RETURN IF NO NAME FOUND     22212000
         LM    A1,A1+1,VNAME(A1)  ELSE LOAD NAME TO BE PRINTED          22213000
         B     LINESTR            AND EXIT VIA STRING DUMP ROUTINE      22214000
         DROP  FRETURN,DB4        GET RID OF BASE REGISTERS             22215000
DUMP     ENDFUNC   ,              END OF DUMP FUNCTION                  22216000
         TITLE 'SPITBOLF -- DUPL FUNCTION'                              22217000
DUPL     FUNCTION 2               FUNCTION ENTRY POINT                  22218000
         LM    A1,A1+1,TEM#2(PDR) PICK UP SECOND ARG TO DUPL            22219000
         BAL   RETURN,GETINT      MUST BE INTEGER                       22220000
         XERR  01,063             SECOND ARGUMENT TO DUPL FUNCTION IS   22221000
*                                 NOT AN INTEGER                        22222000
         LTR   A2,A1+1            COPY DUP FACTOR AND TEST              22223000
         BM    FAILRL             FAIL IF LENGTH NEGATIVE               22224000
         BZ    EXITNULL           RETURN NULL IF ZERO DUP FACTOR        22225000
         LM    A1,A1+1,TEM#1(PDR) LOAD STRING ARGUMENT                  22226000
         BAL   RETURN,GETSTGT     GET A STRING IF POSSIBLE              22227000
         XERR  01,064             FIRST ARGUMENT TO DUPL FUNCTION IS    22228000
*                                 NOT A STRING                          22229000
         LA    R1,1(,A1+1)        GET REAL STRING LENGTH                22230000
         MR    R0,A2              GET FINAL STRING SIZE                 22231000
         C     R1,V$MAXLN         RESULT TOO LONG?                      22232000
         BNH   *+8                SKIP IF OK                            22233000
         XERR  11,010             STRING FORMED BY CALL TO DUPL         22234000
*                                 FUNCTION IS LONGER THAN &MAXLNGTH     22235000
         LA    R0,SCHARS+BOUND(,R1)         GET MAX BLOCK SIZE          22236000
         N     R0,FULLWRD         PUT ON PROPER BOUNDARY                22237000
         STH   R0,STLENGTH(,FR)   STORE AS BLOCK LENGTH                 22238000
         AR    R0,FR              CALCULATE FINAL CORE POINTER          22239000
         CR    R0,PDR             WILL THERE BE ROOM?                   22240000
         BNL   GBGCLF             COLLECT AND REENTER IF NOT            22241000
         STE   ZR,0(,FR)          MAKE FIRST WORD OF SBLOK              22242000
         LR    A2+1,FR            COPY NEW STRING ADDR                  22243000
         LTR   A1+1,A1+1          CHECK FOR NULL STRING                 22244000
         BP    DUPL1              BRANCH IF MORE THAN 1 CHAR TO DUPL    22245000
         BM    EXITNULL           RETURN NULL IF NULL ARG               22246000
         IC    R0,SCHARS(,A1)     GET ONLY CHAR IN ARG                  22247000
         STC   R0,SCHARS(,FR)     STORE IN NEW BLOCK                    22248000
         LR    A1+1,R1            COPY REAL RESULT LENGTH               22249000
         SH    A1+1,H2            GET 360 PROPAGATE LENGTH              22250000
         BM    DUPLOUT            ALL DONE IF 1CAR STG 1 TIME           22251000
         LA    A2+1,1(,FR)        DUMMY 'TO' LOCATION                   22252000
         LR    A1,FR              DUMMY FROM ADDRESS                    22253000
         LA    A2,1               ONLY ONE COPY                         22254000
*                                                                       22255000
*        COME HERE IF GT 1 CHAR STG TO DUPL - MERGE IF 1 CHARACTER      22256000
*                                                                       22257000
DUPL1    LA    R0,256             GET SPECIAL CONSTANT                  22258000
         CR    A1+1,R0            IS IT SMALL OR LARGE?                 22259000
         BL    DUPLS              SKIP TO SPECIAL ROUTINE IF SHORT      22260000
         STM   A1,A1+1,DUPLSAV    SAVE INFO ON STRING TO BE DUPLICATED  22261000
         EJECT                                                          22262000
*                                                                       22263000
*        LOOP TO MOVE ONE COPY OF A LONG STRING                         22264000
*                                                                       22265000
DUPLB    MVC   SCHARS(256,A2+1),SCHARS(A1)  MOVE 256 BYTE CHUNK         22266000
         AR    A1,R0              PUSH FROM POINTER                     22267000
         AR    A2+1,R0            PUSH TO POINTER                       22268000
         SR    A1+1,R0            DECREMENT LENGTH REMAINING            22269000
         CR    A1+1,R0            IS IT STILL TO BIG FOR ONE MOVE?      22270000
         BNL   DUPLB              B IF TOO BIG                          22271000
         EX    A1+1,DUPLMV        MOVE IN LAST PIECE                    22272000
         LA    A2+1,1(A2+1,A1+1)  POINT PAST LAST CHARACTER             22273000
         LM    A1,A1+1,DUPLSAV    RELOAD STRING POINTER AND SIZE        22274000
         BCT   A2,DUPLB           AND MOVE IF MORE DUPS TO FINISH       22275000
         B     DUPLOUT            AND MERGE WITH SHORT STRING ROUTINE   22276000
*                                                                       22277000
*        COME HERE IF STRING LE 256 BYTES LONG                          22278000
*                                                                       22279000
DUPLS    EX    A1+1,DUPLMV        MOVE IN ONE COPY                      22280000
         LA    A2+1,1(A2+1,A1+1)  POINT PAST LAST CHARACTER             22281000
         BCT   A2,DUPLS           LOOP UNTIL ALL COPIES MADE            22282000
*                                                                       22283000
*        LONG STRING DUPL MERGES HERE                                   22284000
*                                                                       22285000
DUPLOUT  LR    A1+1,R1            GET REAL LENGTH OF RESULT             22286000
         BCTR  A1+1,0             GET 360 LENGTH                        22287000
         LR    A1,FR              COPY RESULT ADDRESS                   22288000
         AL    A1,SCODEBT         AND ADD IN TYPE CODE                  22289000
         AH    FR,STLENGTH(,FR)   PUSH CORE POINTER                     22290000
         B     EXIT               RETURN TO CALLER                      22291000
*                                                                       22292000
DUPLMV   MVC   SCHARS(*-*,A2+1),SCHARS(A1)  MOVE IN SMALL STG           22293000
DUPL     ENDFUNC ,                END OF DUPL FUNCTION                  22294000
         TITLE 'SPITBOLF -- ENDFILE FUNCTION'                           22295000
ENDFILE  FUNCTION 1               ENTRY POINT -- ONE ARGUMENT REQUIRED  22296000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         22297000
         BAL   RETURN,GETSTGS     CONVERT TO STRING                     22298000
         XERR  01,065             ARGUMENT TO ENDFILE IS NOT A STRING   22299000
         LA    A1,SCHARS(,A1)     POINT TO ACTUAL FILENAME              22300000
         AH    A1+1,H1            GET REAL LENGTH                       22301000
         BP    *+8                SKIP IF NAME IS NON-NULL              22302000
         XERR  13,042             ARGUMENT TO ENDFILE IS NULL           22303000
         L     R2,=V(SYSDCB)      POINT TO DCB LOCATE ROUTINE           22304000
         BALR  R1,R2              LOCATE DCB                            22305000
         B     SYSERROR           SIGNAL ERROR IF ONE OCCURS            22306000
         L     R2,=V(SYSCLOSE)    ELSE POINT TO CLOSE ROUTINE           22307000
         BALR  R1,R2              CLOSE FILE                            22308000
         B     SYSERROR           GIVE ERROR IF ONE OCCURS              22309000
         B     EXITNULL           ELSE RETURN NULL AS RESULT            22310000
ENDFILE  ENDFUNC                  END OF ENDFILE FUNCTION               22311000
         TITLE 'SPITBOLF -- EVAL FUNCTION'                              22312000
EVAL     FUNCTION  1              NEED ONE ARGUMENT                     22313000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         22314000
         LCR   R0,A1              TEST TYPE                             22315000
         BNM   EXIT               IMMEDIATE RETURN OF ARG IF NUMERIC    22316000
         CLI   TEM#1(PDR),NCODE   IS IT NULL?                           22317000
         BE    EXIT               SUCCEED RETURNING NULL IF NULL ARG    22318000
         CLI   TEM#1(PDR),VCODE   IS IT SIMPLE VARIABLE?                22319000
         BE    EVAL2              JUMP TO TREAT AS READ CALL IF SO      22320000
         CLI   TEM#1(PDR),ECODE   IS IT AN EXPRESSION?                  22321000
         BE    EVAL1              SKIP IF ALREADY AN EXPRESSION         22322000
         BAL   RETURN,GETSTG      ELSE CONVERT ARGUMENT TO STRING       22323000
         B     FAILRL             FAIL IF EVAL ARG NOT AN EXPRESSION    22324000
         L     R1,CODXEQAD        GET ADDRESS OF COMPILER               22325000
         MVI   CODXSW,ECODE       SET TYPE CODE                         22326000
         BALR  RETURN,R1          CALL COMPILER                         22327000
         B     FAILRL             FAIL IF EVAL ARG NOT AN EXPRESSION    22328000
         L     RETURN,RETLOC      RELOAD RETURN POINT IF COMPILED OK    22329000
*                                                                       22330000
*        MERGE HERE WITH EXPRESSION POINTER IN A1                       22331000
*                                                                       22332000
EVAL1    SH    PDR,=Y(STACKSIZ)   PUSH DOWN STACK                       22333000
         STM   FRETURN,RETURN,FRETFLOC(PDR) SAVE RETURN REGISTERS       22334000
         LR    RETURN,A1          SET CODE ARGUMENT FOR $EVAL2          22335000
         CR    DB1,DB2            SET CONDITION CODE NE (EVAL CASE)     22336000
         BAL   R1,$EVAL2          SPECIAL ENTRY IN DEF EXP ROUTINE      22337000
         SR    R1,R1              SET IN CASE OF FAILURE                22338000
         NOPR  R1                 DO NOTHING                            22339000
         LM    FRETURN,RETURN,FRETFLOC(PDR) RESTORE RETURN REGISTERS    22340000
         L     PDR,PDRLOC         POP STACK POINTER AND RESET TO BASE   22341000
         LTR   R1,R1              DID WE FAIL?                          22342000
         BCR   NZ,RETURN          SUCCEED IF NOT                        22343000
         BR    FRETURN            ELSE FAIL                             22344000
*                                                                       22345000
*        COME HERE TO TREAT EVAL(*VARIABLE) AS READ CALL                22346000
*                                                                       22347000
EVAL2    L     PDR,PDRLOC         RESET STACK POINTER                   22348000
         B     $$READ             AND JOIN READ ROUTINE                 22349000
EVAL     ENDFUNC ,                END OF EVAL FUNCTION                  22350000
         TITLE 'SPITBOLF -- FIELD FUNCTION'                             22351000
FIELD    FUNCTION  2              ENTRY POINT -- TWO ARGUMENTS          22352000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         22353000
         BAL   RETURN,GETNAME     LOCATE VARIABLE BLOCK                 22354000
         XERR  01,067             FIRST ARGUMENT TO FIELD IS NOT A NAME 22355000
         LR    A2,A1              IF OK, SAVE POINTER TO VARIABLE BLOCK 22356000
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT        22357000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    22358000
         XERR  01,068             SECOND ARG TO FIELD IS NOT AN INTEGER 22359000
         L     A2+1,VFUNC(,A2)    LOAD FUNCTION POINTER                 22360000
         CLC   FCODE(2,A2+1),PDFBLOKI       IS FUNC FOR PROG DATATYPE?  22361000
         BNE   FAILRL             FAIL IF NOT                           22362000
         CH    A1+1,NFLDSDF(,A2+1)          CHECK FOR NUMBER TOO LARGE  22363000
         BH    FAILRL             FAIL IF SO                            22364000
         SLA   A1+1,2             ELSE MULTIPLY BY FOUR TO INDEX        22365000
         BNP   FAILRL             FAIL IF ZERO OR NEGATIVE              22366000
         L     A1,FLDNPTR-4(A1+1,A2+1)      LOAD NAME POINTER           22367000
         LM    A1,A1+1,VNAME(A1)            LOAD NAME                   22368000
         B     EXIT               RETURN TO CALLER                      22369000
*                                                                       22370000
*        INSTRUCTION TO CHECK FOR PDFBLOK                               22371000
*                                                                       22372000
PDFBLOKI CH    R0,*-*(DB4)        FIRST INSTRUC ON ANY PDFBLOK          22373000
         ORG   *-2                LAST TWO BYTES NOT USED               22374000
*                                                                       22375000
FIELD    ENDFUNC   ,              END OF FIELD FUNCTION                 22376000
         TITLE 'SPITBOLF -- INPUT FUNCTION'                             22377000
INPUT    FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED    22378000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         22379000
         BAL   RETURN,GETNAME     LOCATE NAME BLOCK                     22380000
         XERR  01,069             FIRST ARG TO INPUT IS NOT THE NAME    22381000
*                                 OF A NATURAL VARIABLE                 22382000
         NI    VFLAGS(A1),X'FF'-VINA        RESET IN CASE ERROR         22383000
         TM    VFLAGS(A1),VINP    HAVE THE BALRS ALREADY BEEN SET?      22384000
         BO    INPUT2             SKIP IF YES                           22385000
         L     DB4,AIOASSOC       GET ADDR OF ROUTINE TO INSERT THEM    22386000
         LA    DB3,INFLAG         SET FLAG FOR INPUT CALL               22387000
         BALR  RETURN,DB4         AND CALL IT                           22388000
*                                                                       22389000
*        COME HERE WHEN INTERCEPTS HAVE BEEN SET FOR THIS VARIABLE      22390000
*                                                                       22391000
INPUT2   BALR  DB4,0              SET UP BASE REGISTER                  22392000
         USING *,DB4              TELL ASSEMBLER                        22393000
         CE    ZR,VIOPTR(,A1)     DO WE ALREADY HAVE AN IOBLOK?         22394000
         BNE   INPUT3             SKIP IF YES                           22395000
         LA    R1,IOBSIZE(,FR)    SEE WHERE FREE CORE WILL END UP       22396000
         CR    R1,PDR             DO WE NEED A COLLECT?                 22397000
         BNL   GBGCLF             EXIT IF COLLECT NEEDED                22398000
         IC    R0,VIOPTR(,A1)     SAVE POSSIBLE FLAG BYTE               22399000
         ST    FR,VIOPTR(,A1)     AND SAVE ADDR OF NEW BLOCK            22400000
         STC   R0,VIOPTR(,A1)     RESTORE FLAG BYTE                     22401000
         XC    0(IOBSIZE,FR),0(FR)          CLEAR OUT AREA FOR IOBLOCK  22402000
         MVI   0(FR),IOBLOK       SET DTYPE                             22403000
         LR    FR,R1              UPDATE FREE CORE ADDRESS              22404000
         EJECT                                                          22405000
*                                                                       22406000
*        COME HERE WITH IO BLOCK SET UP                                 22407000
*                                                                       22408000
INPUT3   L     A2,VIOPTR(,A1)     GET POINTER TO IOBLOK                 22409000
         LR    A2+1,A1            SAVE VARIABLE BLOCK ADDRESS           22410000
         LM    A1,A1+1,TEM#2(PDR) GET SECOND ARG TO INPUT               22411000
         BAL   RETURN,GETSTGS     AND GET A STRING FOR THE FILE NAME    22412000
         XERR  01,070             FILE NAME (SECOND ARGUMENT) FOR       22413000
*                                 INPUT CALL IS NOT A STRING            22414000
         LA    A1,SCHARS(,A1)     POINT TO FIRST CHARACTER IN NAME      22415000
         AH    A1+1,H1            GET REAL LENGTH AND TEST FOR NULL     22416000
         L     R0,READDCB         POINT TO STANDARD INPUT FILE IN CASE  22417000
         BZ    INPUT4             SKIP IF NULL TO USE STANDARD INPUT    22418000
*                                                                       22419000
*        HERE WE CALL SYSDCB TO GET THE PTR FOR A NON-NULL FILENAME     22420000
*                                                                       22421000
         L     R2,VOPEN           GET ADDR OF OPEN ROUTINE              22422000
         BALR  R1,R2              CALL IT                               22423000
         B     SYSERROR           ERROR RETURN IF COME HERE             22424000
*                                                                       22425000
*        MERGE HERE WITH DCB POINTER IN (R0)                            22426000
*                                                                       22427000
INPUT4   ST    R0,IFILE(,A2)      SAVE POINTER TO FILE                  22428000
         LM    A1,A1+1,TEM#3(PDR) GET FORMAT ARGUMENT                   22429000
         BAL   RETURN,GETINT      CONVERT IT TO AN INTEGER              22430000
         XERR  01,071             FORMAT SPECIFICATION (THIRD ARGUMENT) 22431000
*                                 FOR INPUT FUNCTION IS NOT AN INTEGER  22432000
         STM   A1,A1+1,IFORMAT(A2)          SAVE THE FORMAT             22433000
         OI    VFLAGS(A2+1),VINA+VINP       SET INPUT ACTIVE FLAGS      22434000
         B     EXITNULL           RETURN NULL AS RESULT                 22435000
*                                                                       22436000
INPUT    ENDFUNC   ,              END OF INPUT FUNCTION                 22437000
         TITLE 'SPITBOLF -- ITEM FUNCTION'                              22438000
*                                                                       22439000
*        NOTE -- THIS FUNCTION IS REALLY REDUNDANT IN SPITBOL SINCE     22440000
*                                                                       22441000
*        ITEM(EXPR,A,B,C...                                             22442000
*                                                                       22443000
*        CAN ALWAYS BE REPLACED WITH --                                 22444000
*                                                                       22445000
*        EXPR<A,B,C...                                                  22446000
*                                                                       22447000
*        FOR EXAMPLE --           A<B><C>                               22448000
*                                                                       22449000
*        ITEM IS INCLUDED SOLELY FOR COMPATABILITY                      22450000
*                                                                       22451000
ITEM     FUNCTION  2,N            ENTRY POINT -- AT LEAST TWO ARGS      22452000
         MVI   NAMEFL,X'FF'       TENTATIVELY SET FOR CALL BY VALUE     22453000
         CLC   0(4,RETURN),BFRVN  CHECK FOR B $$FRVN (CALL BY NAME)     22454000
         BNE   ITEM1              SKIP IF BY VALUE                      22455000
         LA    RETURN,4(,RETURN)  ELSE BUMP RETURN PAST BRANCH          22456000
         MVI   NAMEFL,0           AND SET FLAG FOR BY NAME              22457000
*                                                                       22458000
*        NAME, VALUE CASES MERGE HERE                                   22459000
*                                                                       22460000
ITEM1    CH    R0,H2              CHECK NUMBER OF ARGUMENTS             22461000
         BH    ITEMM              SKIP ON MULTI-DIMENSIONAL CASE        22462000
*                                                                       22463000
*        HERE FOR ONE DIMENSIONAL CASE                                  22464000
*                                                                       22465000
         LM    A1,A2+1,TEM#2(PDR) LOAD ARRAY AND SUBSCRIPT VALUES       22466000
         L     PDR,PDRLOC         RESTORE PDR (NOT DONE IN 1-D ROUTINE) 22467000
         L     R2,SUBSC1AD        LOAD ADDRESS OF 1-D ARRAY ROUTINE     22468000
         BR    R2                 AND JUMP TO IT                        22469000
*                                                                       22470000
*        HERE FOR MULTI-DIMENSIONAL CASE                                22471000
*                                                                       22472000
ITEMM    LM    A1,A1+1,TEM#1(PDR) LOAD ARRAY VALUE                      22473000
         SH    PDR,H8             POINT TO SUBSCRIPTS (PUSH STACK)      22474000
         L     A2,SUBSCMAD        LOAD MULTI-DIM ARRAY ROUTINE ADDRESS  22475000
         BCTR  R0,A2              GET COUNT OF SUBS, JUMP TO ROUTINE    22476000
*                                                                       22477000
ITEM     ENDFUNC   ,              END OF ITEM FUNCTION                  22478000
         TITLE 'SPITBOLF -- LOAD FUNCTION'                              22479000
LOAD     FUNCTION  1              ENTRY POINT -- ONE ARGUMENT REQUIRED  22480000
         BAL   A2+1,XSCANI        INITIALIZE SCAN, SET SCAN BASE REG    22481000
         XERR  01,072             ARGUMENT TO LOAD IS NOT A STRING      22482000
         XERR  13,043             ARGUMENT TO LOAD IS NULL              22483000
         MVC   0(12,FR),LFBKMOD   MOVE EFBLOK MODEL TO FREE CORE        22484000
         MVI   ZTBL+C'(',1        SET FOR STOP ON LEFT PARENTHESIS      22485000
         BALR  RETURN,A2          SCAN OUT LOAD FUNCTION NAME           22486000
         XERR  13,044             FUNCTION NAME IN ARGUMENT TO LOAD     22487000
*                                 IS NULL                               22488000
         XERR  13,045             MISSING ( IN ARGUMENT TO LOAD         22489000
         MVI   ZTBL+C'(',0        NO LONGER STOP ON LEFT PAREN          22490000
         ST    A1,EFNAME(,FR)     SAVE VBLOK ADDRESS IN EFBLOK          22491000
         MVI   ZTBL+C',',LDARG-F$LOAD       STOP ON COMMA, PROPER BR    22492000
         MVI   ZTBL+C')',LDARGEND-F$LOAD    STOP ON RP, PROPER BRANCH   22493000
         OI    XSCANFLG,XSIGNGN   STOP GETNAME CALLS                    22494000
         LR    DB3,FR             INITIALIZE TO START OF CONVERT CHARS  22495000
*                                                                       22496000
*        THIS LOCATION IS ENTERED TO SCAN OUT AN ARGUMENT TYPE          22497000
*                                                                       22498000
LDARG    BALR  RETURN,A2          SCAN OUT NEXT ENTRY                   22499000
         B     LDNOCVT            IF NULL ENTRY, NO CONVERT             22500000
         XERR  13,046             MISSING ) IN ARGUMENT TO LOAD         22501000
*                                                                       22502000
*        COME HERE WITH STRING SPECIFIER FOR ARGUMENT TYPE              22503000
*                                                                       22504000
         BAL   RETURN,GETSTGS     CONVERT TO ACTUAL NAME/ 360 LENGTH    22505000
         NOP   0                  IMPOSSIBLE RETURN                     22506000
         LA    RETURN,4           SET TO NUMBER OF TABLE ENTRIES        22507000
         LA    DB2,LOADSTBL       POINT TO START OF TABLE               22508000
*                                                                       22509000
*        LOOP THROUGH POSSIBLE ENTRIES                                  22510000
*                                                                       22511000
LOADARGL CH    A1+1,0(,DB2)       DOES LENGTH MATCH?                    22512000
         BNE   LOADARGE           SKIP IF NOT                           22513000
         EX    A1+1,LOADARGC      CHECK FOR MATCH OF CHARS IF SO        22514000
         BE    LOADARGF           JUMP IF ENTRY FOUND                   22515000
*                                                                       22516000
*        HERE TO MOVE TO NEXT TABLE ENTRY                               22517000
*                                                                       22518000
LOADARGE LA    DB2,12(,DB2)       BUMP TO NEXT ENTRY                    22519000
         BCT   RETURN,LOADARGL    LOOP BACK IF MORE ENTRIES TO CHECK    22520000
*                                                                       22521000
*        HERE IF NO CONVERSION REQUIRED                                 22522000
*                                                                       22523000
LDNOCVT  LA    DB2,LDNOCVTA-2     POINT TO TABLE ENTRY FOR NO CONVERT   22524000
*                                                                       22525000
*        MERGE HERE WITH (DB2) POINTING TO APPROPRIATE TABLE ENTRY      22526000
*                                                                       22527000
LOADARGF TM    XSCANFLG,XSIGNRO   ARE WE SCANNING RESULT OR ARG?        22528000
         BO    LOADARGR           JUMP IF SCANNING RESULT               22529000
         EJECT                                                          22530000
*                                                                       22531000
*        COME HERE IF WE JUST SCANNED AN ARGUMENT                       22532000
*                                                                       22533000
         MVC   EFTARGS(1,DB3),2(DB2)        SET ARG CONVERT BYTE        22534000
         LA    DB3,1(,DB3)        INCREMENT ARGUMENT BYTE POINTER       22535000
         B     F$LOAD(A2+1)       JUMP (LDARG IF , LDARGEND IF )  )     22536000
*                                                                       22537000
*        HERE AFTER ENCOUNTERING ) ENDING LAST ARGUMENT TYPE            22538000
*                                                                       22539000
LDARGEND OI    XSCANFLG,XSIGNRO   SET TO ALLOW RUNOUT FOR RESULT TYPE   22540000
         MVI   ZTBL+C')',0        CLEAR SCAN TABLE ENTRIES              22541000
         MVI   ZTBL+C',',0        . . . .                               22542000
         B     LDARG              LOOP BACK TO SCAN RESULT TYPE         22543000
*                                                                       22544000
*        HERE AFTER SCANNING OUT RESULT TYPE                            22545000
*                                                                       22546000
LOADARGR MVC   EFTRSL(1,FR),3(DB2)          SET RESULT CONVERT BYTE     22547000
         SR    DB3,FR             GET NUMBER OF ARGUMENTS               22548000
         STH   DB3,EFNARGS(,FR)   STORE NUMBER OF ARGUMENTS             22549000
         CH    DB3,=H'64'         TOO MANY ARGUMENTS?                   22550000
         BNH   *+8                SKIP IF OK (64 OR FEWER ARGS)         22551000
         XERR  13,047             TOO MANY ARGUMENTS (MORE THAN 64)     22552000
*                                 IN FUNCTION TO BE LOADED              22553000
         LA    DB3,EFTARGS+BOUND(,DB3)      GET BLOCK LENGTH FUDGED UP  22554000
         N     DB3,FULLWRD        ADJUST TO FULLWORD                    22555000
         STH   DB3,EFLENG(,FR)    STORE LENGTH OF EFBLOK                22556000
         AR    DB3,FR             FIND HWERE FR WILL END UP             22557000
         CR    DB3,PDR            WILL THERE BE ROOM?                   22558000
         BNL   GBGCLF             GARBAGE COLLECT IF NOT                22559000
         L     A1,EFNAME(,FR)     LOAD POINTER TO VAR BLOCK FOR FUNC    22560000
         L     A1+1,=A($$NOFN-FCODE)        POINT TO UNDEFINED FUNC     22561000
         BAL   RETURN,OPSYN$      UNDEFINE FUNC (POSSIBLE UNLOAD)       22562000
         LR    A2,A1              AND COPY VAR BLOCK ADDRESS            22563000
         L     A1,VNAME(,A2)      LOAD NAME POINTER                     22564000
         AH    A1,VNAME+SOFFSET(,A2)        ADD OFFSET                  22565000
         LA    A1,SCHARS(,A1)     ADJUST FOR STANDARD OFFSET            22566000
         LH    A1+1,VNAME+SLENGTH(,A2)      LOAD 360 LENGTH OF NAME     22567000
         LA    A1+1,1(,A1+1)      ADJUST TO PROPER LENGTH               22568000
         L     R2,=V(SYSLOAD)     POINT TO SYSTEM LOAD ROUTINE          22569000
         BALR  R1,R2              CALL SYSTEM LOAD ROUTINE              22570000
         B     SYSERROR           SIGNAL ERROR IF WE GET ONE            22571000
         ST    R0,EFCODE(,FR)     IF LOAD OK, STORE CODE ADDRESS        22572000
         MVI   EFUSE(FR),0        SET USE COUNT = 0 (OPSYN SETS TO 1)   22573000
         LR    A1,A2              COPY VARIABLE BLOCK ADDRESS           22574000
         LR    A1+1,FR            COPY FUNCTION BLOCK ADDRESS           22575000
         BAL   RETURN,OPSYN$      CALL SYSTEM OPSYN ROUTINE             22576000
         LR    FR,DB3             SET NEW FREE REG PAST EFBLOK          22577000
         LM    DB2,DB3,$$BAS2     RELOAD STANDARD DATA BASE REGS        22578000
         B     EXITNULL           LOAD NULL AS RETURNED RESULT          22579000
*                                                                       22580000
LOADARGC CLC   SCHARS(*-*,A1),4(DB2)        CHECK FOR MATCH ON NAME     22581000
         EJECT                                                          22582000
*                                                                       22583000
*        MODEL BLOCK FOR CONSTRUCTION OF EFBLOK                         22584000
*                                                                       22585000
LFBKMOD  DC    AL1(EFBLOK)        TYPE CODE                             22586000
         DC    AL3(0)             GARBAGE COLLECTOR FIELD               22587000
         DC    Y(0,0)             EFNARGS, EFLENG                       22588000
         B     $$LOAD             INITIAL INSTRUCTION                   22589000
*                                                                       22590000
*        TABLE TO SCAN DATATYPE NAMES                                   22591000
*                                                                       22592000
*        THE FORMAT IS AS FOLLOWS --                                    22593000
*                                                                       22594000
*        BYTES 1,2                360 LENGTH OF NAME                    22595000
*        BYTE 3                   CONVERT BYTE FOR ARGUMENT             22596000
*        BYTE 4                   CONVERT BYTE FOR RESULT               22597000
*        BYTES 5-12               CHARACTERS OF NAME (LEFT JUSTIFIED)   22598000
*                                                                       22599000
LOADSTBL DC    Y(4-1)             360 LENGTH OF 'REAL'                  22600000
         DC    AL1(LOADRL-LOADCL,LOADRRL-LOADRTNS)                      22601000
         DC    CL8'REAL'                                                22602000
*                                                                       22603000
         DC    Y(5-1)             360 LENGTH OF 'DREAL'                 22604000
         DC    AL1(LOADDR-LOADCL,LOADRDR-LOADRTNS)                      22605000
         DC    CL8'DREAL'                                               22606000
*                                                                       22607000
         DC    Y(7-1)             360 LENGTH OF 'INTEGER'               22608000
         DC    AL1(LOADIN-LOADCL,LOADRIN-LOADRTNS)                      22609000
         DC    CL8'INTEGER'                                             22610000
*                                                                       22611000
         DC    Y(6-1)             360 LENGTH OF 'STRING'                22612000
         DC    AL1(LOADST-LOADCL,LOADRST-LOADRTNS)                      22613000
         DC    CL8'STRING'                                              22614000
*                                                                       22615000
*        TABLE ENTRY FOR NO CONVERT (ONLY NEED TYPE BYTES)              22616000
*                                                                       22617000
LDNOCVTA DC    AL1(LOADCNC-LOADCL,LOADRNC-LOADRTNS)                     22618000
*                                                                       22619000
LOAD     ENDFUNC ,                END OF LOAD FUNCTION                  22620000
         TITLE 'SPITBOLF -- LOCAL FUNCTION'                             22621000
LOCAL    FUNCTION  2              ENTRY POINT -- TWO ARGS REQUIRED      22622000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         22623000
         BAL   RETURN,GETNAME     LOCATE VARIABLE BLOCK                 22624000
         XERR  01,073             FIRST ARGUMENT TO LOC IS NOT A NAME   22625000
         LR    A2,A1              IF OK, SAVE VARIABLE BLOCK POINTER    22626000
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT        22627000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    22628000
         XERR  01,074             SECOND ARGUMENT TO LOC NOT AN INTEGER 22629000
         L     A2+1,VFUNC(,A2)    LOAD FUNCTION POINTER                 22630000
         CLC   FCODE(4,A2+1),FBLOKI         IS FUNC PROGRAM DEFINED?    22631000
         BNE   FAILRL             FAIL IF NOT                           22632000
         CH    A1+1,FNLOCS(,A2+1)           IS COUNT TOO LARGE?         22633000
         BH    FAILRL             FAIL IF SO                            22634000
         SLA   A1+1,2             MULTIPLY COUNT BY FOUR                22635000
         BNP   FAILRL             FAIL IF ZERO OR NEGATIVE              22636000
         LH    R0,FNARGS(,A2+1)   PICK UP NUMBER OF ARGS                22637000
         AR    R0,R0              *2                                    22638000
         AR    R0,R0              *4                                    22639000
         AR    A1+1,R0            ADD IN OFFSET FOR ARGS                22640000
         L     A1,FARGS-4(A2+1,A1+1)        LOAD LOCAL POINTER          22641000
         LM    A1,A1+1,VNAME(A1)  LOAD ITS NAME                         22642000
         B     EXIT               RETURN TO CALLER                      22643000
LOCAL    ENDFUNC   ,              END OF LOCAL FUNCTION                 22644000
         TITLE 'SPITBOLF -- LPAD FUNCTION'                              22645000
LPAD     FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED    22646000
         LM    A1,A1+1,TEM#3(PDR)           LOAD THIRD ARGUMENT         22647000
         BAL   RETURN,GETSTGS     CONVERT TO STRING SPECIFIER           22648000
         XERR  01,075             THIRD ARG TO LPAD NOT A STRING        22649000
         MVI   PADCHAR,C' '       PROVISIONALLY SET BLANK AS PAD CHAR   22650000
         LTR   A1+1,A1+1          TEST FOR NO THIRD ARG (NULL)          22651000
         BM    *+10               SKIP IF NULL (BLANK IS DEFAULT)       22652000
         MVC   PADCHAR(1),SCHARS(A1)        ELSE ACQUIRE PAD CHARACTER  22653000
         LM    A1,A1+1,TEM#2(PDR)           NOW GET SECOND ARGUMENT     22654000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    22655000
         XERR  01,076             SECOND ARG TO LPAD IS NOT AN INTEGER  22656000
         C     A1+1,V$MAXLN       IS STRING TOO LONG?                   22657000
         BNH   *+8                SKIP IF OK                            22658000
         XERR  11,011             LPAD CALL RESULTS IN A STRING LONGER  22659000
*                                 THAN &MAXLNGTH CHARACTERS             22660000
         LR    A2,A1+1            SAVE INTEGER LENGTH IN A2             22661000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         22662000
         BAL   RETURN,GETSTGS     GET A TEMPORARY STRING                22663000
         XERR  01,077             FIRST ARGUMENT TO LPAD NOT A STRING   22664000
*                                                                       22665000
*        CHECK FOR SPECIAL CASE OF NULL PADDED TO LENGTH ZERO           22666000
*                                                                       22667000
         LTR   A1+1,A1+1          IS STRING NULL?                       22668000
         BNM   LPAD1              SKIP IF NOT                           22669000
         LTR   A2,A2              IF STRING IS NULL, IS PAD LENGTH 0?   22670000
         BZ    LPAD1A             JUMP TO RETURN NULL ARG IF SO         22671000
         LA    A1,PADCHAR-SCHARS  ELSE SET TO USE PAD CHAR AS ARG       22672000
         SR    A1+1,A1+1          SET LENGTH AS ONE CHAR                22673000
*                                                                       22674000
*        COME HERE TO PERFORM ACTUAL PAD OPERATION                      22675000
*                                                                       22676000
LPAD1    STE   ZR,0(,FR)          PREPARE DTYPE=SCODE=0, GCOLPTR=0      22677000
         LA    R1,SCHARS+BOUND(,A2)         CALCULATE SBLOK LENGTH      22678000
         N     R1,FULLWRD         ADJUST TO FULL WORD BOUNDARY          22679000
         STH   R1,STLENGTH(,FR)   STORE AS SBLOK LENGTH                 22680000
         AR    R1,FR              SEE WHERE FR WILL END UP              22681000
         CR    R1,PDR             WILL WE HAVE ENOUGH ROOM              22682000
         BNL   GBGCLF             GARBAGE COLLECT & TRY AGAIN IF NOT    22683000
         BCTR  A2,0               ADJUST TOTAL COUNT FOR 360            22684000
         LR    R2,A2              SAVE LENGTH OF NEW STRING             22685000
         LR    A2+1,FR            SAVE START OF NEW SBLOK               22686000
         LA    R0,256             GET LOOP CRANK CONSTANT               22687000
         SR    A2,A1+1            GET REAL NUMBER OF PAD CHARACTERS     22688000
         BNM   LPADPL             SKIP IF PADDING TO BE DONE            22689000
*                                                                       22690000
*        MERGE HERE TO RETURN FIRST ARG AS RESULT                       22691000
*                                                                       22692000
LPAD1A   LM    A1,A1+1,TEM#1(PDR) RELOAD FIRST ARG                      22693000
         B     EXIT               RETURN TO CALLER                      22694000
         EJECT                                                          22695000
*                                                                       22696000
*        LOOP TO PAD 256 CHARS AT A TIME                                22697000
*                                                                       22698000
LPADPL   MVC   SCHARS(1,FR),PADCHAR         MOVE IN FIRST PAD CHAR      22699000
         CR    A2,R0              HOW MANY TO GO?                       22700000
         BL    LPADPE             SKIP IF 256 OR LESS                   22701000
         MVC   SCHARS+1(256,FR),SCHARS(FR)  PROPOGATE 256 CHARS         22702000
         SR    A2,R0              CRANK COUNT DOWN                      22703000
         BXLE  FR,R0,LPADPL       BUMP PTR & LOOP (FR < R1)             22704000
*                                                                       22705000
*        COME HERE TO PROPOGATE LAST CHUNK                              22706000
*                                                                       22707000
LPADPE   EX    A2,LPADPP          PROPOGATE REMAINING CHARS             22708000
         AR    FR,A2              BUMP DESTINATION POINTER              22709000
*                                                                       22710000
*        HERE TO COPY 256 CHAR CHUNKS OF STRING INTO NEW SBLOK          22711000
*                                                                       22712000
LPADSL   CR    A1+1,R0            HOW MANY CHARS LEFT?                  22713000
         BL    LPADSE             SKIP IF 256 OR LESS                   22714000
         MVC   SCHARS(256,FR),SCHARS(A1)    ELSE MOVE 256 CHARS         22715000
         AR    A1,R0              BUMP SOURCE POINTER                   22716000
         SR    A1+1,R0            DECREASE COUNT                        22717000
         BXLE  FR,R0,LPADSL       CRANK DESTIN PTR & LOOP (FR<R1)       22718000
*                                                                       22719000
*        COME HERE TO COPY LAST CHUNK (256 CHARS OR LESS)               22720000
*                                                                       22721000
LPADSE   EX    A1+1,LPADSMV       MOVE LAST CHARACTERS                  22722000
*                                                                       22723000
*        EXIT POINT                                                     22724000
*                                                                       22725000
LPADX    LR    FR,R1              SET NEW FREE POINTER                  22726000
         LR    A1,A2+1            RECALL START OF SBLOK                 22727000
         AL    A1,SCODEBT         SUPPLY STRING TYPE BYTE               22728000
         LR    A1+1,R2            RECALL SLENGTH                        22729000
         B     EXIT               RETURN TO CALLER                      22730000
*                                                                       22731000
LPADPP   MVC   SCHARS+1(*-*,FR),SCHARS(FR)  PROP LAST CHARS + 2 EXTRA   22732000
LPADSMV  MVC   SCHARS(*-*,FR),SCHARS(A1)    MOVE LAST CHARS IN COPY     22733000
LPAD     ENDFUNC                  END OF LPAD FUNCTION                  22734000
         TITLE 'SPITBOLF -- OPSYN FUNCTION'                             22735000
OPSYN    FUNCTION  3              ENTRY POINT -- THREE ARGS             22736000
         LM    A1,A1+1,TEM#2(PDR) LOAD OPSYN SECOND ARGUMENT            22737000
         BAL   RETURN,GETNAME     CONVERT TO A NAME                     22738000
         XERR  01,079             SECOND ARGUMENT TO OPSYN IS NOT A     22739000
*                                 LEGAL FUNCTION NAME                   22740000
         LR    A2,A1              SAVE FUNCTION ADDRESS                 22741000
         LM    A1,A1+1,TEM#3(PDR) LOAD THIRD ARGUMENT                   22742000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    22743000
         B     OPSYNF             JUMP FOR NORMAL OPSYN IF NOT INTEGER  22744000
         CH    A1+1,H1            ELSE TEST FOR UNARY OPERATOR OPSYN    22745000
         BE    OPSYNU             SKIP IF SO                            22746000
         CH    A1+1,H2            ELSE TEST FOR BINARY OPERATOR OPSYN   22747000
         BNE   OPSYNF             NORMAL FUNCTION OPSYN IF NOT          22748000
*                                                                       22749000
*        HERE FOR BINARY OPERATOR OPSYN                                 22750000
*                                                                       22751000
         BAL   A2+1,OPSYNO        JUMP TO MERGE POINT, SETTING TBL ADDR 22752000
*                                                                       22753000
*        CONTROL TABLE FOR REDEFINABLE BINARY OPERATORS                 22754000
*                                                                       22755000
         DC    AL1(C'',$$NOT2-OPTRTABL)    BINARY                     22756000
         DC    AL1(C'?',$$QUS2-OPTRTABL)    BINARY ?                    22757000
         DC    AL1(C'%',$$PCT2-OPTRTABL)    BINARY %                    22758000
         DC    AL1(C'#',$$PND2-OPTRTABL)    BINARY #                    22759000
         DC    AL1(C'@',$$ATS2-OPTRTABL)    BINARY @                    22760000
         DC    AL1(C'&&',$$AMP2-OPTRTABL)   BINARY &                    22761000
         DC    X'0000'            END OF TABLE MARKER                   22762000
*                                                                       22763000
*        HERE FOR UNARY OPERATOR OPSYN                                  22764000
*                                                                       22765000
OPSYNU   BAL   A2+1,OPSYNO        JUMP TO MERGE POINT, SETTING TBL ADDR 22766000
*                                                                       22767000
*        CONTROL TABLE FOR REDEFINABLE UNARY OPERATORS                  22768000
*                                                                       22769000
         DC    AL1(C'!',$$EXC1-OPTRTABL)    UNARY EXCLAMATION           22770000
         DC    AL1(C'%',$$PCT1-OPTRTABL)    UNARY %                     22771000
         DC    AL1(C'/',$$SLS1-OPTRTABL)    UNARY /                     22772000
         DC    AL1(C'#',$$PND1-OPTRTABL)    UNARY #                     22773000
         DC    AL1(C'|',$$BAR1-OPTRTABL)    UNARY |                     22774000
         DC    X'0000'            END OF TABLE MARKER                   22775000
*                                                                       22776000
*        MERGE POINT TO UNARY AND BINARY OPERATOR OPSYN                 22777000
*                                                                       22778000
OPSYNO   LM    A1,A1+1,TEM#1(PDR) LOAD FIRST ARGUMENT                   22779000
         BAL   RETURN,GETSTGS     CONVERT TO (TEMPORARY) STRING         22780000
         B     OPSYNF             NORMAL CIRCUIT IF NOT A STRING        22781000
         LTR   A1+1,A1+1          TEST 360 LENGTH                       22782000
         BNZ   OPSYNF             NORMAL CIRCUIT IF NOT ONE CHARACTER   22783000
         EJECT                                                          22784000
*                                                                       22785000
*        LOOP TO SEARCH FOR ENTRY IN OPERATOR CONTROL TABLE             22786000
*                                                                       22787000
OPSYNL   CLC   0(1,A2+1),SCHARS(A1)         IS THIS A MATCH?            22788000
         BE    OPSYNM             SKIP IF SO                            22789000
         LA    A2+1,2(,A2+1)      ELSE BUMP TABLE POINTER               22790000
         CLI   0(A2+1),0          CHECK FOR END OF TABLE                22791000
         BNE   OPSYNL             LOOP BACK IF MORE ENTRIES TO CHECK    22792000
         B     OPSYNF             ELSE NOT FOUND, DO NORMAL FUNC OPSYN  22793000
*                                                                       22794000
*        HERE WHEN WE FIND THE TABLE ENTRY                              22795000
*                                                                       22796000
OPSYNM   SR    A1,A1              PREPARE FOR IC                        22797000
         IC    A1,1(,A2+1)        LOAD ENTRY OFFSET IN OPTRTABL         22798000
         LA    A1,OPTRTABL-VFUNC(A1)        MAKE A DUMMY VBLOK POINTER  22799000
         B     OPSYNS             JUMP TO PERFORM OPSYN                 22800000
*                                                                       22801000
*        HERE FOR NORMAL FUNCTION OPSYN                                 22802000
*                                                                       22803000
OPSYNF   LM    A1,A1+1,TEM#1(PDR) LOAD FIRST ARGUMENT                   22804000
         BAL   RETURN,GETNAME     CONVERT TO NAME                       22805000
         XERR  01,078             FIRST ARGUMENT TO OPSYN IS NOT A      22806000
*                                 LEGAL FUNCTION NAME                   22807000
*                                                                       22808000
*        MERGE HERE TO PERFORM ACTUAL OPSYN                             22809000
*                                                                       22810000
OPSYNS   L     A1+1,VFUNC(,A2)    LOAD FUNCTION POINTER TO BE COPIED    22811000
         BAL   RETURN,OPSYN$      PERFORM OPSYN                         22812000
         B     EXITNULL           RETURN NULL AS RESULT                 22813000
OPSYN    ENDFUNC   ,              END OF OPSYN FUNCTION                 22814000
         TITLE 'SPITBOLF -- OUTPUT FUNCTION'                            22815000
OUTPUT   FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED    22816000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         22817000
         BAL   RETURN,GETNAME     LOCATE VARIABLE BLOCK                 22818000
         XERR  01,080             FIRST ARG TO OUTPUT IS NOT A NAME     22819000
         NI    VFLAGS(A1),X'FF'-VOUA        TURN OFF ACTIVE IN CASE ERR 22820000
         TM    VFLAGS(A1),VOUP    HAVE THE INTERCEPTS BEEN POSTED?      22821000
         BO    OUTPUT2            SKIP IF YES                           22822000
         L     DB4,AIOASSOC       GET ADDR OF ROUTINE TO INSERT THEM    22823000
         LA    DB3,OUTFLAG        SET FLAG FOR OUTPUT CALL              22824000
         BALR  RETURN,DB4         AND CALL ROUTINE TO SET THEM          22825000
*                                                                       22826000
*        COME HERE WHEN INTERCEPTS HAVE BEEN SET FOR THIS VARIABLE      22827000
*                                                                       22828000
OUTPUT2  BALR  DB4,0              SET UP BASE REGISTER                  22829000
         USING *,DB4              TELL ASSEMBLER                        22830000
         CE    ZR,VIOPTR(,A1)     DO WE ALREADY HAVE AN IOBLOK?         22831000
         BNE   OUTPUT3            SKIP IF YES                           22832000
         LA    R1,IOBSIZE(,FR)    SEE WHERE FREE CORE WILL END UP       22833000
         CR    R1,PDR             DO WE NEED A COLLECT?                 22834000
         BNL   GBGCLF             EXIT IF COLLECT NEEDED                22835000
         IC    R0,VIOPTR(,A1)     SAVE POSSIBLE FLAG BYTE               22836000
         ST    FR,VIOPTR(,A1)     STORE ADDRESS OF NEW IOBLOK           22837000
         STC   R0,VIOPTR(,A1)     RESTORE FLAG BYTE                     22838000
         XC    0(IOBSIZE,FR),0(FR)          CLEAR OUT AREA FOR IOBLOK   22839000
         MVI   0(FR),IOBLOK       SET DATA BLOCK TYPE CODE FOR IOBLOK   22840000
         LR    FR,R1              UPDATE FREE CORE ADDRESS              22841000
         EJECT                                                          22842000
*                                                                       22843000
*        COME HERE WITH IOBLOK SET UP                                   22844000
*                                                                       22845000
OUTPUT3  L     A2,VIOPTR(,A1)     LOAD IOBLOK ADDRESS                   22846000
         LR    A2+1,A1            SAVE VARIABLE BLOCK ADDRESS           22847000
         LM    A1,A1+1,TEM#2(PDR) GET SECOND ARG TO OUTPUT              22848000
         BAL   RETURN,GETSTGS     AND GET A STRING FOR THE FILE NAME    22849000
         XERR  01,081             FILE NAME (SECOND ARGUMENT) FOR       22850000
*                                 OUTPUT CALL IS NOT A STRING           22851000
         LA    A1,SCHARS(,A1)     POINT TO FIRST CHARACTER OF NAME      22852000
         L     R0,PRINTDCB        LOAD PTR TO PRINT FILE IN CASE        22853000
         AH    A1+1,H1            GET REAL LENGTH + TEST FOR NULL       22854000
         BZ    OUTPUT4            IF NULL, SKIP TO USE PRINT FILE       22855000
*                                                                       22856000
*        HERE WE CALL SYSDCB TO GET THE PTR FOR A NON-NULL FILENAME     22857000
*                                                                       22858000
         L     R2,VOPEN           GET ADDRESS OF OPEN ROUTINE           22859000
         BALR  R1,R2              CALL ROUTINE TO LOCATE FILE POINTER   22860000
         B     SYSERROR           GIVE ERROR IF ERROR IN FILENAME       22861000
*                                                                       22862000
*        MERGE HERE WITH FILE (DCB) POINTER IN (R0)                     22863000
*                                                                       22864000
OUTPUT4  ST    R0,OFILE(,A2)      SAVE POINTER IN IOBLOK                22865000
         LM    A1,A1+1,TEM#3(PDR) GET FORMAT ARGUMENT                   22866000
         BAL   RETURN,GETSTG      CONVERT TO A STRING                   22867000
         XERR  01,082             FORMAT SPECIFICATION (THIRD ARGUMENT) 22868000
*                                 FOR OUTPUT FUNCTION IS NOT A STRING   22869000
         STM   A1,A1+1,OFORMAT(A2)          SAVE THE FORMAT             22870000
         OI    VFLAGS(A2+1),VOUP+VOUA       SET ACTIVE OUTPUT FLAGS     22871000
         B     EXITNULL           RETURN NULL AS RESULT                 22872000
*                                                                       22873000
OUTPUT   ENDFUNC ,                END OF OUTPUT FUNCTION                22874000
         TITLE 'SPITBOLF -- PROTOTYPE FUNCTION'                         22875000
PROTOTYP FUNCTION  1              ENTRY POINT -- ONE ARG REQUIRED       22876000
         L     A1,TEM#1(,PDR)     LOAD ARGUMENT POINTER                 22877000
         CLI   TEM#1(PDR),ACODE   CHECK FOR ARRAY ARGUMENT              22878000
         BE    PROARRAY           OFF TO GET ARRAY PROTOTYPE IF ARRAY   22879000
         CLI   TEM#1(PDR),TCODE   ELSE IT MUST BE A TABLE               22880000
         BE    *+10               SKIP OVER ERROR MSG IF TABLE          22881000
         XERR  01,083             ARGUMENT TO PROTOTYPE FUNCTION IS NOT 22882000
*                                 A TABLE OR AN ARRAY                   22883000
         L     A1+1,TBDIVIDE(,A1) LOAD NUMBER OF SLOTS*4                22884000
         SRL   A1+1,2             GET NUMBER OF SLOTS                   22885000
         SR    A1,A1              INDICATE INTEGER RESULT               22886000
         B     EXIT               RETURN TO CALLER                      22887000
*                                                                       22888000
*        COME HERE TO LOAD ARRAY PROTOTYPE                              22889000
*                                                                       22890000
PROARRAY LM    A1,A1+1,ASPEC(A1)  LOAD ARRAY SPECIFIER                  22891000
         B     EXIT               RETURN TO CALLER                      22892000
PROTOTYP ENDFUNC   ,              END OF PROTOTYPE FUNCTION             22893000
         TITLE 'SPITBOLF -- REMDR FUNCTION'                             22894000
REMDR    FUNCTION 2               GET TWO ARGUMENTS                     22895000
         LM    A1,A1+1,TEM#2(PDR) GET DIVISOR                           22896000
         BAL   RETURN,GETINT      CONVERT IT TO INTEGER                 22897000
         XERR  01,084             SECOND ARGUMENT TO REMDR FUNCTION IS  22898000
*                                 NOT AN INTEGER                        22899000
         LPR   A2,A1+1            MAKE POSITIVE AND TEST FOR / 0        22900000
         BNZ   *+8                SKIP IF NOT ZERO                      22901000
         XERR  10,015             ATTEMPTED DIVISION BY ZERO IN         22902000
*                                 REMDR FUNCTION                        22903000
         LM    A1,A1+1,TEM#1(PDR) GET QUOTIENT                          22904000
         BAL   RETURN,GETINT      GET AN INTEGER VALUE                  22905000
         XERR  01,085             FIRST ARGUMENT TO REMDR FUNCTION IS   22906000
*                                 NOT AN INTEGER                        22907000
         LR    A1,A1+1            COPY TO FILL IN SIGN BIT              22908000
         SRDA  A1,32              GET LEFT REG SIGN FILLED              22909000
         DR    A1,A2              DO THE DIVIDE                         22910000
         LR    A1+1,A1            GET REMAINDER IN PROPER REG           22911000
         SR    A1,A1              INDICATE INTEGER RESULT               22912000
         B     EXIT               RETURN TO CALLER                      22913000
REMDR    ENDFUNC ,                END OF REMAINDER FUNCTION             22914000
         TITLE 'SPITBOLF -- REPLACE FUNCTION'                           22915000
REPLACE  FUNCTION  3              ENTRY POINT -- THREE ARGS             22916000
         CLI   TEM#1(PDR),NCODE   TEST FOR NULL RIGHT AWAY              22917000
         BE    EXITNULL           RETURN NULL IF FIRST ARG NULL         22918000
         L     R1,=A(ALPHPTR)     MAKE ALPHPTR & ALPHBET ADDRESSABLE    22919000
         USING ALPHPTR,R1         TELL ASSEMBLER                        22920000
         CLC   TEM#2(8,PDR),ALPHPTR         IS 2ND ARG &ALPHABET?       22921000
         BNE   REPLC2             SKIP IF NOT                           22922000
*                                                                       22923000
*        IF SECOND ARG IS &ALPHABET AND THIRD ARG IS OK, THEN WE CAN    22924000
*        USE THIRD ARG AS THE TRANSLATE TABLE (SAVING MUCH TIME)        22925000
*                                                                       22926000
         CLI   TEM#3(PDR),SCODE   IS THIRD ARG STRING?                  22927000
         BNE   REPLC2             MERGE WITH STANDARD CIRCUIT IF NOT    22928000
         LA    R0,256-1           GET ALPHABET SLENGTH FOR CHECK        22929000
         C     R0,TEM#3+4(,PDR)   CHECK 3RD ARG SLENGTH=255,SOFFSET=0   22930000
         L     A2,TEM#3(,PDR)     LOAD 3RD ARG PTR (TRANSLATE TABLE)    22931000
         BE    REPLC4             SKIP ON &ALPHABET CASE                22932000
*                                                                       22933000
*        COME HERE FOR ALL OTHER CASES                                  22934000
*                                                                       22935000
REPLC2   L     R1,ALPHPTR         LOAD PTR TO &ALPHABET DATA            22936000
         MVC   512(256,PDR),SCHARS(R1)      COPY &ALPHABET TO WORK AREA 22937000
         DROP  R1                 DON'T NEED THIS BASE REG ANYMORE      22938000
         LM    A1,A1+1,TEM#3(PDR) LOAD THIRD ARG                        22939000
         BAL   RETURN,GETSTGT     CONVERT TO STRING                     22940000
         XERR  01,086             3RD ARGUMENT TO REPLACE NOT A STRING  22941000
         LTR   A1+1,A1+1          TEST FOR 3RD ARGUMENT NULL            22942000
         BM    FAILRL             FAIL RETURN IF SO                     22943000
         EJECT                                                          22944000
*                                                                       22945000
*        COME HERE WITH THIRD ARGUMENT CONVERTED TO STRING              22946000
*                                                                       22947000
REPLC2A  LR    A2,A1              SAVE 3RD ARG STRING POINTER           22948000
         LR    A2+1,A1+1          SAVE 3RD ARG 360 LENGTH               22949000
         STC   A2+1,REPSV         SAVE LOW ORDER BIT FOR LATER TEST     22950000
         LM    A1,A1+1,TEM#2(PDR) LOAD SECOND ARG                       22951000
         BAL   RETURN,GETSTGS     CONVERT TO STRING SPECIFICATION       22952000
         XERR  01,087             2ND ARGUMENT TO REPLACE NOT A STRING  22953000
         CR    A1+1,A2+1          CHECK LENGTHS                         22954000
         BNE   FAILRL             FAIL IF LENGTHS UNEQUAL               22955000
*                                                                       22956000
*        NOW PREPARE TO PLUG COPY OF &ALPHABET TO USE AS TR TABLE       22957000
*                                                                       22958000
         SR    A2+1,A2+1          CLEAR FOR IC USE IN LOOP              22959000
         SR    R1,R1              INITIALIZE CHARACTER OFFSET           22960000
         LR    R2,A1              SAVE 2ND ARG POINTER                  22961000
         LA    A1,2               SET 2 CHAR INCREMENT FOR BXLE         22962000
*                                                                       22963000
*        LOOP TO PLUG CHARACTERS IN COPY OF &ALPHABET                   22964000
*        WE DO TWO CHARACTERS AT A TIME TO MINIMIZE THE SLOW BXLE       22965000
*                                                                       22966000
         TM    REPSV,X'01'        TEST LENGTH EVEN/ODD                  22967000
         BO    REPLC3             SKIP IF 360 LENGTH ODD - LENGTH EVEN  22968000
         BCT   R1,REPLC3A         SKIP TO DO ODD CHAR FUDGING POINTER   22969000
*                                                                       22970000
*        COME HERE TO PICK UP ODD REPLACE CHARACTER                     22971000
*                                                                       22972000
REPLC3   IC    R0,SCHARS(A2,R1)   PICK UP 1ST REPLACE CHARACTER         22973000
         IC    A2+1,SCHARS(R2,R1)           PICK UP 1ST LOCATION CHAR   22974000
         STC   R0,512(PDR,A2+1)   PERFORM INDICATED REPLACEMENT         22975000
*                                                                       22976000
*        JUMP HERE FIRST TIME FOR CASE OF ODD NUMBER OF CHARACTERS      22977000
*                                                                       22978000
REPLC3A  IC    R0,SCHARS+1(A2,R1) PICK UP 2ND REPLACE CHARACTER         22979000
         IC    A2+1,SCHARS+1(R2,R1)         PICK UP 2ND LOCATION CHAR   22980000
         STC   R0,512(PDR,A2+1)   PERFORM INDICATED REPLACEMENT         22981000
         BXLE  R1,A1,REPLC3       LOOP BACK IF MORE CHARS TO GO         22982000
         LA    A2,512-SCHARS(,PDR)          LOAD TRANSLATE TABLE ADDRES 22983000
*                                                                       22984000
*        NOW PICK UP FIRST ARGUMENT                                     22985000
*                                                                       22986000
REPLC4   LM    A1,A1+1,TEM#1(PDR) LOAD FIRST ARGUMENT                   22987000
         BAL   RETURN,GETSTGS     ELSE CONVERT TO STRING                22988000
         XERR  01,088             1ST ARGUMENT TO REPLACE NOT A STRING  22989000
         EJECT                                                          22990000
*                                                                       22991000
*        NOW PREPARE TO MAKE NEW SBLOK                                  22992000
*                                                                       22993000
REPLC4A  LA    R0,BOUND+SCHARS+1(A1+1)      GET SBLOK LENGTH WITH FUDGE 22994000
         N     R0,FULLWRD         ADJUST TO FULL WORD BOUNDARY          22995000
         STE   ZR,0(,FR)          SET DTYPE=SBLOK=0 GCOLPTR=0           22996000
         STH   R0,STLENGTH(,FR)   STORE SBLOK LENGTH                    22997000
         AR    R0,FR              CALCULATE NEW FR LOCATION             22998000
         CR    R0,PDR             CHECK FOR MEMORY OVERFLOW             22999000
         BNL   GBGCLF             GARBAGE COLLECT IF NO ROOM            23000000
*                                                                       23001000
*        COME HERE TO CREATE NEW SBLOK                                  23002000
*                                                                       23003000
REPLC5   LR    R2,A1              SAVE FIRST ARG POINTER                23004000
         LR    A1,FR              SET ADDRESS OF NEW SBLOK              23005000
         A     A1,SCODEBT         ADD SCODE FOR STRING                  23006000
         LR    A2+1,A1+1          COPY LENGTH TO CRANK DOWN             23007000
         LA    R1,256             GET CRANK CONSTANT FOR LOOP           23008000
         CR    A2+1,R1            CHECK FOR 256 CHARS OR LESS           23009000
         BL    REPLC7             SKIP IF 256 CHARS OR LESS             23010000
*                                                                       23011000
*        LOOP TO MOVE AND TRANSLATE ARG 256 CHARS AT A TIME             23012000
*                                                                       23013000
REPLC6   MVC   SCHARS(256,FR),SCHARS(R2)    MOVE 256 CHARS TO NEW SBLOK 23014000
         TR    SCHARS(256,FR),SCHARS(A2)    TRANSLATE CHARACTERS MOVED  23015000
         AR    R2,R1              BUMP SOURCE POINTER                   23016000
         AR    FR,R1              BUMP DESTINATION POINTER              23017000
         SR    A2+1,R1            DECREMENT COUNT                       23018000
         CR    A2+1,R1            CHECK FOR STILL MORE THAN 256 CHARS   23019000
         BNL   REPLC6             LOOP BACK IF SO                       23020000
*                                                                       23021000
*        COME HERE TO MOVE AND TRANSLATE LAST (OR ONLY) SECTION         23022000
*                                                                       23023000
REPLC7   EX    A2+1,REPLCM        MOVE REMAINING CHARS                  23024000
         EX    A2+1,REPLCT        TRANSLATE REMAINING CHARS             23025000
         LR    FR,R0              SET NEW FREE POINTER LOCATION         23026000
         B     EXIT               RETURN TO CALLER                      23027000
*                                                                       23028000
REPLCM   MVC   SCHARS(*-*,FR),SCHARS(R2)    MOVE REMAINING CHARS        23029000
REPLCT   TR    SCHARS(*-*,FR),SCHARS(A2)    TRANSLATE REMAINING CHARS   23030000
REPLACE  ENDFUNC   ,              END OF REPLACE FUNCTION               23031000
         TITLE 'SPITBOLF -- REVERSE FUNCTION'                           23032000
REVERSE  FUNCTION  1              ENTRY POINT -- ONE ARGUMENT REQUIRED  23033000
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT               23034000
         BAL   RETURN,GETSTGS     CONVERT TO STRING SPECIFICATION       23035000
         XERR  01,089             ARGUMENT TO REVERSE IS NOT A STRING   23036000
         LR    A2,A1              MOVE STRING POINTER TO A2             23037000
         LTR   A1+1,A1+1          TEST FOR NULL                         23038000
         BM    EXITNULL           RETURN NULL IF ARGUMENT IS NULL       23039000
         LA    R1,SCHARS+BOUND+1(,A1+1)     GET LENGTH OF NEW SBLOK     23040000
         N     R1,FULLWRD         ADJUST TO FULL WORD BOUNDARY          23041000
         STH   R1,STLENGTH(,FR)   STORE AS LENGTH OF NEW SBLOK          23042000
         STE   ZR,0(,FR)          SET DTYPE=SCODE=0 , GCOLPTR=0         23043000
         AR    R1,FR              SEE WHERE FR WILL END UP              23044000
         CR    R1,PDR             WILL WE RUN OUT OF STORAGE?           23045000
         BNL   GBGCLF             GARBAGE COLLECT & RETRY IF YES        23046000
         LR    A1,FR              ELSE COPY START OF SBLOK              23047000
         A     A1,SCODEBT         SUPPLY STRING TYPE CODE               23048000
         LA    A2+1,1(,A1+1)      GET NUMBER OF CHARS TO REVERSE        23049000
*                                                                       23050000
*        LOOP TO REVERSE CHARS ONE AT A TIME                            23051000
*                                                                       23052000
         BALR  R2,0               POINT R2 TO START OF LOOP FOR SPEED   23053000
         IC    R0,SCHARS-1(A2,A2+1)         PICK UP NEXT LAST CHARACTER 23054000
         STC   R0,SCHARS(,FR)     STORE AS NEXT BEGIN CHARACTER         23055000
         LA    FR,1(,FR)          PUSH DESTINATION POINTER              23056000
         BCTR  A2+1,R2            LOOP BACK CRANKING COUNTER            23057000
         LR    FR,R1              SET NEW FREE CORE POINTER             23058000
         B     EXIT               AND RETURN TO CALLER                  23059000
REVERSE  ENDFUNC                  END OF REVERSE FUNCTION               23060000
         TITLE 'SPITBOLF -- REWIND FUNCTION'                            23061000
REWIND   FUNCTION 1               ENTRY POINT -- ONE ARGUMENT REQUIRED  23062000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         23063000
         BAL   RETURN,GETSTGS     GET A STRING                          23064000
         XERR  01,090             ARGUMENT TO REWIND IS NOT A STRING    23065000
         LA    A1,SCHARS(,A1)     POINT TO FIRST CHARACTER OF FILE NAME 23066000
         AH    A1+1,H1            GET REAL LENGTH, TEST FOR NULL        23067000
         BP    *+8                SKIP IF NON NULL                      23068000
         XERR  13,048             ARGUMENT TO REWIND IS NULL            23069000
         L     R2,=V(SYSDCB)      LOAD PTR TO FIND DCB ROUTINE          23070000
         BALR  R1,R2              LOCATE DCB                            23071000
         B     SYSERROR           SIGNAL ERROR IF GIVEN                 23072000
         L     R2,=V(SYSRWIND)    POINT TO REWIND ROUTINE               23073000
         BALR  R1,R2              CALL IT                               23074000
         B     SYSERROR           ERROR RETURN IF COME HERE             23075000
         B     EXITNULL           RETURN NULL AS RESULT                 23076000
REWIND   ENDFUNC ,                END OF REWIND FUNCTION                23077000
         TITLE 'SPITBOLF -- RPAD FUNCTION'                              23078000
RPAD     FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED    23079000
         LM    A1,A1+1,TEM#3(PDR)           LOAD THIRD ARGUMENT         23080000
         BAL   RETURN,GETSTGS     CONVERT TO STRING SPECIFIER           23081000
         XERR  01,091             THIRD ARGUMENT TO RPAD NOT A STRING   23082000
         MVI   PADCHAR,C' '       PROVISIONALLY SET BLANK AS PAD CHAR   23083000
         LTR   A1+1,A1+1          TEST FOR NO THIRD ARG (NULL)          23084000
         BM    *+10               SKIP IF NULL (BLANK IS DEFAULT)       23085000
         MVC   PADCHAR(1),SCHARS(A1)        ELSE ACQUIRE PAD CHARACTER  23086000
         LM    A1,A1+1,TEM#2(PDR)           NOW GET SECOND ARGUMENT     23087000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    23088000
         XERR  01,092             2ND ARG TO RPAD IS NOT AN INTEGER     23089000
         C     A1+1,V$MAXLN       WILL THIS BE TOO LONG?                23090000
         BNH   *+8                SKIP IF NOT                           23091000
         XERR  11,012             STRING FORMED BY RPAD EXCEEDS         23092000
*                                 &MAXLNGTH CHARACTERS IN LENGTH        23093000
         LR    A2,A1+1            SAVE INTEGER LENGTH IN A2             23094000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         23095000
         BAL   RETURN,GETSTGS     GET A TEMPORARY STRING                23096000
         XERR  01,093             1ST ARGUMENT TO RPAD IS NOT A STRING  23097000
*                                                                       23098000
*        CHECK FOR SPECIAL CASE OF NULL PADDED TO LENGTH ZERO           23099000
*                                                                       23100000
         LTR   A1+1,A1+1          IS STRING NULL?                       23101000
         BNM   RPAD1              SKIP IF NOT                           23102000
         LTR   A2,A2              IF STRING IS NULL, IS PAD LENGTH 0?   23103000
         BZ    RPAD1A             SKIP TO RETURN NULL ARG IF SO         23104000
         LA    A1,PADCHAR-SCHARS  ELSE SET TO USE PAD CHAR AS FIRST ARG 23105000
         SR    A1+1,A1+1          LENGTH IS ONE CHAR                    23106000
*                                                                       23107000
*        COME HERE TO PERFORM ACTUAL PAD OPERATION                      23108000
*                                                                       23109000
RPAD1    STE   ZR,0(,FR)          PREPARE DTYPE=SBLOK=0, GCOLPTR=0      23110000
         LA    R1,SCHARS+BOUND(,A2)         CALCULATE SBLOK LENGTH      23111000
         N     R1,FULLWRD         ADJUST TO FULL WORD BOUNDARY          23112000
         STH   R1,STLENGTH(,FR)   STORE AS SBLOK LENGTH                 23113000
         AR    R1,FR              SEE WHERE FR WILL END UP              23114000
         CR    R1,PDR             WILL WE HAVE ENOUGH ROOM              23115000
         BNL   GBGCLF             GARBAGE COLLECT & TRY AGAIN IF NOT    23116000
         BCTR  A2,0               ADJUST TOTAL COUNT FOR 360            23117000
         LR    R2,A2              SAVE LENGTH OF NEW STRING             23118000
         LR    A2+1,FR            SAVE START OF NEW SBLOK               23119000
         LA    R0,256             LOAD CRANK CONSTANT FOR LONG STRINGS  23120000
         SR    A2,A1+1            GET NUMBER OF PAD CHARS               23121000
         BNM   RPADSL             SKIP IF ROOM FOR PAD CHARS            23122000
*                                                                       23123000
*        MERGE HERE TO RETURN FIRST ARG AS RESULT                       23124000
*                                                                       23125000
RPAD1A   LM    A1,A1+1,TEM#1(PDR) RELOAD FIRST ARG                      23126000
         B     EXIT               AND RETURN IT AS RESULT               23127000
         EJECT                                                          23128000
*                                                                       23129000
*        LOOP TO COPY 256 CHARACTERS AT A TIME                          23130000
*                                                                       23131000
RPADSL   CR    A1+1,R0            HOW MANY CHARS LEFT?                  23132000
         BL    RPADSE             SKIP IF 256 OR LESS                   23133000
         MVC   SCHARS(256,FR),SCHARS(A1)    ELSE MOVE 256 CHARS         23134000
         AR    A1,R0              BUMP SOURCE POINTER                   23135000
         SR    A1+1,R0            DECREMENT COUNT                       23136000
         BXLE  FR,R0,RPADSL       BUMP DEST PTR & LOOP BACK (FR<R1)     23137000
*                                                                       23138000
*        COME HERE TO MOVE LAST CHUNK (256 CHARS OR LESS)               23139000
*                                                                       23140000
RPADSE   EX    A1+1,RPADSMV       MOVE REMAINING CHARS                  23141000
         AR    FR,A1+1            BUMP FREE POINTER                     23142000
*                                                                       23143000
*        LOOP TO PAD 256 CHARACTERS AT A TIME                           23144000
*                                                                       23145000
RPADPL   MVC   SCHARS+1(1,FR),PADCHAR       MOVE IN FIRST PAD CHAR      23146000
         CR    A2,R0              HOW MANY TO GO?                       23147000
         BL    RPADPE             SKIP IF 256 OR LESS                   23148000
         MVC   SCHARS+1+1(256,FR),SCHARS+1(FR)   PROPOGATE 256 CHARS    23149000
         SR    A2,R0              CRANK COUNT DOWN                      23150000
         BXLE  FR,R0,RPADPL       BUMP PTR & LOOP (FR<R1)               23151000
*                                                                       23152000
*        COME HERE TO PROPOGATE LAST CHUNK AND EXIT                     23153000
*                                                                       23154000
RPADPE   EX    A2,RPADPP          PROPAGATE REMAINING CHARS             23155000
         LR    FR,R1              SET NEW FREE POINTER LOCATION         23156000
         LR    A1,A2+1            RECALL START OF SBLOK                 23157000
         AL    A1,SCODEBT         SUPPLY STRING TYPE BYTE               23158000
         LR    A1+1,R2            RECALL SLENGTH                        23159000
         B     EXIT               RETURN                                23160000
*                                                                       23161000
RPADPP   MVC   SCHARS+1+1(*-*,FR),SCHARS+1(FR) LAST CHRS + 2 EXTRA      23162000
RPADSMV  MVC   SCHARS(*-*,FR),SCHARS(A1)    COPY LAST CHARS             23163000
RPAD     ENDFUNC                  END OF RPAD FUNCTION                  23164000
         TITLE 'SPITBOLF -- SETEXIT FUNCTION'                           23165000
SETEXIT  FUNCTION  1              ENTRY POINT -- ONE ARGUMENT           23166000
         L     A2,EXITLOC         LOAD OLD POINTER                      23167000
         LTR   A2,A2              WAS THERE ONE?                        23168000
         LA    A2,VNAME-VALUE(,A2)          POINT TO NAME FIELD IN CASE 23169000
         BNZ   *+6                SKIP IF THERE WAS                     23170000
         SR    A2,A2              ELSE SET FOR NULL RETURNED RESULT     23171000
         CLI   TEM#1(PDR),NCODE   IS ARGUMENT NULL?                     23172000
         BNE   SETXIT2            JUMP IF NOT                           23173000
*                                                                       23174000
*        CASE OF NULL ARGUMENT -- CLEAR EXIT LOCATION                   23175000
*                                                                       23176000
         STE   ZR,EXITLOC         ZERO OUT EXIT LOCATION                23177000
         B     SETXITX            JUMP TO COMMON EXIT POINT             23178000
*                                                                       23179000
*        COME HERE FOR CASE OF SETTING A NEW EXIT LOCATION              23180000
*                                                                       23181000
SETXIT2  LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT               23182000
         BAL   RETURN,GETNAME     FIND VARIABLE BLOCK                   23183000
         XERR  01,094             ARGUMENT TO SETEXIT IS NOT A LABEL    23184000
         CLC   VLABL+1(3,A1),=AL3($$NOGO)   IS LABEL UNDEFINED?         23185000
         BE    *-10               ERROR IF SO                           23186000
         ST    A1,EXITLOC         IF ALL OK, STORE POINTER              23187000
*                                                                       23188000
*        COMMON EXIT POINT                                              23189000
*                                                                       23190000
SETXITX  LTR   A2,A2              SHOULD WE RETURN NULL?                23191000
         BZ    EXITNULL           RETURN NULL IF SO                     23192000
         LA    A1,0(,A2)          ELSE COPY BLOCK ADDR (STRIP UPPER BY) 23193000
         AL    A1,MCODEBT         SUPPLY PROPER TYPE CODE               23194000
         B     EXIT               AND RETURN TO CALLER                  23195000
SETEXIT  ENDFUNC   ,              END OF SETEXIT FUNCTION               23196000
         TITLE 'SPITBOLF -- SIZE FUNCTION'                              23197000
SIZE     FUNCTION  1              ENTRY POINT -- ONE ARGUMENT           23198000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         23199000
         L     PDR,PDRLOC         RESTORE STACK POINTER                 23200000
         BAL   RETURN,GETSTGS     GET STRING ADDR/LENGTH                23201000
         XERR  01,037             ARGUMENT TO SIZE IS NOT A STRING      23202000
         LA    A1+1,1(,A1+1)      IF STRING, CONVERT 360 TO REAL LENGTH 23203000
         SR    A1,A1              SET TYPE = INTEGER                    23204000
         L     RETURN,RETLOC      RELOAD RETURN LOCATION                23205000
         BR    RETURN             RETURN TO CALLER                      23206000
SIZE     ENDFUNC ,                END OF SIZE FUNCTION                  23207000
         TITLE 'SPITBOLF -- STOPTR FUNCTION'                            23208000
STOPTR   FUNCTION  2              ENTRY POINT -- TWO ARGS REQUIRED      23209000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         23210000
         BAL   RETURN,GETNAME     FIND ASSOCIATED VARIABLE BLOCK        23211000
         B     EXITNULL           RETURN NULL IF NOT A NAME             23212000
         LR    A2,A1              SAVE VARIABLE BLOCK POINTER           23213000
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT        23214000
         BAL   RETURN,GETSTGS     GET A TEMPORARY STRING                23215000
         B     EXITNULL           RETURN NULL IF SECOND ARG NOT STRING  23216000
         LA    RETURN,EXITNULL    SET TO RETURN NULL ON EXIT            23217000
         LTR   A1+1,A1+1          TEST FOR NULL SECOND ARGUMENT         23218000
         BM    STOPTRV            ASSUME STOP VALUE TRACE IF NULL       23219000
         CLI   SCHARS(A1),C'V'    IS IT A VALUE                         23220000
         BE    STOPTRV            SKIP TO STOP VALUE TRACE IF SO        23221000
         CLI   SCHARS(A1),C'L'    IS IT A LABEL?                        23222000
         BE    STOPTRL            SKIP IF SO TO STOP LABEL TRACE        23223000
         CLI   SCHARS(A1),C'K'    IS IT A KEYWORD?                      23224000
         BE    STOPTRK            SKIP IF SO TO STOP KEYWORD TRACE      23225000
         CLI   SCHARS(A1),C'F'    IS IT FUNCTION?                       23226000
         BE    STOPTRF            SKIP IF SO TO STOP FUNCTION TRACE     23227000
         CLI   SCHARS(A1),C'C'    IS IT CALL?                           23228000
         BE    STOPTRC            SKIP IF SO TO STOP TRACE OF FUNC CALL 23229000
         CLI   SCHARS(A1),C'R'    IS IT RETURN?                         23230000
         BCR   NE,RETURN          IGNORE STOPTR CALL IF NOT             23231000
*                                                                       23232000
*        STOP TRACE OF FUNCTION RETURN                                  23233000
*                                                                       23234000
         NI    VFLAGS(A2),X'FF'-VFTR        RESET RETURN TRACE FLAG     23235000
         LA    R1,FRTRCCHN-TRCLINK          POINT TO CHN HEAD           23236000
         BAL   A2+1,STPDCHN1      AND GO OFF TO REMOVE FROM CHAIN       23237000
         BR    RETURN             AND RETURN TO CALLER                  23238000
*                                                                       23239000
*        STOP TRACE OF FUNCTION (CALL AND RETURN)                       23240000
*                                                                       23241000
STOPTRF  NI    VFLAGS(A2),X'FF'-VFTR        TURN OFF RETURN TRACE       23242000
         LA    R1,FRTRCCHN-TRCLINK          POINT TO RETURN TRACE CHN   23243000
         BAL   A2+1,STPDCHN1      AND GO OFF TO REMOVE FROM CHAIN       23244000
*                                                                       23245000
*        STOP TRACE OF FUNCTION CALL (FUNCTION CASE MERGES)             23246000
*                                                                       23247000
STOPTRC  NI    VFLAGS(A2),X'FF'-VFTC        RESET CALL TRACE FLAG       23248000
         LA    R1,FCTRCCHN-TRCLINK          POINT TO CALL CHAIN         23249000
         BAL   A2+1,STPDCHN1      AND GO OFF TO REMOVE FROM CHAIN       23250000
         BR    RETURN             AND RETURN TO CALLER                  23251000
         EJECT                                                          23252000
*                                                                       23253000
*        SUBROUTINE TO SEARCH DOWN CHAIN TO REMOVE REFERENCE TO         23254000
*        SPECIFIED VARIABLE BLOCK IF ONE IS PRESENT                     23255000
*        (A2)  VARIABLE BLOCK ADDRESS                                   23256000
*        BAL   A2+1,STPDCHN1      NORMAL ENTRY                          23257000
*                                                                       23258000
STPDCHN  C     A2,TRVBLK(,R2)     IS THIS A REFERENCE TO OUR VARIABLE?  23259000
         BE    STPDCHN2           OFF TO DELETE FROM CHAIN IF SO        23260000
         LR    R1,R2              SAVE BACK POINTER FOR DECHAIN         23261000
*                                                                       23262000
*        INITIAL ENTRY IS HERE - (R1) IS CHAIN HEAD                     23263000
*                                                                       23264000
STPDCHN1 L     R2,TRCLINK(,R1)    MOVE OUT ON CHAIN                     23265000
         CE    ZR,TRCLINK(,R1)    ARE WE AT CHAIN END?                  23266000
         BNE   STPDCHN            LOOP BACK IF NOT CHAIN END            23267000
         BR    A2+1               ELSE RETURN TO CALLER                 23268000
*                                                                       23269000
*        COME HERE TO REMOVE A TRBLOCK FROM CHAIN                       23270000
*                                                                       23271000
STPDCHN2 MVC   TRCLINK(4,R1),TRCLINK(R2)    MOVE LINK FROM NEXT BLOCK   23272000
         BR    A2+1               AND RETURN TO CALLER                  23273000
*                                                                       23274000
*        STOP KEYWORD TRACE                                             23275000
*                                                                       23276000
STOPTRK  LA    R1,FNCLTRC         ASSUME FNCLEVEL TRACE                 23277000
         CLI   VKEY(A2),K$FNCLEV  IS IT FNCLEVEL?                       23278000
         BE    STOPTRK1           SKIP IF SO                            23279000
         LA    R1,ETYPTRC         ASSUME ERRTYPE                        23280000
         CLI   VKEY(A2),K$ERRTYP  IS IT ERRTYPE?                        23281000
         BE    STOPTRK1           SKIP IF SO                            23282000
         CLI   VKEY(A2),K$STCOUN  LAST TRY IS STCOUNT                   23283000
         BCR   NE,RETURN          ALL DONE IF NOT STCOUNT               23284000
         L     R1,STCNTTRC        LOAD &STCOUNT TRACE INFORMATION       23285000
         LTR   R1,R1              IS IT BEING TRACED?                   23286000
         BCR   Z,RETURN           EXIT IF NOT BEING TRACED              23287000
         STE   ZR,SCNTSAVE        PREVENT INVALID PAT CONCAT OPTIMIZATN 23288000
         L     R1,V$STLIM         LOAD STLIMIT                          23289000
         S     R1,V$STCNT         DECREMENT BY NUMBER OF STMTS EXECUTED 23290000
         LER   SCNT,SINC          SET SCNT TO MINIMUM VALUE IN CASE     23291000
*                                 NUMBER OF STMTS LEFT GE 2**24         23292000
         C     R1,=X'00FFFFFF'    CHECK AGAINST MAXIMUM SETTABLE VALUE  23293000
         BNL   STSTCNT            SKIP IF THIS IS VALUE TO USE          23294000
         LE    SCNT,SPINMX        SET TO MAXIMUM VALUE                  23295000
         ST    R1,STSTART         STORE STLIMIT VALUE                   23296000
         MVI   STSTART,X'7F'      SET UP EXPONENT                       23297000
         SU    SCNT,STSTART       AND GET VALUE FOR SCNT                23298000
*                                                                       23299000
*        COME HERE WITH SCNT SET UP TO ENTER CODE                       23300000
*                                                                       23301000
STSTCNT  STE   SCNT,STSTART       SAVE STARTING VALUE OF SCNT           23302000
         LA    R1,STCNTTRC        SET FOR STCOUNT STOPTR                23303000
         EJECT                                                          23304000
*                                                                       23305000
*        COME HERE WITH R1 POINTING TO PROPER KEYWORD INFORMATION       23306000
*                                                                       23307000
STOPTRK1 STE   ZR,0(,R1)          END KEYWORD TRACE                     23308000
         BR    RETURN             AND RETURN TO CALLER                  23309000
*                                                                       23310000
*        STOP LABEL TRACE                                               23311000
*                                                                       23312000
STOPTRL  L     R1,VLABL(,A2)      GET STATEMENT ADDRESS                 23313000
         CLI   0(R1),LTBLOK       IS THERE A LABEL TRACE BLOCK?         23314000
         BCR   NE,RETURN          EXIT IF NOT                           23315000
         MVC   VLABL+1(3,A2),LTGOTO+1(R1)   RESTORE THE CODE ADDRESS    23316000
         BR    RETURN             RETURN TO CALLER                      23317000
*                                                                       23318000
*        STOP VALUE TRACE                                               23319000
*                                                                       23320000
STOPTRV  NI    VFLAGS(A2),X'FF'-VTRC        TURN OFF TRACE FLAG         23321000
         TM    VFLAGS(A2),VINA+VOUA         IS ANY I/O ACTIVE?          23322000
         BCR   NZ,RETURN          KEEP IOBLOK IF SO (KEEPS TAG AROUND   23323000
         XC    VIOPTR+1(3,A2),VIOPTR+1(A2)  GET RID OF IOBLOK           23324000
STOPTR   ENDFUNC                  END OF STOPTR FUNCTION                23325000
         TITLE 'SPITBOLF -- SUBSTR FUNCTION'                            23326000
SUBSTR   FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED    23327000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         23328000
         BAL   RETURN,GETSTG      CONVERT TO STRING                     23329000
         XERR  01,095             FIRST ARG TO SUBSTR NOT A STRING      23330000
         STM   A1,A1+1,TEM#1(PDR)           STORE CONVERTTED STRING     23331000
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT        23332000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    23333000
         XERR  01,096             2ND ARG TO SUBSTR IS NOT AN INTEGER   23334000
         LTR   A2,A1+1            SAVE AND TEST SECOND ARG              23335000
         BNP   FAILRL             FAIL IF NOT > 0                       23336000
         LM    A1,A1+1,TEM#3(PDR)           LOAD THIRD ARGUMENT         23337000
         BAL   RETURN,GETINT      CONVERT TO INTEGER                    23338000
         XERR  01,097             THIRD ARG TO SUBSTR NOT AN INTEGER    23339000
         LTR   A1+1,A1+1          CHECK THIRD ARGUMENT                  23340000
         BNP   SUBSTR1            CHECK FOR NULL IF 3RD ARG NOT > 0     23341000
         CLI   TEM#1(PDR),NCODE   CHECK FOR NULL FIRST ARGUMENT         23342000
         BE    FAILRL             FAIL IF NULL FIRST ARG                23343000
         BCTR  A2,0               DECREMENT SECOND ARG                  23344000
         BCTR  A1+1,0             DECREMENT THIRD ARG FOR 360           23345000
         LA    R2,0(A2,A1+1)      GET (ARG2 + ARG3 - 2)                 23346000
         CH    R2,TEM#1+SLENGTH(,PDR)       CHECK FOR IN RANGE          23347000
         BH    FAILRL             FAIL IF NOT IN RANGE                  23348000
         AH    A2,TEM#1+SOFFSET(,PDR)       CALCULATE NEW OFFSET        23349000
         STH   A2,TEM#1+SOFFSET(,PDR)       STORE NEW OFFSET            23350000
         STH   A1+1,TEM#1+SLENGTH(,PDR)     STORE NEW SLENGTH           23351000
         LM    A1,A1+1,TEM#1(PDR)           LOAD RESULT                 23352000
         B     EXIT               RETURN TO CALLER                      23353000
*                                                                       23354000
*        COME HERE IF NEW LENGTH EQUALS ZERO (NULL)                     23355000
*        NOTE THAT WE ALLOW ARG2 TO POINT TO FIRST NON-EXISTANT CHAR    23356000
*                                                                       23357000
SUBSTR1  BM    FAILRL             FAIL IF NEGATIVE POSITION REQUIRED    23358000
         SH    A2,H2              DECREMENT FOR TEST VS LENGTH          23359000
         BM    EXITNULL           IF OFFSET = CHAR 1, OK, RETURN NULL   23360000
         CLI   TEM#1(PDR),NCODE   WAS FIRST ARGUMENT NULL?              23361000
         BE    FAILRL             FAIL IF NULL (ONLY PERMIT ARG2=1)     23362000
         CH    A2,TEM#1+SLENGTH(,PDR)       COMPARE FOR WITHIN OLD STRG 23363000
         BNH   EXITNULL           OK IF IN STRING, RETURN NULL          23364000
         B     FAILRL             ELSE FAIL                             23365000
SUBSTR   ENDFUNC   ,              END OF SUBSTR FUNCTION                23366000
         TITLE 'SPITBOLF -- TABLE FUNCTION'                             23367000
*                                                                       23368000
*        FUNCTION TO GENERATE A TABLE                                   23369000
*                                                                       23370000
*        SEE DESCRIPTION OF TABLE STRUCTURE (TBBLOK)                    23371000
*                                                                       23372000
TABLE    FUNCTION  1              ENTRY POINT -- ONE ARG                23373000
         LM    A1,A1+1,TEM#1(PDR) ELSE LOAD ARGUMENT                    23374000
         BAL   RETURN,GETINT      GET AN INTEGER FROM IT                23375000
         XERR  01,098             ARGUMENT TO TABLE IS NOT AN INTEGER   23376000
         SLA   A1+1,2             ARGUMENT * 4 + TEST IT                23377000
         BP    TABLE2             SKIP IF SIZE GIVEN                    23378000
         BM    TABLERR            ERROR IF NEGATIVE                     23379000
         LA    A1+1,11*4          ELSE DEFAULT SIZE IS 11 HEADERS       23380000
*                                                                       23381000
*        COME HERE WITH POSITIVE INTEGER ARGUMENT (*4)                  23382000
*                                                                       23383000
TABLE2   LA    R0,4               GET CONSTANT 4                        23384000
         OR    A1+1,R0            MAKE SURE ARGUMENT IS ODD             23385000
         LA    R0,TBLPTRS(FR,A1+1)          FIND WHERE FR WILL END UP   23386000
         CR    R0,PDR             WILL WE HAVE ROOM?                    23387000
         BL    TABLE3             SKIP IF YES                           23388000
         B     GBGCLF             ELSE DO GARBAGE COLLECTION            23389000
*                                                                       23390000
*        COME HERE WITH ROOM                                            23391000
*                                                                       23392000
TABLE3   STE   ZR,0(,FR)          ZERO GARBAGE COLLECTION FIELD         23393000
         MVI   0(FR),TBBLOK       SET TABLE BLOCK CODE                  23394000
         LR    A1,FR              SET ADDRESS OF TABLE INRESULT REG     23395000
         ST    A1+1,TBDIVIDE(,FR) STORE NUMBER OF ENTRIES * 4           23396000
         SR    R0,FR              GET LENGTH OF BLOCK                   23397000
         ST    R0,TBLENGTH(,FR)   AND SAVE IT IN BLOCK                  23398000
         SRL   A1+1,2             GET BACK NUMBER OF ENTRIES            23399000
*                                                                       23400000
*        LOOP TO ZERO ENTRIES                                           23401000
*                                                                       23402000
TABLE4   STE   ZR,TBLPTRS(,FR)    CLEAR AN ENTRY                        23403000
         LA    FR,4(,FR)          BUMP POINTER TO NEXT ENTRY            23404000
         BCT   A1+1,TABLE4        KEEP GOING TILL ALL ENTRIES ZEROD     23405000
         AL    A1,TCODEBT         ADD IN CODE                           23406000
         LA    FR,TBLPTRS(,FR)    ADJUST FOR FIELDS AT START            23407000
         B     EXIT               RETURN TO CALLER                      23408000
TABLERR  XERR  13,049             ARGUMENT TO TABLE IS ZERO OR NEGATIVE 23409000
TABLE    ENDFUNC   ,              END OF TABLE FUNCTION                 23410000
         TITLE 'SPITBOLF -- TIME FUNCTION'                              23411000
TIME     FUNCTION  0,N            ENTRY POINT -- NO ARGUMENTS REQUIRED  23412000
         L     R2,VSYSTIME        LOAD INTERFACE ROUTINE ADDRESS        23413000
         BALR  R1,R2              CALL IT                               23414000
         B     SYSERROR           ERROR IF COME HERE (IMPOSSIBLE)       23415000
         S     R0,TIME            SUBTRACT STARTING TIME                23416000
         LR    A1+1,R0            COPY TIME                             23417000
         SR    A1,A1              SET ICODE = 0 FOR INTEGER RESULT      23418000
         L     PDR,PDRLOC         RESET STACK POINTER                   23419000
         BR    RETURN             RETURN TO CALLER                      23420000
*                                                                       23421000
TIME     ENDFUNC   ,              END OF THE TIME FUNCTION              23422000
         TITLE 'SPITBOLF -- TRACE FUNCTION'                             23423000
TRACE    FUNCTION  4              ENTRY POINT -- FOUR ARGS REQUIRED     23424000
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT         23425000
         BAL   RETURN,GETNAME     FIND ASSOCIATED VARIABLE BLOCK        23426000
         B     EXITNULL           LEAVE IF NOT A PROPER NAME            23427000
         LR    A2,A1              SAVE POINTER TO VARIABLE BLOCK        23428000
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT        23429000
         BAL   RETURN,GETSTGS     CONVERT TO TEMPORARY STRING           23430000
         B     EXITNULL           LEAVE IF GARBAGE SECOND ARG           23431000
         LA    RETURN,EXITNULL    SET TO RETURN NULL ON EXIT            23432000
         LTR   A1+1,A1+1          TEST FOR NULL (NO SECOND ARG)         23433000
         BM    TRACEV             ASSUME VALUE TRACE IF NULL            23434000
         CLI   SCHARS(A1),C'V'    IS IT VALUE?                          23435000
         BE    TRACEV             SKIP IF VALUE TRACE                   23436000
         CLI   SCHARS(A1),C'L'    IS IT LABEL?                          23437000
         BE    TRACEL             SKIP IF LABEL TRACE                   23438000
         CLI   SCHARS(A1),C'K'    IS IT KEYWORD?                        23439000
         BE    TRACEK             SKIP IF KEYWORD TRACE                 23440000
         CLI   SCHARS(A1),C'F'    IS IT FUNCTION?                       23441000
         BE    TRACEF             SKIP IF FUNCTION TRACE                23442000
         CLI   SCHARS(A1),C'C'    IS IT CALL?                           23443000
         BE    TRACEC             SKIP IF CALL TRACE                    23444000
         CLI   SCHARS(A1),C'R'    IS IT RETURN?                         23445000
         BCR   NE,RETURN          IGNORE CALL IF NOT                    23446000
*                                                                       23447000
*        TRACE FUNCTION RETURN                                          23448000
*                                                                       23449000
         OI    VFLAGS(A2),VFTR    SET FUNCTION RETURN TRACE FLAG        23450000
         B     TRACEFR            AND MERGE WITH 'FUNCTION' TRACE       23451000
*                                                                       23452000
*        TRACE FUNCTION CALL                                            23453000
*                                                                       23454000
TRACEC   OI    VFLAGS(A2),VFTC    SET FUNCTION CALL TRACE FLAG          23455000
         LA    DB2,FCTRCCHN-TRCLINK         POINT TO TRACE CHAIN        23456000
         B     TRACEFC            JUMP TO CHECK FOR DEFINED FUNCTION    23457000
*                                                                       23458000
*        TRACE FUNCTION (CALL & RETURN)                                 23459000
*                                                                       23460000
TRACEF   OI    VFLAGS(A2),VFTC+VFTR         SET CALL AND RETURN FLAGS   23461000
         LA    DB2,FCTRCCHN-TRCLINK         PT TO CALL TRC CHAIN        23462000
         BAL   A2+1,MAKETRB       CHECK FOR AND CHAIN PD TRACE REQUEST  23463000
*                                                                       23464000
*        COME HERE TO CHECK FOR PROG DEF TRACE CALL FOR 'RETURN' TRACE  23465000
*                                                                       23466000
TRACEFR  LA    DB2,FRTRCCHN-TRCLINK         PT TO RETURN TRACE CHAIN    23467000
         EJECT                                                          23468000
*                                                                       23469000
*        MERGE TO CHECK FOR PROG DEFINED FUNC, SET TRACE FLAGS IN FBLOK 23470000
*                                                                       23471000
TRACEFC  BAL   A2+1,MAKETRB       CHECK FOR FOURTH ARGUMENT             23472000
         L     R1,VFUNC(,A2)      LOAD FUNCTION POINTER                 23473000
         CLC   FCODE(4,R1),FBLOKI USER DEFINED FUNCTION?                23474000
         BCR   NE,RETURN          RETURN IF NOT                         23475000
         OC    FFLAGS(1,R1),VFLAGS(A2)      ELSE SET FLAGS IN FBLOK     23476000
         BR    RETURN             AND THEN RETURN TO CALLER             23477000
*                                                                       23478000
*        TRACE LABEL TRANSFER                                           23479000
*                                                                       23480000
TRACEL   CLI   TEM#4(PDR),NCODE   WAS A PROG TRACE FUNCTION GIVEN?      23481000
         BE    TRACEL1            SKIP TO GET ZERO ADDR IF NOT          23482000
         LM    A1,A1+1,TEM#4(PDR) LOAD FOURTH ARGUMENT VALUE            23483000
         BAL   RETURN,GETNAME     AND TRY TO GET VAR BLOCK ADDR         23484000
*                                                                       23485000
*        COME HERE IF NO LEGAL FOURTH ARGUMENT GIVEN, SET ADDR = 0      23486000
*                                                                       23487000
TRACEL1  SR    A1,A1              SET VARIABLE BLOCK ADDR = ZERO        23488000
         SR    A1+1,A1+1          CLEAR OFFSET PORTION OF NAME          23489000
         L     R1,VLABL(,A2)      LOAD LABEL ADDRESS OR LTBLOK ADDR     23490000
         CLI   0(R1),LTBLOK       ARE WE POINTING TO AN LTBLOK          23491000
         BNE   *+8                SKIP IF NOT (R1 IS CODE ADDRESS)      23492000
         L     R1,LTGOTO(,R1)     ELSE LOAD CODE ADDRESS FROM LTBLOK    23493000
         LA    R0,LTSIZE(,FR)     GET FINAL FREE CORE LOCATION          23494000
         CR    R0,PDR             CHECK FOR OVERFLOW                    23495000
         BNL   GBGCLF             OFF TO COLLECT IF OVERFLOW            23496000
         ST    FR,LTLOC(,FR)      SAVE POINTER TO THIS BLOK FOR GBGCOL  23497000
         MVC   0(8,FR),LTMODL     MOVE IN MODEL TRACE CODE              23498000
         MVC   LTTAG(8,FR),TEM#3(PDR)       MOVE IN POSSIBLE TAG        23499000
         ST    A1,LTFUNC(,FR)     SAVE ADDRESS OF FUNCTION NAME         23500000
         ST    R1,LTGOTO(,FR)     SAVE GO TO ADDRESS IN BLOCK           23501000
         ST    A2,LTBLOCK(,FR)    SAVE VARIABLE BLOCK ADDRESS           23502000
         IC    R1,VLABL(,A2)      SAVE LEFT BYTE IN VARIABLE BLOCK      23503000
         ST    FR,VLABL(,A2)      SAVE NEW TRANSFER ADDRESS (TO LTBLOK) 23504000
         STC   R1,VLABL(,A2)      RESTORE LEFT BYTE IN VLABL FIELD      23505000
         LR    FR,R0              COPY NEW FREE CORE ADDRESS            23506000
         B     EXITNULL           AND EXIT RETURNING NULL AS RESULT     23507000
*                                                                       23508000
*        MODEL TO CONSTRUCT LTBLOK (LABEL TRACE BLOCK) IN FREE CORE     23509000
*                                                                       23510000
LTMODL   DC    AL1(LTBLOK)        BLOCK CODE FOR LABEL TRACE            23511000
         DC    AL3(0)             GARBAGE COLLECTION FIELD              23512000
         BAL   DB2,LABTRAC        CALL TO LABEL TRACE ROUTINE           23513000
         EJECT                                                          23514000
*                                                                       23515000
*        TRACE KEYWORD                                                  23516000
*                                                                       23517000
TRACEK   LA    R1,FNCLTRC-TRCLINK POINT FOR FNCLEVEL TRACE              23518000
         CLI   VKEY(A2),K$FNCLEV  IS THIS FNCLEVEL?                     23519000
         BE    TRACEK1            OFF TO PROCESS IF SO                  23520000
         LA    R1,ETYPTRC-TRCLINK SET FOR ERRTYPE TRACE CALL            23521000
         CLI   VKEY(A2),K$ERRTYP  IS THIS ERRTYPE CALL?                 23522000
         BE    TRACEK1            OFF TO PROCESS IF ERRTYPE             23523000
         CLI   VKEY(A2),K$STCOUN  CHECK FOR STCOUNT CALL                23524000
         BCR   NE,RETURN          NOT VALID CALL IF NOT                 23525000
         STE   ZR,SCNTSAVE        STOP INVALID PAT CONCAT OPTIMIZATION  23526000
         SU    SCNT,STSTART       CALULATE NO. OF STMTS EXECUTED        23527000
         STE   SCNT,STSTART       SAVE IN TEMPORARY LOCATION            23528000
         L     R1,STSTART         LOAD INTO GENERAL REGISTER            23529000
         LA    R1,0(,R1)          CLEAR OUT X'7F' EXPONENT              23530000
         A     R1,V$STCNT         ADD IN STMTS ALREADY COUNTED          23531000
         ST    R1,V$STCNT         AND SAVE UPDATED VALUE                23532000
         LE    SCNT,SPINMX        LOAD MAXIMUM SCNT VALUE               23533000
         STE   SCNT,STSTART       SET UP VALID STSTART                  23534000
         LA    R1,STCNTTRC-TRCLINK          SET FOR STCOUNT TRACE       23535000
*                                                                       23536000
*        COME HERE WITH R1 POINTING TO KEYWORD TRACE WORD -TRCLINK      23537000
*                                                                       23538000
TRACEK1  LR    DB2,R1             SET UP DB2 FOR MAKETRB CALL           23539000
         STE   ZR,TRCLINK(,DB2)   CLEAR OUT OLD TRACE STATUS            23540000
         MVI   TRCLINK(DB2),X'FF' TURN ON STD TRACE IN CASE NO 4TH ARG  23541000
         BAL   A2+1,MAKETRB       SET UP TRB AND CLEAR LEFT BYTE IF 4TH 23542000
         BR    RETURN             AND RETURN TO CALLER                  23543000
*                                                                       23544000
*        TRACE VALUE                                                    23545000
*                                                                       23546000
TRACEV   CE    ZR,VIOPTR(,A2)     MIGHT WE HAVE ACTIVE TRACE INFO?      23547000
         BE    TRACEV1            NOTHING TO DO IF NO IOBLOK PRESENT    23548000
         L     R1,VIOPTR(,A2)     ELSE LOAD IOBLOK ADDRESS              23549000
         STE   ZR,IOFUNC(,R1)     CLEAR OUT POSSIBLE TRACE FUNC ADDR    23550000
         STE   ZR,IOTAG(,R1)      CLEAR OUT POSSIBLE TRACE TAG          23551000
*                                 IF THIS FREES IOB, PROBABLY USED SOON 23552000
*                                 SO DON'T BOTHER TO GET RID OF IOBLOK  23553000
         EJECT                                                          23554000
*                                                                       23555000
*        COME HERE WHEN OLD TRACE INFORMATION HAS BEEN DISCARDED        23556000
*                                                                       23557000
TRACEV1  CLI   TEM#4(PDR),NCODE   IS THERE A FOURTH ARGUMENT?           23558000
         BE    TRACEV3            SKIP IF NOT                           23559000
         LM    A1,A1+1,TEM#4(PDR) LOAD NAME OF FUNCTION                 23560000
         BAL   RETURN,GETNAME     GET VARIABLE BLOCK ADDRESS            23561000
         B     TRACEV3            TREAT ILLEGAL NAME AS NO NAME         23562000
         CE    ZR,VIOPTR(,A2)     DO WE ALREADY HAVE AN IOBLOK?         23563000
         BNE   TRACEV2            SKIP IF ONE ALREADY BUILT             23564000
         LA    R2,IOBSIZE(,FR)    SEE WHERE FREE CORE WILL END UP       23565000
         CR    R2,PDR             WILL WE NEED A COLLECT FIRST?         23566000
         BNL   GBGCLF             EXIT IF COLLECT NEEDED                23567000
         XC    0(IOBSIZE,FR),0(FR)          CLEAR OUT AN IOBLOK         23568000
         MVI   0(FR),IOBLOK       SET TYPE CODE IN BLOCK                23569000
         IC    R0,VIOPTR(,A2)     SAVE LEFT BYTE OF IOPTR               23570000
         ST    FR,VIOPTR(,A2)     SAVE ADDRESS OF IOBLOK                23571000
         STC   R0,VIOPTR(,A2)     RESTORE LEFT BYTE OF VIOPTR           23572000
         LR    FR,R2              UPDATE FREE CORE POINTER              23573000
*                                                                       23574000
*        COME HERE WITH ADDRESS OF IOBLOK IN VIOPTR                     23575000
*                                                                       23576000
TRACEV2  L     R1,VIOPTR(,A2)     LOAD ADDRESS OF IOBLOK                23577000
         ST    A1,IOFUNC(,R1)     SAVE ADDRESS OF FUNCTION TO BE INVOKE 23578000
         ST    A2,IOVBLK(,R1)     SAVE ADDRESS OF TRACED VARIABLE       23579000
         MVC   IOTAG(8,R1),TEM#3(PDR)       SAVE TAG FOR CALLS          23580000
*                                                                       23581000
*        COME HERE TO SET UP INTERCEPTS                                 23582000
*                                                                       23583000
TRACEV3  LR    A1,A2              COPY BLOCK ADDRESS                    23584000
         TM    VFLAGS(A1),VOUP    ARE THE INTERCEPTS SET?               23585000
         BO    TRACEV4            SKIP IF ALREADY SET                   23586000
         L     DB4,AIOASSOC       GET ADDRESS OF SETUP ROUTINE          23587000
         LA    DB3,OUTFLAG        SET CALL FOR OUTPUT CASE              23588000
         BALR  RETURN,DB4         AND SET UP INTERCEPTS                 23589000
*                                                                       23590000
*        COME HERE WITH INTERCEPTS SET                                  23591000
*                                                                       23592000
TRACEV4  OI    VFLAGS(A1),VTRC+VOUP         SET FLAGS INDICATING SETUP  23593000
         B     EXITNULL           RETURN NULL AS VALUE, ALL DONE        23594000
         EJECT                                                          23595000
*                                                                       23596000
*        THIS SUBROUTINE IS USED TO ADD A TRBLOK TO THE CHAIN           23597000
*        INDICATED BY TRCLINK(DB2) IF A FUNCTION NAME IS GIVEN FOR THIS 23598000
*        CALL.  NO CHECK IS MADE FOR DUPLICATE NAME ENTRIES AS THESE    23599000
*        WILL NOT INTERFERE. MULTIPLE STOPTR CALLS WILL DELETE DUP NMS  23600000
*        DO NOT SAVE LEFT BYTE OF CHAIN PTR WORD - SEE KEYWORD CALL     23601000
*                                                                       23602000
*        LA    DB2,(CHAIN HEAD)-TRCLINK     SET UP DB2 FOR CALL         23603000
*        BAL   A2+1,MAKETRB       CALL TO THIS ROUTINE                  23604000
*                                                                       23605000
MAKETRB  CLI   TEM#4(PDR),NCODE   IS A FOURTH ARGUMENT PRESENT?         23606000
         BE    MAKETRBX           OFF TO EXIT IF NO FOURTH ARGUMENT     23607000
         LM    A1,A1+1,TEM#4(PDR) LOAD FOURTH ARG = TRACE FUNCTION      23608000
         BAL   RETURN,GETNAME     LOCATE VARIABLE BLOCK FOR NAME        23609000
         B     MAKETRBX           EXIT IF ILLEGAL NAME                  23610000
         STE   ZR,0(,FR)          CLEAR FIRST WORD OF TRBLOK            23611000
         MVI   0(FR),TRBLOK       SET BLOK CODE                         23612000
         ST    A1,TRFUNC(,FR)     SAVE NAME OF FUNCTION TO BE CALLED    23613000
         ST    A2,TRVBLK(,FR)     SAVE NAME OF ITEM TO BE TRACED        23614000
         MVC   TRTAG(8,FR),TEM#3(PDR)       MOVE TAG INTO TRACE BLOCK   23615000
         LA    R2,TRBSIZE(,FR)    SEE WHERE FREE CORE WILL END UP       23616000
         CR    R2,PDR             WILL WE NEED A COLLECT?               23617000
         BNL   GBGCLF             OFF TO COLLECT & RE-ENTER IF YES      23618000
         L     A1+1,TRCLINK(,DB2) LOAD HEAD OF CHAIN ADDRESS            23619000
         LA    A1+1,0(,A1+1)      CLEAR POSSIBLE UPPER BYTE             23620000
         ST    A1+1,TRCLINK(,FR)  CONTINUE CHAIN THROUGH NEW BLOCK      23621000
         ST    FR,TRCLINK(,DB2)   PUT NEW BLOCK AT HEAD OF CHAIN        23622000
         LR    FR,R2              UPDATE FREE CORE POINTER              23623000
*                                                                       23624000
*        COME HERE TO EXIT (LOAD NULL AND RESTORE DB2)                  23625000
*                                                                       23626000
MAKETRBX L     DB2,$$BAS2         RESTORE DB2                           23627000
         B     EXITNULL           RETURN TO CALLER                      23628000
TRACE    ENDFUNC                  END OF TRACE FUNCTION                 23629000
         TITLE 'SPITBOLF -- TRIM FUNCTION'                              23630000
TRIM     FUNCTION 1               ENTRY POINT -- ONE ARGUMENT REQUIRED  23631000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         23632000
         BAL   RETURN,GETSTG      CONVERT TO STRING                     23633000
         XERR  01,099             ARGUMENT TO TRIM IS NOT A STRING      23634000
         C     A1,NCODEBT         CHECK FOR NULL                        23635000
         BNL   EXITNULL           RETURN NULL IF NULL                   23636000
         STM   A1,A1+1,TRIMSV     SAVE SPECIFIER                        23637000
         AH    A1,TRIMSV+SOFFSET  ADD STRING OFFSET                     23638000
         LH    R1,TRIMSV+SLENGTH  LOAD 360 LENGTH                       23639000
         AR    A1,R1              POINT TO LAST CHARACTER               23640000
         LA    R1,1(,R1)          GET REAL LENGTH                       23641000
*                                                                       23642000
*        LOOP TO BACK OFF ONE CHARACTER AT A TIME                       23643000
*                                                                       23644000
         BALR  R2,0               SET LOOP ADDRESS FOR SPEED            23645000
TRIML    CLI   SCHARS(A1),C' '    IS THIS CHARACTER BLANK?              23646000
         BNE   TRIMD              SKIP IF WE FIND A NON-BLANK           23647000
         BCTR  A1,0               IF BLANK, BACK OFF POINTER            23648000
         BCTR  R1,R2              BACK TO TEST NEXT CHARACTER           23649000
         B     EXITNULL           RETURN NULL IF WE FALL THROUGH        23650000
*                                                                       23651000
*        COME HERE TO SETUP A NEW SPECIFIER FOR THE TRIMMED STRING      23652000
*                                                                       23653000
TRIMD    BCTR  R1,0               GET 360 LENGTH OF RESIDUAL STRING     23654000
         STH   R1,TRIMSV+SLENGTH  STORE IN LENGTH FIELD                 23655000
         LM    A1,A1+1,TRIMSV     LOAD MODIFIED SPECIFIER               23656000
         B     EXIT               RETURN TO CALLER                      23657000
TRIM     ENDFUNC ,                END OF TRIM FUNCTION                  23658000
         TITLE 'SPITBOLF -- UNLOAD FUNCTION'                            23659000
UNLOAD   FUNCTION  1              ENTRY POINT -- ONE ARGUMENT REQUIRED  23660000
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT               23661000
         BAL   RETURN,GETNAME     GET POINTER TO VARIABLE BLOCK         23662000
         XERR  01,100             ARGUMENT TO UNLOAD IS NOT THE NAME OF 23663000
*                                 A VARIABLE                            23664000
         L     A1+1,=A($$NOFN-FCODE)        GET NEW FUNCTION ADDR=NOFN  23665000
         BAL   RETURN,OPSYN$      STORE NEW FUNCTION ADDRESS            23666000
         B     EXITNULL           RETURN NULL AS RESULT                 23667000
UNLOAD   ENDFUNC ,                END OF UNLOAD FUNCTION                23668000
         TITLE 'SPITBOLF -- VALUE FUNCTION'                             23669000
VALUE    FUNCTION  1,N            MAKE SURE NO CODE IN THIS MACRO       23670000
*                                                                       23671000
*        THE VALUE FUNCTION IS ESSENTIALLY A PECULIAR TYPE OF FFBLOK    23672000
*        WHICH ACCEPTS NAMES AS ARGUMENTS INSTEAD OF PROGRAM DATATYPES. 23673000
*        THE COMMENTS BELOW SHOW HOW THE INSTRUCTIONS IN THE VALUE      23674000
*        FUNCTION ARE ARRANGED SO THAT CONTROL PASSES CORRECTLY.        23675000
*                                                                       23676000
*        THIS FIRST INSTRUCTION SERVES NO PURPOSE EXCEPT TO MAKE THIS   23677000
*        LOOK LIKE AN FFBLOK WHEN THE DATA FUNCTION IS LINKING FFBLOKS  23678000
*                                                                       23679000
         CLI   TEM#1(PDR),DCODE   PRETEND WE ARE AN FFBLOK              23680000
*                                                                       23681000
*        WE CAN COME TO THE FOLLOWING LOCATION EITHER BY EXECUTING THE  23682000
*        ABOVE INSTRUCTION (WHEN THERE IS NO OTHER FIELD FUNCTION       23683000
*        CALLED VALUE), OR THE NEXT INSTRUCTION MAY BE THE SUBJECT OF   23684000
*        THE EXECUTE INSTRUCTION IN THE $$FLCN CIRCUIT. $$FLCN NORMALLY 23685000
*        EXPECTS AN LA INSTRUCTION IN THE LOCATION. SINCE VALUE IS      23686000
*        NOT A STANDARD FFBLOK, IT MUST RETAIN CONTROL IN THIS CASE.    23687000
*        THIS IS ACHEIVED BY THE BRANCH INSTRUCTION.                    23688000
*                                                                       23689000
         B     *+4                MAKE SURE WE RETAIN CONTROL           23690000
*                                                                       23691000
*        NOW COMPUTE RESULT. THIS ESSENTIALLY DUPLICATES UNARY $        23692000
*                                                                       23693000
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT                         23694000
         CLI   TEM#1(PDR),MCODE   IS ARGUMENT A NAME?                   23695000
         BE    VALUENM            SKIP IF SO                            23696000
         ST    RETURN,RETLOC      ELSE SAVE RETURN LOCATION             23697000
         BAL   RETURN,GETNAME     CONVERT TO NAME                       23698000
         XERR  01,049             THE ARGUMENT TO VALUE IS NOT A NAME   23699000
*                                 OR PROGRAM DEFINED DATATYPE.          23700000
         L     RETURN,RETLOC      IF OK, RELOAD RETURN POINT            23701000
         L     PDR,PDRLOC         RESTORE STACK POINTER                 23702000
*                                                                       23703000
*        MERGE HERE WITH NAME IN (A1,A1+1)                              23704000
*                                                                       23705000
VALUENM  CLC   0(4,RETURN),BFRVN  WAS THIS CALLED BY NAME?              23706000
         BE    VALUENN            SKIP IF SO                            23707000
         AR    A1,A1+1            ELSE ADD OFFSET TO BASE ADDRESS       23708000
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE                            23709000
         BR    RETURN             AND RETURN TO CALLER                  23710000
*                                                                       23711000
*        HERE IF VALUE FUNCTION WAS CALLED BY NAME                      23712000
*                                                                       23713000
VALUENN  LA    RETURN,4(,RETURN)  BUMP RETURN PAST ERROR BRANCH         23714000
         BR    RETURN             RETURN WITH NAME IN (A1,A1+1)         23715000
VALUE    ENDFUNC   ,              END OF VALUE FUNCTION                 23716000
         TITLE 'SPITBOLD -- START OF DSECT, SYSTEM AREA'                23717000
*        THE SPITBOLD DSECT IS THE MAIN DATA AREA ALLOCATED BY THE      23718000
*        SYSTEM INTERFACE. THE FIRST SECTION IS USED TO HOLD            23719000
*        STANDARD WORK AREAS AND ALTERABLE CONTANTS AS DESCRIBED BY     23720000
*        THE FOLLOWING PAGES, THE REMAINDER IS USED FOR DYNAMIC STORAGE 23721000
*                                                                       23722000
SPITBOLD DSECT ,                  START OF DSECT                        23723000
*                                                                       23724000
*        THE FIRST FOUR BYTES ARE NOT USED BY THE SYSTEM INTERFACE      23725000
*        IN SPITBOL, A B $$DOIO INSTRUCTION AT THIS LOCATION ALLOWS     23726000
*        A TWO BYTE (BALR) INSTRUCTION LINKAGE TO THE I/O ROUTINES      23727000
*                                                                       23728000
         B     $$DOIO             TRANSFER TO EXECUTION I/O ROUTINE     23729000
*                                                                       23730000
*        THE FOLLOWING LOCATION CONTAINS A POINTER TO THE INTERFACE     23731000
*        WORK AREA. IT IS USED BY THE INTERFACE TO RELOAD THE POINTER   23732000
*                                                                       23733000
SYSCONS  EQU   *                  START OF SYSTEM CONSTANTS ETC.        23734000
WORKLOC  DS    F                  POINTER TO INTERFACE WORK AREA        23735000
*                                                                       23736000
*        THE FOLLOWING AREA IS USED TO SAVE ENTRY REGISTERS ON CALLS    23737000
*        TO THE SYSTEM INTERFACE, IT MAY BE USED FOR ANY OTHER          23738000
*        PURPOSE BETWEEN CALLS                                          23739000
*                                                                       23740000
SAVE1    DS    18F                REGISTER SAVE AREA                    23741000
*                                                                       23742000
*        THE FOLLOWING AREA IS USED WHEN A PROGRAM CHECK OCCURS         23743000
*                                                                       23744000
SYSPSW   DS    D                  SAVE INTERRUPT PSW                    23745000
SYSREGS  DS    12D                SAVE REG VALUES (0-15, FR0-FR6)       23746000
*                                                                       23747000
*        THE FOLLOWING LOCATIONS ARE INITIALIZED BY THE INTERFACE       23748000
*                                                                       23749000
DATASIZE DS    F                  TOTAL LENGTH OF DATA AREA             23750000
PRINTDCB DS    A                  POINTER TO DCB FOR SYSPRINT           23751000
PUNCHDCB DS    A                  POINTER TO DCB FOR SYSPUNCH           23752000
READDCB  DS    A                  POINTER TO SYSIN DCB                  23753000
PGDEPTH  DS    F                  NUMBER OF LINES PER PAGE              23754000
STARTADR DS    A                  ADDRESS OF SYSSTART                   23755000
INTFLAG  DS    A                  0/1 FOR PRECISE/IMPRECISE INTERRUPTS  23756000
LSYS     EQU   *-SYSCONS          LENGTH OF SYSTEM CONSTANTS            23757000
USERD    DS    0D                 START OF USER SECTION                 23758000
*                                                                       23759000
*        THE FOLLOWING LOCATIONS CONTAIN THE ADDRESSES OF THE VARIOUS   23760000
*        SPITBOL CONTROL SECTIONS. THIS INFORMATION IS USED FOR         23761000
*        DEBUGGING AND BY THE DUMP AND SYSTEM RELOAD ROUTINES.          23762000
*                                                                       23763000
CSECTAD  DS    0F                 START OF CSECT ADDRESSES              23764000
SPITCAD  DC    A(SPITBOLC)        COMPILER                              23765000
SPITRAD  DC    A(SPITBOLR)        ROOT PHASE                            23766000
SPITPAD  DC    A(SPITBOLP)        PATTERN ROUTINES                      23767000
SPITXAD  DC    A(SPITBOLX)        NON-ADDRESSABLE EXECUTION ROUTINES    23768000
SPITAAD  DC    A(SPITBOLA)        ADDRESSABLE EXECUTION ROUTINES, DATA  23769000
SPITFAD  DC    A(SPITBOLF)        STANDARD FUNCTION DEFINITIONS         23770000
SPITLAD  DS    A (SPITBOLL)       LOW CORE OF DATA AREA (RELOAD)        23771000
SPITHAD  DS    A (SPITBOLH)       HIGH CORE OF DATA AREA (RELOAD)       23772000
         TITLE 'SPITBOLD -- DATA AREA BASE REGISTER TABLE'              23773000
*                                                                       23774000
*        VARIABLE BLOCKS ARE ALLOCATED IN 4K SEGMENTS                   23775000
*        THE FOLLOWING LOCATIONS CONTAIN POINTERS TO THE FIRST          23776000
*        THREE 4K BLOCKS. REGISTERS DB1,DB2,DB3 CONTAIN THESE VALUES    23777000
*        DURING EXECUTION OF GENERATED CODE                             23778000
*                                                                       23779000
$$BAS1   DS    A                  LOCATION OF 1ST BLOCK (= DB1)         23780000
$$BAS2   DS    A                  LOCATION OF 2ND BLOCK (= DB2)         23781000
*                                                                       23782000
*        THE FOLLOWING ENTRY ($$BAS3) IS A SPECIAL CASE. THE UPPER BYTE 23783000
*        IS SET TO X'FF'. THIS IS BECAUSE I/O ASSOCIATIONS CAUSE        23784000
*        GENERATION OF THE INSTRUCTION BALR DB3,DB1, AND ALSO FAILURES  23785000
*        SOMETIMES BRANCH VIA DB1. THE NEGATIVE SETTING OF DB3 ALLOWS   23786000
*        THE CASES TO BE DISTINGUISHED (SEE TEST LOCATED AT $$DOIO)     23787000
*        NOTE THAT DB3 CAN HAVE THE VALUE OF ZERO EVEN AFTER A VALUE    23788000
*        HAS BEEN STORED IN $$BAS3 (AS A RESULT OF UNARY $). THIS       23789000
*        PRECLUDES THE USE OF MORE OBVIOUS TESTS SUCH AS C DB3,$$BAS3.  23790000
*                                                                       23791000
$$BAS3   DS    A                  LOCATION OF 3RD BLOCK (= DB3)         23792000
*                                                                       23793000
*        THE REMAINING LOCATIONS IN THIS TABLE ARE FILLED IN AS         23794000
*        THE BLOCKS ARE ALLOCATED AND THE APPROPRIATE VALUES LOADED     23795000
*        INTO THE FOURTH (VARIABLE) BASE REGISTER DB4 AS REQUIRED.      23796000
*                                                                       23797000
$$BAS4   DS    A                  LOCATION OF 4TH BLOCK                 23798000
$$BAS5   DS    A                  LOCATION OF 5TH BLOCK                 23799000
$$BAS6   DS    A                  LOCATION OF 6TH BLOCK                 23800000
$$BAS7   DS    A                  LOCATION OF 7TH BLOCK                 23801000
$$BAS8   DS    A                  LOCATION OF 8TH BLOCK                 23802000
$$BAS9   DS    A                  LOCATION OF 9TH BLOCK                 23803000
$$BAS10  DS    A                  LOCATION OF 10TH BLOCK                23804000
$$BAS11  DS    A                  LOCATION OF 11TH BLOCK                23805000
$$BAS12  DS    A                  LOCATION OF 12TH BLOCK                23806000
$$BAS13  DS    A                  LOCATION OF 13TH BLOCK                23807000
$$BAS14  DS    A                  LOCATION OF 14TH BLOCK                23808000
$$BAS15  DS    A                  LOCATION OF 15TH BLOCK                23809000
$$BAS16  DS    A                  LOCATION OF 16TH BLOCK                23810000
$$BAS17  DS    A                  LOCATION OF 17TH BLOCK                23811000
$$BAS18  DS    A                  LOCATION OF 18TH BLOCK                23812000
$$BAS19  DS    A                  LOCATION OF 19TH BLOCK                23813000
$$BAS20  DS    A                  LOCATION OF 20TH BLOCK                23814000
$$BAS21  DS    A                  LOCATION OF 21ST BLOCK                23815000
$$BAS22  DS    A                  LOCATION OF 22ND BLOCK                23816000
$$BAS23  DS    A                  LOCATION OF 23RD BLOCK                23817000
$$BAS24  DS    A                  LOCATION OF 24TH BLOCK                23818000
$$BAS25  DS    A                  LOCATION OF 25TH BLOCK                23819000
$$BAS26  DS    A                  LOCATION OF 26TH BLOCK                23820000
$$BAS27  DS    A                  LOCATION OF 27TH BLOCK                23821000
$$BAS28  DS    A                  LOCATION OF 28TH BLOCK                23822000
$$BAS29  DS    A                  LOCATION OF 29TH BLOCK                23823000
$$BAS30  DS    A                  LOCATION OF 30TH BLOCK                23824000
$$BAS31  DS    A                  LOCATION OF 31ST BLOCK                23825000
$$BAS32  DS    A                  LOCATION OF 32ND BLOCK                23826000
         TITLE 'SPITBOLD -- AREAS COMMON TO EXECUTION AND COMPILATION'  23827000
*                                                                       23828000
*        THE FOLLOWING BYTE CONTROLS COMMUNICATION TO COMMON COMPILE-   23829000
*        EXECUTE ROUTINES AND PROVIDES OTHER GLOBAL COMMUNICATIONS      23830000
*                                                                       23831000
STAGE    DS    X                  FLAGS AS BELOW                        23832000
$COMPILE EQU   1                  WE ARE IN COMPILATION                 23833000
$EXECUTE EQU   2                  WE ARE IN EXECUTION                   23834000
$GBGCLF  EQU   4                  IF OUT OF ROOM, CALL GBGCLF           23835000
$OVERTIM EQU   8                  FLAG SET IF WE RUN OUT OF TIME        23836000
$CLEARFG EQU   16                 FLAG SET FOR CLEAR CALL TO VARLOC     23837000
*                                                                       23838000
*        SYSTEM CONSTANT ADDRESSES ETC.                                 23839000
*                                                                       23840000
TIME     DS    F                  SAVE VALUE OF TIMER                   23841000
SCNTTSAV DS    F                  SAVE SCNT ON TIMER TRAP               23842000
DYNAMB   DS    A                  START OF DYNAMIC EXECUTION AREA       23843000
SUBEXBOT DS    A                  START OF CONSTANT EXPR CODE           23844000
SUBEXTOP DS    A                  END OF CONSTANT EXPR CODE             23845000
ESTACKS  DS    A                  END OF COMPILER WORK STACKS           23846000
HICINUSE DS    A                  START OF ALLOCATED HIGH CORE AREA     23847000
CONSCHAN DS    F                  PTR TO FREELIST OF CONSTANT BLOCKS    23848000
CURBASE  DS    H                  CURRENT OFFSET INTO BASE TABLE        23849000
BSTMNO   DS    H                  BINARY STATEMENT NUMBER               23850000
STMNO    DS    PL3                DECIMAL STATEMENT NUMBER              23851000
SUPRXEQ  DS    X                  SET NONZERO FOR ERROR, -NOERRORS ON   23852000
BYPASXEQ DS    X                  SET NONZERO FOR -NOEXECUTE OPTION     23853000
CRELFLG  DS    X                  #0 => GCOL MUST RELOCATE 'CONSTANTS'  23854000
*                                                                       23855000
*        THE FOLLOWING DATA AREA POINTERS ARE RELOCATED ON A RELOAD     23856000
*                                                                       23857000
FDRELOC  DS    0F                 ADDRESS OF FIRST DATA AREA POINTER    23858000
CODEADR  DS    A                  ADDRESS OF MAIN GENERATED CODE        23859000
TRAADR   DS    A                  LOC IN CODE FOR START OF EXECUTION    23860000
ENDCODAD DS    A                  ADDRESS OF END OF MAIN GENERATED CODE 23861000
DATACUR  DS    A                  POINTER TO CURRENT 4K BLOCK           23862000
HASHTBAD DS    A                  ADDR OF VARIABLE HASH TABLE - VLINK   23863000
HASHTBNS EQU   127                NUMBER OF SLOTS IN VARIABLE HASH TBL  23864000
HASHTBEN DS    A                  END OF HASH TBL (HASHTBAD+4*HASHTBNS) 23865000
NDRELOC  EQU   (*-FDRELOC)/4      NUMBER OF DATA AREA POINTERS          23866000
*                                                                       23867000
*        SAVE AREAS FOR VARLOC                                          23868000
*                                                                       23869000
VARLOCHS DS    D                  HASH WORK AREA IN VARLOC              23870000
VARLOCSV DS    4F                 SAVE ENTRY REGS IN VARLOC             23871000
VARLOCSL DS    A                  SAVE HASH SLOT LOCATION               23872000
VARLOCLK DS    2A                 SAVE VARLOC LINKAGE / ADDRESS         23873000
         EJECT                                                          23874000
*                                                                       23875000
*        SAVE AREAS FOR GET4KBLK                                        23876000
*                                                                       23877000
GET4KSV  DS    2F                 SAVE R4,R5 IN GET4KBLK                23878000
GET4KLK  DS    A                  SAVE LINKAGE TO GET4KBLK              23879000
*                                                                       23880000
*        SAVE AREAS FOR HICORE                                          23881000
*                                                                       23882000
HICORESV DS    3F                 GENERAL REG SAVE                      23883000
HICORPDR DS    A                  SAVE PDR IN HIGHCORE (CODE,EVAL CASE) 23884000
*                                                                       23885000
*        WORK AREAS FOR NUMERIC CONVERSION ROUTINES                     23886000
*                                                                       23887000
STNWRK   DS    D                  WORK AREA FOR STGTONUM                23888000
NTSWRK   EQU   STNWRK             WORK AREA FOR NUMTOSTG                23889000
NTSWRK2  DS    D                  WORK AREA FOR NUMTOSTG                23890000
STNSV    DS    5F                 SAVE REGS IN STGTONUM                 23891000
STNSV2   EQU   NTSWRK2            ADDTNL REG SAVE FOR STGTONUM          23892000
NTSSAV   EQU   STNSV              SAVE REGS FOR NUMTOSTG                23893000
NTSRTN   DS    A                  SAVE NUMTOSTG LINKAGE                 23894000
STNRTN   EQU   NTSRTN             SAVE STGTONUM LINKAGE                 23895000
NTSRSL   DS    CL22               RESULT AREA FOR NUMTOSTG              23896000
         DS    0H                 ALLIGN NTSFRM                         23897000
NTSFRM   DS    X                  FORMAT NUMBER FOR NUMTOSTG            23898000
NTSDGS   DS    X                  NUMBER OF DIGITS FOR NUMTOSTG         23899000
STNFLG   DS    C                  FLAGS FOR STGTONUM                    23900000
STNM     EQU   1                  FLAG FOR NEGATIVE MAGNITUDE           23901000
STND     EQU   2                  FLAG FOR DREAL RESULT                 23902000
STNEM    EQU   4                  FLAG FOR NEGATIVE EXPONENT            23903000
*                                                                       23904000
*        THE FOLLOWING LOCATIONS ARE USED FOR OPERATORS WHICH ARE       23905000
*        NORMALLY UNDEFINED. WHEN ONE OF THESE OPERATORS IS DEFINED     23906000
*        USING OPSYN WITH A THIRD ARGUMENT, ITS CORRESPONDING ENTRY     23907000
*        IN THIS TABLE IS SET TO POINT TO THE APPROPRIATE FUNCTION.     23908000
*        BY DEFAULT, THESE LOCATIONS ARE INITIALIZED TO POINT TO THE    23909000
*        ERROR ROUTINE 'UNDEFOPR' IN SPITBOLA (SEE CODING FOR DETAILS). 23910000
*                                                                       23911000
OPTRTABL DS    0F                 START OF TABLE                        23912000
$$SLS1   DS    A                  UNARY /                               23913000
$$AMP2   DS    A                  BINARY &                              23914000
$$NOT2   DS    A                  BINARY                               23915000
$$ATS2   DS    A                  BINARY @                              23916000
$$BAR1   DS    A                  UNARY |                               23917000
$$PND1   DS    A                  UNARY #                               23918000
$$PND2   DS    A                  BINARY #                              23919000
$$QUS2   DS    A                  BINARY ?                              23920000
$$PCT1   DS    A                  UNARY %                               23921000
$$PCT2   DS    A                  BINARY %                              23922000
$$EXC1   DS    A                  UNARY EXCLAMATION                     23923000
NOPTRS   EQU   (*-OPTRTABL)/4     NUMBER OF ENTRIES                     23924000
         TITLE 'SPITBOLD -- EXECUTION AREAS REQUIRING INITIALIZATION'   23925000
*                                                                       23926000
*        THE FOLLOWING FOUR BYTES GET INSERTED INTO THE CODE FOR I/O    23927000
*        CALLS -- SEE IOASSOC ROUTINE FOR DETAILS                       23928000
*                                                                       23929000
XEQVALS  DS    0F                 DEFINE START AND ALLIGN               23930000
IOASSCOD BALR  DB3,DB1            CALL TO I/O ROUTINE                   23931000
         DS    XL2                SPACE FOR I/O CALL PARAMETERS         23932000
*                                                                       23933000
*        PATREGS -- INITIAL SETTINGS OF PATTERN MATCH REGS              23934000
*                                                                       23935000
ANCHMODE DC    X'00000000'        HIGH ORDER BIT SET ON FOR &ANCHOR = 1 23936000
SCANMODE DC    A(QPATSUBS)        SET TO FPATSUBS IF &FULLSCAN = 1      23937000
*                                                                       23938000
*        DATA TO BUILD ANY,NOTANY PATTERN                               23939000
*                                                                       23940000
ANYTPTR  DC    A(0)               POINTER TO CURRENT ANY TABLE          23941000
ANYMASK  EQU   *+1                LOCATION OF BIT MASK                  23942000
         TM    CTCHARS(R2),0      ANYMASK=0 AT START TO FORCE NEW TABLE 23943000
ANYPARAM EQU   ANYTPTR            PARAMS FOR ANY,NOTANY BLOCK           23944000
*                                                                       23945000
*        THE FOLLOWING LA INSTRUCTIONS ARE USED TO ACQUIRE S ADDRESSES  23946000
*                                                                       23947000
FTRCLA   LA    DB2,*-*            USED BY THE TRACE ROUTINES            23948000
GBGLA    EQU   FTRCLA             LA GR1,*-* (GR1=DB2) USED BY GCOL     23949000
*                                                                       23950000
*        COUNT OF GARBAGE COLLECTIONS                                   23951000
*                                                                       23952000
GCOLCNT  DC    PL3'-1'            COUNT OF GARBAGE COLLECTIONS          23953000
*                                 FUDGED TO NOT COUNT CALL IN ECONC     23954000
*                                                                       23955000
*        IF THE FOLLOWING BYTE IS NON-ZERO, THE GARBAGE COLLECTOR WILL  23956000
*        RETURN TO ITS CALLER EVEN IF IT WOULD NORMALLY FAIL            23957000
*                                                                       23958000
CLLCTFL  DC    X'00'              SET BY COLLECT FUNCTION               23959000
*                                                                       23960000
*        STARTING VALUE OF SCNT STATEMENT COUNT REG                     23961000
*                                                                       23962000
STSTART  DC    X'7FFF3CAF'        = OVERFLOW - 50000                    23963000
*                                                                       23964000
*        THE FOLLOWING ERROR CALL IS FOR SYSTEM ERRORS (MAJOR=12)       23965000
*        THE MINOR CODE IS RETURNED BY THE INTERFACE AND FILLED IN      23966000
*                                                                       23967000
SYSERCOD DS    F                  SYSTEM ERROR CALL (XERR *-*,*-*)      23968000
*                                                                       23969000
LXEQVALS EQU   *-XEQVALS          LENGTH OF ABOVE VALUES                23970000
         EJECT                                                          23971000
*                                                                       23972000
*        VALUES OF KEYWORD VARIABLES                                    23973000
*                                                                       23974000
V$FNCLEV DC    F'0'               VALUE OF &FNCLEVEL                    23975000
V$TRACE  DC    F'0'               VALUE OF &TRACE                       23976000
V$FTRACE DC    F'0'               VALUE OF &FTRACE                      23977000
V$ABEND  DC    F'0'               VALUE OF &ABEND                       23978000
V$CODE   DC    F'0'               VALUE OF &CODE                        23979000
V$DUMP   DC    F'0'               VALUE OF &DUMP                        23980000
V$ERRLIM DC    F'0'               VALUE OF &ERRLIMIT                    23981000
V$INPUT  DC    F'1'               VALUE OF &INPUT                       23982000
V$OUTPUT DC    F'1'               VALUE OF &OUTPUT                      23983000
V$TRIM   DC    F'0'               VALUE OF &TRIM                        23984000
V$MAXLN  DC    F'5000'            VALUE OF &MAXLNGTH                    23985000
V$STLIM  DC    F'50000'           VALUE OF &STLIMIT                     23986000
V$ANCHOR DC    F'0'               VALUE OF &ANCHOR                      23987000
V$SCAN   DC    F'0'               VALUE OF &FULLSCAN                    23988000
V$ERRTYP DC    F'0'               VALUE OF &ERRTYPE                     23989000
V$STCNT  DC    F'0'               SPECIAL VALUE USED WITH &STCOUNT      23990000
V$RETYPE DC    X'00'              VALUE OF &RTNTYPE (048-RET,FRET,NRET) 23991000
LKEYS    EQU   *-V$ABEND          LENGTH OF KEYWORD VALUES              23992000
         EJECT                                                          23993000
*                                                                       23994000
*        LINKAGE SAVE LOCATIONS                                         23995000
*                                                                       23996000
*        THE FOLLOWING LOCATIONS ARE USED AT EXECUTION TIME TO SAVE     23997000
*        LINKAGE LOCATIONS. SOME OR ALL OF THESE VALUES MAY POINT TO    23998000
*        CODE IN DYNAMIC MEMORY AND THUS REQUIRE RELOCATION.            23999000
*                                                                       24000000
*        THEY MUST BE SET ZERO AT THE START OF EXECUTION AND IN ECONC   24001000
*        TO STOP THE COLLECTOR FROM RELOCATING GARBAGE VALUES           24002000
*                                                                       24003000
LINKLOCS DS    0D                 START OF LINKAGE SAVE LOCATIONS       24004000
*                                                                       24005000
FRETLOC  DS    F                  SAVE FRETURN                          24006000
RETLOC   DS    F                  SAVE RETURN (MUST FOLLOW FRETLOC)     24007000
*                                                                       24008000
SETXTFRT DS    F                  SAVE FRETURN FROM LAST ERROR (D BDRY) 24009000
SETXTRET DS    F                  SAVE RETURN FROM LAST ERROR           24010000
*                                                                       24011000
DOLLSAV  DS    F                  SAVE RETURN POINT TO UNARY $ ROUTINE  24012000
*                                                                       24013000
CRETSAVE DS    F                  SAVE RETURN POINT TO CONCATENATION    24014000
*                                                                       24015000
PRETLOC  DS    F                  SAVE RET POINT TO PATTERN CONCAT      24016000
*                                                                       24017000
WRETLOC  DS    F                  SAVE RETURN POINT TO WRITE ROUTINE    24018000
*                                                                       24019000
*        THE FOLLOWING LOCATION IS USED TO SAVE THE VALUE OF RETURN     24020000
*        ON ENTRY TO A STATEMENT INVOLVING A KEYWORD REFERENCE.         24021000
*        RETURN ALWAYS POINTS TO THE LAST STATEMENT EXECUTED.           24022000
*        THIS ALLOWS THE VALUE OF THE KEYWORD &LASTNO TO BE OBTAINED.   24023000
*                                                                       24024000
$$LAST   DS    F                  SAVE RETURN                           24025000
*                                                                       24026000
*        THE FOLLOWING LOCATION IS USED TO HOLD THE CODE ADDRESS IN     24027000
*        SITUATIONS WHERE RETLOC IS SET WRONG ON ENTRY TO THE           24028000
*        ERROR MESSAGE ROUTINE. IT MUST BE RESET TO ZERO WHEN           24029000
*        THE ROUTINE REQUIRING IT TERMINATES.                           24030000
*                                                                       24031000
ALTLOC   DS    F                  ALTERNATE CODE RETURN LOCATION        24032000
*                                                                       24033000
ENDLINKS EQU   *                  END OF LINKAGE LOCATIONS              24034000
         TITLE 'SPITBOLD -- EXECUTION AREAS CONTAINING PERMANENT INFO'  24035000
*                                                                       24036000
*        THE FOLLOWING AREAS ARE USED AT EXECUTION TIME AND SAVE        24037000
*        VALUES WHICH MUST BE KEPT AROUND. HENCE THEY CANNOT            24038000
*        BE OVERLAPPED WITH THE COMPILER WORK AREAS SINCE CALLS         24039000
*        TO THE CODE FUNCTION OR EVAL WOULD DESTROY THEM                24040000
*        ALL THESE AREAS ARE CLEARED TO ZERO AT THE START OF EXECUTION  24041000
*                                                                       24042000
PERMWORK DS    0D                 ALLIGN                                24043000
*                                                                       24044000
*        SAVE LOCATIONS FOR PATTERN,STRING CONSTRUCTION OPTIMIZATION    24045000
*        BY REMEMBERING INFORMATION ABOUT THE LAST STRING OR PATTERN    24046000
*        BUILT, TIME CAN BE SAVED IN BUILDING STRUCTURES                24047000
*                                                                       24048000
SCNTSAVE DS    F                  SCNT WHEN LAST PATTERN WAS BUILT      24049000
PCFRSAVE DS    F                  SAVE FR VALUE WHEN SCNT WAS SAVED     24050000
*                                                                       24051000
CONCFRSV DS    3F                 FR,A1,A1+1 FOR LAST STRING BUILT      24052000
*                                                                       24053000
*        LOCATION OF VARIABLE BLOCK FROM MOST RECENT SETEXIT CALL       24054000
*        LABEL IN BLOCK IS EXIT ADDRESS FOR EXECUTION ERROR             24055000
*                                                                       24056000
EXITLOC  DS    F                  INITIAL VALUE = ZERO = NO INTERCEPT   24057000
*                                                                       24058000
*        THE FOLLOWING LOCATION CONTAINS A POINTER TO THE CURRENT       24059000
*        PDR FOR THIS LEVEL. THIS MAY BE DIFFERENT FROM THE             24060000
*        ACTUAL VALUE OF PDR WHEN A FUNCTION CALL PUSHES PDR            24061000
*        OR WHEN AN EXPANSION OF THE PATTERN MATCHING STACK OCCURS      24062000
*                                                                       24063000
PDRLOC   DS    A                  POINTER TO CURRENT STACK LEVEL        24064000
*                                                                       24065000
*        THE FOLLOWING LOCATIONS ARE POINTERS TO TRBLOKS USED FOR       24066000
*        FUNCTION CALL AND RETURN TRACING, AND TRACING OF THE KEYWORDS  24067000
*        &STCOUNT,&ERRTYPE, AND &FNCLEVEL.  THE KEYWORD LOCATIONS       24068000
*        CAN INDICATE A TRACE WITHOUT A TRBLOK (NO 4TH ARGUMENT) IF     24069000
*        THE CORRESSPONDING LOCATION IS NEGATIVE                        24070000
*                                                                       24071000
FCTRCCHN DS    F                  HEAD OF CHAIN FOR CALL TRACING        24072000
*                                                                       24073000
FRTRCCHN DS    F                  HEAD OF CHAIN FOR RETURN TRACING      24074000
*                                                                       24075000
FNCLTRC  DS    F                  FLAG/POINTER FOR &FNCLEVEL TRACE      24076000
*                                                                       24077000
STCNTTRC DS    F                  FLAG/POINTER FOR &STCOUNT TRACE       24078000
*                                                                       24079000
ETYPTRC  DS    F                  FLAG/POINTER FOR &ERRTYPE TRACE       24080000
*                                                                       24081000
LPERMWRK EQU   *-PERMWORK         LENGTH OF AREA (CLEARED TO ZERO)      24082000
         TITLE 'SPITBOLD -- COMPILER WORK AREAS'                        24083000
*                                                                       24084000
*        THE FOLLOWING WORK AREAS ARE USED AT COMPILE TIME OR DURING    24085000
*        A CALL TO THE CODE FUNCTION, THEY ARE OVERLAYED BY SOME        24086000
*        OF THE EXECUTION WORK AREAS                                    24087000
*                                                                       24088000
COMPWORK EQU   *                  START OF COMPILER AREAS               24089000
*                                                                       24090000
*        WORK AREAS FOR COMPILATION CONTROL CIRCUIT                     24091000
*                                                                       24092000
         DS    0D                 ALLIGN                                24093000
RITESIDE DS    A                  BLOCK PTR FOR RIGHT SIDE EXPR         24094000
LEFTSIDE DS    F                  BLOCK PTR FOR LEFT SIDE EXPR          24095000
FGOTO    DS    A                  BLOCK PTR FOR FAILURE GOTO EXPR       24096000
UNCONDF  EQU   X'01'              FLG SET IN UPPER BYTE OF FGOTO FOR    24097000
*                                 UNCONDITIONAL GOTO WITH -NOFAIL SET   24098000
SGOTO    DS    A                  BLOCK PTR FOR SUCCESS GOTO EXPR       24099000
NGOTOFLG EQU   X'02'              FLAG SET IN UPPER BYTE OF SGOTO,FGOTO 24100000
*                                 FOR NORMAL (NOT DIRECT) GOTO          24101000
FGOINAD  DS    F                  SAVE CODE LOC FOR FGOTO GENERATION    24102000
CMPILBLK DS    3F                 SPACE TO BUILD BINARY OPTR BLOCK      24103000
GOSCANSV DS    2F                 SAVE CALLING REG IN GOSCAN            24104000
STMCODE  DS    A                  LOC OF START OF CODE FOR STMNT        24105000
FAILFLAG DS    X                  SET TO X'FF' FOR LA TYPE FGOTO        24106000
FRETOPT  DS    X                  1 IF LR FRETURN,SYS IN EFFECT         24107000
*                                 2 IF LR FRETURN,DB1 IN EFFECT         24108000
*                                 0 IF NEITHER IN EFFECT                24109000
PREDFUNC DS    X                  NON-ZERO IF PREDICATE FUNCTION REF    24110000
*                                                                       24111000
*        WORK AREAS FOR SCAN                                            24112000
*                                                                       24113000
SCANWRK  DS    D                  GENERAL SCRATCH AREA                  24114000
FLAGLOC  DS    A                  LOCATION FOR ERROR FLAG               24115000
SCANLOC  DS    A                  CURRENT SCAN POINTER                  24116000
SCANAD   DS    A                  ADDRESS RETURNED BY SCAN              24117000
LABSAVE  DS    A                  SAVE LABEL LOC FOR & SPECIAL CODE     24118000
SCANHSV  DS    4F                 SAVE REGS IN SCAN HASH ROUTINE        24119000
STOPLOC  DS    F                  LOCATION OF X'00' END OF CARD CHAR    24120000
SCANFL   DS    X                  SAVE TYPE OF SCANNED ITEM             24121000
SCANCHR  DS    C                  SAVE CHARACTER BEFORE SCANNED ITEM    24122000
GOTOFLG  DS    X                  FLAG TO PERMIT DETECTION OF S( & F(   24123000
NUMTYPE  DS    C                  SAVE TERMINATOR TYPE IN SCANNUM       24124000
RESCAN   DS    X                  SET NON-ZERO TO OBTAIN RESCAN         24125000
AMPFLAG  DS    X                  FLAG FOR & CODE GENERATED             24126000
*                                                                       24127000
*        WORK AREAS FOR EXPAN                                           24128000
*                                                                       24129000
EXPSAV   DS    4F                 SAVE ENTRY REGS                       24130000
EXPINIT  DS    A                  ADDRESS OF AREA TO BUILD BLOCKS       24131000
WRKSTKAD DS    A                  ADDRESS OF EXPAN OPERATOR STACK       24132000
         DS    A                  ADDRESS OF EXPAN POINTER STACK        24133000
EXPNUMBR DS    H                  STORES 200 - NUM OF ITEMS IN EXPR     24134000
STATE    DS    X                  CURRENT EXPAN STATE                   24135000
PATFLG   DS    X                  SET NONZERO FOR PATTERN MATCH         24136000
         EJECT                                                          24137000
*                                                                       24138000
*        WORK AREAS FOR CODGEN                                          24139000
*                                                                       24140000
CONCODAD DS    F                  SAVE LC BEFORE GENERATING CONS CODE   24141000
CONSTAK  DS    F                  SAVE STACK PTR OVER CONS EXPR         24142000
CALSDSV  DS    3F                 SAVE REGS IN CALCSAD                  24143000
LASTOPN  DS    A                  PTR TO SAVE VALUE LOADED INTO A1,A1+1 24144000
LASTNOP  DS    A                  ADDR OF LAST NOP'S GENERATED          24145000
OLDBASE  DS    H                  SAVE DB4 VALUE (OFFSET INTO BASE TBL) 24146000
SOLDBASE DS    H                  SAVE OLDBASE OVER CONS EXPR           24147000
AUR$     AUR   SCNT,SINC          AUR AT START OF EACH STATEMENT        24148000
*                                 OPCODE SET TO X'3D' FOR -CODE ON      24149000
CONGEN   DS    X                  SET NONZERO FOR CONSTANT EXPR         24150000
*                                                                       24151000
*        WORK AREAS FOR CONTROL CARD PROCESSOR                          24152000
*                                                                       24153000
CONCSAV  DS    2F                 SAVE ENTRY REGISTERS                  24154000
*                                                                       24155000
*        WORK AREAS FOR INPUT AND OUTPUT ROUTINES                       24156000
*                                                                       24157000
LASTSEQ  DS    D                  LAST SEQUENCE NUMBER                  24158000
IOHOLD   DS    4F                 SAVE REGS OVER I/O CALL               24159000
SYSAVE   DS    5F                 SAVE REGS OVER SYS INTERFACE CALL     24160000
MAXCOPY  EQU   4                  MAX NESTING LEVELS (-COPY)            24161000
INPUTDCB DS    (MAXCOPY+1)A       STACK FOR INPUT FILE POINTERS         24162000
RDDCBOFS DS    H                  OFFSET INTO INPUTDCB STACK            24163000
LINELEFT DS    H                  NUMBER OF LINES LEFT ON PAGE          24164000
ERRFLG   DS    X                  FLAG FOR ERROR INSIDE ERROR DETECT    24165000
FATAL    DS    X                  FLAG FOR FATAL ERROR                  24166000
PAGENO   DS    PL2                CURRENT PAGE NUMBER                   24167000
OUTTITB  DS    C'1'               PAGE TITLE BUFFER                     24168000
OUTITLE  DS    CL66               TITLE AREA                            24169000
         DC    CL36' '            FILLER                                24170000
         DS    C'PAGE '           PAGE NUMBER CAPTION                   24171000
OUTPAGE  DS    CL3                SPACE FOR PAGE NUMBER                 24172000
         DS    C'0'               CONTROL CHARACTER FOR SUBTITLE        24173000
OUSTITL  DS    CL66               SUBTITLE                              24174000
INBUF    DS    CL80               INPUT BUFFER                          24175000
         DS    X                  ROOM FOR SCAN TERMINATE CHAR -IN80    24176000
EOF      DS    X                  FLAG FOR END OF FILE                  24177000
         DS    0F                 ALLIGN FOR CODSVREG EQUATE            24178000
         DS    C' '               CONTROL CHAR FOR OUTPUT BUFFER        24179000
BUFR     DS    CL133              OUTPUT BUFFER                         24180000
         ORG   BUFR+6+72+2        POSITION TO SERIALIZATION FIELD       24181000
SERIAL   DS    CL8                SERIALIZATION FIELD (-IN72)           24182000
         ORG   BUFR+133           POSITION PAST BUFFER                  24183000
*                                                                       24184000
*        SAVE AREAS FOR EXECUTE TIME ENTRY TO COMPILER                  24185000
*                                                                       24186000
CODSVREG DS    16F                SAVE AREA FOR REGS                    24187000
CODXSW   DS    X                  =ECODE,CCODE -- CONVERT TO EXPR, CODE 24188000
CODEOS   DS    X                  SET NON-ZERO AT END OF STRING         24189000
         EJECT                                                          24190000
*                                                                       24191000
*        SAVE AREAS FOR ACCUMULATION OF STATISTICS                      24192000
*                                                                       24193000
STRUSED  DS    F                  BYTES USED FOR STRINGS                24194000
VARUSED  DS    F                  BYTES USED FOR VARIABLE BLOCKS        24195000
CONUSED  DS    F                  BYTES USED FOR CONSTANTS              24196000
ERRCOUNT DS    PL3                COUNT OF COMPILATION ERRORS           24197000
*                                                                       24198000
*        SAVE AREAS FOR CODE LISTER (PRCODE)                            24199000
*                                                                       24200000
PRWRK    DS    D                  GENERAL SCRATCH AREA                  24201000
PRLOCSV  DS    A                  SAVE CODE LOC WHILE PRINTING EXPRS    24202000
CEXPCNT  DS    F                  COUNT OF CONSTANT EXPRESSIONS         24203000
VEXOFS   DS    H                  OFFSET TO END OF EXPRESSION QUEUE     24204000
VEXPTR   DS    H                  POINTER TO CURRENT ITEM IN EXPR STK   24205000
LADR     DS    A                  POINTER INTO LABEL STACK              24206000
CODBASE  DS    A                  SAVE CURRENT DB4 VALUE                24207000
VEXNUM   DS    H                  NUMBER OF CURRENT EXPR BEING PRINTED  24208000
LCNT     DS    PL3                LABEL COUNT                           24209000
*                                                                       24210000
*        SETTINGS FOR CONTROL CARD SWITCHES                             24211000
*                                                                       24212000
SWITCHES EQU   *                  START OF SWITCHES                     24213000
CODESW   DS    X                  SET NON-ZERO FOR -CODE                24214000
DUBLFLG  DS    X                  SET NON-ZERO FOR -DOUBLE              24215000
FAILSET  DS    X                  SET NON-ZERO FOR -FAIL                24216000
IN72     DS    X                  SET NON-ZERO FOR -IN72                24217000
LISTSW   DS    X                  SET NON-ZERO FOR -LIST                24218000
NOXEQE   DS    X                  SET NON-ZERO FOR -NOERRORS            24219000
OPTFLAG  DS    X                  SET NON-ZERO FOR -OPTIMIZE            24220000
PRINFLG  DS    X                  SET NON-ZERO FOR -PRINT               24221000
SEQFLG   DS    X                  SET NON-ZERO FOR -SEQUENCE            24222000
LSWITCH  EQU   *-SWITCHES         LENGTH OF SWITCHES                    24223000
         TITLE 'SPITBOLD -- VOLATILE EXECUTION WORK AREAS'              24224000
*                                                                       24225000
*        THE FOLLOWING LOCATIONS ARE USED BY VARIOUS EXECUTION ROUTINES 24226000
*        WHILE THEY ARE EXECUTING. SINCE NO PERMANENT VALUES ARE        24227000
*        STORED, THESE AREAS MAY OVERLAP THE COMPILER WORK AREAS        24228000
*                                                                       24229000
         ORG   COMPWORK           OVERLAY COMPILER AREAS                24230000
*                                                                       24231000
*        SAVE AREAS FOR GET (TYPE CONVERT) ROUTINES                     24232000
*                                                                       24233000
GETSVV   DS    D                  SAVE ARG TO CVNUM + OTHER USES        24234000
GETSV    DS    2F                 SAVE ARGUMENT ON ENTRY                24235000
GETPATSV DS    2F                 SAVE DB2,DB3 IN GETPAT                24236000
GETPSV   DS    2F                 SEVERAL USES IN GETPAT                24237000
*                                                                       24238000
*        SAVE AREAS FOR LPAD,RPAD                                       24239000
*                                                                       24240000
PADCHAR  DS    C                  SAVE PAD CHARACTER                    24241000
*                                                                       24242000
*        SAVE AREAS FOR TRIM FUNCTION                                   24243000
*                                                                       24244000
TRIMSV   DS    2F                 SAVE ARGUMENT TO TRIM                 24245000
*                                                                       24246000
*        SAVE AREAS FOR ARITHMETIC OPERATOR ROUTINES                    24247000
*                                                                       24248000
ARITHSV  DS    2D                 SAVE ARGUMENTS + OTHER USES           24249000
*                                                                       24250000
*        SAVE AREAS FOR MPBLOK (CONSTRUCT PATTERN BLOCK)                24251000
*                                                                       24252000
PBLOKSW  DS    X                  SET TO X'00' FOR RETURN TO CODE       24253000
*                                                                       24254000
*        SAVE AREAS FOR IDENT                                           24255000
*                                                                       24256000
IDNTSV   DS    2D                 SAVE IDENT ARGUMENTS                  24257000
*                                                                       24258000
*        SAVE AREAS FOR CONCATENATION ROUTINE                           24259000
*                                                                       24260000
CONCATSF DS    F                  SAVE FR (+4 = CONCATSV)               24261000
CONCATSV DS    4F                 SAVE ARGUMENTS                        24262000
PATFLAG  DS    X                  FF=CONCATENATION, 00=ALTERNATION      24263000
PATCNLN  DS    H                  SAVE LENGTH OF LEFT PATTERN           24264000
*                                                                       24265000
*        SAVE AREAS FOR PATTERN REPLACEMENT                             24266000
*                                                                       24267000
PART1    DS    2F                 UNMATCHED INITIAL STRING SPEC         24268000
PART2    DS    2F                 REPLACEMENT STRING                    24269000
*                                                                       24270000
*        SAVE AREAS FOR ETEST (USED BY BREAK,SPAN ETC.)                 24271000
*                                                                       24272000
ETESTSV  DS    F                  STORE ARGUMENT                        24273000
*                                                                       24274000
*        SAVE AREAS FOR PATTERN MATCHING                                24275000
*                                                                       24276000
FRSAVE   DS    F                  SAVE FR VALUE DURING PATTERN MATCH    24277000
         EJECT                                                          24278000
*                                                                       24279000
*        SAVE AREAS FOR $EVAL                                           24280000
*                                                                       24281000
EVALSV   DS    F                  STORE RESULT OF UNEVAL EXPR (TYPETST) 24282000
EVALVAR  DS    F                  SAVE VARBLK ADDR FOR PATTERN MATCH IO 24283000
*                                                                       24284000
*        SAVE AREAS FOR $ (INDIRECT ADDRESSING) ROUTINE                 24285000
*                                                                       24286000
DOLLFLG  DS    X                  FLAGS FOR CALL                        24287000
$BYVAL   EQU   1                  CALL BY VALUE                         24288000
$BYNAM   EQU   2                  CALL BY NAME                          24289000
$GETNM   EQU   4                  CALL FROM GETNAME                     24290000
DOLLWORK DS    F                  WORKAREA FOR UNARY DOLLARS            24291000
*                                                                       24292000
*        SAVE AREAS FOR READ                                            24293000
*                                                                       24294000
READSAVE DS    2F                 SAVE A2,A2+1 OVER CALL                24295000
READFLG  DS    X                  =1=>RETURN RESULT IN A1,A1+1, ELSE A2 24296000
*                                                                       24297000
*        SAVE AREAS FOR WRITE                                           24298000
*                                                                       24299000
WDB4SAV  DS    F                  SAVE DB4 OVER WRITE CALL              24300000
*                                                                       24301000
*        SAVE AREAS FOR DEFINE                                          24302000
*                                                                       24303000
FMOD     DS    X                  DISTINGUISH BETWEEN LOCALS,ARGS       24304000
FCONCST  DS    3F                 SAVE MISC REGS                        24305000
         EJECT                                                          24306000
*                                                                       24307000
*        SAVE AREAS FOR KEYWORD ACCESS ROUTINES                         24308000
*                                                                       24309000
KGETSV   DS    F                  USED TO LOAD &STCOUNT                 24310000
*                                                                       24311000
*        SAVE AREAS FOR DATATYPE ROUTINE                                24312000
*                                                                       24313000
DATATSV  DS    F                  SAVE ARG TO CHECK DATATYPE            24314000
*                                                                       24315000
*        DATA AREAS FOR XSCAN (EXECUTION SCAN ROUTINE)                  24316000
*                                                                       24317000
XSCANSV  DS    2F                 SAVE LENGTH LEFT, LOCATION            24318000
XSCANFLG DS    X                  FLAGS AS FOLLOWS                      24319000
XSIGNRO  EQU   1                  IGNORE RUNOUT (I.E. RUNOUT OK)        24320000
XSIGNGN  EQU   2                  INHIBIT CALL TO GETNAME               24321000
*                                                                       24322000
*        SAVE AREAS FOR TABLE, ARRAY REFERENCE ROUTINES                 24323000
*                                                                       24324000
         DS    0D                 ALLIGN FOLLOWING CONSTANTS FOR LM,STM 24325000
SRETFSV  DS    F                  SAVE FRETURN IN TABLE ROUTINE         24326000
SRETSV   DS    F                  SAVE RETURN (MAY BE RELOCATABLE)      24327000
SUBSCSV  DS    4F                 SAVE ARG + OTHER USES                 24328000
TBLSV    DS    F                  COMPUTE TABLE HASH, SAVE TABLE ADDR   24329000
NAMEFL   DS    X                  00 = BY NAME, FF = BY VALUE           24330000
*                                                                       24331000
*        SAVE AREAS FOR CONVERT FUNCTION                                24332000
*                                                                       24333000
CVTSAVE  DS    F                  TABLE PTR FOR CONVERT TO TABLE        24334000
CVTEND   DS    F                  END OF ARRAY PTR, CONVERT TO TABLE    24335000
         EJECT                                                          24336000
*                                                                       24337000
*        SAVE AREAS FOR REPLACE                                         24338000
*                                                                       24339000
REPSV    DS    X                  SAVE LENGTH FOR EVEN/ODD LENGTH TEST  24340000
*                                                                       24341000
*        SAVE AREAS FOR TRACE,ERROR,EXIT ROUTINES                       24342000
*                                                                       24343000
STOPSV   DS    D                  USED FOR NUMERIC CONVERSIONS          24344000
DTESAVE  DS    4F                 SAVE REGS IN LINETERM                 24345000
LINESV   DS    3F                 SAVE REGS OVER LINEVAL                24346000
LINEIDSV DS    3F                 SAVE CALLING REGS IN LINEID           24347000
FUNCSAVE DS    F                  SAVE FUNC BLOCK ADDR OVER CALL TRACE  24348000
TRCSVDB4 DS    F                  SAVE DB4 OVER LABEL TRACE CALL        24349000
*                                                                       24350000
*        SAVE AREAS FOR DUMP FUNCTION                                   24351000
*                                                                       24352000
DMPSV1   DS    F                  SAVE SUBSCRIPT VALUES + OTHER USES    24353000
DMPBSAV  DS    F                  SAVE BLK ADDR WHEN GOING THROUGH CORE 24354000
DMPARG   DS    X                  SAVE ARGUMENT TO DUMP FUNCTION        24355000
VARCHAIN DS    F                  POINTS TO SORTED CHAIN OF VAR BLKS    24356000
DMNAMSV  DS    F                  SAVE VAR BLK ADDR FOR NAMED ARRAY/TBL 24357000
*                                                                       24358000
*        SAVE AREAS FOR TBCHRON                                         24359000
*                                                                       24360000
TBCHRSV  DS    F                  POINT TO CHRONOLOGICAL LIST OF TBL EL 24361000
*                                                                       24362000
*        SAVE AREAS FOR OPSYN$                                          24363000
*                                                                       24364000
OPSYNSV  DS    2F                 SAVE A1,A1+1 OVER SYSUNLOD CALL       24365000
*                                                                       24366000
*        SAVE AREAS FOR GARBAGE COLLECTOR                               24367000
*                                                                       24368000
         DS    0D                 ALLIGN FOLLOWING 2 WORDS FOR STD      24369000
GPCHAIN  DS    F                  PTR TO CHAIN OF PATTERN EXPR PTRS     24370000
GECHAIN  DS    F                  PTR TO CHAIN OF ECODE EXPR PTRS       24371000
PASS3S   DS    F                  POINTER TO CHAIN OF BLOCKS IN USE     24372000
GCOLSV   DS    16F                SAVE ALL REGS ON ENTRY                24373000
GCOLNRG  DS    X                  FLAGS AS FOLLOWS --                   24374000
GRELOC1  EQU   X'01'              ON => RELOCATE (A1,A1+1)              24375000
GRELOC2  EQU   X'02'              ON => RELOCATE (A2,A2+1)              24376000
GGBGCLF  EQU   X'04'              ON => GBGCLF CALL                     24377000
GCMPRSS  EQU   X'08'              ON => SPECIAL COMPRESSION PROCEDURE   24378000
LABRLFLG DS    X                  FLAG FOR RELOCATABLE LABELS PRESENT   24379000
*                                                                       24380000
*        SAVE AREAS FOR NUMERICAL, LEXICAL COMPARISON FUNCTIONS         24381000
*                                                                       24382000
CMPRSAVE DS    F                  SAVE RETURN POINT                     24383000
*                                                                       24384000
*        SAVE AREAS FOR PATSET (USED BY LEN,POS,TAB,RTAB,RPOS)          24385000
*                                                                       24386000
PATSETSV DS    F                  SAVE ARGUMENT TO TEST IT              24387000
         EJECT                                                          24388000
*                                                                       24389000
*        SAVE AREAS FOR EXTERNAL FUNCTION CALL CIRCUIT                  24390000
*                                                                       24391000
LOADF0   DS    D                  STORE FR0 ON RETURN (POSSIBLE RESULT) 24392000
LOADF1   DS    E                  SAVE SCNT OVER EXTERNAL FUNCTION CALL 24393000
LOADSW   DS    X                  00 DURING ARGS, FF DURING RESULT SCAN 24394000
*                                                                       24395000
*        SAVE AREAS FOR DUPL FUNCTION                                   24396000
*                                                                       24397000
DUPLSAV  DS    2F                 SAVE STRING POINTER                   24398000
*                                                                       24399000
*        WORK AREA TO BUILD OUT OF LINE CODE FOR USE IN DOLLAR/DOT RTNS 24400000
*                                                                       24401000
DOLDOTX  BAL   R1,MPBLOK          CALL TO MAKE PATTERN BLOCK ROUTINE    24402000
         DS    CL6                PARAMS FILLED IN BEFORE USE           24403000
         B     DOLDOTR            RETURN TO INLINE CODE                 24404000
*                                                                       24405000
*        THE FOLLOWING TABLE AREA SERVES A DUAL PURPOSE --              24406000
*                                                                       24407000
*        1)    THE 256 BYTES AT ZTBL ARE NORMALLY ALL ZERO AND ARE      24408000
*              USED FOR VARIOUS PURPOSES AS SUCH. THE TABLE IS ALSO     24409000
*              USED AS A TRT TABLE BY PLUGGING SELECTED CHARS           24410000
*              (SEE XSCAN). IN THE LATTER CASE, CARE MUST BE TAKEN TO   24411000
*              ENSURE THAT THE TABLE IS CORRECTLY UNPLUGGED,            24412000
*              ESPECIALLY IN THE CASE OF A SETEXIT ERROR TRAP.          24413000
*                                                                       24414000
*        2)    THE ENTIRE 511 BYTE AREA IS USED AS A MASTER BREAK       24415000
*              TABLE IN WHICH ALL BREAK TABLES FOR ONE CHARACTER ARE    24416000
*              ALLOCATED. FOR THIS PURPOSE, THERE ARE 255 ZEROS,        24417000
*              FOLLOWED BY A SINGLE NONZERO BYTE, FOLLOWED BY           24418000
*              255 ADDITIONAL ZERO BYTES. THE CORRECT TABLE             24419000
*              ADDRESS FOR THE CHARACTER X IS (BREAKTBL-X)              24420000
*                                                                       24421000
         ORG   ,                  POSITION TO HIGHEST POINT             24422000
         DS    0D                 ALLIGN FOR FAST COPIES                24423000
ZTBL     DS    XL256'00'          256 BYTES OF ZEROS                    24424000
*                                                                       24425000
*        THIS IS THE REFERENCE POINT FOR THE MASTER BREAK TABLE         24426000
*                                                                       24427000
BREAKTBL EQU   *-CTCHARS          SUPPLY THE PROPER TBLOK OFFSET        24428000
         DC    X'FF'              ONE NON-ZERO BYTE                     24429000
         DC    256X'00'           256 ADDITIONAL ZERO BYTES             24430000
*                                                                       24431000
*        THE ABOVE TABLES ARE ALSO USED AT COMPILE TIME AS FOLLOWS      24432000
*                                                                       24433000
SCANTB4  EQU   BREAKTBL+1         LITERAL SCAN TBL, ' " ENTRIES PLUGGED 24434000
CHASH    EQU   ZTBL               HASH TABLE FOR CONSTANTS (SEE SCAN)   24435000
         TITLE 'SPITBOLD -- WORK AREAS FOR OBJECT MODULE GENERATOR'     24436000
*                                                                       24437000
*        THE FOLLOWING AREAS ARE USED DURING GENERATION OF OBJECT       24438000
*        MODULES AND CAN OVERLAP OTHER VOLATILE AREAS                   24439000
*                                                                       24440000
         ORG   COMPWORK           OVERLAY COMPILER AREAS                24441000
OBJDCB   DS    A                  ADDR OF SYSOBJ FILE                   24442000
OBJBUFR  DS    CL80               OUTPUT BUFFER FOR OBJECT MODULE       24443000
OBJSER   DS    PL4                SERIALIZATION COUNTER                 24444000
OBJWSAV  DS    6F                 SAVE REGS IN OBJWRITE                 24445000
         TITLE 'SPITBOLD -- END OF DSECT'                               24446000
*                                                                       24447000
*        THE REST OF THE FIRST 4K IS USED TO STORE VARIABLES AND        24448000
*        CONSTANTS. DATABGN SHOWS THE START OF THE AVAILABLE AREA       24449000
*                                                                       24450000
         ORG   ,                  REPOSITION TO HIGHEST LOC IN SPITBOLD 24451000
         ORG   (*-SPITBOLD+31)/32*32+SPITBOLD ADJUST TO 32 BYTE BDRY    24452000
DATABGN  EQU   *                  START OF AREA AVAILABLE FOR VARS/CONS 24453000
*                                                                       24454000
*        THE FOLLOWING DEFINITIONS GIVE THE LOCATIONS OF THE FIRST      24455000
*        THREE VARIABLE BLOCKS WHICH ARE ALWAYS CONSTRUCTED.            24456000
*                                                                       24457000
         ORG   *-VALUE            ADJUST FOR VALUE OFFSET               24458000
B$INPUT  DS    (VARSIZ)X          BLOCK FOR INPUT                       24459000
B$OUTPUT DS    (VARSIZ)X          BLOCK FOR OUTPUT                      24460000
B$PUNCH  DS    (VARSIZ)X          BLOCK FOR PUNCH                       24461000
         END   ,                  END OF EVERYTHING                     24462000
